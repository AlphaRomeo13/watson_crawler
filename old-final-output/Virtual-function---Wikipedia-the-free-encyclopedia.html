<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Virtual-function---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Virtual function</h1>
<ul>
<li>Ad hoc polymorphism</li>
<li>Function overloading</li>
<li>Operator overloading</li>
<li>Parametric polymorphism</li>
<li>Double dispatch</li>
<li>Multiple dispatch</li>
<li>Single &amp; dynamic dispatch</li>
<li>Subtyping</li>
<li><strong class="selflink">Virtual function</strong></li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In object-oriented programming, a <b>virtual function</b> or <b>virtual method</b> is a function or method whose behavior can be overridden within an inheriting class by a function with the same signature. This concept is an important part of the polymorphism portion of object-oriented programming (OOP).</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Purpose</li>
<li>2 Example</li>
<li>3 Abstract classes and pure virtual functions</li>
<li>4 Behavior during construction and destruction</li>
<li>5 Virtual destructors</li>
<li>6 See also</li>
<li>7 References</li>
</ul>
<p></p>
<h2>Purpose</h2>
<p>The concept of the virtual function solves the following problem:</p>
<p>In object-oriented programming, when a derived class inherits from a base class, an object of the derived class may be referred to via a pointer or reference of the base class type instead of the derived class type. If there are base class methods overridden by the derived class, the method actually called by such a reference or pointer can be bound either 'early' (by the compiler), according to the declared type of the pointer or reference, or 'late' (i.e. by the runtime system of the language), according to the actual type of the object referred to.</p>
<p>Virtual functions are resolved 'late'. If the function in question is 'virtual' in the base class, the most-derived class's implementation of the function is called according to the actual type of the object referred to, regardless of the declared type of the pointer or reference. If it is not 'virtual', the method is resolved 'early' and the function called is selected according to the declared type of the pointer or reference.</p>
<p>Virtual functions allow a program to call methods that don't necessarily even exist at the moment the code is compiled.</p>
<p>In C++, <i>virtual methods</i> are declared by prepending the virtual keyword to the function's declaration in the base class. This modifier is inherited by all implementations of that method in derived classes, meaning that they can continue to over-ride each other and be late-bound.</p>
<h2>Example</h2>
<p>For example, a base class <code>Animal</code> could have a virtual function <code>eat</code>. Subclass <code>Fish</code> would implement <code>eat()</code> differently than subclass <code>Wolf</code>, but one can invoke <code>eat()</code> on any class instance referred to as Animal, and get the <code>eat()</code> behavior of the specific subclass.</p>
<p>This allows a programmer to process a list of objects of class <code>Animal</code>, telling each in turn to eat (by calling <code>eat()</code>), without needing to know what kind of animal may be in the list, how each animal eats, or what the complete set of possible animal types might be.</p>
<h2>Abstract classes and pure virtual functions</h2>
<p>A <b>pure virtual function</b> or <b>pure virtual method</b> is a virtual function that is required to be implemented by a derived class if that class is not abstract. Classes containing pure virtual methods are termed "abstract" and they cannot be instantiated directly. A subclass of an abstract class can only be instantiated directly if all inherited pure virtual methods have been implemented by that class or a parent class. Pure virtual methods typically have a declaration (signature) and no definition (implementation).</p>
<p>As an example, an abstract base class <code>MathSymbol</code> may provide a pure virtual function <code>doOperation()</code>, and derived classes <code>Plus</code> and <code>Minus</code> implement <code>doOperation()</code> to provide concrete implementations. Implementing <code>doOperation()</code> would not make sense in the <code>MathSymbol</code> class, as <code>MathSymbol</code> is an abstract concept whose behaviour is defined solely for each given kind (subclass) of <code>MathSymbol</code>. Similarly, a given subclass of <code>MathSymbol</code> would not be complete without an implementation of <code>doOperation()</code>.</p>
<p>Although pure virtual methods typically have no implementation in the class that declares them, pure virtual methods in C++ are permitted to contain an implementation in their declaring class, providing fallback or default behaviour that a derived class can delegate to, if appropriate.</p>
<p>Pure virtual functions can also be used where the method declarations are being used to define an interface - similar to what the interface keyword in Java explicitly specifies. In such a use, derived classes will supply all implementations. In such a design pattern, the abstract class which serves as an interface will contain <i>only</i> pure virtual functions, but no data members or ordinary methods. In C++, using such purely abstract classes as interfaces works because C++ supports multiple inheritance. However, because many OOP languages do not support multiple inheritance, they often provide a separate interface mechanism. An example is the Java programming language.</p>
<h2>Behavior during construction and destruction</h2>
<p>Languages differ in their behavior while the constructor or destructor of an object is running. For some languages, notably C++, the virtual dispatching mechanism has different semantics during construction and destruction of an object. While it is recommended that virtual function calls in constructors should be avoided for C++, in some other languages, for example C# and Java, the derived implementation can be called during construction and design patterns such as the Abstract Factory Pattern actively promote this usage in languages supporting the ability.</p>
<h2>Virtual destructors</h2>
<p>Object-oriented languages typically manage memory allocation and de-allocation automatically when objects are created and destroyed. However, some object-oriented languages allow a custom destructor method to be implemented, if desired. If the language in question uses automatic memory management, the custom destructor (generally called a finalizer in this context) that is called is certain to be the appropriate one for the object in question. For example, if an object of type Wolf that inherits Animal is created, and both have custom destructors, the one called will be the one declared in Wolf.</p>
<p>In manual memory management contexts, the situation can be more complex, particularly as relates to static dispatch. If an object of type Wolf is created but pointed to by an Animal pointer, and it is this Animal pointer type that is deleted, the destructor called may actually be the one defined for Animal and not the one for Wolf, unless the destructor is virtual. This is particularly the case with C++, where the behavior is a common source of programming errors.</p>
<h2>See also</h2>
<ul>
<li>Inheritance</li>
<li>Superclass</li>
<li>Virtual inheritance</li>
</ul>
</body>
</html>