<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Semantic-oriented-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Semantic-oriented programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li><strong class="selflink">Semantic</strong></li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Semantic-oriented programming</b> (<b>SOP</b>) is a programming paradigm in which the programmer formulizes the logic of a domain by means of semantic structures. Similar to Concept programming and Concept-oriented programming.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Common features</li>
<li>2 Goals</li>
<li>3 SOPlets</li>
<li>4 SymADE</li>
<li>5 See also</li>
<li>6 External links</li>
</ul>
<p></p>
<h2>Common features</h2>
<p>The way of how these semantic information are represented in the system vary according to the approach chosen (see below), common to these approaches are the following features:</p>
<ul>
<li>The semantics represent static facts, that is: facts that describe the domain in question at a given moment, and which do not change during runtime (as opposed to Semantic Web for instance)</li>
<li>The system has native access to these semantic structures during compile time and runtime, and can interpret them in order to fulfill the requested features</li>
<li>Clear separation from logic and implementation (where possible)</li>
<li>In many cases, SOP supports the notion of Single Source of Truth (SSoT), such that every semantic concept is stored exactly once, Any possible linkages to this concept are by reference only</li>
<li>A programmer can freely and quickly add new semantic meanings without breaking compatibility with the system environment</li>
</ul>
<h2>Goals</h2>
<p>The goals of SOP are:</p>
<ul>
<li>Improving the maintainability of a software</li>
<li>Improving the transparency of a software</li>
<li>Flexibility by allowing exchangeability of logic and/or implementation</li>
<li>Optimal support for agile development processes (refactoring)</li>
</ul>
<h2>SOPlets</h2>
<p>Soplets is a method of describing semantic concepts as blocks of code, using existing features of the (Java) language, namely annotations and enumerations. Each block of code (called Soplet) represents all properties and features of a given concept (as far as reasonable and feasible), including features outside of the traditional modelling scope, such as translations, documentation, requirement tracking and so on.</p>
<p>Soplets can be referenced and used from anywhere inside the code. Given the strong-typed nature of the references they can be safely refactored as seen fit.</p>
<p>A Soplet may be enhanced by one or more (stateless) functions, which are directly attached to the code block. That way also related features related to a given concept (such as calculations, validation, transformations etc.) beyond pure key-value pairs may be associated with a given Soplet.</p>
<p>The structure of a Soplet is formally defined by the stereotype it implements. This stereotype may be individually composed of several aspects (such as Translatable, Beanable, Bindable, Testable etc.), which in turn may be freely defined by the developer (or which are part of a framework which he uses).</p>
<p>An open-source plugin (based on the Project Lombok plugin) allows the creation of byte-code during compile-time, based on the information contained in the Soplets. For instance, a data bean may have all of its attributes, getters and setters generated.</p>
<h2>SymADE</h2>
<p>SymADE (Symbolic Adaptable Development Environment) is an open-source IDE and implementation of SOP (Semantic-oriented programming) paradigm.</p>
<p>In SymADE a program is edited and stored as a tree of semantic nodes (meanings). The tree is edited by structural editor, and programmers can edit either the semantic tree directly or a projection of the semantic tree onto syntax tree. There may be multiple projections of the same tree, and they can be rendered on the screen as reach text, as UML diagrams and so on.</p>
<p>Semantic meanings are completely user-defined. This allows to use SymADE for creating and editing new domain-specific languages, modify existing languages, use in the same piece of code a mix of multiple languages.</p>
<p>SymADE is common in spirit with IP (Intentional Programming)and JetBrains MPS. The main difference is that they define and edit syntax trees, but in SymADE you create and edit semantic trees. This gives an unbound possibility for automating code writing, i.e. the actual code can be written by computer based on dialog interaction with programmers. And of cause, the SymADE project is open-source, unlike proprietary IP and MPS development environments.</p>
<p>The higher automation of code writing will allow to create more complex programs without increasing the amount of abstraction layers - because the computer, not programmers, will take care of the code complexity. This will allow to write more complex programs without increasing resource requirements (CPU speed and memory size).</p>
<h2>See also</h2>
<ul>
<li>Model-driven engineering</li>
<li>Domain-specific languages</li>
<li>Service-oriented programming</li>
<li>Language-oriented programming</li>
<li>Aspect-oriented programming</li>
<li>Generative programming</li>
<li>Intentional programming</li>
<li>Automatic programming</li>
<li>Resource-oriented architecture</li>
<li>Transaction-level modeling</li>
<li>Concept programming</li>
</ul>
<h2>External links</h2>
<ul>
<li>SYMbolic Adaptable Development Environment as an open-source, reference implementation of SOP.</li>
<li>Soplets Java based SOP including an open-source Eclipse-based byte-code generator</li>
</ul>
<ul>
<li>Concept-oriented programming</li>
</ul>
</body>
</html>