<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>List-Implementations-The-Java-Tutorials---------------------Collections--Implementations.html</title></head>
<body>
<h1>List Implementations</h1>
<p><code>List</code> implementations are grouped into general-purpose and special-purpose implementations.</p>
<h2>General-Purpose List Implementations</h2>
<p>There are two general-purpose 
<code>List</code> implementations 혰 
<code>ArrayList</code> and 
<code>LinkedList</code>. Most of the time, you'll probably use <code>ArrayList</code>, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the <code>List</code>, and it can take advantage of <code>System.arraycopy</code> when it has to move multiple elements at the same time. Think of <code>ArrayList</code> as <code>Vector</code> without the synchronization overhead.</p>
<p>If you frequently add elements to the beginning of the <code>List</code> or iterate over the <code>List</code> to delete elements from its interior, you should consider using <code>LinkedList</code>. These operations require constant-time in a <code>LinkedList</code> and linear-time in an <code>ArrayList</code>. But you pay a big price in performance. Positional access requires linear-time in a <code>LinkedList</code> and constant-time in an <code>ArrayList</code>. Furthermore, the constant factor for <code>LinkedList</code> is much worse. If you think you want to use a <code>LinkedList</code>, measure the performance of your application with both <code>LinkedList</code> and <code>ArrayList</code> before making your choice; <code>ArrayList</code> is usually faster.</p>
<p><code>ArrayList</code> has one tuning parameter 혰 the <em>initial capacity</em>, which refers to the number of elements the <code>ArrayList</code> can hold before it has to grow. <code>LinkedList</code> has no tuning parameters and seven optional operations, one of which is <code>clone</code>. The other six are <code>addFirst</code>, <code>getFirst</code>, <code>removeFirst</code>, <code>addLast</code>, <code>getLast</code>, and <code>removeLast</code>. <code>LinkedList</code> also implements the <code>Queue</code> interface.</p>
<h2>Special-Purpose List Implementations</h2>
<p>
<code>CopyOnWriteArrayList</code> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code>CopyOnWriteArraySet</code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code>ConcurrentModificationException</code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p>
<p>If you need synchronization, a <code>Vector</code> will be slightly faster than an <code>ArrayList</code> synchronized with <code>Collections.synchronizedList</code>. But <code>Vector</code> has loads of legacy operations, so be careful to always manipulate the <code>Vector</code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p>
<p>If your <code>List</code> is fixed in size 혰 that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> 혰 you have a third option that's definitely worth considering. See <code>Arrays.asList</code> in the 
Convenience Implementations section for more information.</p>
</body>
</html>