<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Automatic-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Automatic programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li><strong class="selflink">Automatic</strong></li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li><strong class="selflink">Automatic</strong></li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computer science, the term <b>automatic programming</b> identifies a type of computer programming in which some mechanism generates a computer program to allow human programmers to write the code at a higher abstraction level.</p>
<p>There has been little agreement on the precise definition of automatic programming, mostly because its meaning has changed over time. David Parnas, tracing the history of "automatic programming" in published research, noted that in the 1940s it described automation of the manual process of punching paper tape. Later it referred to translation of high-level programming languages like Fortran and ALGOL. In fact, one of the earliest programs identifiable as a compiler was called Autocode. Parnas concluded that "automatic programming has always been a euphemism for programming in a higher-level language than was then available to the programmer."</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Origin</li>
<li>2 Generative programming</li>
<li>3 Source code generation
<ul>
<li>3.1 Implementations</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<ul>
<li>3.1 Implementations</li>
</ul>
<p></p>
<h2>Origin</h2>
<p>Mildred Koss, an early UNIVAC programmer, explains: "Writing machine code involved several tedious steps—breaking down a process into discrete instructions, assigning specific memory locations to all the commands, and managing the I/O buffers. After following these steps to implement mathematical routines, a sub-routine library, and sorting programs, our task was to look at the larger programming process. We needed to understand how we might reuse tested code and have the machine help in programming. As we programmed, we examined the process and tried to think of ways to abstract these steps to incorporate them into higher-level language. This led to the development of interpreters, assemblers, compilers, and generators—programs designed to operate on or produce other programs, that is, <i>automatic programming</i>."</p>
<h2>Generative programming</h2>
<p><i>Generative programming</i> is a style of computer programming that uses automated source code creation through generic frames, classes, prototypes, templates, aspects, and code generators to improve programmer productivity. It is often related to code-reuse topics such as component-based software engineering and product family engineering.</p>
<h2>Source code generation</h2>
<p><i>Source code generation</i> is the act of generating source code based on an ontological model such as a template and is accomplished with a programming tool such as a template processor or an integrated development environment (IDE). These tools allow the generation of source code through any of various means. A macro processor, such as the C preprocessor, which replaces patterns in source code according to relatively simple rules, is a simple form of source code generator.</p>
<h3>Implementations</h3>
<p>IDEs such as Eclipse, Interface Builder and Microsoft Visual Studio have more advanced forms of source code generation, with which the programmer can interactively select and customize "snippets" of source code. Program "wizards", which allow the programmer to design graphical user interfaces interactively while the compiler invisibly generates the corresponding source code, are another common form of source code generation. This may be contrasted with, for example, user interface markup languages, which define user interfaces declaratively.</p>
<p>Besides the generation of code from a wizard or template, IDEs can also generate and manipulate code to automate code refactorings that would require multiple (error prone) manual steps, thereby improving developer productivity. Examples of such features in IDEs are the refactoring class browsers for Smalltalk and those found in Java IDEs like IntelliJ and Eclipse.</p>
<p>A specialized alternative involves the generation of <i>optimized</i> code for quantities defined mathematically within a Computer algebra system (CAS). Compiler optimization consisting of finding common intermediates of a vector of size <img class="mwe-math-fallback-image-inline tex" alt=" n " src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> requires a complexity of <img class="mwe-math-fallback-image-inline tex" alt="O(n^2)" src="//upload.wikimedia.org/math/1/8/9/189317b4b935a745fcfaf95940d2b4f0.png"> or <img class="mwe-math-fallback-image-inline tex" alt="O(n^3)" src="//upload.wikimedia.org/math/6/8/0/6809c59370e21b3e6e8fd117442fd377.png"> operations whereas the very design of a computer algebra system requires only <img class="mwe-math-fallback-image-inline tex" alt="O(n)" src="//upload.wikimedia.org/math/7/b/a/7ba55e7c64a9405a0b39a1107e90ca94.png"> operations. These facilities can be used as pre-optimizer before processing by the compiler. This option has been used for handling mathematically large expressions in e.g. computational (quantum) chemistry.</p>
<p>Examples:</p>
<ul>
<li>Acceleo is an open source code generator for Eclipse used to generate any textual language (Java, PHP, Python, etc.) from EMF models defined from any metamodel (UML, SysML, etc.).</li>
</ul>
<ul>
<li>Actifsource is a plugin for Eclipse that allows graphical modelling and model-based code generation using custom templates.</li>
</ul>
<ul>
<li>Altova MapForce is a graphical data mapping, conversion, and integration tool capable of generating application code in Java, C#, or C++ for executing recurrent transformations.</li>
</ul>
<ul>
<li>CodeFluent Entities from SoftFluent is a graphical tool integrated into Microsoft Visual Studio that generates .NET source code, in C# or Visual Basic.</li>
</ul>
<ul>
<li>DMS Software Reengineering Toolkit is a system for defining arbitrary domain specific languages and translating them to other languages.</li>
</ul>
<ul>
<li>General-purpose declarative language uses the natural and built-in generative programming capabilities provided by macroexpansion in Common Lisp in order to achieve seamless automatic programming.</li>
</ul>
<ul>
<li>hprcARCHITECT (from MNB Technologies, Inc) is an artificial intelligence-based software development tool with a Virtual Whiteboard human interface. Language and technology agnostic, the tool's development was funded by the US Air Force to solve the problem of code generation for systems targeting mixed processor technologies.</li>
</ul>
<ul>
<li>Spring Roo is an open source active code generator for Spring Framework based Java applications. It uses AspectJ mixins to provide separation of concerns during round-trip maintenance.</li>
</ul>
<ul>
<li>RISE is a free information modeling suite for system development using ERD or UML. Database code generation for MySQL, PostgreSQL and Microsoft SQL Server. Persistence code generation for C# (.NET) and PHP including both SOAP and JSON style web services and AJAX proxy code.</li>
</ul>
<ul>
<li>The Maple computer algebra system offers code generators optimizers with Fortran, C and Java. Mathematica and MuPAD have comparable interfaces.</li>
</ul>
<ul>
<li>Screen Sculptor, SoftCode, UI Programmer, and Genifer are examples of pioneering program generators that arose during the mid-1980s through the early 1990s. They developed and advanced the technology of extendable, template based source code generators on a mass market scale.</li>
</ul>
<ul>
<li>GeneXus is a Cross-Platform, knowledge representation-based, development tool,[1] mainly oriented to enterprise-class applications for Web applications, smart devices and the Microsoft Windows platform. A developer describes an application in a high-level, mostly declarative language, from which native code is generated for multiple environments.</li>
</ul>
<h2>See also</h2>
<ul>
<li>Code generation (compiler)</li>
<li>Code optimization (compiler)</li>
<li>Comparison of code generation tools</li>
<li>Template processor</li>
<li>Source-to-source compiler</li>
<li>Model Driven Engineering (MDE)</li>
<li>Model Driven Architecture (MDA)</li>
<li>Domain-Specific Modeling (DSM)</li>
<li>Feature Oriented Programming</li>
<li>Program transformation</li>
</ul>
<ul>
<li>Modeling language</li>
<li>Data transformation</li>
<li>Semantic translation</li>
<li>Vocabulary-based transformation</li>
<li>Metaprogramming</li>
<li>Language-oriented programming (LOP)</li>
<li>Object-oriented analysis and design (OOAD)</li>
<li>Unified Modeling Language (UML)</li>
</ul>
<ul>
<li>artificial intelligence</li>
<li>Multi-agent system</li>
<li>Inductive programming</li>
</ul>
</body>
</html>