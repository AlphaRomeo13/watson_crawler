<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Effects-of-Type-Erasure-and-Bridge-Methods-The-Java-Tutorials---------------------Learning-the-Java-Language--Generics-Updated.html</title></head>
<body>
<h1>Effects of Type Erasure and Bridge Methods</h1>
<p>
Sometimes type erasure causes a situation that you may not have anticipated. The following example shows how this can occur. The example (described in
Bridge Methods) shows how a compiler sometimes creates a synthetic method, called a bridge method, as part of the type erasure process.</p>
<p>
Given the following two classes:</p>
<p>WHATSON? f1f757fe-d92e-42f3-9741-27b734344350</p>
<pre>
public class Node&lt;T&gt; {

    private T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node&lt;Integer&gt; {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
</pre>
<p>
Consider the following code:</p>
<p>WHATSON? 0d7eab43-6713-461c-9bba-dba58a69271e</p>
<pre>
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     // Causes a ClassCastException to be thrown.
Integer x = mn.data;
</pre>
<p>
After type erasure, this code becomes:</p>
<p>WHATSON? 55ad7a41-6adb-42c1-9185-c13726e8d27c</p>
<pre>
MyNode mn = new MyNode(5);
Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
n.setData("Hello");
Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.
</pre>
<p>
Here is what happens as the code is executed:</p>
<ul>
<li><tt>n.setData("Hello");</tt> causes the method <tt>setData(Object)</tt> to be executed on the object of class <tt>MyNode</tt>. (The <tt>MyNode</tt> class inherited <tt>setData(Object)</tt> from <tt>Node</tt>.)</li>
<li>In the body of <tt>setData(Object)</tt>, the data field of the object referenced by <tt>n</tt> is assigned to a <tt>String</tt>.</li>
<li>The data field of that same object, referenced via <tt>mn</tt>, can be accessed and is expected to be an integer (since <tt>mn</tt> is a <tt>MyNode</tt> which is a <tt>Node&lt;Integer&gt;</tt>.</li>
<li>Trying to assign a <tt>String</tt> to an <tt>Integer</tt> causes a <tt>ClassCastException</tt> from a cast inserted at the assignment by a Java compiler.</li>
</ul>
<h2>Bridge Methods</h2>
<p>
When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a <em>bridge method</em>, as part of the type erasure process. You normally don't need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p>
<p>
After type erasure, the <tt>Node</tt> and <tt>MyNode</tt> classes become:</p>
<p>WHATSON? dfb39b30-7440-465f-930a-be394e83709e</p>
<pre>
public class Node {

    private Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println(Integer data);
        super.setData(data);
    }
}
</pre>
<p>
After type erasure, the method signatures do not not match. The <tt>Node</tt> method becomes <tt>setData(Object)</tt> and the <tt>MyNode</tt> method becomes <tt>setData(Integer)</tt>. Therefore, the <tt>MyNode</tt> <tt>setData</tt> method does not override the <tt>Node</tt> <tt>setData</tt> method.</p>
<p>
To solve this problem and preserve the
polymorphism of generic types after type erasure, a Java compiler generates a bridge method to ensure that subtyping works as expected. For the <tt>MyNode</tt> class, the compiler generates the following bridge method for <tt>setData</tt>:</p>
<p>WHATSON? 95579e6d-feb7-4444-89fe-a6595ee172de</p>
<pre>
class MyNode extends Node {

    <strong>// Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }</strong>

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
</pre>
<p>
As you can see, the bridge method, which has the same method signature as the <tt>Node</tt> class's <tt>setData</tt> method after type erasure, delegates to the original <tt>setData</tt> method.</p>
</body>
</html>