<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Concurrent-computing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Concurrent computing</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li><strong class="selflink">Concurrent computing</strong>
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Concurrent computing</b> is a form of computing in which several computations are executing during overlapping time periods – <i>concurrently</i> – instead of <i>sequentially</i> (one completing before the next starts). This is a property of a system – this may be an individual program, a computer, or a network – and there is a separate execution point or "thread of control" for each computation ("process"). A <i>concurrent system</i> is one where a computation can make progress without waiting for all other computations to complete – where more than one computation can make progress at "the same time" (see definition, below).</p>
<p>As a programming paradigm, concurrent computing is a form of modular programming, namely factoring an overall computation into subcomputations that may be executed concurrently. Pioneers in the field of concurrent computing include Edsger Dijkstra, Per Brinch Hansen, and C.A.R. Hoare.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Introduction
<ul>
<li>1.1 Coordinating access to shared resources</li>
<li>1.2 Advantages of concurrent computation</li>
</ul>
</li>
<li>2 Models of concurrency</li>
<li>3 Implementation
<ul>
<li>3.1 Concurrent interaction and communication</li>
</ul>
</li>
<li>4 History</li>
<li>5 Prevalence</li>
<li>6 Languages supporting concurrent programming</li>
<li>7 See also</li>
<li>8 Notes</li>
<li>9 References</li>
<li>10 Further reading</li>
<li>11 External links</li>
</ul>
<ul>
<li>1.1 Coordinating access to shared resources</li>
<li>1.2 Advantages of concurrent computation</li>
</ul>
<ul>
<li>3.1 Concurrent interaction and communication</li>
</ul>
<p></p>
<h2>Introduction</h2>
<p>Concurrent computing is related to but distinct from parallel computing, though these concepts are frequently confused, and both can be described as "multiple processes executing <i>during the same period of time</i>". In parallel computing, execution literally occurs at the same instant, for example on separate processors of a multi-processor machine – parallel computing is impossible on a (single-core) single processor, as only one computation can occur at any instant (during any single clock cycle). By contrast, concurrent computing consists of process <i>lifetimes</i> overlapping, but execution need not happen at the same instant.</p>
<p>For example, concurrent processes can be executed on a single core by interleaving the execution steps of each process via time slices: only one process runs at a time, and if it does not complete during its time slice, it is <i>paused,</i> another process begins or resumes, and then later the original process is resumed. In this way multiple processes are part-way through execution at a single instant, but only one process is being executed at that instant.</p>
<p>Concurrent computations <i>may</i> be executed in parallel, for example by assigning each process to a separate processor or processor core, or distributing a computation across a network. This is known as task parallelism.</p>
<p>By contrast, parallel computing by data parallelism may or may not be concurrent computing – a single process may control all computations, in which case it is not concurrent, or the computations may be spread across several processes, in which case this is concurrent. For example, SIMD (single instruction, multiple data) processing is (data) parallel but not concurrent – multiple computations are happening at the same instant (in parallel), but there is only a single process. Examples of this include vector processors and graphics processing units (GPUs). By contrast, MIMD (multiple instruction, multiple data) processing is both data parallel and task parallel, and is concurrent; this is commonly implemented as SPMD (single program, multiple data), where multiple programs execute concurrently and in parallel on different data.</p>
<p>The exact timing of when tasks in a concurrent system are executed depend on the scheduling, and tasks need not always be executed concurrently. For example, given two tasks, T1 and T2:</p>
<ul>
<li>T1 may be executed and finished before T2</li>
<li>T2 may be executed and finished before T1</li>
<li>T1 and T2 may be executed alternatively (time-slicing)</li>
<li>T1 and T2 may be executed simultaneously at the same instant of time (parallelism)</li>
</ul>
<p>The word "sequential" is used as an antonym for both "concurrent" and "parallel"; when these are explicitly distinguished, <i>concurrent/sequential</i> and <i>parallel/serial</i> are used as opposing pairs.</p>
<h3>Coordinating access to shared resources</h3>
<p>The main challenge in designing concurrent programs is concurrency control: ensuring the correct sequencing of the interactions or communications between different computational executions, and coordinating access to resources that are shared among executions. Potential problems include race conditions, deadlocks, and resource starvation. For example, consider the following algorithm for making withdrawals from a checking account represented by the shared resource <code>balance</code>:</p>
<ol>
<li>
<pre>
  bool withdraw( int withdrawal )
</pre></li>
<li>
<pre>
  {
</pre></li>
<li>
<pre>
     if ( balance &gt;= withdrawal )
</pre></li>
<li>
<pre>
     {
</pre></li>
<li>
<pre>
         balance -= withdrawal;
</pre></li>
<li>
<pre>
         return true;
</pre></li>
<li>
<pre>
     } 
</pre></li>
<li>
<pre>
     return false;
</pre></li>
<li>
<pre>
  }
</pre></li>
</ol>
<p>WHATSON? d8966dd6-fe10-4616-9260-115241d4a80a</p>
<pre>
  bool withdraw( int withdrawal )
</pre>
<p>WHATSON? 8b017667-7092-43f4-9919-d99424921e85</p>
<pre>
  {
</pre>
<p>WHATSON? 061178fe-d207-4e65-a9f7-dd32636a0cf4</p>
<pre>
     if ( balance &gt;= withdrawal )
</pre>
<p>WHATSON? b96458de-eba6-4e4a-9e77-e680e77df6b1</p>
<pre>
     {
</pre>
<p>WHATSON? db36e9de-c07c-4afe-ab5d-85ee58e883e2</p>
<pre>
         balance -= withdrawal;
</pre>
<p>WHATSON? 98083d98-62ff-4fc9-b417-05e874e0a8bb</p>
<pre>
         return true;
</pre>
<p>WHATSON? e92fb35b-9adb-4e8b-b66c-7bd5cfe4584c</p>
<pre>
     } 
</pre>
<p>WHATSON? c5991f0f-c142-4575-bdd8-d818759e6f69</p>
<pre>
     return false;
</pre>
<p>WHATSON? 3b2a8f2a-53eb-4af5-910d-acae944845a0</p>
<pre>
  }
</pre>
<p>Suppose <code>balance=500</code>, and two concurrent <i>threads</i> make the calls <code>withdraw(300)</code> and <code>withdraw(350)</code>. If line 3 in both operations executes before line 5 both operations will find that <code>balance &gt; withdrawal</code> evaluates to <code>true</code>, and execution will proceed to subtracting the withdrawal amount. However, since both processes perform their withdrawals, the total amount withdrawn will end up being more than the original balance. These sorts of problems with shared resources require the use of concurrency control, or non-blocking algorithms.</p>
<p>Because concurrent systems rely on the use of shared resources (including communication media), concurrent computing in general requires the use of some form of arbiter somewhere in the implementation to mediate access to these resources.</p>
<p>Unfortunately, while many solutions exist to the problem of a conflict over one resource, many of those "solutions" have their own concurrency problems such as deadlock when more than one resource is involved.</p>
<h3>Advantages of concurrent computation</h3>
<ul>
<li>Increased application throughput – parallel execution of a concurrent program allows the number of tasks completed in certain time period to increase.</li>
<li>High responsiveness for input/output – input/output-intensive applications mostly wait for input or output operations to complete. Concurrent programming allows the time that would be spent waiting to be used for another task.</li>
<li>More appropriate program structure – some problems and problem domains are well-suited to representation as concurrent tasks or processes.</li>
</ul>
<h2>Models of concurrency</h2>
<p>There are several models of concurrent computing, which can be used to understand and analyze concurrent systems. These models include:</p>
<ul>
<li>Actor model
<ul>
<li>Object-capability model for security</li>
</ul>
</li>
<li>Petri nets</li>
<li>Process calculi such as
<ul>
<li>Ambient calculus</li>
<li>Calculus of Communicating Systems (CCS)</li>
<li>Communicating Sequential Processes (CSP)</li>
<li>π-calculus</li>
<li>Join-calculus</li>
</ul>
</li>
<li>Input/output automaton</li>
</ul>
<ul>
<li>Object-capability model for security</li>
</ul>
<ul>
<li>Ambient calculus</li>
<li>Calculus of Communicating Systems (CCS)</li>
<li>Communicating Sequential Processes (CSP)</li>
<li>π-calculus</li>
<li>Join-calculus</li>
</ul>
<h2>Implementation</h2>
<p>A number of different methods can be used to implement concurrent programs, such as implementing each computational execution as an operating system process, or implementing the computational processes as a set of threads within a single operating system process.</p>
<h3>Concurrent interaction and communication</h3>
<p>In some concurrent computing systems, communication between the concurrent components is hidden from the programmer (e.g., by using futures), while in others it must be handled explicitly. Explicit communication can be divided into two classes:</p>
<p>Shared memory and message passing concurrency have different performance characteristics. Typically (although not always), the per-process memory overhead and task switching overhead is lower in a message passing system, but the overhead of message passing itself is greater than for a procedure call. These differences are often overwhelmed by other performance factors.</p>
<h2>History</h2>
<p>Concurrent computing developed out of earlier work on railroads and telegraphy, from the 19th and early 20th century, and some terms date to this period, such as semaphores. These arose to address the question of how to handle multiple trains on the same railroad system (avoiding collisions and maximizing efficiency) and how to handle multiple transmissions over a given set of wires (improving efficiency), such as via time-division multiplexing (1870s).</p>
<p>The academic study of concurrent algorithms started in the 1960s, with Dijkstra (1965) credited with being the first paper in this field, identifying and solving mutual exclusion.</p>
<h2>Prevalence</h2>
<p>Concurrency is pervasive in computing, occurring from low-level hardware on a single chip to world-wide networks. Examples follow.</p>
<p>At the hardware level:</p>
<ul>
<li>Instruction pipeline in a central processing unit (CPU) makes the instruction cycle concurrent</li>
<li>Graphics pipeline in a graphics processing unit (GPU)</li>
</ul>
<p>At the programming language level:</p>
<ul>
<li>Channel</li>
<li>Coroutine</li>
<li>Futures and promises</li>
</ul>
<p>At the operating system level:</p>
<ul>
<li>Computer multitasking, including both cooperative multitasking and preemptive multitasking
<ul>
<li>Time-sharing, which replaced sequential batch processing of jobs with concurrent use of a system</li>
</ul>
</li>
<li>Process</li>
<li>Thread</li>
</ul>
<ul>
<li>Time-sharing, which replaced sequential batch processing of jobs with concurrent use of a system</li>
</ul>
<p>At the network level, networked systems are generally concurrent by their nature, as they consist of separate devices.</p>
<p>A widespread basic example of concurrency in software engineering is a software pipeline, which considers individual steps in the pipeline as filters operating on a stream. For example, some or all phases of a compiler may be structured as a pipeline. Today this is most common for the compiler frontend, structured as a lexer followed by a parser, which start with a stream of source code, which is converted by the lexer to a stream of tokens, then by the parser to a parse tree – this can also be done for other computer languages like HTML. This may be followed by other pipeline stages, notably in a one-pass compiler, though most modern compilers in most uses are multi-pass and do not operate as strict pipelines.</p>
<h2>Languages supporting concurrent programming</h2>
<p>Concurrent programming languages are programming languages that use language constructs for concurrency. These constructs may involve multi-threading, support for distributed computing, message passing, shared resources (including shared memory) or futures and promises. Such languages are sometimes described as Concurrency Oriented Languages or Concurrency Oriented Programming Languages (COPL).</p>
<p>Today, the most commonly used programming languages that have specific constructs for concurrency are Java and C#. Both of these languages fundamentally use a shared-memory concurrency model, with locking provided by monitors (although message-passing models can and have been implemented on top of the underlying shared-memory model). Of the languages that use a message-passing concurrency model, Erlang is probably the most widely used in industry at present.</p>
<p>Many concurrent programming languages have been developed more as research languages (e.g. Pict) rather than as languages for production use. However, languages such as Erlang, Limbo, and occam have seen industrial use at various times in the last 20 years. Languages in which concurrency plays an important role include:</p>
<ul>
<li>Ada - general purpose programming language with native support for message passing and monitor based concurrency.</li>
<li>Alef – concurrent language with threads and message passing, used for systems programming in early versions of Plan 9 from Bell Labs</li>
<li>Alice – extension to Standard ML, adds support for concurrency via futures.</li>
<li>Ateji PX – an extension to Java with parallel primitives inspired from pi-calculus</li>
<li>Axum – domain specific concurrent programming language, based on the Actor model and on the .NET Common Language Runtime using a C-like syntax.</li>
<li>Chapel – a parallel programming language being developed by Cray Inc.</li>
<li>Charm++ – C++-like language for thousands of processors.</li>
<li>Cilk – a concurrent C</li>
<li>Cω – C Omega, a research language extending C#, uses asynchronous communication</li>
<li>C# – supports concurrent computing since version 5.0 using lock, yield, async and await keywords, as well as the TPL</li>
<li>Clojure – a modern Lisp targeting the JVM</li>
<li>Concurrent Clean – a functional programming language, similar to Haskell</li>
<li>Concurrent Collections (CnC) Achieves implicit parallelism independent of memory model by explicitly defining data- and control flow</li>
<li>Concurrent Haskell – lazy, pure functional language operating concurrent processes on shared memory</li>
<li>Concurrent ML – a concurrent extension of Standard ML</li>
<li>Concurrent Pascal – by Per Brinch Hansen</li>
<li>Curry</li>
<li>D – multi-paradigm system programming language with explicit support for concurrent programming (Actor model)</li>
<li>E – uses promises, ensures deadlocks cannot occur</li>
<li>ECMAScript – promises available in various libraries, proposed for inclusion in standard in ECMAScript 6</li>
<li>Eiffel – through its SCOOP mechanism based on the concepts of Design by Contract</li>
<li>Elixir – dynamic and functional meta-programming aware language running on the Erlang VM.</li>
<li>Erlang – uses asynchronous message passing with nothing shared</li>
<li>Faust – Realtime functional programming language for signal processing. The Faust compiler provides automatic parallelization using either OpenMP or a specific work-stealing scheduler.</li>
<li>Fortran – Coarrays and "do concurrent" are part of Fortran 2008 standard</li>
<li>Go – systems programming language with a concurrent programming model based on CSP</li>
<li>Hume functional concurrent lang. for bounded space and time environments where automata processes are described by synchronous channels patterns and message passing.</li>
<li>Io – actor-based concurrency</li>
<li>Janus features distinct "askers" and "tellers" to logical variables, bag channels; is purely declarative</li>
<li>JoCaml Concurrent and distributed channel based language (extension of OCaml) that implements the Join-calculus of processes.</li>
<li>Join Java – concurrent language based on the Java programming language</li>
<li>Joule – dataflow language, communicates by message passing</li>
<li>Joyce – a concurrent teaching language built on Concurrent Pascal with features from CSP by Per Brinch Hansen</li>
<li>LabVIEW – graphical, dataflow programming language, in which functions are nodes in a graph and data is wires between those nodes. Includes object oriented language extensions.</li>
<li>Limbo – relative of Alef, used for systems programming in Inferno (operating system)</li>
<li>MultiLisp – Scheme variant extended to support parallelism</li>
<li>Modula-2 – systems programming language by N.Wirth as a successor to Pascal with native support for coroutines.</li>
<li>Modula-3 – modern language in Algol family with extensive support for threads, mutexes, condition variables.</li>
<li>Newsqueak – research language with channels as first-class values; predecessor of Alef</li>
<li>Node.js – modern javascript language</li>
<li>occam – influenced heavily by Communicating Sequential Processes (CSP).
<ul>
<li>occam-π – a modern variant of occam, which incorporates ideas from Milner's π-calculus</li>
</ul>
</li>
<li>Orc – a heavily concurrent, nondeterministic language based on Kleene algebra.</li>
<li>Oz – multiparadigm language, supports shared-state and message-passing concurrency, and futures
<ul>
<li>Mozart Programming System – multiplatform Oz</li>
</ul>
</li>
<li>ParaSail – a pointer-free, data-race-free, object-oriented parallel programming language</li>
<li>Pict – essentially an executable implementation of Milner's π-calculus</li>
<li>Perl with AnyEvent and Coro</li>
<li>Python with Twisted, greenlet and gevent.</li>
<li>Reia – uses asynchronous message passing between shared-nothing objects</li>
<li>Red/System – a system programming based on Rebol.</li>
<li>Rust – a systems programming language with a focus on massive concurrency, utilizing message-passing with move semantics, shared immutable memory, and shared mutable memory that is provably free of data races.</li>
<li>SALSA – actor language with token-passing, join, and first-class continuations for distributed computing over the Internet</li>
<li>Scala – a general purpose programming language designed to express common programming patterns in a concise, elegant, and type-safe way</li>
<li>SequenceL – general purpose functional programming language whose primary design objectives are ease of programming, code clarity/readability, and automatic parallelization for performance on multicore hardware, which is provably free of Race condition</li>
<li>SR – research language</li>
<li>Stackless Python</li>
<li>StratifiedJS – a combinator-based concurrency language based on JavaScript</li>
<li>SuperPascal – a concurrent teaching language built on Concurrent Pascal and Joyce by Per Brinch Hansen</li>
<li>Swift (parallel scripting language) – a concurrent programming language with a C syntax for massively parallel architectures</li>
<li>Unicon – Research language.</li>
<li>Termite Scheme adds Erlang-like concurrency to Scheme</li>
<li>TNSDL – a language used at developing telecommunication exchanges, uses asynchronous message passing</li>
<li>VHDL – VHSIC Hardware Description Language, aka IEEE STD-1076</li>
<li>XC – a concurrency-extended subset of the C programming language developed by XMOS based on Communicating Sequential Processes. The language also offers built-in constructs for programmable I/O.</li>
</ul>
<ul>
<li>occam-π – a modern variant of occam, which incorporates ideas from Milner's π-calculus</li>
</ul>
<ul>
<li>Mozart Programming System – multiplatform Oz</li>
</ul>
<p>Many other languages provide support for concurrency in the form of libraries (on level roughly comparable with the above list).</p>
<h2>See also</h2>
<ul>
<li>List of important publications in concurrent, parallel, and distributed computing</li>
<li>Chu space</li>
<li>Critical section</li>
<li>Flow-based programming</li>
<li>Multitasking</li>
<li>Parallel computing</li>
<li>Ptolemy Project</li>
<li>Race condition</li>
<li>Sheaf (mathematics)</li>
<li>Software transactional memory</li>
<li>Transaction processing</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> This is discounting parallelism internal to a processor core, such as pipelining or vectorized instructions. A single-core, single-processor <i>machine</i> may be capable of some parallelism, such as with a coprocessor, but the processor itself is not.</li>
</ol>
</body>
</html>