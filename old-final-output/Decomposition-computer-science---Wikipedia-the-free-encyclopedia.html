<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Decomposition-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Decomposition (computer science)</h1>
<p><b>Decomposition</b> in computer science, also known as <i>factoring</i>, refers to the process by which a complex problem or system is broken down into parts that are easier to conceive, understand, program, and maintain.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Overview</li>
<li>2 Decomposition topics
<ul>
<li>2.1 Decomposition paradigm</li>
<li>2.2 Decomposition diagram</li>
</ul>
</li>
<li>3 See also</li>
<li>4 References</li>
<li>5 External links</li>
</ul>
<ul>
<li>2.1 Decomposition paradigm</li>
<li>2.2 Decomposition diagram</li>
</ul>
<p></p>
<h2>Overview</h2>
<p>There are different types of decomposition defined in computer sciences:</p>
<ul>
<li>In structured programming, <i>algorithmic decomposition</i> breaks a process down into well-defined steps.</li>
<li>Structured analysis breaks down a software system from the system context level to system functions and data entities as described by Tom DeMarco.</li>
<li><i>Object-oriented decomposition</i>, on the other hand, breaks a large system down into progressively smaller classes or objects that are responsible for some part of the problem domain.</li>
<li>According to Booch, algorithmic decomposition is a necessary part of object-oriented analysis and design, but object-oriented systems start with and emphasize decomposition into classes.</li>
</ul>
<p>More generally, functional decomposition in computer science is a technique for mastering the complexity of the function of a model. A functional model of a system is thereby replaced by a series of functional models of subsystems.</p>
<h2>Decomposition topics</h2>
<h3>Decomposition paradigm</h3>
<p>A decomposition paradigm in computer programming is a strategy for organizing a program as a number of parts, and it usually implies a specific way to organize a program text. Usually the aim of using a decomposition paradigm is to optimize some metric related to program complexity, for example the modularity of the program or its maintainability.</p>
<p>Most decomposition paradigms suggest breaking down a program into parts so as to minimize the static dependencies among those parts, and to maximize the cohesiveness of each part. Some popular decomposition paradigms are the procedural, modules, abstract data type and object oriented ones.</p>
<p>The concept of decomposition paradigm is entirely independent and different from that of model of computation, but the two are often confused, most often in the cases of the functional model of computation being confused with procedural decomposition, and of the actor model of computation being confused with object oriented decomposition.</p>
<h3>Decomposition diagram</h3>
<ul>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/ca/6_Decomposition_Structure.svg/93px-6_Decomposition_Structure.svg.png" width="93" height="120" data-file-width="744" data-file-height="957"></div>
</div>
<div class="gallerytext">
<p>Decomposition Structure</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:34px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/29/21_Negative_Node-Numbered_Context.svg/120px-21_Negative_Node-Numbered_Context.svg.png" width="120" height="82" data-file-width="673" data-file-height="461"></div>
</div>
<div class="gallerytext">
<p>Negative Node-Numbered Context</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:23px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/18/Static%2C_Dynamic%2C_and_Requirements_Models_for_Sys_Partition.jpg/120px-Static%2C_Dynamic%2C_and_Requirements_Models_for_Sys_Partition.jpg" width="120" height="104" data-file-width="814" data-file-height="704"></div>
</div>
<div class="gallerytext">
<p>Static, Dynamic, and Requirements Models for Systems Partition</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:17px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/28/Functions_and_Use_Scenarios_Mapping_to_Requirements_and_Goals.jpg/120px-Functions_and_Use_Scenarios_Mapping_to_Requirements_and_Goals.jpg" width="120" height="116" data-file-width="816" data-file-height="787"></div>
</div>
<div class="gallerytext">
<p>Functions and Use Scenarios Mapping to Requirements and Goals</p>
</div>
</div>
</li>
</ul>
<p>Decomposition Structure</p>
<p>Negative Node-Numbered Context</p>
<p>Static, Dynamic, and Requirements Models for Systems Partition</p>
<p>Functions and Use Scenarios Mapping to Requirements and Goals</p>
<p>A decomposition diagram shows a high-level function, process, organization, data subject area, or other type of object broken down into lower level, more detailed components. For example, decomposition diagrams may represent organizational structure or functional decomposition into processes. Decomposition diagrams provide a logical hierarchical decomposition of a system.</p>
<h2>See also</h2>
<ul>
<li>Code refactoring</li>
<li>Component-based software engineering</li>
<li>Dynamization</li>
<li>Duplicate code</li>
<li>Event partitioning</li>
<li>How to Solve It</li>
<li>Integrated Enterprise Modeling</li>
<li>Personal information management</li>
<li>Readability</li>
<li>Subroutine</li>
</ul>
</body>
</html>