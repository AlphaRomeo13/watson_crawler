<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Parameter-computer-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Parameter (computer programming)</h1>
<p>In computer programming, a <b>parameter</b> is a special kind of variable, used in a subroutine to refer to one of the pieces of data provided as input to the subroutine. These pieces of data are called <b>arguments</b>. An ordered list of parameters is usually included in the definition of a subroutine, so that, each time the subroutine is called, its arguments for that call can be assigned to the corresponding parameters.</p>
<p>Just as in standard mathematical usage, the <i>argument</i> is thus the actual input passed to a function, procedure, or routine, whereas the <i>parameter</i> is the variable inside the implementation of the subroutine. For example, if one defines the <code>add</code> subroutine as <code>def add(x, y): return x + y</code>, then <code>x, y</code> are parameters, while if this is called as <code>add(2, 3)</code>, then <code>2, 3</code> are the arguments. Note that variables from the calling context can be arguments: if the subroutine is called as <code>a = 2; b = 3; add(a, b)</code> then the <i>variables</i> <code>a, b</code> are the arguments, not only the <i>values</i> <code>2, 3</code>. See the Parameters and arguments section for more information.</p>
<p>In the most common case, call by value, a parameter acts within the subroutine as a variable initialized to the value of the argument (a local (isolated) copy of the argument if the argument is a variable), but in other cases, e.g. call by reference, the argument supplied by the caller can be affected by actions within the called subroutine (as discussed in evaluation strategy). In call by value, one can thus think of arguments as values (properly, think of the <i>value</i> of arguments as the "arguments" themselves), but in general arguments are not simply values.</p>
<p>The semantics for how parameters can be declared and how the arguments get passed to the parameters of subroutines are defined by the language, but the details of how this is represented in any particular computer system depend on the calling conventions of that system.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Example</li>
<li>2 Parameters and arguments
<ul>
<li>2.1 Alternative convention in Eiffel</li>
</ul>
</li>
<li>3 Datatypes</li>
<li>4 Argument passing
<ul>
<li>4.1 Default arguments</li>
<li>4.2 Variable-length parameter lists</li>
<li>4.3 Named parameters</li>
<li>4.4 Multiple parameters in functional languages</li>
</ul>
</li>
<li>5 Output parameters
<ul>
<li>5.1 Use</li>
<li>5.2 Drawbacks</li>
<li>5.3 Alternatives</li>
</ul>
</li>
<li>6 See also</li>
<li>7 Notes</li>
<li>8 References</li>
</ul>
<ul>
<li>2.1 Alternative convention in Eiffel</li>
</ul>
<ul>
<li>4.1 Default arguments</li>
<li>4.2 Variable-length parameter lists</li>
<li>4.3 Named parameters</li>
<li>4.4 Multiple parameters in functional languages</li>
</ul>
<ul>
<li>5.1 Use</li>
<li>5.2 Drawbacks</li>
<li>5.3 Alternatives</li>
</ul>
<p></p>
<h2>Example</h2>
<p>The following program in the C programming language defines a function that is named "sales_tax" and has one parameter named "price". The type of price is "double" (i.e. a double-precision floating point number). The function's return type is also a double.</p>
<p>WHATSON? f5310ca4-ed37-4b2a-a7de-c947fc0c005d</p>
<pre>
double sales_tax(double price)
{
    return 0.05 * price;
}
</pre>
<p>After the function has been defined, it can be invoked as follows:</p>
<p>WHATSON? 7cc01452-328f-47c4-8257-bf40a31f3d4c</p>
<pre>
sales_tax(10.00);
</pre>
<p>In this example, the function has been invoked with the number 10.00. When this happens, 10.00 will be assigned to price, and the function begins calculating its result. The steps for producing the result are specified below enclosed in {} "0.05 * price" indicates that the first thing to do is multiply 0.05 by the value of price, which gives 0.50. "return" means the function will produce the result of "0.05 * price". Therefore, the final result is 0.50.</p>
<h2>Parameters and arguments</h2>
<p>The terms <i>parameter</i> and <i>argument</i> are sometimes loosely used interchangeably, and the context is used to distinguish the meaning. The term <i>parameter</i> (sometimes called <i>formal parameter</i>) is often used to refer to the variable as found in the function definition, while <i>argument</i> (sometimes called <i>actual parameter</i>) refers to the actual input passed. For example, if one defines a function as <code>def f(x): ...</code>, then <code>x</code> is the parameter, while if it called by <code>a = ...; f(a)</code> then <code>a</code> is the argument. In both cases a parameter is an (unbound) variable, while the argument can be thought of as a value or variable, depending on the calling convention. In case of call by value, one can think of the argument as a value (properly, as the <i>value</i> of the argument) – for example, <code>f(2)</code> and <code>a = 2; f(a)</code> are equivalent calls – while in call by reference one can think of the argument as a variable in the calling context.</p>
<p>Parameters appear in procedure definitions; arguments appear in procedure calls. In the function definition <code>f(x) = x*x</code> the variable <var>x</var> is a parameter; in the function call <code>f(2)</code> the value 2 is the argument of the function. Loosely, a parameter is a type, and an argument is an instance.</p>
<p>A parameter is an intrinsic property of the procedure, included in its definition. For example, in many languages, a procedure to add two supplied integers together and calculate the sum would need two parameters, one for each integer. In general, a procedure may be defined with any number of parameters, or no parameters at all. If a procedure has parameters, the part of its definition that specifies the parameters is called its <i>parameter list</i>.</p>
<p>By contrast, the arguments are the values supplied to the procedure when it is called. Unlike the parameters, which form an unchanging part of the procedure's definition, the arguments may vary from call to call. Each time a procedure is called, the part of the procedure call that specifies the arguments is called the <i>argument list</i>.</p>
<p>Although parameters are also commonly referred to as arguments, arguments are more properly thought of as the actual values or references assigned to the parameter variables when the subroutine is called at run-time. When discussing code that is calling into a subroutine, any values or references passed into the subroutine are the arguments, and the place in the code where these values or references are given is the <i>parameter list</i>. When discussing the code inside the subroutine definition, the variables in the subroutine's parameter list are the parameters, while the values of the parameters at runtime are the arguments. For example in C, when dealing with threads it's common to pass in an argument of type void* and cast it to an expected type:</p>
<p>WHATSON? ed842fc7-9626-449e-9b4b-6bb1c22f0560</p>
<pre>
void ThreadFunction( void* pThreadArgument )
{
    // Naming the first parameter 'pThreadArgument' is correct, rather than
    // 'pThreadParameter'. At run time the value we use is an argument. As mentioned
    // above, reserve the term parameter for when discussing subroutine definitions.
}
</pre>
<p>To better understand the difference, consider the following function written in C:</p>
<p>WHATSON? 98ab4ed3-2086-469a-9b56-6d22b7c75c0a</p>
<pre>
int sum(int addend1, int addend2)
{
    return addend1 + addend2;
}
</pre>
<p>The function <i>sum</i> has two parameters, named <i>addend1</i> and <i>addend2</i>. It adds the values passed into the parameters, and returns the result to the subroutine's caller (using a technique automatically supplied by the C compiler).</p>
<p>The code which calls the <i>sum</i> function might look like this:</p>
<p>WHATSON? acc655d2-bcc5-4eb8-b377-fbd0c11d0e79</p>
<pre>
int sumValue;
int value1 = 40;
int value2 = 2;
 
sumValue = sum(value1, value2);
</pre>
<p>The variables <i>value1</i> and <i>value2</i> are initialized with values. <i>value1</i> and <i>value2</i> are both arguments to the <i>sum</i> function in this context.</p>
<p>At runtime, the values assigned to these variables are passed to the function <i>sum</i> as arguments. In the <i>sum</i> function, the parameters <i>addend1</i> and <i>addend2</i> are evaluated, yielding the arguments 40 and 2, respectively. The values of the arguments are added, and the result is returned to the caller, where it is assigned to the variable <i>sumValue</i>.</p>
<p>Because of the difference between parameters and arguments, it is possible to supply inappropriate arguments to a procedure. The call may supply too many or too few arguments; one or more of the arguments may be a wrong type; or arguments may be supplied in the wrong order. Any of these situations causes a mismatch between the parameter and argument lists, and the procedure will often return an unintended answer or generate a runtime error.</p>
<h3>Alternative convention in Eiffel</h3>
<p>Within the Eiffel software development method and language, the terms <i>argument</i> and <i>parameter</i> have distinct uses established by convention. The term <i>argument</i> is used exclusively in reference to a routine's inputs, and the term <i>parameter</i> is used exclusively in type parameterization for generic classes.</p>
<p>Consider the following routine definition:</p>
<p>WHATSON? 6232e16c-e7e6-44e8-91e5-c9407c8e8a27</p>
<pre>
    sum (addend1: INTEGER; addend2: INTEGER): INTEGER
        do
            Result := addend1 + addend2
        end
</pre>
<p>The routine <code>sum</code> takes two arguments <code>addend1</code> and <code>addend2</code>, which are called the routine's <b>formal arguments</b>. A call to <code>sum</code> specifies <b>actual arguments</b>, as shown below with <code>value1</code> and <code>value2</code>.</p>
<p>WHATSON? 05c4bfea-2b25-4e30-b37b-4d2033b6ffac</p>
<pre>
    sum_value: INTEGER
    value1: INTEGER = 40
    value2: INTEGER = 2
                …
            sum_value := sum (value1, value2)
</pre>
<p>Parameters are also thought of as either <b>formal</b> or <b>actual</b>. <b>Formal generic parameters</b> are used in the definition of generic classes. In the example below, the class <code>HASH_TABLE</code> is declared as a generic class which has two formal generic parameters, <code>G</code> representing data of interest and <code>K</code> representing the hash key for the data:</p>
<p>WHATSON? 45f5d08c-1614-48fa-a189-2684cab96da7</p>
<pre>
class HASH_TABLE [G, K -&gt; HASHABLE] 
            …
</pre>
<p>When a class becomes a client to <code>HASH_TABLE</code>, the formal generic parameters are substituted with <b>actual generic parameters</b> in a <b>generic derivation</b>. In the following attribute declaration, <code>my_dictionary</code> is to be used as a character string based dictionary. As such, both data and key formal generic parameters are substituted with actual generic parameters of type <code>STRING</code>.</p>
<p>WHATSON? a5d3c512-becd-40fd-a8ae-a5072493a0c9</p>
<pre>
    my_dictionary: HASH_TABLE [STRING, STRING]
</pre>
<h2>Datatypes</h2>
<p>In strongly typed programming languages, each parameter's type must be specified in the procedure's declaration. Languages using type inference attempt to discover the types automatically from the function's body and usage. Dynamically typed programming languages defer type resolution until run-time. Weakly typed languages perform little to no type resolution, relying instead on the programmer for correctness.</p>
<p>Some languages use a special keyword (e.g. <i>void</i>) to indicate that the subroutine has no parameters; in formal type theory, such functions take an empty parameter list (whose type is not <i>void</i>, but rather <i>unit</i>).</p>
<h2>Argument passing</h2>
<p>The exact mechanism for assigning arguments to parameters, called <i>argument passing</i>, depends upon the evaluation strategy used for that parameter (typically call by value), which may be specified using keywords.</p>
<h3>Default arguments</h3>
<p>Some programming languages such as Ada, C++, Clojure, Common Lisp, Fortran 90, Python, Ruby, Tcl, and Windows PowerShell allow for a default argument to be explicitly or implicitly given in a subroutine's declaration. This allows the caller to omit that argument when calling the subroutine. If the default argument is explicitly given, then that value is used if it is not provided by the caller. If the default argument is implicit (sometimes by using a keyword such as <i>Optional</i>) then the language provides a well-known value (such as <i>null</i>, <i>Empty</i>, zero, an empty string, etc.) if a value is not provided by the caller.</p>
<p>PowerShell example:</p>
<p>WHATSON? c58e796c-ea49-403a-b12d-97e9ca7b06b8</p>
<pre>
 function doc($g = 1.21) {
   "$g gigawatts? $g gigawatts? Great Scott!"
 }
</pre>
<p>WHATSON? dd908b9f-13d2-449e-a0a4-88dfb4edba67</p>
<pre>
<b>PS&gt;</b> doc
1.21 gigawatts? 1.21 gigawatts? Great Scott!
</pre>
<p>WHATSON? fad59b9a-786d-45f7-b1df-a6edb4f0c234</p>
<pre>
<b>PS&gt;</b> doc 88
88 gigawatts? 88 gigawatts? Great Scott!
</pre>
<p>Default arguments can be seen as a special case of the variable-length argument list.</p>
<h3>Variable-length parameter lists</h3>
<p>Some languages allow subroutines to be defined to accept a variable number of arguments. For such languages, the subroutines must iterate through the list of arguments.</p>
<p>PowerShell example:</p>
<p>WHATSON? 772a40f9-7383-4cf6-a74c-d98f6ef53e33</p>
<pre>
 function marty {
   $args | foreach { "back to the year $_" }
 }
</pre>
<p>WHATSON? 1c5b7f3a-8b89-4c5f-9e29-6d8d46d0d01d</p>
<pre>
<b>PS&gt;</b> marty 1985
back to the year 1985
</pre>
<p>WHATSON? 6a9b4214-4a5b-4514-95c5-7a214d0a2e00</p>
<pre>
<b>PS&gt;</b> marty 2015 1985 1955
back to the year 2015
back to the year 1985
back to the year 1955
</pre>
<h3>Named parameters</h3>
<p>Some programming languages—such as Ada and Windows PowerShell—allow subroutines to have named parameters. This allows the calling code to be more self-documenting. It also provides more flexibility to the caller, often allowing the order of the arguments to be changed, or for arguments to be omitted as needed.</p>
<p>PowerShell example:</p>
<p>WHATSON? f4f8ad68-dd88-412b-8edd-991d93229635</p>
<pre>
 function jennifer($adjectiveYoung, $adjectiveOld) {
   "Young Jennifer: I'm $adjectiveYoung!"
   "Old Jennifer: I'm $adjectiveOld!"
 }
</pre>
<p>WHATSON? 209467c3-047e-414f-9300-03497bfaad8e</p>
<pre>
<b>PS&gt;</b> jennifer 'fresh' 'experienced'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<p>WHATSON? dc5b6b51-6c59-4cdf-be3d-4bff99d6c0c3</p>
<pre>
<b>PS&gt;</b> jennifer -adjectiveOld 'experienced' -adjectiveYoung 'fresh'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<h3>Multiple parameters in functional languages</h3>
<p>In lambda calculus, each function has exactly one parameter. What is thought of as functions with multiple parameters is usually represented in lambda calculus as a function which takes the first argument, and returns a function which takes the rest of the arguments; this is a transformation known as currying. Some programming languages, like ML and Haskell, follow this scheme. In these languages, every function has exactly one parameter, and what may look like the definition of a function of multiple parameters, is actually syntactic sugar for the definition of a function that returns a function, etc. Function application is left-associative in these languages as well as in lambda calculus, so what looks like an application of a function to multiple arguments is correctly evaluated as the function applied to the first argument, then the resulting function applied to the second argument, etc.</p>
<h2>Output parameters</h2>
<p>An <b>output parameter</b>, also known as an <b>out parameter</b> or <b>return parameter</b>, is a parameter used for output, rather than the more usual use for input. Using call by reference parameters, or call by value parameters where the value is a reference, as output parameters is an idiom in some languages, notably C and C++, while other languages have built-in support for output parameters. Languages with built-in support for output parameters include Ada (see Ada subprograms), Fortran (since Fortran 90; see Fortran "intent"), various procedural extensions to SQL, such as PL/SQL (see PL/SQL functions) and Transact-SQL, C# and the .NET Framework, and the scripting language TScript (see TScript function declarations).</p>
<p>More precisely, one may distinguish three types of parameters or <b>parameter modes</b>: <i>input parameters</i>, <i>output parameters,</i> and <i>input/output parameters;</i> these are often denoted <code>in</code>, <code>out</code>, and <code>in out</code> or <code>inout</code>. An input argument (the argument to an input parameter) must be a value, such as an initialized variable or literal, and must not be redefined or assigned to; an output argument must be an assignable variable, but it need not be initialized, any existing value is not accessible, and must be assigned a value; and an input/output argument must be an initialized, assignable variable, and can optionally be assigned a value. The exact requirements and enforcement vary between languages – for example, in Ada 83 output parameters can only be assigned to, not read, even after assignment (this was removed in Ada 95 to remove the need for an auxiliary accumulator variable). These are analogous to the notion of a value in an expression being an r-value (has a value), an l-value (can be assigned), or an r-value/l-value (has a value and can be assigned), respectively, though these terms have specialized meanings in C.</p>
<p>In some cases only input and input/output are distinguished, with output being considered a specific use of input/output, and in other cases only input and output (but not input/output) are supported. The default mode varies between languages: in Fortran 90 input/output is default, while in C# and SQL extensions input is default, and in TScript each parameter is explicitly specified as input or output.</p>
<p>Syntactically, parameter mode is generally indicated with a keyword in the function declaration, such as <code>void f(out int x)</code> in C#. Conventionally output parameters are often put at the end of the parameter list to clearly distinguish them, though this is not always followed. TScript uses a different approach, where in the function declaration input parameters are listed, then output parameters, separated by a colon (:) and there is no return type to the function itself, as in this function, which computes the size of a text fragment:</p>
<p>WHATSON? f8af5c4e-e057-46c7-94ff-3310d379885e</p>
<pre>
 TextExtent(WString text, Font font : Integer width, Integer height)
</pre>
<p>Parameter modes are a form of denotational semantics, stating the programmer's intent and allowing compilers to catch errors and apply optimizations – they do not necessarily imply operational semantics (how the parameter passing actually occurs). Notably, while input parameters can be implemented by call by value, and output and input/output parameters by call by reference – and this is a straightforward way to implement these modes in languages without built-in support – this is not always how they are implemented. This distinction is discussed in detail in the <i>Ada '83 Rationale,</i> which emphasizes that the parameter mode is abstracted from which parameter passing mechanism (by reference or by copy) is actually implemented. For instance, while in C# input parameters (default, no keyword) are passed by value, and output and input/output parameters (<code>out</code> and <code>ref</code>) are passed by reference, in PL/SQL input parameters (<code>IN</code>) are passed by reference, and output and input/output parameters (<code>OUT</code> and <code>IN OUT</code>) are by default passed by value and the result copied back, but can be passed by reference by using the <code>NOCOPY</code> compiler hint.</p>
<p>A syntactically similar construction to output parameters is to assign the return value to a variable with the same name as the function. This is found in Pascal and Fortran 66 and Fortran 77, as in this Pascal example:</p>
<p>WHATSON? 80936467-838f-470e-add8-6d6dde123fb8</p>
<pre>
function f(x, y: integer): integer;
begin
    f := x + y;
end;
</pre>
<p>This is semantically different in that when called, the function is simply evaluated – it is not passed a variable from the calling scope to store the output in.</p>
<h3>Use</h3>
<p>The primary use of output parameters is to return multiple values from a function, while the use of input/output parameters is to modify state using parameter passing (rather than by shared environment, as in global variables). An important use of returning multiple values is to solve the semipredicate problem of returning both a value and an error status – see Semipredicate problem: Multivalued return.</p>
<p>For example, to return two variables from a function in C, one may write:</p>
<p>WHATSON? 3dee6b22-a512-4b3f-91dd-0d80c839e3fd</p>
<pre>
int width, height;
f(x, &amp;width, &amp;height);
</pre>
<p>where <code>x</code> is an input parameter and <code>width</code> and <code>height</code> are output parameters, passed by reference.</p>
<p>A common use case in C and related languages is for exception handling, where a function places the return value in an output variable, and returns a boolean corresponding to whether the function succeeded or not. An archetypal example is the <code>TryParse</code> method in .NET, especially C#, which parses a string into an integer, returning <code>true</code> on success and <code>false</code> on failure. This has the following signature:</p>
<p>WHATSON? 576b768c-47aa-4b55-b238-82583678f22c</p>
<pre>
public static bool TryParse(string s, out int result)
</pre>
<p>and may be used as follows:</p>
<p>WHATSON? 76d13ba9-68f6-441e-9dd4-7ae86a2b01be</p>
<pre>
int result;
if (!Int32.TryParse(s, result)) {
    // exception handling
}
</pre>
<p>Similar considerations apply to returning a value of one of several possible types, where the return value can specify the type and then value is stored in one of several output variables.</p>
<p>Another use is as a micro-optimization, to avoid assigning a local variable in a function and then needing to copy it when returning. This can be done when output parameters are implemented by call by reference. For example, in C++, instead of the more usual:</p>
<p>WHATSON? f08fe5c3-27d4-4a2c-80ca-dc96d2ea749d</p>
<pre>
LargeObject obj = f(x);
</pre>
<p>one might instead write:</p>
<p>WHATSON? a4e0f3d4-1356-46b5-abe5-54a2fbfcceaf</p>
<pre>
LargeObject obj;
f(x, &amp;obj);
</pre>
<p>so the function <code>f</code> does not need to assign space for the object or copy it on returning.</p>
<h3>Drawbacks</h3>
<p>Output parameters are often discouraged in modern programming, essentially as being awkward, confusing, and too low-level – commonplace return values are considerably easier to understand and work with. Notably, output parameters involve functions with side effects (modifying the output parameter) and are semantically similar to references, which are more confusing than pure functions and values, and the distinction between output parameters and input/output parameters can be subtle. Further, since in common programming styles most parameters are simply input parameters, output parameters and input/output parameters are unusual and hence susceptible to misunderstanding.</p>
<p>Output and input/output parameters prevent function composition, since the output is stored in variables, rather than in the value of an expression. Thus one must initially declare a variable, and then each step of a chain of functions must be a separate statement. For example, in C++ the following function composition:</p>
<p>WHATSON? 18a768df-0dbc-4e63-90f7-df858e1525c5</p>
<pre>
Object obj = g(y, f(x));
</pre>
<p>when written with output and input/output parameters instead becomes (for <code>f</code> it is an output parameter, for <code>g</code> an input/output parameter):</p>
<p>WHATSON? 0f0567f3-b7ee-4fae-b3ce-298f3feabbd7</p>
<pre>
Object obj;
f(x, &amp;obj);
g(y, &amp;obj);
</pre>
<p>In the special case of a function with a single output or input/output parameter and no return value, function composition is possible if the output or input/output parameter (or in C/C++, its address) is also returned by the function, in which case the above becomes:</p>
<p>WHATSON? 087f2add-4ef8-4fb3-9e12-7527e0d323cd</p>
<pre>
Object obj;
g(y, f(x, &amp;obj));
</pre>
<h3>Alternatives</h3>
<p>There are various alternatives to the use cases of output parameters.</p>
<p>For returning multiple values from a function, an alternative is to return a tuple. Syntactically this is clearer if automatic sequence unpacking and parallel assignment can be used, as in Go or Python, such as:</p>
<p>WHATSON? 42dc0835-c8c9-4d33-97ad-90eac30da1fe</p>
<pre>
def f():
    return 1, 2
a, b = f()
</pre>
<p>For returning a value of one of several types, a tagged union can be used instead; the most common cases are nullable types (option types), where the return value can be null to indicate failure. For exception handling, one can return a nullable type, or raise an exception. For example, in Python one might have either:</p>
<p>WHATSON? b3a23756-d518-4bb3-80ab-688a2596be99</p>
<pre>
result = Parse(s)
if result is None:
    # exception handling
</pre>
<p>or, more idiomatically:</p>
<p>WHATSON? 58600591-904e-4e9e-8998-b5b1f7b25f30</p>
<pre>
try:
    result = Parse(s)
except ParseError:
    # exception handling
</pre>
<p>The micro-optimization of not requiring a local variable and copying the return when using output variables can also be applied to conventional functions and return values by sufficiently sophisticated compilers.</p>
<p>The usual alternative to output parameters in C and related languages is to return a single data structure containing all return values. For example, given a structure encapsulating width and height, one can write:</p>
<p>WHATSON? 3e2f720f-c5cf-4b78-9207-1ff3dba18828</p>
<pre>
WidthHeight width_and_height = f(x);
</pre>
<p>In object-oriented languages, instead of using input/output parameters, one can often use call by sharing, passing a reference to an object and then mutating the object, though not changing which object the variable refers to.</p>
<h2>See also</h2>
<ul>
<li>Command-line argument</li>
<li>Evaluation strategy</li>
<li>Operator overloading</li>
<li>Free variables and bound variables</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> In this article, the term "subroutine" refers to any subroutine-like construct, which have different names and slightly different meanings depending on the programming language being discussed.</li>
<li><b>^</b> C and C++ are call by value, but if type is a reference (a C/C++ pointer or C++ reference), then setting the value of the reference can be used to produce call by reference style behavior.</li>
</ol>
</body>
</html>