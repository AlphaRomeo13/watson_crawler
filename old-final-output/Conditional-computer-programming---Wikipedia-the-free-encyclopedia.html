<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Conditional-computer-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Conditional (computer programming)</h1>
<p>In computer science, <b>conditional statements</b>, <b>conditional expressions</b> and <b>conditional constructs</b> are features of a programming language which perform different computations or actions depending on whether a programmer-specified boolean <i>condition</i> evaluates to true or false. Apart from the case of branch predication, this is always achieved by selectively altering the control flow based on some condition.</p>
<p>In imperative programming languages, the term "conditional statement" is usually used, whereas in functional programming, the terms "conditional expression" or "conditional construct" are preferred, because these terms all have distinct meanings.</p>
<p>Although dynamic dispatch is not usually classified as a conditional construct, it is another way to select between alternatives at runtime.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 If–then(–else)
<ul>
<li>1.1 Else if</li>
<li>1.2 If-then-else expressions
<ul>
<li>1.2.1 Algol family</li>
<li>1.2.2 Lisp dialects</li>
<li>1.2.3 Haskell</li>
<li>1.2.4 C-like languages</li>
<li>1.2.5 In Visual Basic</li>
</ul>
</li>
<li>1.3 Arithmetic if</li>
<li>1.4 Object-oriented implementation in Smalltalk</li>
</ul>
</li>
<li>2 Case and switch statements</li>
<li>3 Pattern matching</li>
<li>4 Branch predication</li>
<li>5 Choice system cross reference</li>
<li>6 See also</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>1.1 Else if</li>
<li>1.2 If-then-else expressions
<ul>
<li>1.2.1 Algol family</li>
<li>1.2.2 Lisp dialects</li>
<li>1.2.3 Haskell</li>
<li>1.2.4 C-like languages</li>
<li>1.2.5 In Visual Basic</li>
</ul>
</li>
<li>1.3 Arithmetic if</li>
<li>1.4 Object-oriented implementation in Smalltalk</li>
</ul>
<ul>
<li>1.2.1 Algol family</li>
<li>1.2.2 Lisp dialects</li>
<li>1.2.3 Haskell</li>
<li>1.2.4 C-like languages</li>
<li>1.2.5 In Visual Basic</li>
</ul>
<p></p>
<h2>If–then(–else)</h2>
<p>The <code>if–then</code> construct (sometimes called <code>if–then–else</code>) is common across many programming languages. Although the syntax varies quite a bit from language to language, the basic structure (in pseudocode form) looks like this:</p>
<p>WHATSON? bba49084-e908-4b9c-8d36-e746db6efbfc</p>
<pre>
 IF (boolean condition) THEN
    (consequent)
 ELSE
    (alternative)
 END IF
</pre>
<p>When an interpreter finds an <code>If</code>, it expects a boolean condition – for example, <code>x &gt; 0</code>, which means "the variable x contains a number that is greater than zero" – and evaluates that condition. If the condition is <code>true</code>, the statements following the <code>then</code> are executed. Otherwise, the execution continues in the following branch – either in the <code>else</code> block (which is usually optional), or if there is no <code>else</code> branch, then after the <code>end If</code>.</p>
<p>After either branch has been executed, control returns to the point after the <code>end If</code>.</p>
<p>In early programming languages, especially some dialects of BASIC in the 1980s home computers, an <code>if–then</code> statement could only contain <code>GOTO</code> statements. This led to a hard-to-read style of programming known as spaghetti programming, with programs in this style called <i>spaghetti code</i>. As a result, structured programming, which allows (virtually) arbitrary statements to be put in statement blocks inside an <code>if</code> statement, gained in popularity, until it became the norm even in most BASIC programming circles. Such mechanisms and principles were based on the older but more advanced ALGOL family of languages, and ALGOL-like languages such as Pascal and Modula-2 influenced modern BASIC variants for many years. While it is possible while using only <code>GOTO</code> statements in <code>if-then</code> statements to write programs that are not spaghetti code and are just as well structured and readable as programs written in a structured programming language, structured programming makes this easier and enforces it. Structured <code>if-then-else</code> statements like the example above are one of the key elements of structured programming, and they are present in most popular high-level programming languages such as C, Java, JavaScript and Visual Basic .</p>
<p>A subtlety is that the optional else clause found in many languages means that the context-free grammar is ambiguous, since nested conditionals can be parsed in multiple ways. Specifically,</p>
<p>WHATSON? 4e5ae744-282d-4d5a-88c9-67c246bc8dc6</p>
<pre>
<b>if</b> a <b>then</b> <b>if</b> b <b>then</b> s <b>else</b> s2
</pre>
<p>can be parsed as</p>
<p>WHATSON? 92a85649-1aa9-48f9-b219-b6da174c8bd2</p>
<pre>
<b>if</b> a <b>then</b> (<b>if</b> b <b>then</b> s) <b>else</b> s2
</pre>
<p>or</p>
<p>WHATSON? 3e4c9a05-9b8b-4945-ae4e-7aa2d09b7f61</p>
<pre>
<b>if</b> a <b>then</b> (<b>if</b> b <b>then</b> s <b>else</b> s2)
</pre>
<p>depending on whether the <code>else</code> is associated with the first <code>if</code> or second <code>if</code>. This is known as the dangling else problem, and is resolved in various ways, depending on the language.</p>
<h3>Else if</h3>
<p>By using <code>else if</code>, it is possible to combine several conditions. Only the statements following the first condition that is found to be true will be executed. All other statements will be skipped. The statements of</p>
<p>WHATSON? f4fc60cd-c398-43cd-af61-fe2d0984be63</p>
<pre>
if condition then
   --statements
elseif condition then
    -- more statements
elseif condition then
    -- more statements;
...
else
    -- other statements;
end if;
</pre>
<p><code>elsif</code>, in Ada, is simply syntactic sugar for <code>else</code> followed by <code>if</code>. In Ada, the difference is that only one <code>end if</code> is needed, if one uses <code>elsif</code> instead of <code>else</code> followed by <code>if</code>. This is similar in Perl, which provides the keyword <code>elsif</code> to avoid the large number of braces that would be required by multiple <code>if</code> and <code>else</code> statements and also in Python, which uses the special keyword <code>elif</code> because structure is denoted by indentation rather than braces, so a repeated use of <code>else</code> and <code>if</code> would require increased indentation after every condition.</p>
<p>However, in many languages more directly descended from Algol, such as Algol68, Simula, Pascal, BCPL and C, this special syntax for the <code>else if</code> construct is not present, nor is it present in the many syntactical derivatives of C, such as Java, ECMA-script, PHP, and so on. This works because in these languages, any <i>single</i> statement (in this case <code>if <i>cond</i></code>...) can follow a conditional without being enclosed in a block.</p>
<p>This design choice has a slight "cost" in that code <code>else if</code> branch is, effectively, adding an extra nesting level, complicating the job for some compilers (or its implementors), which has to analyse and implement arbitrarily long <code>else if</code> chains recursively.</p>
<p>If all terms in the sequence of conditionals are testing the value of a single expression (e.g., <code>if x=0</code> ... <code>else if x=1</code> ... <code>else if x=2</code>...), then an alternative is the switch statement, also called case-statement or select-statement. Conversely, in languages that do not have a switch statement, these can be produced by a sequence of <code>else if</code> statements.</p>
<h3>If-then-else expressions</h3>
<p>Many languages support <i>if expressions</i>, which are similar to if statements, but return a value as a result. Thus, they are true expressions (which evaluate to a value), not statements (which changes the program state or perform some kind of action).</p>
<h4>Algol family</h4>
<p>ALGOL 60 and some other members of the ALGOL family allow <code>if-then-else</code> as an expression:</p>
<p>WHATSON? d03e8f89-dabc-4c13-9acc-83a6eb577f74</p>
<pre>
  myvariable := if x &gt; 10 then 1 else 2
</pre>
<h4>Lisp dialects</h4>
<p>In dialects of Lisp -- Scheme, Racket and Common Lisp -- the first of which was inspired to a great extent by ALGOL:</p>
<p>WHATSON? ee0eae63-6801-42ca-85d2-22a15b337edd</p>
<pre>
 ;; Scheme
 (define myvariable (if (&gt; x 10) 1 2))   ; Assigns ‘myvariable’ to 1 or 2, depending on the value of ‘x’
 ;; Common Lisp
 (let ((x 5))
   (setq myvariable (if (&gt; x 10) 1 2)))  ; Assigns ‘myvariable’ to 2
</pre>
<h4>Haskell</h4>
<p>In Haskell 98, there is only an <i>if expression</i>, no <i>if statement</i>, and the <code>else</code> part is compulsory, as every expression must have some value. Logic that would be expressed with conditionals in other languages is usually expressed with pattern matching in recursive functions.</p>
<p>Because Haskell is lazy, it is possible to write control structures, such as <i>if</i>, as ordinary expressions; the lazy evaluation means that an <i>if function</i> can evaluate only the condition and proper branch (where a strict language would evaluate all three). It can be written like this:</p>
<p>WHATSON? 4fe9cbc9-26d8-42b1-b11b-dafa7eedf9a0</p>
<pre>
if' :: Bool -&gt; a -&gt; a -&gt; a
if' True x _ = x
if' False _ y = y
</pre>
<h4>C-like languages</h4>
<p>C and C-like languages has a special ternary operator (?:) for conditional expressions with a function that may be described by a template like this:</p>
<p>WHATSON? 1066f39d-880b-4858-8454-062a700d7e87</p>
<pre>
<code>condition ? evaluated-when-true : evaluated-when-false</code>
</pre>
<p>This means that it can be inlined into expressions, unlike if-statements, in C-like languages:</p>
<p>WHATSON? 6c9a87f8-2bdb-4702-89ed-c0e1179d4ba3</p>
<pre>
my_variable = (x &gt; 10) ? "foo" : "bar";  // In C-like languages
</pre>
<p>which can be compared to the Algol-family if-then-else expressions (and similar in Ruby and Scala, among others).</p>
<p>To accomplish the same using an if-statement, this would take more than one line of code (under typical layout conventions):</p>
<p>WHATSON? 7742f8e5-ff86-42f3-8f7c-4fbb343ca9d7</p>
<pre>
if (x &gt; 10)
  my_variable = 'foo';
else
  my_variable = 'bar';
</pre>
<p>Some argue that the explicit if/then statement is easier to read and that it may compile to more efficient code than the ternary operator, while others argue that concise expressions are easier to read than statements spread over several lines.</p>
<h4>In Visual Basic</h4>
<p>In Visual Basic and some other languages, a function called <code>IIf</code> is provided, which can be used as a conditional expression. However, it does not behave like a true conditional expression, because both the true and false branches are always evaluated; it is just that the result of one of them is thrown away, while the result of the other is returned by the IIf function.</p>
<h3>Arithmetic if</h3>
<p>Up to Fortran 77, the language Fortran has an "arithmetic if" statement which is halfway between a computed IF and a case statement, based on the trichotomy <img class="mwe-math-fallback-image-inline tex" alt="x &lt; 0" src="//upload.wikimedia.org/math/9/7/f/97fdf90850f660f05349f4ad145b62dc.png">, <img class="mwe-math-fallback-image-inline tex" alt="x = 0" src="//upload.wikimedia.org/math/e/1/1/e11729b0b65ecade3fc272548a3883fc.png">, <img class="mwe-math-fallback-image-inline tex" alt="x &gt; 0" src="//upload.wikimedia.org/math/8/8/7/887fb68a10cbd4369b27c90bee0334d8.png">. This was the earliest conditional statement in Fortran:</p>
<p>WHATSON? 69af2578-d7e0-40ea-b851-3e158e7f260b</p>
<pre>
IF (e) label1, label2, label3
</pre>
<p>Where e is any numeric expression (not necessarily an integer); this is equivalent to</p>
<p>WHATSON? 0386aa2a-e536-4926-a972-fa4f5ae9811d</p>
<pre>
IF (e .LT. 0) GOTO label1
IF (e .EQ. 0) GOTO label2
GOTO label3
</pre>
<p>Because this arithmetic IF is equivalent to multiple <code>GOTO</code> statements, it is considered to be an unstructured control statement, and should not be used if more structured statements can be used. In practice it has been observed that most arithmetic <code>IF</code> statements referenced the following statement with one or two of the labels.</p>
<p>This was the only conditional control statement in the original implementation of Fortran on the IBM 704 computer. On that computer it could be implemented quite efficiently using instructions such as 'Branch if accumulator negative'.</p>
<h3>Object-oriented implementation in Smalltalk</h3>
<p>In contrast to other languages, in Smalltalk the conditional statement is not a language construct but defined in the class <code>Boolean</code> as an abstract method that takes two parameters, both closures. <code>Boolean</code> has two subclasses, <code>True</code> and <code>False</code>, which both define the method, <code>True</code> executing the first closure only, <code>False</code> executing the second closure only.</p>
<p>WHATSON? e22e23b9-c525-4ff2-b898-3054324e335c</p>
<pre>
var = condition 
    ifTrue: [ 'foo' ]
    ifFalse: [ 'bar' ]
</pre>
<h2>Case and switch statements</h2>
<p>Switch statements (in some languages, <i>case statements</i> or multiway branches) compare a given value with specified constants and take action according to the first constant to match. There is usually a provision for a default action ('else','otherwise') to be taken if no match succeeds. Switch statements can allow compiler optimizations, such as lookup tables. In dynamic languages, the cases may not be limited to constant expressions, and might extend to pattern matching, as in the shell script example on the right, where the '*)' implements the default case as a regular expression matching any string.</p>
<p>WHATSON? 68593212-84b5-443c-bf1b-ea5c050ea4ee</p>
<pre>
case someChar of
  'a': actionOnA;
  'x': actionOnX;
  'y','z':actionOnYandZ;
  else actionOnNoMatch;
end;
</pre>
<p>WHATSON? be744364-4bb1-40fc-b6bf-bdf868acb5f5</p>
<pre>
switch (someChar) {
  case 'a': actionOnA; break;
  case 'x': actionOnX; break;
  case 'y':
  case 'z': actionOnYandZ; break;
  default: actionOnNoMatch;
}
</pre>
<p>WHATSON? 32d4a659-d83d-4f99-a7c4-f2cf571d69e5</p>
<pre>
case $someChar in 
   a)    actionOnA; ;;
   x)    actionOnX; ;;
   [yz]) actionOnYandZ; ;;
  *)     actionOnNoMatch  ;;
esac
</pre>
<h2>Pattern matching</h2>
<p>Pattern matching may be seen as a more sophisticated alternative to both <i>if-then-else</i>, and <i>case</i> statements. It is available in many programming languages with functional programming features, such as Wolfram Language, ML and many others. Here is a simple example written in the OCaml language:</p>
<p>WHATSON? 28648ad6-e3e6-4ab2-b594-a9fe03321495</p>
<pre>
 match fruit with
 | "apple" -&gt; cook pie
 | "coconut" -&gt; cook dango_mochi
 | "banana" -&gt; mix;;
</pre>
<p>The power of pattern matching is the ability to <i>concisely</i> match not only actions but also <i>values</i> to patterns of data. Here is an example written in Haskell which illustrates both of these features:</p>
<p>WHATSON? 8d6fc66f-c6f2-4c3f-93da-8c0dc6d15df3</p>
<pre>
 map _ []      = []
 map f (h : t) = f h : map f t
</pre>
<p>This code defines a function <i>map</i>, which applies the first argument (a function) to each of the elements of the second argument (a list), and returns the resulting list. The two lines are the two definitions of the function for the two kinds of arguments possible in this case – one where the list is empty (just return an empty list) and the other case where the list is not empty.</p>
<p>Pattern matching is not strictly speaking <i>always</i> a choice construct, because it is possible in Haskell to write only one alternative, which is guaranteed to always be matched – in this situation, it is not being used as a choice construct, but simply as a way to bind names to values. However, it is frequently used as a choice construct in the languages in which it is available.</p>
<h2>Branch predication</h2>
<p>In assembly language, branch predication is a feature of certain central processing unit (CPU) instruction sets which permits conditional execution of instructions, without having to perform costly conditional jumps.</p>
<h2>Choice system cross reference</h2>
<p>This table refers to the most recent language specification of each language. For languages that do not have a specification, the latest officially released implementation is referred to.</p>
<ol>
<li><b></b> This refers to pattern matching as a distinct conditional construct in the programming language – as opposed to mere string pattern matching support, such as regular expression support.</li>
<li><b></b> <b></b> <b></b> <b></b> <b></b> The often-encountered <code>else if</code> in the C family of languages, and in COBOL and Haskell, is not a language feature but a set of nested and independent <i>if then else</i> statements combined with a particular source code layout. However, this also means that a distinct else-if construct is not really needed in these languages.</li>
<li><b></b> <b></b> In Haskell and F#, a separate constant choice construct is unneeded, because the same task can be done with pattern matching.</li>
<li><b></b> <b></b> SQL has two similar constructs that fulfill both roles, both introduced in SQL-92. A "searched <code>CASE</code>" expression <code>CASE WHEN cond1 THEN expr1 WHEN cond2 THEN expr2 [...] ELSE exprDflt END</code> works like <code>if ... else if ... else</code>, whereas a "simple <code>CASE</code>" expression: <code>CASE expr WHEN val1 THEN expr1 [...] ELSE exprDflt END</code> works like a switch statement. For details and examples see Case (SQL).</li>
</ol>
<h2>See also</h2>
<ul>
<li>Branch (computer science)</li>
<li>Conditional compilation</li>
<li>Dynamic dispatch for another way to make execution choices</li>
<li>McCarthy Formalism for history and historical references</li>
<li>Named condition</li>
<li>Test (Unix)</li>
<li>Yoda conditions</li>
</ul>
</body>
</html>