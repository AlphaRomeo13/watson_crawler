<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Strong-and-weak-typing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Strong and weak typing</h1>
<p>In computer programming, programming languages are often colloquially referred to as <b>strongly typed</b> or <b>weakly typed</b>. In general, these terms do not have a precise definition, but in general a strongly typed language is more likely to generate an error or refuse to compile a program if the argument passed to a function does not closely match the expected type. A very weakly typed language may produce unpredictable results or may perform implicit type conversion instead. On the other hand, a very strongly typed language may not work at all or crash when data of an unexpected type is passed to a function.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Definitions of "strong" or "weak"
<ul>
<li>2.1 Implicit type conversions and "type punning"</li>
<li>2.2 Pointers</li>
<li>2.3 Untagged unions</li>
<li>2.4 Dynamic type-checking</li>
<li>2.5 Static type-checking</li>
<li>2.6 Predictability</li>
<li>2.7 Type inference</li>
</ul>
</li>
<li>3 Variation across programming languages</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<ul>
<li>2.1 Implicit type conversions and "type punning"</li>
<li>2.2 Pointers</li>
<li>2.3 Untagged unions</li>
<li>2.4 Dynamic type-checking</li>
<li>2.5 Static type-checking</li>
<li>2.6 Predictability</li>
<li>2.7 Type inference</li>
</ul>
<p></p>
<h2>History</h2>
<p>In 1974, Liskov and Zilles described a strongly-typed language as one in which "whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function." Jackson wrote, "In a strongly typed language each data area will have a distinct type and each process will state its communication requirements in terms of these types."</p>
<h2>Definitions of "strong" or "weak"</h2>
<p>A number of different language design decisions have been referred to as evidence of "strong" or "weak" typing. In fact, many of these are more accurately understood as the presence or absence of type safety, memory safety, static type-checking, or dynamic type-checking.</p>
<h3>Implicit type conversions and "type punning"</h3>
<p>Some programming languages make it easy to use a value of one type as if it were a value of another type. This is sometimes described as "weak typing".</p>
<p>For example, Aahz Maruch writes that "<i>Type Conversion occurs when you have a statically typed language and you use the syntactic features of the language to force the usage of one type as if it were a different type (consider the common use of void* in C). Coercion is usually a symptom of weak typing. Conversion, on the other hand, creates a brand-new object of the appropriate type.</i>" </p>
<p>As another example, GCC describes this as <i>type-punning</i> and warns that it will <i>break strict aliasing</i>. Thiago Macieira discusses several problems that can arise when type-punning causes the compiler to make inappropriate optimizations.</p>
<p>It is easy to focus on the syntax, but Macieira's argument is really about semantics. There are many examples of languages which allow implicit conversions, but in a type-safe manner. For example, both C++ and C# allow programs to define operators to convert a value from one type to another in a semantically meaningful way. When a C++ compiler encounters such a conversion, it treats the operation just like a function call. In contrast, converting a value to the C type "void*" is an unsafe operation which is invisible to the compiler.</p>
<h3>Pointers</h3>
<p>Some programming languages expose pointers as if they were numeric values, and allow users to perform arithmetic on them. These languages are sometimes referred to as "weakly typed", since pointer arithmetic can be used to bypass the language's type system.</p>
<h3>Untagged unions</h3>
<p>Some programming languages support untagged unions, which allow a value of one type to be viewed as if it were a value of another type. In the article titled <i>A hacked Boolean</i>, Bill McCarthy demonstrates how a Boolean value in .NET programming may become internally corrupted so that two values may both be "true" and yet still be considered unequal to each other.</p>
<h3>Dynamic type-checking</h3>
<p>Some programming languages do not have static type-checking. In many such languages, it is easy to write programs which would be rejected by most static type-checkers. For example, a variable might store either a number or the Boolean value "false". Some programmers refer to these languages as "weakly typed", since they do not <i>seem</i> to enforce the "strong" type discipline found in a language with a static type-checker.</p>
<h3>Static type-checking</h3>
<p>In Luca Cardelli's article Typeful Programming, a "strong type system" is described as one in which there is no possibility of an unchecked runtime type error. In other writing, the absence of unchecked run-time errors is referred to as <i>safety</i> or <i>type safety</i>; Tony Hoare's early papers call this property <i>security</i>.</p>
<h3>Predictability</h3>
<p>If simple operations do not behave in a way that one would expect, a programming language can be said to be "weakly typed". For example, consider the following program:</p>
<p>WHATSON? 3f8b3c47-ba7c-4fa1-8c51-12873fa9b8f8</p>
<pre>
x = "5" + 6
</pre>
<p>Different languages will assign a different value to 'x':</p>
<ul>
<li>One language might convert 6 to a string, and concatenate the two arguments to produce the string "56" (e.g. JavaScript)</li>
<li>Another language might convert "5" to a number, and add the two arguments to produce the number 11 (e.g. Perl, PHP)</li>
<li>Yet another language might convert the string "5" to a pointer representing where the string is stored within memory, and add 6 to that value to produce an address in memory (e.g. C)</li>
<li>And yet another language might simply fail to compile this program or run the code, saying that the two operands have incompatible type (e.g. Ruby, BASIC)</li>
</ul>
<p>Languages that work like the first three examples have all been called "weakly typed" at various times, even though only one of them (the third) represents a possible safety violation.</p>
<h3>Type inference</h3>
<p>Languages with static type systems differ in the extent to which users are required to manually state the types used in their program. Some languages, such as C, require that every variable be declared with a type. Other languages, such as Haskell, use the Hindley-Milner method to infer all types based on a global analysis. Other languages, such as C# and C++, lie somewhere in between; some types can be inferred based on local information, while others must be specified. Some programmers use the term weakly typed to refer to languages with type inference, often without realizing that the type information is present but implicit.</p>
<h2>Variation across programming languages</h2>
<p>Note that some of these definitions are contradictory, others are merely orthogonal, and still others are special cases (with additional constraints) of other, more "liberal" (less strong) definitions. Because of the wide divergence among these definitions, it is possible to defend claims about most programming languages that they are either strongly or weakly typed. For instance:</p>
<ul>
<li>Java, Pascal, Ada and C require all variables to have a declared type, and support the use of explicit casts of arithmetic values to other arithmetic types. Java, C#, Ada and Pascal are sometimes said to be more strongly typed than C, a claim that is probably based on the fact that C supports more kinds of implicit conversions, and C also allows pointer values to be explicitly cast while Java and Pascal do not. Java itself may be considered more strongly typed than Pascal as manners of evading the static type system in Java are controlled by the Java Virtual Machine's type system. C# is similar to Java in that respect, though it allows disabling dynamic type checking by explicitly putting code segments in an "unsafe context". Pascal's type system has been described as "too strong", because the size of an array or string is part of its type, making some programming tasks very difficult.</li>
<li>The object-oriented programming languages Smalltalk, Ruby, Python, and Self are all "strongly typed" in the sense that typing errors are prevented at runtime and they do little implicit type conversion, but these languages make no use of static type checking: the compiler does not check or enforce type constraint rules. The term duck typing is now used to describe the dynamic typing paradigm used by the languages in this group.</li>
<li>The Lisp family of languages are all "strongly typed" in the sense that typing errors are prevented at runtime. Some Lisp dialects like Common Lisp or Clojure do support various forms of type declarations and some compilers (CMUCL and related) use these declarations together with type inference to enable various optimizations and also limited forms of compile time type checks.</li>
<li>Standard ML, F#, OCaml, Scala and Haskell are statically type checked but the compiler automatically infers a precise type for all values. These languages (along with most functional languages) are considered to have stronger type systems than Java, as they permit no implicit type conversions. While OCaml's libraries allow one form of evasion (<i>Object magic</i>), this feature remains unused in most applications.</li>
<li>Visual Basic is a hybrid language. In addition to variables with declared types, it is also possible to declare a variable of "Variant" data type that can store data of any type. Its implicit casts are fairly liberal where, for example, one can sum string variants and pass the result into an integer variable.</li>
<li>Assembly language and Forth have been said to be <i>untyped</i>. There is no type checking; it is up to the programmer to ensure that data given to functions is of the appropriate type. Any type conversion required is explicit.</li>
</ul>
<p>For this reason, writers who wish to write unambiguously about type systems often eschew the term "strong typing" in favor of specific expressions such as "type safety".</p>
<h2>See also</h2>
<ul>
<li>Data type includes a more thorough discussion of typing issues</li>
<li>Comparison of programming languages</li>
<li>Type system</li>
<li>Type safety</li>
<li>Memory safety</li>
</ul>
</body>
</html>