<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Role-oriented-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Role-oriented programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li><strong class="selflink">Role-oriented</strong></li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li><strong class="selflink">Role-oriented</strong></li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li><strong class="selflink">Role-oriented</strong></li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li><strong class="selflink">Role-oriented</strong></li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Role-oriented programming</b> is a form of computer programming aimed at expressing things in terms which are analogous to human conceptual understanding of the world. This should make programs easier to understand and maintain.</p>
<p>The main idea of role-oriented programming is that humans think in terms of roles. This claim is often backed up by examples of social relations. For example, a student attending a class and the same student at a party are the same person, yet he plays two different roles. In particular, the interactions of this person with the outside world depend on his current role. The roles typically share features, e.g., the intrinsic properties of being a person. This sharing of properties is often handled by the delegation mechanism.</p>
<p>In the older literature and in the field of databases, it seems that there has been little consideration for the context in which roles interplay with each other. Such a context is being established in newer role- and aspect-oriented programming languages such as Object Teams.</p>
<p>Many researchers have argued the advantages of roles in modeling and implementation. Roles allow objects to evolve over time, they enable independent and concurrently existing views (interfaces) of the object, explicating the different contexts of the object, and separating concerns. Generally roles are a natural element of our daily concept forming. Roles in programming languages enable objects to have changing interfaces, as we see it in real life - things change over time, are used differently in different contexts, etc.</p>
<p>A complete overview and taxonomy of Role languages is provided in the Ph.D. thesis [1]</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Programming languages with explicit support for roles</li>
<li>2 Authors of role literature</li>
<li>3 See also</li>
<li>4 References</li>
<li>5 External links</li>
</ul>
<p></p>
<h2>Programming languages with explicit support for roles</h2>
<ul>
<li>Object Teams</li>
<li>powerJava</li>
<li>EpsilonJ</li>
<li>Chameleon</li>
<li>Perl 5 (Moose)</li>
<li>Perl 6</li>
<li>JavaScript Delegation - Functions as Roles (Traits and Mixins)</li>
</ul>
<h2>Authors of role literature</h2>
<ul>
<li>Charles Bachman</li>
<li>Trygve Reenskaug</li>
<li>Georg Gottlob</li>
<li>Bent Bruun Kristensen</li>
<li>Kasper Ã˜sterbye</li>
<li>Friedrich Steimann</li>
<li>Stephan Herrmann</li>
<li>Barbara Pernici</li>
<li>Bruce Wallace</li>
<li>Kasper B. Graversen</li>
</ul>
<h2>See also</h2>
<ul>
<li>Object Oriented Role Analysis Method</li>
<li>Object-role modeling</li>
<li>Aspect-oriented programming</li>
<li>Subject-oriented programming</li>
<li>Subject (programming)</li>
<li>Traits (computer science)</li>
<li>Data, context and interaction</li>
</ul>
</body>
</html>