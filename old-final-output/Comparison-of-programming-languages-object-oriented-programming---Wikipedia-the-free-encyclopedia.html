<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Comparison-of-programming-languages-object-oriented-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Comparison of programming languages (object-oriented programming)</h1>
<ul>
<li>General comparison</li>
<li>Basic syntax</li>
<li>Basic instructions</li>
<li>Arrays</li>
<li>Associative arrays</li>
<li>String operations</li>
<li>String functions</li>
<li>List comprehension</li>
<li><strong class="selflink">Object-oriented programming</strong></li>
<li>Object-oriented constructors</li>
<li>Database access</li>
</ul>
<ul>
<li>Evaluation strategy</li>
<li>List of "Hello World" programs</li>
</ul>
<ul>
<li>Web application frameworks</li>
<li>Comparison of the Java and .NET platforms</li>
</ul>
<ul>
<li>Comparison of individual programming languages
<ul>
<li>ALGOL 58's influence on ALGOL 60</li>
<li>ALGOL 60: Comparisons with other languages</li>
<li>Comparison of ALGOL 68 and C++</li>
<li>ALGOL 68: Comparisons with other languages</li>
<li>Compatibility of C and C++</li>
<li>Comparison of Pascal and Borland Delphi</li>
<li>Comparison of Object Pascal and C</li>
<li>Comparison of Pascal and C</li>
<li>Comparison of Java and C++</li>
<li>Comparison of C# and Java</li>
<li>Comparison of C# and Visual Basic .NET</li>
<li>Comparison of Visual Basic and Visual Basic .NET</li>
</ul>
</li>
</ul>
<ul>
<li>ALGOL 58's influence on ALGOL 60</li>
<li>ALGOL 60: Comparisons with other languages</li>
<li>Comparison of ALGOL 68 and C++</li>
<li>ALGOL 68: Comparisons with other languages</li>
<li>Compatibility of C and C++</li>
<li>Comparison of Pascal and Borland Delphi</li>
<li>Comparison of Object Pascal and C</li>
<li>Comparison of Pascal and C</li>
<li>Comparison of Java and C++</li>
<li>Comparison of C# and Java</li>
<li>Comparison of C# and Visual Basic .NET</li>
<li>Comparison of Visual Basic and Visual Basic .NET</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>This <b>Comparison of programming languages</b> compares how object-oriented programming languages such as C++, Python, Perl, Java, Object Pascal and others manipulate data structures.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Object construction and destruction</li>
<li>2 Class declaration</li>
<li>3 Class members
<ul>
<li>3.1 Constructors and destructors</li>
<li>3.2 Fields</li>
<li>3.3 Methods</li>
<li>3.4 Properties
<ul>
<li>3.4.1 Manually implemented</li>
<li>3.4.2 Automatically implemented</li>
</ul>
</li>
<li>3.5 Overloaded operators
<ul>
<li>3.5.1 Standard operators</li>
<li>3.5.2 Indexers</li>
<li>3.5.3 Type casts</li>
</ul>
</li>
</ul>
</li>
<li>4 Member access</li>
<li>5 Member availability</li>
<li>6 Special variables</li>
<li>7 Special methods</li>
<li>8 Type manipulation</li>
<li>9 Namespace management</li>
<li>10 Contracts</li>
<li>11 See also</li>
<li>12 References and notes</li>
</ul>
<ul>
<li>3.1 Constructors and destructors</li>
<li>3.2 Fields</li>
<li>3.3 Methods</li>
<li>3.4 Properties
<ul>
<li>3.4.1 Manually implemented</li>
<li>3.4.2 Automatically implemented</li>
</ul>
</li>
<li>3.5 Overloaded operators
<ul>
<li>3.5.1 Standard operators</li>
<li>3.5.2 Indexers</li>
<li>3.5.3 Type casts</li>
</ul>
</li>
</ul>
<ul>
<li>3.4.1 Manually implemented</li>
<li>3.4.2 Automatically implemented</li>
</ul>
<ul>
<li>3.5.1 Standard operators</li>
<li>3.5.2 Indexers</li>
<li>3.5.3 Type casts</li>
</ul>
<p></p>
<p><br style="clear:both;"></p>
<h2>Object construction and destruction</h2>
<p>WHATSON? b1a705de-4c61-498e-ba26-3cfa1088c0fc</p>
<pre>
Pointy x: 10 y: 20.
Array with: -1 with: 3 with: 2.
</pre>
<p>WHATSON? 99ece545-c81b-446f-a84c-824a3a7bd3aa</p>
<pre>
val obj = new Object // no parameters
val obj = new Object(arg0, arg1, arg2...)
val obj = Object(arg0, arg1, arg2...) // case class
val obj = new Object(arg0, arg1, param1 = value1, ...) // named parameters
</pre>
<h2>Class declaration</h2>
<p><tt>'<i>ClassName = Class'</i> «(<b>ClassParent, Interfaces)</b>»<br>
private<br>
// Private members(include Methods and Fields)<br>
public<br>
// Public members<br>
protected<br>
// Protected members<br>
published<br>
// Published members<br>
end;</tt></p>
<p>WHATSON? c7cdb83e-f38c-49fe-acfc-a33d06a9f5e9</p>
<pre>
class ConcreteClass(constructor params)
extends ParentClass
with Trait1 with Trait2 with Trait2 {
// members
}
</pre>
<p>WHATSON? 7ec5b386-7249-45ba-adf5-d2202f6ae146</p>
<pre>
trait TraitName
extends OtherTrait1
with OtherTrait2 with OtherTrait3 {
// members
}
</pre>
<p>WHATSON? 9fcf6ec4-bd10-4a0c-9704-3fc3afd386b3</p>
<pre>
package name
</pre>
<p><code><b>END CLASS</b> name<b>.</b></code></p>
<p><code><b>END INTERFACE</b> name<b>.</b></code></p>
<h2>Class members</h2>
<h3>Constructors and destructors</h3>
<h3>Fields</h3>
<h3>Methods</h3>
<p><code>«<b>DATA DIVISION.</b><br>
<b>LINKAGE SECTION.</b><br>
parameter declarations»<br>
<b>PROCEDURE DIVISION</b>« <b>USING</b> parameters»<b>.</b></code></p>
<p><code><b>END METHOD</b> foo<b>.</b></code></p>
<p><code><b>DATA DIVISION.</b><br>
<b>LINKAGE SECTION.</b><br>
«parameter declarations»<br>
result-var declaration<br>
<b>PROCEDURE DIVISION</b>« <b>USING</b> parameters» <b>RETURNING</b> result-var<b>.</b></code></p>
<p><code><b>END METHOD</b> foo<b>.</b></code></p>
<h3>Properties</h3>
<p>How to declare a property named "Bar"</p>
<h4>Manually implemented</h4>
<p><tt><b>- (</b>type<b>)</b>bar <b>{</b> instructions <b>}</b></tt></p>
<p><code><b>DATA DIVISION.</b><br>
<b>LINKAGE SECTION.</b><br>
return-var declaration<br>
<b>PROCEDURE DIVISION RETURNING</b> return-var<b>.</b></code></p>
<p><code><b>END METHOD.</b><br>
<b>METHOD-ID. SET PROPERTY</b> bar<b>.</b><br>
<b>DATA DIVISION.</b><br>
<b>LINKAGE SECTION.</b><br>
value-var declaration<br>
<b>PROCEDURE DIVISION USING</b> value-var<b>.</b></code></p>
<p><code><b>END METHOD.</b></code></p>
<p><code><b>DATA DIVISION.</b><br>
<b>LINKAGE SECTION.</b><br>
return-var declaration<br>
<b>PROCEDURE DIVISION RETURNING</b> return-var<b>.</b></code></p>
<p><code><b>END METHOD.</b></code></p>
<p><code><b>DATA DIVISION.</b><br>
<b>LINKAGE SECTION.</b><br>
value-var declaration<br>
<b>PROCEDURE DIVISION USING</b> value-var<b>.</b></code></p>
<p><code><b>END METHOD.</b></code></p>
<h4>Automatically implemented</h4>
<h3>Overloaded operators</h3>
<h4>Standard operators</h4>
<h4>Indexers</h4>
<h4>Type casts</h4>
<h2>Member access</h2>
<p>How to access members of an object x</p>
<p><code><b>x::"</b>method<b>"</b>«<b>(</b>«parameters»<b>)</b>»</code></p>
<p><code>cls<b>::"</b>method<b>"</b>«<b>(</b>«parameters»<b>)</b>» or<br>
property <b>OF</b> cls</code></p>
<h2>Member availability</h2>
<h2>Special variables</h2>
<h2>Special methods</h2>
<h2>Type manipulation</h2>
<h2>Namespace management</h2>
<h2>Contracts</h2>
<h2>See also</h2>
<ul>
<li>Object-oriented programming</li>
</ul>
<h2>References and notes</h2>
<ol>
<li><b>^</b> <b>parameter = argument</b> may be repeated if the constructor has several parameters</li>
<li><b>^</b> SAP reserved to himself the use of destruction</li>
<li>^           This language uses garbage collection to release unused memory.</li>
<li><b>^</b> OCaml objects can be created directly without going through a class.</li>
<li>^        This language supports multiple inheritance. A class can have more than one parent class</li>
<li><b>^</b> Not providing a parent class makes the class a root class. In practice, this is almost never done. One should generally use the conventional base class of the framework one is using, which is <code>NSObject</code> for Cocoa and GNUstep, or <code>Object</code> otherwise.</li>
<li><b>^</b> Usually the <code>@interface</code> portion is placed into a header file, and the <code>@interface</code> portion is placed into a separate source code file.</li>
<li><b>^</b> Prefixes to class and protocol names conventionally used as a kind of namespace</li>
<li><b>^</b> In Python interfaces are classes whose methods have <b>pass</b> as their bodies</li>
<li><b>^</b> The class is an Object.<br>
Just send a message to the superclass (st-80) or the destination namespace (Visualworks).</li>
<li><b>^</b> The namespace is an Object.<br>
Just send a message to the parent namespace.</li>
<li><b>^</b> A finalizer is called by the garbage collector when an object is about to be garbage-collected. There is no guarantee on when it will be called or if it will be called at all.</li>
<li><b>^</b> In ABAP, the constructor is to be defined like a method (see comments about method) with the following restrictions: the method name must be "constructor", and only "importing" parameters can be defined</li>
<li><b>^</b> An optional comma-separated list of initializers for member objects and parent classes goes here. The syntax for initializing member objects is
<dl>
<dd><tt>"member_name<b>(</b>parameters<b>)</b>"</tt></dd>
</dl>
This works even for primitive members, in which case one parameter is specified and that value is copied into the member. The syntax for initializing parent classes is
<dl>
<dd><tt>"class_name<b>(</b>parameters<b>)</b>".</tt></dd>
</dl>
If an initializer is not specified for a member or parent class, then the default constructor is used.</li>
<li><b>^</b> Any Eiffel procedure can be used as a creation procedure, aka constructors. See Eiffel paragraph at Constructor (computer science).</li>
<li><b>^</b> Implementing <b>{DISPOSABLE}.dispose</b> ensures that <b>dispose</b> will be called when object is garbage collected.</li>
<li><b>^</b> This "initializer" construct is rarely used. Fields in OCaml are usually initialized directly in their declaration. Only when additional imperative operations are needed is "initializer" used. The "parameters to the constructor" in other languages are instead specified as the parameters to the class in OCaml. See the class declaration syntax for more details.</li>
<li><b>^</b> This syntax is usually used to overload constructors</li>
<li><b>^</b> In JavaScript, constructor itself is an object.</li>
<li><b>^</b> Constructors can be emulated with a factory method returning a class instance.</li>
<li>^    Scope identifier must appear once in the file declaration, all variable declarations after this scope identifier have his scope, until another scope identifier or the end of class declaration is reached</li>
<li><b>^</b> In ABAP, you don't declare specific fields or methods to be accessible by outside things. Rather, you declare outside classes to be friends to have access to the class's fields or methods.</li>
<li><b>^</b> In C++, you don't declare specific fields to be accessible by outside things. Rather, you declare outside functions and classes to be friends to have access to the class's fields. See friend function and friend class for more details.</li>
<li><b>^</b> Just send a message to the class
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="smalltalk source-smalltalk">
<pre>
class addInstVarName: field.
class removeInstVarName: field.
</pre></div>
</div>
</li>
<li>^     Just assign a value to it in a method</li>
<li><b>^</b> Python doesn't have private fields - all fields are publically accessible at all times. A community convention exists to prefix implementation details with a single underscore, but this is not enforced at all by the language itself.</li>
<li><b>^</b> All class data is 'private' because the COBOL standard does not specify any way to access it.</li>
<li><b>^</b> The declaration and implementation of methods in ABAP are separate. <b>methods</b> statement is to be used inside the class definition. <b>method</b> (without "s") is to be used inside the class implementation. <b>parameter = argument</b> can be repeated if there are several parameters.</li>
<li><b>^</b> In ABAP, the return parameter name is explicitly defined in the method signature within the class definition</li>
<li><b>^</b> The declaration and implementation of methods in C++ are usually separate. Methods are declared inside the class definition (which is usually included in a header file) using the syntax
<dl>
<dd><tt>type foo<b>(</b>«parameters»<b>);</b></tt></dd>
</dl>
The implementation of methods is usually provided in a separate source file, with the following syntax
<dl>
<dd><tt>type class<b>::</b>foo<b>(</b>«parameters»<b>) {</b> instructions <b>}</b></tt></dd>
</dl>
Although the body of a method <i>could</i> be included with the declaration inside the class definition, as shown in the table here, this is generally a bad idea. Because the class definition will need to be included with every source file which uses the fields or methods of the class, having code in the class definition will cause the method code to be compiled with every source file, increasing the size of the code. There are some circumstances, however, where it is useful to include the body of a method with the declaration. One reason is that the compiler will try to inline methods that are included in the class declaration; so if you have a very short one-liner method, it may make it faster to allow the compiler to inline it, by including the body along with the declaration. Also, if you have a template class or method, then all the code must be included with the declaration, because only with the code can the template be instantiated.</li>
<li>^   Just assign a function to it in a method</li>
<li><b>^</b> Alternative implementation:
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="python source-python">
<pre>
def bar():
    doc = "The bar property."
    def fget(self):
        return self._bar
    def fset(self, value):
        self._bar = value
    return locals()
bar = property(**bar())
</pre></div>
</div>
</li>
<li><b>^</b> these examples need the Class::Accessor module installed</li>
<li>^    Although Eiffel does not support overloading of operators, it can define operators</li>
<li><b>^</b> PHP does not support operator overloading natively, but support can be added using the "operator" PECL package.</li>
<li><b>^</b> Your class needs to implement the ArrayAccess interface.</li>
<li><b>^</b> Your class needs to overload '@{}' (array dereference) or subclass one of Tie::Array or Tie::StdArray to hook array operations</li>
<li>^   In ABAP, arguments must be passed using this syntax:
<dl>
<dd><b>x-&gt;</b>method<b>(</b>«<b>exporting</b> parameter = argument» «<b>importing</b> parameter = argument» «<b>changing</b> parameter = argument» «<b>returning value(</b>parameter<b>)</b>»</dd>
<dd><b>parameter = argument</b> can be repeated if there are several parameters</dd>
</dl>
</li>
<li><b>^</b> C++ doesn't have a "super" keyword, because multiple inheritance is possible, and so it may be ambiguous which base class is desired. Instead, you can use the <code>BaseClassName::member</code> syntax to access an overridden member in the specified base class. Microsoft Visual C++ provides a non-standard keyword "__super" for this purpose; but this is not supported in other compilers.[1]</li>
<li>^         The keyword here is not a value in itself and it can only be used to access a method of the superclass.</li>
<li><b>^</b> But be afraid, they have not the same value.</li>
<li><b>^</b> only for Optional types</li>
<li>^   In this language, instance methods are passed the current object as the first parameter, which is conventionally named "self", but this is not required to be the case.</li>
<li><b>^</b> "Precursor" in Eiffel is actually a call to the method of the same name in the superclass. So Precursor(args) is equivalent to "super.currentMethodName(args)" in Java. There is no way of calling a method of different name in the superclass.</li>
<li><b>^</b> "super" in Ruby, unlike in other languages, is actually a call to the method of the same name in the superclass. So super(args) in Ruby is equivalent to "super.currentMethodName(args)" in Java. There is no way of calling a method of different name in the superclass.</li>
<li><b>^</b> In OCaml, an object declaration can optionally start with a parameter which will be associated with the current object. This parameter is conventionally named "self", but this is not required to be the case. It is good practice to put a parameter there so that one can call one's own methods.</li>
<li><b>^</b> In OCaml, an inheritance declaration ("inherit") can optionally be associated with a value, with the syntax "<b>inherit</b> parent_class «parameters» <b>as</b> super". Here "super" is the name we gave to the variable associated with this parent object. It can be named something else.</li>
<li><b>^</b> However, if you really wanted the ability to have an "optional" value in OCaml, you would wrap the value inside an <code>option</code> type, whose values are <code>None</code> and <code>Some x</code>, which could be used to represent "null reference" and "non-null reference to an object" as in other languages.</li>
<li><b>^</b> assuming that "x" and "y" are the objects (and not a pointer). Can be customized by overloading the object's <code>==</code> operator</li>
<li><b>^</b> Only accessible from within the class itself, since the <code>clone()</code> method inherited from <code>Object</code> is protected, unless the class overrides the method and makes it public. If you use the <code>clone()</code> inherited from <code>Object</code>, your class will need to implement the <code>Cloneable</code> interface to allow cloning.</li>
<li><b>^</b> The class should implement the interface <code>Comparable</code> for this method to be standardized.</li>
<li><b>^</b> Implemented by the object's <code>copyWithZone:</code> method</li>
<li><b>^</b> <code>compare:</code> is the conventional name for the comparison method in Foundation classes. However, no formal protocol exists</li>
<li><b>^</b> Only if object conforms to the <code>Printable</code> protocol</li>
<li><b>^</b> Only if object conforms to the <code>DebugPrintable</code> protocol</li>
<li><b>^</b> Only if object conforms to the <code>Equatable</code> protocol</li>
<li><b>^</b> Only if object conforms to the <code>Comparable</code> protocol</li>
<li><b>^</b> Only if object conforms to the <code>hashValue</code> protocol</li>
<li><b>^</b> Can be customized by the object's <code>__str__()</code> method</li>
<li><b>^</b> Can be customized by the object's <code>__repr__()</code> method</li>
<li><b>^</b> Can be customized by the object's <code>__copy__()</code> method</li>
<li><b>^</b> Can be customized by the object's <code>__eq__()</code> method</li>
<li><b>^</b> Only in Python 2.x and before (removed in Python 3.0). Can be customized by the object's <code>__cmp__()</code> method</li>
<li><b>^</b> Can be customized by the object's <code>__hash__()</code> method. Not all types are hashable (mutable types are usually not hashable)</li>
<li><b>^</b> Can be customized by the object's <code>__toString()</code> method</li>
<li><b>^</b> Can be customized by the object's <code>__clone()</code> method</li>
<li>^   Can be customized by overloading the object's string conversion operator</li>
<li><b>^</b> This example requires <b>use</b>ing <b>Data::Dumper</b></li>
<li><b>^</b> This example requires <b>use</b>ing <b>Storable</b></li>
<li><b>^</b> This example requires <b>use</b>ing <b>Scalar::Util</b></li>
<li><b>^</b> Run-time type information in ABAP can be gathered by using different description Classes like CL_ABAP_CLASSDESCR.</li>
<li>^      Upcasting is implicit in this language. A subtype instance can be used where a supertype is needed.</li>
<li>^    This language is dynamically typed. Casting between types is not necessary.</li>
<li><b>^</b> This language doesn't give run-time type information. It is unnecessary because it is statically typed and downcasting is not possible.</li>
</ol>
<p>WHATSON? 300adcb9-d474-45d1-a8a8-9420b0710bbb</p>
<pre>
class addInstVarName: field.
class removeInstVarName: field.
</pre>
<p>WHATSON? 918ec3a0-ee35-4f2a-9b94-751ee9ac45ce</p>
<pre>
def bar():
    doc = "The bar property."
    def fget(self):
        return self._bar
    def fset(self, value):
        self._bar = value
    return locals()
bar = property(**bar())
</pre>
</body>
</html>