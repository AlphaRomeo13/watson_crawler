<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>How-to-Use-Panels-The-Java-Tutorials---------------------Creating-a-GUI-With-JFCSwing--Using-Swing-Components.html</title></head>
<body>
<h1>How to Use Panels</h1>
<p>The 
<code>JPanel</code> class provides general-purpose containers for lightweight components. By default, panels do not add colors to anything except their own background; however, you can easily add borders to them and otherwise customize their painting. Details can be found in 
Performing Custom Painting.</p>
<p>In many types of look and feel, panels are opaque by default. Opaque panels work well as content panes and can help with painting efficiently, as described in 
Using Top-Level Containers. You can change a panel's transparency by invoking the <code>setOpaque</code> method. A transparent panel draws no background, so that any components underneath show through.</p>
<h2>An Example</h2>
<p>The following picture shows a colored version of the <code>Converter</code> application, which is discussed in more detail in Using Models.</p>
<p>The <code>Converter</code> example uses panels in several ways:</p>
<ul>
<li>One <code>JPanel</code> instance  colored red in the preceding snapshot  serves as a content pane for the application's frame. This content pane uses a top-to-bottom 
<code>BoxLayout</code> to lay out its contents, and an empty border to put 5 pixels of space around them. See Using Top-Level Containers for information about content panes.</li>
<li>Two instances of a custom <code>JPanel</code> subclass named <code>ConversionPanel</code>  colored cyan  are used to contain components and coordinate communication between components. These <code>ConversionPanel</code> panels also have titled borders, which describe their contents and enclose the contents with a line. Each <code>ConversionPanel</code> panel uses a left-to-right <code>BoxLayout</code> object to lay out its contents.</li>
<li>In each <code>ConversionPanel</code>, a <code>JPanel</code> instance  colored magenta  is used to ensure the proper size and position of the combo box. Each of these <code>JPanel</code> instances uses a top-to-bottom <code>BoxLayout</code> object (helped by an invisible space-filling component) to lay out the combo box.</li>
<li>In each <code>ConversionPanel</code>, an instance of an unnamed <code>JPanel</code> subclass  colored blue  groups two components (a text field and a slider) and restricts their size. Each of these <code>JPanel</code> instances uses a top-to-bottom <code>BoxLayout</code> object to lay out its contents.</li>
</ul>
<p>Here is what the <code>Converter</code> application normally looks like.</p>
<p>As the <code>Converter</code> example demonstrates, panels are useful for grouping components, simplifying component layout, and putting borders around groups of components. The rest of this section gives hints on grouping and laying out components. For information about using borders, see 
How to Use Borders.</p>
<h2>Setting the Layout Manager</h2>
<p>Like other containers, a panel uses a layout manager to position and size its components. By default, a panel's layout manager is an instance of 
<code>FlowLayout</code>, which places the panel's contents in a row. You can easily make a panel use any other layout manager by invoking the <code>setLayout</code> method or by specifying a layout manager when creating the panel. The latter approach is preferable for performance reasons, since it avoids the unnecessary creation of a <code>FlowLayout</code> object.</p>
<p>Here is an example of how to set the layout manager when creating the panel.</p>
<p>WHATSON? 768022cd-7f2c-4143-ad76-fc185c7630ed</p>
<pre>
JPanel p = new JPanel(new BorderLayout()); //PREFERRED!
</pre>
<p>This approach does not work with <code>BoxLayout</code>, since the <code>BoxLayout</code> constructor requires a pre-existing container. Here is an example that uses <code>BoxLayout</code>.</p>
<p>WHATSON? 1904ffeb-dded-4446-8dfe-1e10938dfbdc</p>
<pre>
JPanel p = new JPanel();
p.setLayout(new BoxLayout(p, BoxLayout.PAGE_AXIS));
</pre>
<h2>Adding Components</h2>
<p>When you add components to a panel, you use the <code>add</code> method. Exactly which arguments you specify to the <code>add</code> method depend on which layout manager the panel uses. When the layout manager is <code>FlowLayout</code>, <code>BoxLayout</code>, <code>GridLayout</code>, or <code>SpringLayout</code>, you will typically use the one-argument <code>add</code> method, like this:</p>
<p>WHATSON? 0d40245f-edab-4f1e-8a13-3b12f61f3742</p>
<pre>
aFlowPanel.add(aComponent);
aFlowPanel.add(anotherComponent);
</pre>
<p>When the layout manager is <code>BorderLayout</code>, you need to provide an argument specifying the added component's position within the panel. For example:</p>
<p>WHATSON? a03f2045-3f15-4732-900b-c8209c1fa133</p>
<pre>
aBorderPanel.add(aComponent, BorderLayout.CENTER);
aBorderPanel.add(anotherComponent, BorderLayout.PAGE_END);
</pre>
<p>With <code>GridBagLayout</code> you can use either <code>add</code> method, but you must somehow specify 
grid bag constraints for each component.</p>
<p>For information about choosing and using the standard layout managers, see 
Using Layout Managers.</p>
<h2>The Panel API</h2>
<p>The API in the <code>JPanel</code> class itself is minimal. The methods you are most likely to invoke on a <code>JPanel</code> object are those it inherits from its superclasses  
<code>JComponent</code>, 
<code>Container</code>, and 
<code>Component</code>. The following tables list the API you are most likely to use, with the exception of methods related to 
borders and layout hints. For more information about the API that all <code>JComponent</code> objects can use, see The JComponent Class.</p>
<p>
</p>
<ul>
<li>Creating a <code>JPanel</code></li>
<li>Managing a Container's Components</li>
<li>Setting or Getting the Layout Manager</li>
</ul>
<h2>Examples That Use Panels</h2>
<p>Many examples contained in this lesson use <code>JPanel</code> objects. The following table lists a few.</p>
</body>
</html>