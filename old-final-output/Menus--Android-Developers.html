<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Menus--Android-Developers.html</title></head>
<body>
<h1>Menus</h1>
<h2>In this document</h2>
<ol>
  <li>Defining a Menu in XML</li>
  <li>Creating an Options Menu
    <ol>
      <li>Handling click events</li>
      <li>Changing menu items at runtime</li>
    </ol>
  </li>
  <li>Creating Contextual Menus
    <ol>
      <li>Creating a floating context menu</li>
      <li>Using the contextual action mode</li>
    </ol>
  </li>
  <li>Creating a Popup Menu
    <ol>
      <li>Handling click events</li>
    </ol>
  </li>
  <li>Creating Menu Groups
    <ol>
      <li>Using checkable menu items</li>
    </ol>
  </li>
  <li>Adding Menu Items Based on an Intent
    <ol>
      <li>Allowing your activity to be added to other menus</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Handling click events</li>
      <li>Changing menu items at runtime</li>
    </ol>
<ol>
      <li>Creating a floating context menu</li>
      <li>Using the contextual action mode</li>
    </ol>
<ol>
      <li>Handling click events</li>
    </ol>
<ol>
      <li>Using checkable menu items</li>
    </ol>
<ol>
      <li>Allowing your activity to be added to other menus</li>
    </ol>
<h2>Key classes</h2>
<ol>
    <li><code>Menu</code></li>
    <li><code>MenuItem</code></li>
    <li><code>ContextMenu</code></li>
    <li><code>ActionMode</code></li>
  </ol>
<h2>See also</h2>
<ol>
    <li>Action Bar</li>
    <li>Menu Resource</li>
    <li>Say
Goodbye to the Menu Button</li>
  </ol>
<p>Menus are a common user interface component in many types of applications. To provide a familiar
and consistent user experience, you should use the <code>Menu</code> APIs to present user
actions and other options in your activities.</p>
<p>Beginning with Android 3.0 (API level 11), Android-powered devices are no longer required to
provide a dedicated <em>Menu</em> button. With this change, Android apps should migrate away from a
dependence on the traditional 6-item menu panel and instead provide an action bar to present common
user actions.</p>
<p>Although the design and user experience for some menu items have changed, the semantics to define
a set of actions and options is still based on the <code>Menu</code> APIs. This
guide shows how to create the three fundamental types of menus or action presentations on all
versions of Android:</p>
<p>If you're developing for Android 2.3 or lower, users can
reveal the options menu panel by pressing the <em>Menu</em> button.</p>
<p>On Android 3.0 and higher, items from the options menu are presented by the action bar as a combination of on-screen action
items and overflow options. Beginning with Android 3.0, the <em>Menu</em> button is deprecated (some
devices
don't have one), so you should migrate toward using the action bar to provide access to actions and
other options.</p>
<p>See the section about Creating an Options Menu.</p>
<p>When developing for Android 3.0 and higher, you should instead use the contextual action mode to enable actions on selected content. This mode displays
action items that affect the selected content in a bar at the top of the screen and allows the user
to select multiple items.</p>
<p>See the section about Creating Contextual Menus.</p>
<p>See the section about Creating a Popup Menu.</p>
<h2>Defining a Menu in XML</h2>
<p>For all menu types, Android provides a standard XML format to define menu items.
Instead of building a menu in your activity's code, you should define a menu and all its items in an
XML menu resource. You can then
inflate the menu resource (load it as a <code>Menu</code> object) in your activity or
fragment.</p>
<p>Using a menu resource is a good practice for a few reasons:</p>
<ul>
  <li>It's easier to visualize the menu structure in XML.</li>
  <li>It separates the content for the menu from your application's behavioral code.</li>
  <li>It allows you to create alternative menu configurations for different platform versions,
screen sizes, and other configurations by leveraging the app resources framework.</li>
</ul>
<p>To define the menu, create an XML file inside your project's <code>res/menu/</code>
directory and build the menu with the following elements:</p>
<p>Here's an example menu named <code>game_menu.xml</code>:</p>
<p>WHATSON? 8d260462-45f2-44c9-80e2-741aa320e2c8</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:id="@+id/new_game"
          android:icon="@drawable/ic_new_game"
          android:title="@string/new_game"
          android:showAsAction="ifRoom"/&gt;
    &lt;item android:id="@+id/help"
          android:icon="@drawable/ic_help"
          android:title="@string/help" /&gt;
&lt;/menu&gt;
</pre>
<p>The <code>&lt;item&gt;</code> element supports several attributes you can use to define an item's
appearance and behavior. The items in the above menu include the following attributes:</p>
<p>These are the most important attributes you should use, but there are many more available.
For information about all the supported attributes, see the Menu Resource document.</p>
<p>You can add a submenu to an item in any menu (except a submenu) by adding a <code>&lt;menu&gt;</code>
element as the child of an <code>&lt;item&gt;</code>. Submenus are useful when your application has a lot
of functions that can be organized into topics, like items in a PC application's menu bar (File,
Edit, View, etc.). For example:</p>
<p>WHATSON? a12d13bc-d84c-4c90-ba49-82f9e6df6c96</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:id="@+id/file"
          android:title="@string/file" &gt;
        &lt;!-- "file" submenu --&gt;
        &lt;menu&gt;
            &lt;item android:id="@+id/create_new"
                  android:title="@string/create_new" /&gt;
            &lt;item android:id="@+id/open"
                  android:title="@string/open" /&gt;
        &lt;/menu&gt;
    &lt;/item&gt;
&lt;/menu&gt;
</pre>
<p>To use the menu in your activity, you need to inflate the menu resource (convert the XML
resource into a programmable object) using <code>MenuInflater.inflate()</code>. In the following sections, you'll see how to inflate a menu for each
menu type.</p>
<h2>Creating an Options Menu</h2>
<p><strong>Figure 1.</strong> Options menu in the
Browser, on Android 2.3.</p>
<p>The options menu is where you should include actions and other options that are relevant to the
current activity context, such as "Search," "Compose email," and "Settings."</p>
<p>Where the items in your options menu appear on the screen depends on the version for which you've
developed your application:</p>
<ul>
  <li>If you've developed your application for <strong>Android 2.3.x (API level 10) or
lower</strong>, the contents of your options menu appear at the bottom of the screen when the user
presses the <em>Menu</em> button, as shown in figure 1. When opened, the first visible portion is
the icon
menu, which holds up to six menu items. If your menu includes more than six items, Android places
the sixth item and the rest into the overflow menu, which the user can open by selecting
<em>More</em>.</li>

  <li>If you've developed your application for <strong>Android 3.0 (API level 11) and
higher</strong>, items from the options menu are available in the action bar. By default, the system
places all items in the action overflow, which the user can reveal with the action overflow icon on
the right side of the action bar (or by pressing the device <em>Menu</em> button, if available). To
enable
quick access to important actions, you can promote a few items to appear in the action bar by adding
<code>android:showAsAction="ifRoom"</code> to the corresponding <code>&lt;item&gt;</code> elements (see figure
2). <p>For more information about action items and other action bar behaviors, see the Action Bar guide. </p>
<p><strong>Note:</strong> Even if you're <em>not</em> developing for Android 3.0 or
higher, you can build your own action bar layout for a similar effect. For an example of how you can
support older versions of Android with an action bar, see the Action Bar Compatibility
sample.</p>
</li>
</ul>
<p>For more information about action items and other action bar behaviors, see the Action Bar guide. </p>
<p><strong>Note:</strong> Even if you're <em>not</em> developing for Android 3.0 or
higher, you can build your own action bar layout for a similar effect. For an example of how you can
support older versions of Android with an action bar, see the Action Bar Compatibility
sample.</p>
<p><strong>Figure 2.</strong> Action bar from the Honeycomb Gallery app, showing
navigation tabs and a camera action item (plus the action overflow button).</p>
<p>You can declare items for the options menu from either your <code>Activity</code>
subclass or a <code>Fragment</code> subclass. If both your activity and fragment(s)
declare items for the options menu, they are combined in the UI. The activity's items appear
first, followed by those of each fragment in the order in which each fragment is added to the
activity. If necessary, you can re-order the menu items with the <code>android:orderInCategory</code>
attribute in each <code>&lt;item&gt;</code> you need to move.</p>
<p>To specify the options menu for an activity, override <code>onCreateOptionsMenu()</code> (fragments provide their
own <code>onCreateOptionsMenu()</code> callback). In this
method, you can inflate your menu resource (defined in XML) into the <code>Menu</code> provided in the callback. For example:</p>
<p>WHATSON? 883f757d-0840-4210-a8ab-74ae84ce406c</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = <code>getMenuInflater()</code>;
    inflater.inflate(R.menu.game_menu, menu);
    return true;
}
</pre>
<p>You can also add menu items using <code>add()</code> and retrieve items with <code>findItem()</code> to revise their
properties with <code>MenuItem</code> APIs.</p>
<p>If you've developed your application for Android 2.3.x and lower, the system calls <code>onCreateOptionsMenu()</code> to create the options menu
when the user opens the menu for the first time. If you've developed for Android 3.0 and higher, the
system calls <code>onCreateOptionsMenu()</code> when
starting the activity, in order to show items to the action bar.</p>
<h3>Handling click events</h3>
<p>When the user selects an item from the options menu (including action items in the action bar),
the system calls your activity's <code>onOptionsItemSelected()</code> method. This method passes the <code>MenuItem</code> selected. You
can identify the item by calling <code>getItemId()</code>, which returns the unique
ID for the menu item (defined by the <code>android:id</code> attribute in the menu resource or with an
integer given to the <code>add()</code> method). You can match
this ID against known menu items to perform the appropriate action. For example:</p>
<p>WHATSON? 78e30f82-b6ec-4504-9173-a41837a1c68e</p>
<pre>
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle item selection
    switch (item.getItemId()) {
        case R.id.new_game:
            newGame();
            return true;
        case R.id.help:
            showHelp();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}
</pre>
<p>When you successfully handle a menu item, return <code>true</code>. If you don't handle the menu
item, you should call the superclass implementation of <code>onOptionsItemSelected()</code> (the default
implementation returns false).</p>
<p>If your activity includes fragments, the system first calls <code>onOptionsItemSelected()</code> for the activity then
for each fragment (in the order each fragment was added) until one returns
<code>true</code> or all fragments have been called.</p>
<p><strong>Tip:</strong> Android 3.0 adds the ability for you to define the on-click
behavior for a menu item in XML, using the <code>android:onClick</code> attribute. The value for the
attribute must be the name of a method defined by the activity using the menu. The method
must be public and accept a single <code>MenuItem</code> parameter—when the system
calls this method, it passes the menu item selected. For more information and an example, see the Menu Resource document.</p>
<p><strong>Tip:</strong> If your application contains multiple activities and
some of them provide the same options menu, consider creating
an activity that implements nothing except the <code>onCreateOptionsMenu()</code> and <code>onOptionsItemSelected()</code> methods. Then extend this class for each activity that should share the
same options menu. This way, you can manage one set of code for handling menu
actions and each descendant class inherits the menu behaviors.
If you want to add menu items to one of the descendant activities,
override <code>onCreateOptionsMenu()</code> in that activity. Call <code>super.onCreateOptionsMenu(menu)</code> so the
original menu items are created, then add new menu items with <code>menu.add()</code>. You can also override the super class's
behavior for individual menu items.</p>
<h3>Changing menu items at runtime</h3>
<p>After the system calls <code>onCreateOptionsMenu()</code>, it retains an instance of the <code>Menu</code> you populate and
will not call <code>onCreateOptionsMenu()</code>
again unless the menu is invalidated for some reason. However, you should use <code>onCreateOptionsMenu()</code> only to create the initial
menu state and not to make changes during the activity lifecycle.</p>
<p>If you want to modify the options menu based on 
events that occur during the activity lifecycle, you can do so in
the <code>onPrepareOptionsMenu()</code> method. This
method passes you the <code>Menu</code> object as it currently exists so you can modify it,
such as add, remove, or disable items. (Fragments also provide an <code>onPrepareOptionsMenu()</code> callback.)</p>
<p>On Android 2.3.x and lower, the system calls <code>onPrepareOptionsMenu()</code> each time the user opens the options menu (presses the <em>Menu</em>
button).</p>
<p>On Android 3.0 and higher, the options menu is considered to always be open when menu items are
presented in the action bar. When an event occurs and you want to perform a menu update, you must
call <code>invalidateOptionsMenu()</code> to request that the
system call <code>onPrepareOptionsMenu()</code>.</p>
<p><strong>Note:</strong> 
You should never change items in the options menu based on the <code>View</code> currently
in focus. When in touch mode (when the user is not using a trackball or d-pad), views
cannot take focus, so you should never use focus as the basis for modifying
items in the options menu. If you want to provide menu items that are context-sensitive to a <code>View</code>, use a Context Menu.</p>
<h2>Creating Contextual Menus</h2>
<p><strong>Figure 3.</strong> Screenshots of a floating context menu (left)
and the contextual action bar (right).</p>
<p>A contextual menu offers actions that affect a specific item or context frame in the UI. You
can provide a context menu for any view, but they are most often used for items in a <code>ListView</code>, <code>GridView</code>, or other view collections in which
the user can perform direct actions on each item.</p>
<p>There are two ways to provide contextual actions:</p>
<ul>
  <li>In a floating context menu. A menu appears as a
floating list of menu items (similar to a dialog) when the user performs a long-click (press and
hold) on a view that declares support for a context menu. Users can perform a contextual
action on one item at a time.</li>

  <li>In the contextual action mode. This mode is a system implementation of
<code>ActionMode</code> that displays a <em>contextual action bar</em> at the top of the
screen with action items that affect the selected item(s). When this mode is active, users
can perform an action on multiple items at once (if your app allows it).</li>
</ul>
<p><strong>Note:</strong> The contextual action mode is available on Android 3.0 (API
level 11) and higher and is the preferred technique for displaying contextual actions when
available. If your app supports versions lower than 3.0 then you should fall back to a floating
context menu on those devices.</p>
<h3>Creating a floating context menu</h3>
<p>To provide a floating context menu:</p>
<ol>
  <li>Register the <code>View</code> to which the context menu should be associated by
calling <code>registerForContextMenu()</code> and pass
it the <code>View</code>.
  <p>If your activity uses a <code>ListView</code> or <code>GridView</code> and
you want each item to provide the same context menu, register all items for a context menu by
passing the <code>ListView</code> or <code>GridView</code> to <code>registerForContextMenu()</code>.</p>
</li>

  <li>Implement the <code>onCreateContextMenu()</code> method
in your <code>Activity</code> or <code>Fragment</code>.
  <p>When the registered view receives a long-click event, the system calls your <code>onCreateContextMenu()</code>
method. This is where you define the menu items, usually by inflating a menu resource. For
example:</p>
<pre>
@Override
public void onCreateContextMenu(ContextMenu menu, View v,
                                ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.context_menu, menu);
}
</pre>

<p><code>MenuInflater</code> allows you to inflate the context menu from a menu resource. The callback method
parameters include the <code>View</code>
that the user selected and a <code>ContextMenu.ContextMenuInfo</code> object that provides
additional information about the item selected. If your activity has several views that each provide
a different context menu, you might use these parameters to determine which context menu to
inflate.</p>
</li>

<li>Implement <code>onContextItemSelected()</code>.
  <p>When the user selects a menu item, the system calls this method so you can perform the
appropriate action. For example:</p>

<pre>
@Override
public boolean onContextItemSelected(MenuItem item) {
    AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
    switch (item.getItemId()) {
        case R.id.edit:
            editNote(info.id);
            return true;
        case R.id.delete:
            deleteNote(info.id);
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
</pre>

<p>The <code>getItemId()</code> method queries the ID for
the selected menu item, which you should assign to each menu item in XML using the <code>android:id</code> attribute, as shown in the section about Defining a Menu in
XML.</p>

<p>When you successfully handle a menu item, return <code>true</code>. If you don't handle the menu item,
you should pass the menu item to the superclass implementation. If your activity includes fragments,
the activity receives this callback first. By calling the superclass when unhandled, the system
passes the event to the respective callback method in each fragment, one at a time (in the order
each fragment was added) until <code>true</code> or <code>false</code> is returned. (The default
implementation for <code>Activity</code> and <code>android.app.Fragment</code> return <code>false</code>, so you should always call the superclass when unhandled.)</p>
</li>
</ol>
<p>If your activity uses a <code>ListView</code> or <code>GridView</code> and
you want each item to provide the same context menu, register all items for a context menu by
passing the <code>ListView</code> or <code>GridView</code> to <code>registerForContextMenu()</code>.</p>
<p>When the registered view receives a long-click event, the system calls your <code>onCreateContextMenu()</code>
method. This is where you define the menu items, usually by inflating a menu resource. For
example:</p>
<p>WHATSON? ef5b0f20-6c8f-46de-8f09-2447d49d7700</p>
<pre>
@Override
public void onCreateContextMenu(ContextMenu menu, View v,
                                ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.context_menu, menu);
}
</pre>
<p><code>MenuInflater</code> allows you to inflate the context menu from a menu resource. The callback method
parameters include the <code>View</code>
that the user selected and a <code>ContextMenu.ContextMenuInfo</code> object that provides
additional information about the item selected. If your activity has several views that each provide
a different context menu, you might use these parameters to determine which context menu to
inflate.</p>
<p>When the user selects a menu item, the system calls this method so you can perform the
appropriate action. For example:</p>
<p>WHATSON? ca56d863-54a3-4ae1-9d30-046fac0eaec9</p>
<pre>
@Override
public boolean onContextItemSelected(MenuItem item) {
    AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
    switch (item.getItemId()) {
        case R.id.edit:
            editNote(info.id);
            return true;
        case R.id.delete:
            deleteNote(info.id);
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
</pre>
<p>The <code>getItemId()</code> method queries the ID for
the selected menu item, which you should assign to each menu item in XML using the <code>android:id</code> attribute, as shown in the section about Defining a Menu in
XML.</p>
<p>When you successfully handle a menu item, return <code>true</code>. If you don't handle the menu item,
you should pass the menu item to the superclass implementation. If your activity includes fragments,
the activity receives this callback first. By calling the superclass when unhandled, the system
passes the event to the respective callback method in each fragment, one at a time (in the order
each fragment was added) until <code>true</code> or <code>false</code> is returned. (The default
implementation for <code>Activity</code> and <code>android.app.Fragment</code> return <code>false</code>, so you should always call the superclass when unhandled.)</p>
<h3>Using the contextual action mode</h3>
<p>The contextual action mode is a system implementation of <code>ActionMode</code> that
focuses user interaction toward performing contextual actions. When a
user enables this mode by selecting an item, a <em>contextual action bar</em> appears at the top of
the screen to present actions the user can perform on the currently selected item(s). While this
mode is enabled, the user can select multiple items (if you allow it), deselect items, and continue
to navigate within the activity (as much as you're willing to allow). The action mode is disabled
and the contextual action bar disappears when the user deselects all items, presses the BACK button,
or selects the <em>Done</em> action on the left side of the bar.</p>
<p><strong>Note:</strong> The contextual action bar is not necessarily
associated with the action bar. They operate
independently, even though the contextual action bar visually overtakes the action bar
position.</p>
<p>If you're developing for Android 3.0 (API level 11) or higher, you
should usually use the contextual action mode to present contextual actions, instead of the floating context menu.</p>
<p>For views that provide contextual actions, you should usually invoke the contextual action mode
upon one of two events (or both):</p>
<ul>
  <li>The user performs a long-click on the view.</li>
  <li>The user selects a checkbox or similar UI component within the view.</li>
</ul>
<p>How your application invokes the contextual action mode and defines the behavior for each
action depends on your design. There are basically two designs:</p>
<ul>
  <li>For contextual actions on individual, arbitrary views.</li>
  <li>For batch contextual actions on groups of items in a <code>ListView</code> or <code>GridView</code> (allowing the user to select multiple
items and perform an action on them all).</li>
</ul>
<p>The following sections describe the setup required for each scenario.</p>
<h4>Enabling the contextual action mode for individual views</h4>
<p>If you want to invoke the contextual action mode only when the user selects specific
views, you should:</p>
<ol>
  <li>Implement the <code>ActionMode.Callback</code> interface. In its callback methods, you
can specify the actions for the contextual action bar, respond to click events on action items, and
handle other lifecycle events for the action mode.</li>
  <li>Call <code>startActionMode()</code> when you want to show the
bar (such as when the user long-clicks the view).</li>
</ol>
<p>For example:</p>
<ol>
  <li>Implement the <code>ActionMode.Callback</code> interface:
<pre>
private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {

    // Called when the action mode is created; startActionMode() was called
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
        // Inflate a menu resource providing context menu items
        MenuInflater inflater = mode.getMenuInflater();
        inflater.inflate(R.menu.context_menu, menu);
        return true;
    }

    // Called each time the action mode is shown. Always called after onCreateActionMode, but
    // may be called multiple times if the mode is invalidated.
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        return false; // Return false if nothing is done
    }

    // Called when the user selects a contextual menu item
    @Override
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_share:
                shareCurrentItem();
                mode.finish(); // Action picked, so close the CAB
                return true;
            default:
                return false;
        }
    }

    // Called when the user exits the action mode
    @Override
    public void onDestroyActionMode(ActionMode mode) {
        mActionMode = null;
    }
};
</pre>

<p>Notice that these event callbacks are almost exactly the same as the callbacks for the options menu, except each of these also pass the <code>ActionMode</code> object associated with the event. You can use <code>ActionMode</code> APIs to make various changes to the CAB, such as revise the title and
subtitle with <code>setTitle()</code> and <code>setSubtitle()</code> (useful to indicate how many items are
selected).</p>

<p>Also notice that the above sample sets the <code>mActionMode</code> variable null when the
action mode is destroyed. In the next step, you'll see how it's initialized and how saving
the member variable in your activity or fragment can be useful.</p>
</li>

  <li>Call <code>startActionMode()</code> to enable the contextual
action mode when appropriate, such as in response to a long-click on a <code>View</code>:

<pre>
someView.setOnLongClickListener(new View.OnLongClickListener() {
    // Called when the user long-clicks on someView
    public boolean onLongClick(View view) {
        if (mActionMode != null) {
            return false;
        }

        // Start the CAB using the ActionMode.Callback defined above
        mActionMode = getActivity().startActionMode(mActionModeCallback);
        view.setSelected(true);
        return true;
    }
});
</pre>

<p>When you call <code>startActionMode()</code>, the system returns
the <code>ActionMode</code> created. By saving this in a member variable, you can
make changes to the contextual action bar in response to other events. In the above sample, the
<code>ActionMode</code> is used to ensure that the <code>ActionMode</code> instance
is not recreated if it's already active, by checking whether the member is null before starting the
action mode.</p>
</li>
</ol>
<p>WHATSON? de09f702-9021-4383-a58c-1722b212c7a6</p>
<pre>
private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {

    // Called when the action mode is created; startActionMode() was called
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
        // Inflate a menu resource providing context menu items
        MenuInflater inflater = mode.getMenuInflater();
        inflater.inflate(R.menu.context_menu, menu);
        return true;
    }

    // Called each time the action mode is shown. Always called after onCreateActionMode, but
    // may be called multiple times if the mode is invalidated.
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        return false; // Return false if nothing is done
    }

    // Called when the user selects a contextual menu item
    @Override
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_share:
                shareCurrentItem();
                mode.finish(); // Action picked, so close the CAB
                return true;
            default:
                return false;
        }
    }

    // Called when the user exits the action mode
    @Override
    public void onDestroyActionMode(ActionMode mode) {
        mActionMode = null;
    }
};
</pre>
<p>Notice that these event callbacks are almost exactly the same as the callbacks for the options menu, except each of these also pass the <code>ActionMode</code> object associated with the event. You can use <code>ActionMode</code> APIs to make various changes to the CAB, such as revise the title and
subtitle with <code>setTitle()</code> and <code>setSubtitle()</code> (useful to indicate how many items are
selected).</p>
<p>Also notice that the above sample sets the <code>mActionMode</code> variable null when the
action mode is destroyed. In the next step, you'll see how it's initialized and how saving
the member variable in your activity or fragment can be useful.</p>
<p>WHATSON? bc0885e6-586a-41ad-ab2f-1e2d62dc6bad</p>
<pre>
someView.setOnLongClickListener(new View.OnLongClickListener() {
    // Called when the user long-clicks on someView
    public boolean onLongClick(View view) {
        if (mActionMode != null) {
            return false;
        }

        // Start the CAB using the ActionMode.Callback defined above
        mActionMode = getActivity().startActionMode(mActionModeCallback);
        view.setSelected(true);
        return true;
    }
});
</pre>
<p>When you call <code>startActionMode()</code>, the system returns
the <code>ActionMode</code> created. By saving this in a member variable, you can
make changes to the contextual action bar in response to other events. In the above sample, the
<code>ActionMode</code> is used to ensure that the <code>ActionMode</code> instance
is not recreated if it's already active, by checking whether the member is null before starting the
action mode.</p>
<h4>Enabling batch contextual actions in a ListView or GridView</h4>
<p>If you have a collection of items in a <code>ListView</code> or <code>GridView</code> (or another extension of <code>AbsListView</code>) and want to
allow users to perform batch actions, you should:</p>
<ul>
  <li>Implement the <code>AbsListView.MultiChoiceModeListener</code> interface and set it
for the view group with <code>setMultiChoiceModeListener()</code>. In the listener's callback methods, you can specify the actions
for the contextual action bar, respond to click events on action items, and handle other callbacks
inherited from the <code>ActionMode.Callback</code> interface.</li>

  <li>Call <code>setChoiceMode()</code> with the <code>CHOICE_MODE_MULTIPLE_MODAL</code> argument.</li>
</ul>
<p>For example:</p>
<p>WHATSON? 371698a1-941f-4cc3-a028-2286eb2eeeb6</p>
<pre>
ListView listView = getListView();
listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
listView.setMultiChoiceModeListener(new MultiChoiceModeListener() {

    @Override
    public void onItemCheckedStateChanged(ActionMode mode, int position,
                                          long id, boolean checked) {
        // Here you can do something when items are selected/de-selected,
        // such as update the title in the CAB
    }

    @Override
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        // Respond to clicks on the actions in the CAB
        switch (item.getItemId()) {
            case R.id.menu_delete:
                deleteSelectedItems();
                mode.finish(); // Action picked, so close the CAB
                return true;
            default:
                return false;
        }
    }

    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
        // Inflate the menu for the CAB
        MenuInflater inflater = mode.getMenuInflater();
        inflater.inflate(R.menu.context, menu);
        return true;
    }

    @Override
    public void onDestroyActionMode(ActionMode mode) {
        // Here you can make any necessary updates to the activity when
        // the CAB is removed. By default, selected items are deselected/unchecked.
    }

    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        // Here you can perform updates to the CAB due to
        // an <code>invalidate()</code> request
        return false;
    }
});
</pre>
<p>That's it. Now when the user selects an item with a long-click, the system calls the <code>onCreateActionMode()</code>
method and displays the contextual action bar with the specified actions. While the contextual
action bar is visible, users can select additional items.</p>
<p>In some cases in which the contextual actions provide common action items, you might
want to add a checkbox or a similar UI element that allows users to select items, because they
might not discover the long-click behavior. When a user selects the checkbox, you
can invoke the contextual action mode by setting the respective list item to the checked
state with <code>setItemChecked()</code>.</p>
<h2>Creating a Popup Menu</h2>
<p><strong>Figure 4.</strong> A popup menu in the Gmail app, anchored to the overflow
button at the top-right.</p>
<p>A <code>PopupMenu</code> is a modal menu anchored to a <code>View</code>.
It appears below the anchor view if there is room, or above the view otherwise. It's useful for:</p>
<ul>
  <li>Providing an overflow-style menu for actions that <em>relate to</em> specific content (such as
Gmail's email headers, shown in figure 4).
    <p><strong>Note:</strong> This is not the same as a context menu, which is
generally for actions that <em>affect</em> selected content. For actions that affect selected
content, use the contextual action mode or floating context menu.</p></li>
  <li>Providing a second part of a command sentence (such as a button marked "Add"
that produces a popup menu with different "Add" options).</li>
  <li>Providing a drop-down similar to <code>Spinner</code> that does not retain
a persistent selection.</li>
</ul>
<p><strong>Note:</strong> This is not the same as a context menu, which is
generally for actions that <em>affect</em> selected content. For actions that affect selected
content, use the contextual action mode or floating context menu.</p>
<p><strong>Note:</strong> <code>PopupMenu</code> is available with API
level 11 and higher.</p>
<p>If you define your menu in XML, here's how you can show the popup menu:</p>
<ol>
  <li>Instantate a <code>PopupMenu</code> with its constructor, which takes the
current application <code>Context</code> and the <code>View</code> to which the
menu should be anchored.</li>
  <li>Use <code>MenuInflater</code> to inflate your menu resource into the <code>Menu</code> object returned by <code>PopupMenu.getMenu()</code>. On API level 14 and above, you can use
<code>PopupMenu.inflate()</code> instead.</li>
  <li>Call <code>PopupMenu.show()</code>.</li>
</ol>
<p>For example, here's a button with the <code>android:onClick</code> attribute
that shows a popup menu:</p>
<p>WHATSON? c591a12c-70c4-43c9-99b2-8cd847500c9c</p>
<pre>
&lt;ImageButton
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:src="@drawable/ic_overflow_holo_dark"
    android:contentDescription="@string/descr_overflow_button"
    android:onClick="showPopup" /&gt;
</pre>
<p>The activity can then show the popup menu like this:</p>
<p>WHATSON? 78cc4618-2cbe-4483-a724-739bf32abb06</p>
<pre>
public void showPopup(View v) {
    PopupMenu popup = new PopupMenu(this, v);
    MenuInflater inflater = popup.getMenuInflater();
    inflater.inflate(R.menu.actions, popup.getMenu());
    popup.show();
}
</pre>
<p>In API level 14 and higher, you can combine the two lines that inflate the menu with <code>PopupMenu.inflate()</code>.</p>
<p>The menu is dismissed when the user selects an item or touches outside the menu
area. You can listen for the dismiss event using <code>PopupMenu.OnDismissListener</code>.</p>
<h3>Handling click events</h3>
<p>To perform an
action when the user selects a menu item, you must implement the <code>PopupMenu.OnMenuItemClickListener</code> interface and register it with your <code>PopupMenu</code> by calling <code>setOnMenuItemclickListener()</code>. When the user selects an item, the system calls the <code>onMenuItemClick()</code> callback in
your interface.</p>
<p>For example:</p>
<p>WHATSON? a3b1260f-da83-4780-849a-d135c2dbd338</p>
<pre>
public void showMenu(View v) {
    PopupMenu popup = new PopupMenu(this, v);

    // This activity implements OnMenuItemClickListener
    popup.setOnMenuItemClickListener(this);
    popup.inflate(R.menu.actions);
    popup.show();
}

@Override
public boolean onMenuItemClick(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.archive:
            archive(item);
            return true;
        case R.id.delete:
            delete(item);
            return true;
        default:
            return false;
    }
}
</pre>
<h2>Creating Menu Groups</h2>
<p>A menu group is a collection of menu items that share certain traits. With a group, you
can:</p>
<ul>
  <li>Show or hide all items with <code>setGroupVisible()</code></li>
  <li>Enable or disable all items with <code>setGroupEnabled()</code></li>
  <li>Specify whether all items are checkable with <code>setGroupCheckable()</code></li>
</ul>
<p>You can create a group by nesting <code>&lt;item&gt;</code> elements inside a <code>&lt;group&gt;</code>
element in your menu resource or by specifying a group ID with the <code>add()</code> method.</p>
<p>Here's an example menu resource that includes a group:</p>
<p>WHATSON? b1300b31-356c-49f7-97db-c7f4a231c441</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:id="@+id/menu_save"
          android:icon="@drawable/menu_save"
          android:title="@string/menu_save" /&gt;
    &lt;!-- menu group --&gt;
    &lt;group android:id="@+id/group_delete"&gt;
        &lt;item android:id="@+id/menu_archive"
              android:title="@string/menu_archive" /&gt;
        &lt;item android:id="@+id/menu_delete"
              android:title="@string/menu_delete" /&gt;
    &lt;/group&gt;
&lt;/menu&gt;
</pre>
<p>The items that are in the group appear at the same level as the first item—all three items
in the menu are siblings. However, you can modify the traits of the two
items in the group by referencing the group ID and using the methods listed above. The system
will also never separate grouped items. For example, if you declare <code>android:showAsAction="ifRoom"</code> for each item, they will either both appear in the action
bar or both appear in the action overflow.</p>
<h3>Using checkable menu items</h3>
<p><strong>Figure 5.</strong> Screenshot of a submenu with checkable
items.</p>
<p>A menu can be useful as an interface for turning options on and off, using a checkbox for
stand-alone options, or radio buttons for groups of
mutually exclusive options. Figure 5 shows a submenu with items that are checkable with radio
buttons.</p>
<p><strong>Note:</strong> Menu items in the Icon Menu (from the options menu) cannot
display a checkbox or radio button. If you choose to make items in the Icon Menu checkable,
you must manually indicate the checked state by swapping the icon and/or text
each time the state changes.</p>
<p>You can define the checkable behavior for individual menu items using the <code>android:checkable</code> attribute in the <code>&lt;item&gt;</code> element, or for an entire group with
the <code>android:checkableBehavior</code> attribute in the <code>&lt;group&gt;</code> element. For
example, all items in this menu group are checkable with a radio button:</p>
<p>WHATSON? 9151eb3a-eb99-4318-ab51-4c7cdc4a110f</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;group android:checkableBehavior="single"&gt;
        &lt;item android:id="@+id/red"
              android:title="@string/red" /&gt;
        &lt;item android:id="@+id/blue"
              android:title="@string/blue" /&gt;
    &lt;/group&gt;
&lt;/menu&gt;
</pre>
<p>The <code>android:checkableBehavior</code> attribute accepts either:
</p>
<p>You can apply a default checked state to an item using the <code>android:checked</code> attribute in
the <code>&lt;item&gt;</code> element and change it in code with the <code>setChecked()</code> method.</p>
<p>When a checkable item is selected, the system calls your respective item-selected callback method
(such as <code>onOptionsItemSelected()</code>). It
is here that you must set the state of the checkbox, because a checkbox or radio button does not
change its state automatically. You can query the current state of the item (as it was before the
user selected it) with <code>isChecked()</code> and then set the checked state with
<code>setChecked()</code>. For example:</p>
<p>WHATSON? 359701e7-5dd9-4f3d-b4da-edebbe3b4e43</p>
<pre>
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.vibrate:
        case R.id.dont_vibrate:
            if (item.isChecked()) item.setChecked(false);
            else item.setChecked(true);
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}
</pre>
<p>If you don't set the checked state this way, then the visible state of the item (the checkbox or
radio button) will not
change when the user selects it. When you do set the state, the activity preserves the checked state
of the item so that when the user opens the menu later, the checked state that you
set is visible.</p>
<p><strong>Note:</strong>
Checkable menu items are intended to be used only on a per-session basis and not saved after the
application is destroyed. If you have application settings that you would like to save for the user,
you should store the data using Shared Preferences.</p>
<h2>Adding Menu Items Based on an Intent</h2>
<p>Sometimes you'll want a menu item to launch an activity using an <code>Intent</code>
(whether it's an activity in your application or another application). When you know the intent you
want to use and have a specific menu item that should initiate the intent, you can execute the
intent with <code>startActivity()</code> during the
appropriate on-item-selected callback method (such as the <code>onOptionsItemSelected()</code> callback).</p>
<p>However, if you are not certain that the user's device
contains an application that handles the intent, then adding a menu item that invokes it can result
in a non-functioning menu item, because the intent might not resolve to an
activity. To solve this, Android lets you dynamically add menu items to your menu
when Android finds activities on the device that handle your intent.</p>
<p>To add menu items based on available activities that accept an intent:</p>
<ol>
  <li>Define an
intent with the category <code>CATEGORY_ALTERNATIVE</code> and/or
<code>CATEGORY_SELECTED_ALTERNATIVE</code>, plus any other requirements.</li>
  <li>Call <code>Menu.addIntentOptions()</code>. Android then searches for any applications that can perform the intent
and adds them to your menu.</li>
</ol>
<p>If there are no applications installed
that satisfy the intent, then no menu items are added.</p>
<p><strong>Note:</strong>
<code>CATEGORY_SELECTED_ALTERNATIVE</code> is used to handle the currently
selected element on the screen. So, it should only be used when creating a Menu in <code>onCreateContextMenu()</code>.</p>
<p>For example:</p>
<p>WHATSON? 67b47474-40e5-4d89-aff4-66c71ac43450</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu){
    super.onCreateOptionsMenu(menu);

    // Create an Intent that describes the requirements to fulfill, to be included
    // in our menu. The offering app must include a category value of Intent.CATEGORY_ALTERNATIVE.
    Intent intent = new Intent(null, dataUri);
    intent.addCategory(Intent.CATEGORY_ALTERNATIVE);

    // Search and populate the menu with acceptable offering applications.
    menu.addIntentOptions(
         R.id.intent_group,  // Menu group to which new items will be added
         0,      // Unique item ID (none)
         0,      // Order for the items (none)
         this.getComponentName(),   // The current activity name
         null,   // Specific items to place first (none)
         intent, // Intent created above that describes our requirements
         0,      // Additional flags to control items (none)
         null);  // Array of MenuItems that correlate to specific items (none)

    return true;
}</pre>
<p>For each activity found that provides an intent filter matching the intent defined, a menu
item is added, using the value in the intent filter's <code>android:label</code> as the
menu item title and the application icon as the menu item icon. The
<code>addIntentOptions()</code> method returns the number of menu items added.</p>
<p><strong>Note:</strong> When you call <code>addIntentOptions()</code>, it overrides any and all menu items by the menu group specified in the first
argument.</p>
<h3>Allowing your activity to be added to other menus</h3>
<p>You can also offer the services of your activity to other applications, so your
application can be included in the menu of others (reverse the roles described above).</p>
<p>To be included in other application menus, you need to define an intent
filter as usual, but be sure to include the <code>CATEGORY_ALTERNATIVE</code>
and/or <code>CATEGORY_SELECTED_ALTERNATIVE</code> values for the intent filter
category. For example:</p>
<p>WHATSON? 4416a45b-2081-46fd-9f76-f333dcce0ebd</p>
<pre>
&lt;intent-filter label="@string/resize_image"&gt;
    ...
    &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
    &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>Read more about writing intent filters in the
Intents and Intent Filters document.</p>
<p>For a sample application using this technique, see the 
Note
Pad sample code.</p>
<h1>Menus</h1>
<h2>In this document</h2>
<ol>
  <li>Defining a Menu in XML</li>
  <li>Creating an Options Menu
    <ol>
      <li>Handling click events</li>
      <li>Changing menu items at runtime</li>
    </ol>
  </li>
  <li>Creating Contextual Menus
    <ol>
      <li>Creating a floating context menu</li>
      <li>Using the contextual action mode</li>
    </ol>
  </li>
  <li>Creating a Popup Menu
    <ol>
      <li>Handling click events</li>
    </ol>
  </li>
  <li>Creating Menu Groups
    <ol>
      <li>Using checkable menu items</li>
    </ol>
  </li>
  <li>Adding Menu Items Based on an Intent
    <ol>
      <li>Allowing your activity to be added to other menus</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Handling click events</li>
      <li>Changing menu items at runtime</li>
    </ol>
<ol>
      <li>Creating a floating context menu</li>
      <li>Using the contextual action mode</li>
    </ol>
<ol>
      <li>Handling click events</li>
    </ol>
<ol>
      <li>Using checkable menu items</li>
    </ol>
<ol>
      <li>Allowing your activity to be added to other menus</li>
    </ol>
<h2>Key classes</h2>
<ol>
    <li><code>Menu</code></li>
    <li><code>MenuItem</code></li>
    <li><code>ContextMenu</code></li>
    <li><code>ActionMode</code></li>
  </ol>
<h2>See also</h2>
<ol>
    <li>Action Bar</li>
    <li>Menu Resource</li>
    <li>Say
Goodbye to the Menu Button</li>
  </ol>
<p>Menus are a common user interface component in many types of applications. To provide a familiar
and consistent user experience, you should use the <code>Menu</code> APIs to present user
actions and other options in your activities.</p>
<p>Beginning with Android 3.0 (API level 11), Android-powered devices are no longer required to
provide a dedicated <em>Menu</em> button. With this change, Android apps should migrate away from a
dependence on the traditional 6-item menu panel and instead provide an action bar to present common
user actions.</p>
<p>Although the design and user experience for some menu items have changed, the semantics to define
a set of actions and options is still based on the <code>Menu</code> APIs. This
guide shows how to create the three fundamental types of menus or action presentations on all
versions of Android:</p>
<p>If you're developing for Android 2.3 or lower, users can
reveal the options menu panel by pressing the <em>Menu</em> button.</p>
<p>On Android 3.0 and higher, items from the options menu are presented by the action bar as a combination of on-screen action
items and overflow options. Beginning with Android 3.0, the <em>Menu</em> button is deprecated (some
devices
don't have one), so you should migrate toward using the action bar to provide access to actions and
other options.</p>
<p>See the section about Creating an Options Menu.</p>
<p>When developing for Android 3.0 and higher, you should instead use the contextual action mode to enable actions on selected content. This mode displays
action items that affect the selected content in a bar at the top of the screen and allows the user
to select multiple items.</p>
<p>See the section about Creating Contextual Menus.</p>
<p>See the section about Creating a Popup Menu.</p>
<h2>Defining a Menu in XML</h2>
<p>For all menu types, Android provides a standard XML format to define menu items.
Instead of building a menu in your activity's code, you should define a menu and all its items in an
XML menu resource. You can then
inflate the menu resource (load it as a <code>Menu</code> object) in your activity or
fragment.</p>
<p>Using a menu resource is a good practice for a few reasons:</p>
<ul>
  <li>It's easier to visualize the menu structure in XML.</li>
  <li>It separates the content for the menu from your application's behavioral code.</li>
  <li>It allows you to create alternative menu configurations for different platform versions,
screen sizes, and other configurations by leveraging the app resources framework.</li>
</ul>
<p>To define the menu, create an XML file inside your project's <code>res/menu/</code>
directory and build the menu with the following elements:</p>
<p>Here's an example menu named <code>game_menu.xml</code>:</p>
<p>WHATSON? b23de1af-053a-42c7-b7cb-5b60222e39dc</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:id="@+id/new_game"
          android:icon="@drawable/ic_new_game"
          android:title="@string/new_game"
          android:showAsAction="ifRoom"/&gt;
    &lt;item android:id="@+id/help"
          android:icon="@drawable/ic_help"
          android:title="@string/help" /&gt;
&lt;/menu&gt;
</pre>
<p>The <code>&lt;item&gt;</code> element supports several attributes you can use to define an item's
appearance and behavior. The items in the above menu include the following attributes:</p>
<p>These are the most important attributes you should use, but there are many more available.
For information about all the supported attributes, see the Menu Resource document.</p>
<p>You can add a submenu to an item in any menu (except a submenu) by adding a <code>&lt;menu&gt;</code>
element as the child of an <code>&lt;item&gt;</code>. Submenus are useful when your application has a lot
of functions that can be organized into topics, like items in a PC application's menu bar (File,
Edit, View, etc.). For example:</p>
<p>WHATSON? 961f564d-9a27-45ed-bec8-a91a71e7a813</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:id="@+id/file"
          android:title="@string/file" &gt;
        &lt;!-- "file" submenu --&gt;
        &lt;menu&gt;
            &lt;item android:id="@+id/create_new"
                  android:title="@string/create_new" /&gt;
            &lt;item android:id="@+id/open"
                  android:title="@string/open" /&gt;
        &lt;/menu&gt;
    &lt;/item&gt;
&lt;/menu&gt;
</pre>
<p>To use the menu in your activity, you need to inflate the menu resource (convert the XML
resource into a programmable object) using <code>MenuInflater.inflate()</code>. In the following sections, you'll see how to inflate a menu for each
menu type.</p>
<h2>Creating an Options Menu</h2>
<p><strong>Figure 1.</strong> Options menu in the
Browser, on Android 2.3.</p>
<p>The options menu is where you should include actions and other options that are relevant to the
current activity context, such as "Search," "Compose email," and "Settings."</p>
<p>Where the items in your options menu appear on the screen depends on the version for which you've
developed your application:</p>
<ul>
  <li>If you've developed your application for <strong>Android 2.3.x (API level 10) or
lower</strong>, the contents of your options menu appear at the bottom of the screen when the user
presses the <em>Menu</em> button, as shown in figure 1. When opened, the first visible portion is
the icon
menu, which holds up to six menu items. If your menu includes more than six items, Android places
the sixth item and the rest into the overflow menu, which the user can open by selecting
<em>More</em>.</li>

  <li>If you've developed your application for <strong>Android 3.0 (API level 11) and
higher</strong>, items from the options menu are available in the action bar. By default, the system
places all items in the action overflow, which the user can reveal with the action overflow icon on
the right side of the action bar (or by pressing the device <em>Menu</em> button, if available). To
enable
quick access to important actions, you can promote a few items to appear in the action bar by adding
<code>android:showAsAction="ifRoom"</code> to the corresponding <code>&lt;item&gt;</code> elements (see figure
2). <p>For more information about action items and other action bar behaviors, see the Action Bar guide. </p>
<p><strong>Note:</strong> Even if you're <em>not</em> developing for Android 3.0 or
higher, you can build your own action bar layout for a similar effect. For an example of how you can
support older versions of Android with an action bar, see the Action Bar Compatibility
sample.</p>
</li>
</ul>
<p>For more information about action items and other action bar behaviors, see the Action Bar guide. </p>
<p><strong>Note:</strong> Even if you're <em>not</em> developing for Android 3.0 or
higher, you can build your own action bar layout for a similar effect. For an example of how you can
support older versions of Android with an action bar, see the Action Bar Compatibility
sample.</p>
<p><strong>Figure 2.</strong> Action bar from the Honeycomb Gallery app, showing
navigation tabs and a camera action item (plus the action overflow button).</p>
<p>You can declare items for the options menu from either your <code>Activity</code>
subclass or a <code>Fragment</code> subclass. If both your activity and fragment(s)
declare items for the options menu, they are combined in the UI. The activity's items appear
first, followed by those of each fragment in the order in which each fragment is added to the
activity. If necessary, you can re-order the menu items with the <code>android:orderInCategory</code>
attribute in each <code>&lt;item&gt;</code> you need to move.</p>
<p>To specify the options menu for an activity, override <code>onCreateOptionsMenu()</code> (fragments provide their
own <code>onCreateOptionsMenu()</code> callback). In this
method, you can inflate your menu resource (defined in XML) into the <code>Menu</code> provided in the callback. For example:</p>
<p>WHATSON? 92c7eee0-47ac-40f6-a309-9af25565ca11</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = <code>getMenuInflater()</code>;
    inflater.inflate(R.menu.game_menu, menu);
    return true;
}
</pre>
<p>You can also add menu items using <code>add()</code> and retrieve items with <code>findItem()</code> to revise their
properties with <code>MenuItem</code> APIs.</p>
<p>If you've developed your application for Android 2.3.x and lower, the system calls <code>onCreateOptionsMenu()</code> to create the options menu
when the user opens the menu for the first time. If you've developed for Android 3.0 and higher, the
system calls <code>onCreateOptionsMenu()</code> when
starting the activity, in order to show items to the action bar.</p>
<h3>Handling click events</h3>
<p>When the user selects an item from the options menu (including action items in the action bar),
the system calls your activity's <code>onOptionsItemSelected()</code> method. This method passes the <code>MenuItem</code> selected. You
can identify the item by calling <code>getItemId()</code>, which returns the unique
ID for the menu item (defined by the <code>android:id</code> attribute in the menu resource or with an
integer given to the <code>add()</code> method). You can match
this ID against known menu items to perform the appropriate action. For example:</p>
<p>WHATSON? 0aff10f2-0fbc-425f-a1b0-e67ac6d36b54</p>
<pre>
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle item selection
    switch (item.getItemId()) {
        case R.id.new_game:
            newGame();
            return true;
        case R.id.help:
            showHelp();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}
</pre>
<p>When you successfully handle a menu item, return <code>true</code>. If you don't handle the menu
item, you should call the superclass implementation of <code>onOptionsItemSelected()</code> (the default
implementation returns false).</p>
<p>If your activity includes fragments, the system first calls <code>onOptionsItemSelected()</code> for the activity then
for each fragment (in the order each fragment was added) until one returns
<code>true</code> or all fragments have been called.</p>
<p><strong>Tip:</strong> Android 3.0 adds the ability for you to define the on-click
behavior for a menu item in XML, using the <code>android:onClick</code> attribute. The value for the
attribute must be the name of a method defined by the activity using the menu. The method
must be public and accept a single <code>MenuItem</code> parameter—when the system
calls this method, it passes the menu item selected. For more information and an example, see the Menu Resource document.</p>
<p><strong>Tip:</strong> If your application contains multiple activities and
some of them provide the same options menu, consider creating
an activity that implements nothing except the <code>onCreateOptionsMenu()</code> and <code>onOptionsItemSelected()</code> methods. Then extend this class for each activity that should share the
same options menu. This way, you can manage one set of code for handling menu
actions and each descendant class inherits the menu behaviors.
If you want to add menu items to one of the descendant activities,
override <code>onCreateOptionsMenu()</code> in that activity. Call <code>super.onCreateOptionsMenu(menu)</code> so the
original menu items are created, then add new menu items with <code>menu.add()</code>. You can also override the super class's
behavior for individual menu items.</p>
<h3>Changing menu items at runtime</h3>
<p>After the system calls <code>onCreateOptionsMenu()</code>, it retains an instance of the <code>Menu</code> you populate and
will not call <code>onCreateOptionsMenu()</code>
again unless the menu is invalidated for some reason. However, you should use <code>onCreateOptionsMenu()</code> only to create the initial
menu state and not to make changes during the activity lifecycle.</p>
<p>If you want to modify the options menu based on 
events that occur during the activity lifecycle, you can do so in
the <code>onPrepareOptionsMenu()</code> method. This
method passes you the <code>Menu</code> object as it currently exists so you can modify it,
such as add, remove, or disable items. (Fragments also provide an <code>onPrepareOptionsMenu()</code> callback.)</p>
<p>On Android 2.3.x and lower, the system calls <code>onPrepareOptionsMenu()</code> each time the user opens the options menu (presses the <em>Menu</em>
button).</p>
<p>On Android 3.0 and higher, the options menu is considered to always be open when menu items are
presented in the action bar. When an event occurs and you want to perform a menu update, you must
call <code>invalidateOptionsMenu()</code> to request that the
system call <code>onPrepareOptionsMenu()</code>.</p>
<p><strong>Note:</strong> 
You should never change items in the options menu based on the <code>View</code> currently
in focus. When in touch mode (when the user is not using a trackball or d-pad), views
cannot take focus, so you should never use focus as the basis for modifying
items in the options menu. If you want to provide menu items that are context-sensitive to a <code>View</code>, use a Context Menu.</p>
<h2>Creating Contextual Menus</h2>
<p><strong>Figure 3.</strong> Screenshots of a floating context menu (left)
and the contextual action bar (right).</p>
<p>A contextual menu offers actions that affect a specific item or context frame in the UI. You
can provide a context menu for any view, but they are most often used for items in a <code>ListView</code>, <code>GridView</code>, or other view collections in which
the user can perform direct actions on each item.</p>
<p>There are two ways to provide contextual actions:</p>
<ul>
  <li>In a floating context menu. A menu appears as a
floating list of menu items (similar to a dialog) when the user performs a long-click (press and
hold) on a view that declares support for a context menu. Users can perform a contextual
action on one item at a time.</li>

  <li>In the contextual action mode. This mode is a system implementation of
<code>ActionMode</code> that displays a <em>contextual action bar</em> at the top of the
screen with action items that affect the selected item(s). When this mode is active, users
can perform an action on multiple items at once (if your app allows it).</li>
</ul>
<p><strong>Note:</strong> The contextual action mode is available on Android 3.0 (API
level 11) and higher and is the preferred technique for displaying contextual actions when
available. If your app supports versions lower than 3.0 then you should fall back to a floating
context menu on those devices.</p>
<h3>Creating a floating context menu</h3>
<p>To provide a floating context menu:</p>
<ol>
  <li>Register the <code>View</code> to which the context menu should be associated by
calling <code>registerForContextMenu()</code> and pass
it the <code>View</code>.
  <p>If your activity uses a <code>ListView</code> or <code>GridView</code> and
you want each item to provide the same context menu, register all items for a context menu by
passing the <code>ListView</code> or <code>GridView</code> to <code>registerForContextMenu()</code>.</p>
</li>

  <li>Implement the <code>onCreateContextMenu()</code> method
in your <code>Activity</code> or <code>Fragment</code>.
  <p>When the registered view receives a long-click event, the system calls your <code>onCreateContextMenu()</code>
method. This is where you define the menu items, usually by inflating a menu resource. For
example:</p>
<pre>
@Override
public void onCreateContextMenu(ContextMenu menu, View v,
                                ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.context_menu, menu);
}
</pre>

<p><code>MenuInflater</code> allows you to inflate the context menu from a menu resource. The callback method
parameters include the <code>View</code>
that the user selected and a <code>ContextMenu.ContextMenuInfo</code> object that provides
additional information about the item selected. If your activity has several views that each provide
a different context menu, you might use these parameters to determine which context menu to
inflate.</p>
</li>

<li>Implement <code>onContextItemSelected()</code>.
  <p>When the user selects a menu item, the system calls this method so you can perform the
appropriate action. For example:</p>

<pre>
@Override
public boolean onContextItemSelected(MenuItem item) {
    AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
    switch (item.getItemId()) {
        case R.id.edit:
            editNote(info.id);
            return true;
        case R.id.delete:
            deleteNote(info.id);
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
</pre>

<p>The <code>getItemId()</code> method queries the ID for
the selected menu item, which you should assign to each menu item in XML using the <code>android:id</code> attribute, as shown in the section about Defining a Menu in
XML.</p>

<p>When you successfully handle a menu item, return <code>true</code>. If you don't handle the menu item,
you should pass the menu item to the superclass implementation. If your activity includes fragments,
the activity receives this callback first. By calling the superclass when unhandled, the system
passes the event to the respective callback method in each fragment, one at a time (in the order
each fragment was added) until <code>true</code> or <code>false</code> is returned. (The default
implementation for <code>Activity</code> and <code>android.app.Fragment</code> return <code>false</code>, so you should always call the superclass when unhandled.)</p>
</li>
</ol>
<p>If your activity uses a <code>ListView</code> or <code>GridView</code> and
you want each item to provide the same context menu, register all items for a context menu by
passing the <code>ListView</code> or <code>GridView</code> to <code>registerForContextMenu()</code>.</p>
<p>When the registered view receives a long-click event, the system calls your <code>onCreateContextMenu()</code>
method. This is where you define the menu items, usually by inflating a menu resource. For
example:</p>
<p>WHATSON? 459f316c-93e6-411e-9ee6-89823e7c8660</p>
<pre>
@Override
public void onCreateContextMenu(ContextMenu menu, View v,
                                ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.context_menu, menu);
}
</pre>
<p><code>MenuInflater</code> allows you to inflate the context menu from a menu resource. The callback method
parameters include the <code>View</code>
that the user selected and a <code>ContextMenu.ContextMenuInfo</code> object that provides
additional information about the item selected. If your activity has several views that each provide
a different context menu, you might use these parameters to determine which context menu to
inflate.</p>
<p>When the user selects a menu item, the system calls this method so you can perform the
appropriate action. For example:</p>
<p>WHATSON? 25c352b3-7aee-4810-8593-5c9736998c01</p>
<pre>
@Override
public boolean onContextItemSelected(MenuItem item) {
    AdapterContextMenuInfo info = (AdapterContextMenuInfo) item.getMenuInfo();
    switch (item.getItemId()) {
        case R.id.edit:
            editNote(info.id);
            return true;
        case R.id.delete:
            deleteNote(info.id);
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
</pre>
<p>The <code>getItemId()</code> method queries the ID for
the selected menu item, which you should assign to each menu item in XML using the <code>android:id</code> attribute, as shown in the section about Defining a Menu in
XML.</p>
<p>When you successfully handle a menu item, return <code>true</code>. If you don't handle the menu item,
you should pass the menu item to the superclass implementation. If your activity includes fragments,
the activity receives this callback first. By calling the superclass when unhandled, the system
passes the event to the respective callback method in each fragment, one at a time (in the order
each fragment was added) until <code>true</code> or <code>false</code> is returned. (The default
implementation for <code>Activity</code> and <code>android.app.Fragment</code> return <code>false</code>, so you should always call the superclass when unhandled.)</p>
<h3>Using the contextual action mode</h3>
<p>The contextual action mode is a system implementation of <code>ActionMode</code> that
focuses user interaction toward performing contextual actions. When a
user enables this mode by selecting an item, a <em>contextual action bar</em> appears at the top of
the screen to present actions the user can perform on the currently selected item(s). While this
mode is enabled, the user can select multiple items (if you allow it), deselect items, and continue
to navigate within the activity (as much as you're willing to allow). The action mode is disabled
and the contextual action bar disappears when the user deselects all items, presses the BACK button,
or selects the <em>Done</em> action on the left side of the bar.</p>
<p><strong>Note:</strong> The contextual action bar is not necessarily
associated with the action bar. They operate
independently, even though the contextual action bar visually overtakes the action bar
position.</p>
<p>If you're developing for Android 3.0 (API level 11) or higher, you
should usually use the contextual action mode to present contextual actions, instead of the floating context menu.</p>
<p>For views that provide contextual actions, you should usually invoke the contextual action mode
upon one of two events (or both):</p>
<ul>
  <li>The user performs a long-click on the view.</li>
  <li>The user selects a checkbox or similar UI component within the view.</li>
</ul>
<p>How your application invokes the contextual action mode and defines the behavior for each
action depends on your design. There are basically two designs:</p>
<ul>
  <li>For contextual actions on individual, arbitrary views.</li>
  <li>For batch contextual actions on groups of items in a <code>ListView</code> or <code>GridView</code> (allowing the user to select multiple
items and perform an action on them all).</li>
</ul>
<p>The following sections describe the setup required for each scenario.</p>
<h4>Enabling the contextual action mode for individual views</h4>
<p>If you want to invoke the contextual action mode only when the user selects specific
views, you should:</p>
<ol>
  <li>Implement the <code>ActionMode.Callback</code> interface. In its callback methods, you
can specify the actions for the contextual action bar, respond to click events on action items, and
handle other lifecycle events for the action mode.</li>
  <li>Call <code>startActionMode()</code> when you want to show the
bar (such as when the user long-clicks the view).</li>
</ol>
<p>For example:</p>
<ol>
  <li>Implement the <code>ActionMode.Callback</code> interface:
<pre>
private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {

    // Called when the action mode is created; startActionMode() was called
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
        // Inflate a menu resource providing context menu items
        MenuInflater inflater = mode.getMenuInflater();
        inflater.inflate(R.menu.context_menu, menu);
        return true;
    }

    // Called each time the action mode is shown. Always called after onCreateActionMode, but
    // may be called multiple times if the mode is invalidated.
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        return false; // Return false if nothing is done
    }

    // Called when the user selects a contextual menu item
    @Override
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_share:
                shareCurrentItem();
                mode.finish(); // Action picked, so close the CAB
                return true;
            default:
                return false;
        }
    }

    // Called when the user exits the action mode
    @Override
    public void onDestroyActionMode(ActionMode mode) {
        mActionMode = null;
    }
};
</pre>

<p>Notice that these event callbacks are almost exactly the same as the callbacks for the options menu, except each of these also pass the <code>ActionMode</code> object associated with the event. You can use <code>ActionMode</code> APIs to make various changes to the CAB, such as revise the title and
subtitle with <code>setTitle()</code> and <code>setSubtitle()</code> (useful to indicate how many items are
selected).</p>

<p>Also notice that the above sample sets the <code>mActionMode</code> variable null when the
action mode is destroyed. In the next step, you'll see how it's initialized and how saving
the member variable in your activity or fragment can be useful.</p>
</li>

  <li>Call <code>startActionMode()</code> to enable the contextual
action mode when appropriate, such as in response to a long-click on a <code>View</code>:

<pre>
someView.setOnLongClickListener(new View.OnLongClickListener() {
    // Called when the user long-clicks on someView
    public boolean onLongClick(View view) {
        if (mActionMode != null) {
            return false;
        }

        // Start the CAB using the ActionMode.Callback defined above
        mActionMode = getActivity().startActionMode(mActionModeCallback);
        view.setSelected(true);
        return true;
    }
});
</pre>

<p>When you call <code>startActionMode()</code>, the system returns
the <code>ActionMode</code> created. By saving this in a member variable, you can
make changes to the contextual action bar in response to other events. In the above sample, the
<code>ActionMode</code> is used to ensure that the <code>ActionMode</code> instance
is not recreated if it's already active, by checking whether the member is null before starting the
action mode.</p>
</li>
</ol>
<p>WHATSON? c20034e1-a125-4ae8-a476-2a369e018751</p>
<pre>
private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {

    // Called when the action mode is created; startActionMode() was called
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
        // Inflate a menu resource providing context menu items
        MenuInflater inflater = mode.getMenuInflater();
        inflater.inflate(R.menu.context_menu, menu);
        return true;
    }

    // Called each time the action mode is shown. Always called after onCreateActionMode, but
    // may be called multiple times if the mode is invalidated.
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        return false; // Return false if nothing is done
    }

    // Called when the user selects a contextual menu item
    @Override
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_share:
                shareCurrentItem();
                mode.finish(); // Action picked, so close the CAB
                return true;
            default:
                return false;
        }
    }

    // Called when the user exits the action mode
    @Override
    public void onDestroyActionMode(ActionMode mode) {
        mActionMode = null;
    }
};
</pre>
<p>Notice that these event callbacks are almost exactly the same as the callbacks for the options menu, except each of these also pass the <code>ActionMode</code> object associated with the event. You can use <code>ActionMode</code> APIs to make various changes to the CAB, such as revise the title and
subtitle with <code>setTitle()</code> and <code>setSubtitle()</code> (useful to indicate how many items are
selected).</p>
<p>Also notice that the above sample sets the <code>mActionMode</code> variable null when the
action mode is destroyed. In the next step, you'll see how it's initialized and how saving
the member variable in your activity or fragment can be useful.</p>
<p>WHATSON? 332246a7-a1ba-4daf-815b-0a544e50da91</p>
<pre>
someView.setOnLongClickListener(new View.OnLongClickListener() {
    // Called when the user long-clicks on someView
    public boolean onLongClick(View view) {
        if (mActionMode != null) {
            return false;
        }

        // Start the CAB using the ActionMode.Callback defined above
        mActionMode = getActivity().startActionMode(mActionModeCallback);
        view.setSelected(true);
        return true;
    }
});
</pre>
<p>When you call <code>startActionMode()</code>, the system returns
the <code>ActionMode</code> created. By saving this in a member variable, you can
make changes to the contextual action bar in response to other events. In the above sample, the
<code>ActionMode</code> is used to ensure that the <code>ActionMode</code> instance
is not recreated if it's already active, by checking whether the member is null before starting the
action mode.</p>
<h4>Enabling batch contextual actions in a ListView or GridView</h4>
<p>If you have a collection of items in a <code>ListView</code> or <code>GridView</code> (or another extension of <code>AbsListView</code>) and want to
allow users to perform batch actions, you should:</p>
<ul>
  <li>Implement the <code>AbsListView.MultiChoiceModeListener</code> interface and set it
for the view group with <code>setMultiChoiceModeListener()</code>. In the listener's callback methods, you can specify the actions
for the contextual action bar, respond to click events on action items, and handle other callbacks
inherited from the <code>ActionMode.Callback</code> interface.</li>

  <li>Call <code>setChoiceMode()</code> with the <code>CHOICE_MODE_MULTIPLE_MODAL</code> argument.</li>
</ul>
<p>For example:</p>
<p>WHATSON? 40babdfb-c865-4da1-86a4-985d41cf8698</p>
<pre>
ListView listView = getListView();
listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
listView.setMultiChoiceModeListener(new MultiChoiceModeListener() {

    @Override
    public void onItemCheckedStateChanged(ActionMode mode, int position,
                                          long id, boolean checked) {
        // Here you can do something when items are selected/de-selected,
        // such as update the title in the CAB
    }

    @Override
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        // Respond to clicks on the actions in the CAB
        switch (item.getItemId()) {
            case R.id.menu_delete:
                deleteSelectedItems();
                mode.finish(); // Action picked, so close the CAB
                return true;
            default:
                return false;
        }
    }

    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
        // Inflate the menu for the CAB
        MenuInflater inflater = mode.getMenuInflater();
        inflater.inflate(R.menu.context, menu);
        return true;
    }

    @Override
    public void onDestroyActionMode(ActionMode mode) {
        // Here you can make any necessary updates to the activity when
        // the CAB is removed. By default, selected items are deselected/unchecked.
    }

    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        // Here you can perform updates to the CAB due to
        // an <code>invalidate()</code> request
        return false;
    }
});
</pre>
<p>That's it. Now when the user selects an item with a long-click, the system calls the <code>onCreateActionMode()</code>
method and displays the contextual action bar with the specified actions. While the contextual
action bar is visible, users can select additional items.</p>
<p>In some cases in which the contextual actions provide common action items, you might
want to add a checkbox or a similar UI element that allows users to select items, because they
might not discover the long-click behavior. When a user selects the checkbox, you
can invoke the contextual action mode by setting the respective list item to the checked
state with <code>setItemChecked()</code>.</p>
<h2>Creating a Popup Menu</h2>
<p><strong>Figure 4.</strong> A popup menu in the Gmail app, anchored to the overflow
button at the top-right.</p>
<p>A <code>PopupMenu</code> is a modal menu anchored to a <code>View</code>.
It appears below the anchor view if there is room, or above the view otherwise. It's useful for:</p>
<ul>
  <li>Providing an overflow-style menu for actions that <em>relate to</em> specific content (such as
Gmail's email headers, shown in figure 4).
    <p><strong>Note:</strong> This is not the same as a context menu, which is
generally for actions that <em>affect</em> selected content. For actions that affect selected
content, use the contextual action mode or floating context menu.</p></li>
  <li>Providing a second part of a command sentence (such as a button marked "Add"
that produces a popup menu with different "Add" options).</li>
  <li>Providing a drop-down similar to <code>Spinner</code> that does not retain
a persistent selection.</li>
</ul>
<p><strong>Note:</strong> This is not the same as a context menu, which is
generally for actions that <em>affect</em> selected content. For actions that affect selected
content, use the contextual action mode or floating context menu.</p>
<p><strong>Note:</strong> <code>PopupMenu</code> is available with API
level 11 and higher.</p>
<p>If you define your menu in XML, here's how you can show the popup menu:</p>
<ol>
  <li>Instantate a <code>PopupMenu</code> with its constructor, which takes the
current application <code>Context</code> and the <code>View</code> to which the
menu should be anchored.</li>
  <li>Use <code>MenuInflater</code> to inflate your menu resource into the <code>Menu</code> object returned by <code>PopupMenu.getMenu()</code>. On API level 14 and above, you can use
<code>PopupMenu.inflate()</code> instead.</li>
  <li>Call <code>PopupMenu.show()</code>.</li>
</ol>
<p>For example, here's a button with the <code>android:onClick</code> attribute
that shows a popup menu:</p>
<p>WHATSON? 4097edb4-14d0-4ced-9210-2e74a2fc5919</p>
<pre>
&lt;ImageButton
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:src="@drawable/ic_overflow_holo_dark"
    android:contentDescription="@string/descr_overflow_button"
    android:onClick="showPopup" /&gt;
</pre>
<p>The activity can then show the popup menu like this:</p>
<p>WHATSON? fbc3bb01-fad1-4a6f-a213-90bbdf09f199</p>
<pre>
public void showPopup(View v) {
    PopupMenu popup = new PopupMenu(this, v);
    MenuInflater inflater = popup.getMenuInflater();
    inflater.inflate(R.menu.actions, popup.getMenu());
    popup.show();
}
</pre>
<p>In API level 14 and higher, you can combine the two lines that inflate the menu with <code>PopupMenu.inflate()</code>.</p>
<p>The menu is dismissed when the user selects an item or touches outside the menu
area. You can listen for the dismiss event using <code>PopupMenu.OnDismissListener</code>.</p>
<h3>Handling click events</h3>
<p>To perform an
action when the user selects a menu item, you must implement the <code>PopupMenu.OnMenuItemClickListener</code> interface and register it with your <code>PopupMenu</code> by calling <code>setOnMenuItemclickListener()</code>. When the user selects an item, the system calls the <code>onMenuItemClick()</code> callback in
your interface.</p>
<p>For example:</p>
<p>WHATSON? f9c9ac2c-7a15-4456-931e-b629b711ce4c</p>
<pre>
public void showMenu(View v) {
    PopupMenu popup = new PopupMenu(this, v);

    // This activity implements OnMenuItemClickListener
    popup.setOnMenuItemClickListener(this);
    popup.inflate(R.menu.actions);
    popup.show();
}

@Override
public boolean onMenuItemClick(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.archive:
            archive(item);
            return true;
        case R.id.delete:
            delete(item);
            return true;
        default:
            return false;
    }
}
</pre>
<h2>Creating Menu Groups</h2>
<p>A menu group is a collection of menu items that share certain traits. With a group, you
can:</p>
<ul>
  <li>Show or hide all items with <code>setGroupVisible()</code></li>
  <li>Enable or disable all items with <code>setGroupEnabled()</code></li>
  <li>Specify whether all items are checkable with <code>setGroupCheckable()</code></li>
</ul>
<p>You can create a group by nesting <code>&lt;item&gt;</code> elements inside a <code>&lt;group&gt;</code>
element in your menu resource or by specifying a group ID with the <code>add()</code> method.</p>
<p>Here's an example menu resource that includes a group:</p>
<p>WHATSON? 11c70506-e0b4-4790-b1da-ce33556b5b01</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;item android:id="@+id/menu_save"
          android:icon="@drawable/menu_save"
          android:title="@string/menu_save" /&gt;
    &lt;!-- menu group --&gt;
    &lt;group android:id="@+id/group_delete"&gt;
        &lt;item android:id="@+id/menu_archive"
              android:title="@string/menu_archive" /&gt;
        &lt;item android:id="@+id/menu_delete"
              android:title="@string/menu_delete" /&gt;
    &lt;/group&gt;
&lt;/menu&gt;
</pre>
<p>The items that are in the group appear at the same level as the first item—all three items
in the menu are siblings. However, you can modify the traits of the two
items in the group by referencing the group ID and using the methods listed above. The system
will also never separate grouped items. For example, if you declare <code>android:showAsAction="ifRoom"</code> for each item, they will either both appear in the action
bar or both appear in the action overflow.</p>
<h3>Using checkable menu items</h3>
<p><strong>Figure 5.</strong> Screenshot of a submenu with checkable
items.</p>
<p>A menu can be useful as an interface for turning options on and off, using a checkbox for
stand-alone options, or radio buttons for groups of
mutually exclusive options. Figure 5 shows a submenu with items that are checkable with radio
buttons.</p>
<p><strong>Note:</strong> Menu items in the Icon Menu (from the options menu) cannot
display a checkbox or radio button. If you choose to make items in the Icon Menu checkable,
you must manually indicate the checked state by swapping the icon and/or text
each time the state changes.</p>
<p>You can define the checkable behavior for individual menu items using the <code>android:checkable</code> attribute in the <code>&lt;item&gt;</code> element, or for an entire group with
the <code>android:checkableBehavior</code> attribute in the <code>&lt;group&gt;</code> element. For
example, all items in this menu group are checkable with a radio button:</p>
<p>WHATSON? dc457312-8b3a-42e2-98dd-6d6685003495</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;group android:checkableBehavior="single"&gt;
        &lt;item android:id="@+id/red"
              android:title="@string/red" /&gt;
        &lt;item android:id="@+id/blue"
              android:title="@string/blue" /&gt;
    &lt;/group&gt;
&lt;/menu&gt;
</pre>
<p>The <code>android:checkableBehavior</code> attribute accepts either:
</p>
<p>You can apply a default checked state to an item using the <code>android:checked</code> attribute in
the <code>&lt;item&gt;</code> element and change it in code with the <code>setChecked()</code> method.</p>
<p>When a checkable item is selected, the system calls your respective item-selected callback method
(such as <code>onOptionsItemSelected()</code>). It
is here that you must set the state of the checkbox, because a checkbox or radio button does not
change its state automatically. You can query the current state of the item (as it was before the
user selected it) with <code>isChecked()</code> and then set the checked state with
<code>setChecked()</code>. For example:</p>
<p>WHATSON? ca437fc3-fd74-4d7b-ac78-5efa131abddf</p>
<pre>
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.vibrate:
        case R.id.dont_vibrate:
            if (item.isChecked()) item.setChecked(false);
            else item.setChecked(true);
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}
</pre>
<p>If you don't set the checked state this way, then the visible state of the item (the checkbox or
radio button) will not
change when the user selects it. When you do set the state, the activity preserves the checked state
of the item so that when the user opens the menu later, the checked state that you
set is visible.</p>
<p><strong>Note:</strong>
Checkable menu items are intended to be used only on a per-session basis and not saved after the
application is destroyed. If you have application settings that you would like to save for the user,
you should store the data using Shared Preferences.</p>
<h2>Adding Menu Items Based on an Intent</h2>
<p>Sometimes you'll want a menu item to launch an activity using an <code>Intent</code>
(whether it's an activity in your application or another application). When you know the intent you
want to use and have a specific menu item that should initiate the intent, you can execute the
intent with <code>startActivity()</code> during the
appropriate on-item-selected callback method (such as the <code>onOptionsItemSelected()</code> callback).</p>
<p>However, if you are not certain that the user's device
contains an application that handles the intent, then adding a menu item that invokes it can result
in a non-functioning menu item, because the intent might not resolve to an
activity. To solve this, Android lets you dynamically add menu items to your menu
when Android finds activities on the device that handle your intent.</p>
<p>To add menu items based on available activities that accept an intent:</p>
<ol>
  <li>Define an
intent with the category <code>CATEGORY_ALTERNATIVE</code> and/or
<code>CATEGORY_SELECTED_ALTERNATIVE</code>, plus any other requirements.</li>
  <li>Call <code>Menu.addIntentOptions()</code>. Android then searches for any applications that can perform the intent
and adds them to your menu.</li>
</ol>
<p>If there are no applications installed
that satisfy the intent, then no menu items are added.</p>
<p><strong>Note:</strong>
<code>CATEGORY_SELECTED_ALTERNATIVE</code> is used to handle the currently
selected element on the screen. So, it should only be used when creating a Menu in <code>onCreateContextMenu()</code>.</p>
<p>For example:</p>
<p>WHATSON? 58f04b21-41e0-4570-b7ef-70afc6100e7c</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu){
    super.onCreateOptionsMenu(menu);

    // Create an Intent that describes the requirements to fulfill, to be included
    // in our menu. The offering app must include a category value of Intent.CATEGORY_ALTERNATIVE.
    Intent intent = new Intent(null, dataUri);
    intent.addCategory(Intent.CATEGORY_ALTERNATIVE);

    // Search and populate the menu with acceptable offering applications.
    menu.addIntentOptions(
         R.id.intent_group,  // Menu group to which new items will be added
         0,      // Unique item ID (none)
         0,      // Order for the items (none)
         this.getComponentName(),   // The current activity name
         null,   // Specific items to place first (none)
         intent, // Intent created above that describes our requirements
         0,      // Additional flags to control items (none)
         null);  // Array of MenuItems that correlate to specific items (none)

    return true;
}</pre>
<p>For each activity found that provides an intent filter matching the intent defined, a menu
item is added, using the value in the intent filter's <code>android:label</code> as the
menu item title and the application icon as the menu item icon. The
<code>addIntentOptions()</code> method returns the number of menu items added.</p>
<p><strong>Note:</strong> When you call <code>addIntentOptions()</code>, it overrides any and all menu items by the menu group specified in the first
argument.</p>
<h3>Allowing your activity to be added to other menus</h3>
<p>You can also offer the services of your activity to other applications, so your
application can be included in the menu of others (reverse the roles described above).</p>
<p>To be included in other application menus, you need to define an intent
filter as usual, but be sure to include the <code>CATEGORY_ALTERNATIVE</code>
and/or <code>CATEGORY_SELECTED_ALTERNATIVE</code> values for the intent filter
category. For example:</p>
<p>WHATSON? d125d49b-9d75-4d49-99f8-480b8b6c0594</p>
<pre>
&lt;intent-filter label="@string/resize_image"&gt;
    ...
    &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
    &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>Read more about writing intent filters in the
Intents and Intent Filters document.</p>
<p>For a sample application using this technique, see the 
Note
Pad sample code.</p>
</body>
</html>