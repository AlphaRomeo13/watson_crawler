<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Interface-computing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Interface (computing)</h1>
<p>In computing, an <b>interface</b> is a shared boundary across which two separate components of a computer system exchange information. The exchange can be between software, computer hardware, peripheral devices, humans and combinations of these. Some computer hardware devices such as a touchscreen can send and receive data through the interface, while others such as a mouse, microphone or joystick are one way only.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Hardware interfaces</li>
<li>2 Software interfaces
<ul>
<li>2.1 Software interfaces in practice</li>
<li>2.2 Software interfaces in object-oriented languages</li>
<li>2.3 Programming to the interface</li>
</ul>
</li>
<li>3 See also</li>
<li>4 References</li>
</ul>
<ul>
<li>2.1 Software interfaces in practice</li>
<li>2.2 Software interfaces in object-oriented languages</li>
<li>2.3 Programming to the interface</li>
</ul>
<p></p>
<h2>Hardware interfaces</h2>
<p>Hardware interfaces exist in many of the components such as the various buses, storage devices, other I/O devices, etc. A hardware interface is described by the mechanical, electrical and logical signals at the interface and the protocol for sequencing them (sometimes called signaling). A standard interface, such as SCSI, decouples the design and introduction of computing hardware, such as I/O devices, from the design and introduction of other components of a computing system, thereby allowing users and manufacturers great flexibility in the implementation of computing systems. Hardware interfaces can be parallel with several electrical connections carrying parts of the data simultaneously, or serial where data is sent one bit at a time.</p>
<h2>Software interfaces</h2>
<p>A software interface may refer to a wide range of different types of interface at different "levels": an operating system may interface with pieces of hardware. Applications or programs running on the operating system may need to interact via streams, and in object oriented programs, objects within an application may need to interact via methods.</p>
<h3>Software interfaces in practice</h3>
<p>A key principle of design is to prohibit access to all resources by default, allowing access only through well-defined entry points, i.e. interfaces. Software interfaces provide access to computer resources (such as memory, CPU, storage, etc.) of the underlying computer system; direct access (i.e. not through well designed interfaces) to such resources by software can have major ramifications—sometimes disastrous ones—for functionality and stability.</p>
<p>Interfaces between software components can provide: constants, data types, types of procedures, exception specifications and method signatures. Sometimes, public variables are also defined as part of an interface.</p>
<p>The interface of a software module <i>A</i> is deliberately defined separately from the <i>implementation</i> of that module. The latter contains the actual code of the procedures and methods described in the interface, as well as other "private" variables, procedures, etc. Another software module <i>B</i>, for example the client to <i>A</i>, that interacts with <i>A</i> is forced to do so <i>only</i> through the published interface. One practical advantage of this arrangement is that replacing the implementation of <i>A</i> by another implementation of the same interface should not cause <i>B</i> to fail—how <i>A</i> internally meets the requirements of the interface is not relevant to <i>B</i>, which is only concerned with the specifications of the interface. (See also Liskov substitution principle.)</p>
<h3>Software interfaces in object-oriented languages</h3>
<p>In object-oriented languages, the term <i>interface</i> is often used to define an abstract type that contains no data or code, but defines behaviors as method signatures. A class having code and data for all the methods corresponding to that interface is said to <i>implement</i> that interface. Furthermore, a class can implement multiple interfaces, and hence can <i>be</i> of different types at the same time.</p>
<p>An interface is hence a type definition; anywhere an object can be exchanged (for example, in a function or method call) the <i>type</i> of the object to be exchanged can be defined in terms of its interface rather than specifying a particular class. This means that any class that implements that interface can be used. For example, a dummy implementation may be used to allow development to progress before the final implementation is available. In another case, a fake or mock implementation may be substituted during testing. Such stub implementations are replaced by real code later in the development process.</p>
<p>Usually a method defined in an interface cannot be used directly; it must be implemented by non-abstract code that will run when it is actually invoked. An interface called "<tt>Stack</tt>" might define two methods: <code>push()</code> and <code>pop()</code>. It can be implemented in different ways, for example, <tt>FastStack</tt> and <tt>GenericStack</tt>—the first being fast, working with a stack of fixed size, and the second using a data structure that can be resized, but at the cost of somewhat lower speed.</p>
<p>An interface may define only a single method; for example, the Java language defines the interface <tt>Readable</tt> that has the single <code>read()</code> method. Various implementations are used for different purposes, including <tt>BufferedReader</tt>, <tt>FileReader</tt>, <tt>InputStreamReader</tt>, <tt>PipedReader</tt>, and <tt>StringReader</tt>. Marker interfaces like Serializable contain no methods at all.</p>
<h3>Programming to the interface</h3>
<p>The use of interfaces allows a programming style called <i>programming to the interface</i>. The idea behind this is to base programming logic on the interfaces of the objects used, rather than on internal implementation details. Programming to the interface reduces dependency on implementation specifics and makes code more reusable. It gives the programmer the ability to later change the behavior of the system by simply swapping the object used with another implementing the same interface.</p>
<p>Pushing this idea to the extreme, inversion of control leaves the <i>context</i> to inject the code with the specific implementations of the interface that will be used to perform the work.</p>
<h2>See also</h2>
<ul>
<li>Abstraction inversion</li>
<li>Application binary interface</li>
<li>Application programming interface</li>
<li>Business Interoperability Interface</li>
<li>Computer bus</li>
<li>Implementation (computer science)</li>
<li>Implementation inheritance</li>
<li>Inheritance semantics</li>
<li>Modular programming</li>
<li>Software componentry</li>
<li>User interface</li>
<li>Virtual inheritance</li>
</ul>
</body>
</html>