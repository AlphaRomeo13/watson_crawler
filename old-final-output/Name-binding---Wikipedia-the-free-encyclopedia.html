<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Name-binding---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Name binding</h1>
<p>In programming languages, <b>name binding</b> is the association of entities (data and/or code) with identifiers. An identifier bound to an object is said to reference that object. Machine languages have no built-in notion of identifiers, but name-object bindings as a service and notation for the programmer is implemented by programming languages. Binding is intimately connected with scoping, as scope determines which names bind to which objects – at which locations in the program code (lexically) and in which one of the possible execution paths (temporally).</p>
<p>Use of an identifier <code>id</code> in a context that establishes a binding for <code>id</code> is called a binding (or defining) occurrence. In all other occurrences (e.g., in expressions, assignments, and subprogram calls), an identifier stands for what it is bound to; such occurrences are called applied occurrences.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Binding time</li>
<li>2 Rebinding and mutation</li>
<li>3 Late static</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<p></p>
<h2>Binding time</h2>
<p>The binding of names before the program is run is called <b>static</b> (also "early"); bindings performed as the program runs are dynamic (also "late" or "virtual").</p>
<p>An example of a static binding is a direct C function call: the function referenced by the identifier cannot change at runtime.</p>
<p>But an example of dynamic binding is dynamic dispatch, as in a C++ virtual method call. Since the specific type of a polymorphic object is not known before runtime (in general), the executed function is dynamically bound. Take, for example, the following Java code:</p>
<p>WHATSON? a36ed823-e5aa-4034-92e1-ddaeb9452add</p>
<pre>
 public void foo(java.util.List&lt;String&gt; list) {
     list.add("bar");
 }
</pre>
<p><code>List</code> is an interface, so <code>list</code> must refer to a subtype of it. Is it a reference to a <code>LinkedList</code>, an <code>ArrayList</code>, or some other subtype of <code>List</code>? The actual method referenced by <code>add</code> is not known until runtime. In a language like C, the actual function <i>is</i> known.</p>
<h2>Rebinding and mutation</h2>
<p>Rebinding should not be confused with mutation – "rebinding" is a change to the <i>referencing</i> identifier; "mutation" is a change to the <i>referenced</i> value. Consider the following Java code:</p>
<p>WHATSON? 762fbe65-6c0a-409c-bdc5-12dd38e24580</p>
<pre>
 LinkedList&lt;String&gt; list;
 list = new LinkedList&lt;String&gt;();
 list.add("foo");
 list = null;
</pre>
<p>The identifier <code>list</code> initially references nothing (it is uninitialized); it is then rebound to reference an object (a linked list of strings). The linked list referenced by <code>list</code> is then mutated, adding a string to the list. Lastly, <code>list</code> is rebound to <code>null</code>.</p>
<h2>Late static</h2>
<p>Late static binding is a variant of binding somewhere between static and dynamic binding. Consider the following PHP example:</p>
<p>WHATSON? c0cce4eb-12f8-4e2f-b73b-b1af87650155</p>
<pre>
class A {
    static $word = "hello";
    static function hello() {print self::$word;}
}
 
class B extends A {
    static $word = "bye";
}
 
B::hello();
</pre>
<p>In this example, the PHP interpreter binds the function <code>hello()</code> to class <code>A</code>, and so the call to <code>B::hello()</code> produces the string "hello". If the semantics of <code>self::$word</code> had been based on late static binding, then the result would have been "bye".</p>
<p>Beginning with PHP version 5.3, late static binding is supported. Specifically, if <code>self::$word</code> in the above were changed to <code>static::$word</code> as shown in the following block, then the result of the call to <code>B::hello()</code> would be "bye":</p>
<p>WHATSON? c79bd684-7234-471d-9bf5-44fb4822391c</p>
<pre>
class A {
    static $word = "hello";
    static function hello() {print static::$word;}
}
 
class B extends A {
    static $word = "bye";
}
 
B::hello();
</pre>
<h2>See also</h2>
<ul>
<li>Late binding</li>
<li>Branch table method of applying name binding via branch table or function pointers</li>
<li>Dynamic dispatch</li>
<li>Higher-order abstract syntax (HOAS)</li>
</ul>
</body>
</html>