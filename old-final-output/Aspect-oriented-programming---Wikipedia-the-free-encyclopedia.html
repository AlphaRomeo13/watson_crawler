<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Aspect-oriented-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Aspect-oriented programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computing, <b>aspect-oriented programming</b> (<b>AOP</b>) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. AOP forms a basis for aspect-oriented software development.</p>
<p>AOP includes programming methods and tools that support the modularization of concerns at the level of the source code, while "aspect-oriented software development" refers to a whole engineering discipline.</p>
<p>Aspect-oriented programming entails breaking down program logic into distinct parts (so-called <i>concerns</i>, cohesive areas of functionality). Nearly all programming paradigms support some level of grouping and encapsulation of concerns into separate, independent entities by providing abstractions (e.g., functions, procedures, modules, classes, methods) that can be used for implementing, abstracting and composing these concerns. But some concerns defy these forms of implementation and are called <i>crosscutting concerns</i> because they "cut across" multiple abstractions in a program.</p>
<p>Logging exemplifies a crosscutting concern because a logging strategy necessarily affects every logged part of the system. Logging thereby <i>crosscuts</i> all logged classes and methods.</p>
<p>All AOP implementations have some crosscutting expressions that encapsulate each concern in one place. The difference between implementations lies in the power, safety, and usability of the constructs provided. For example, interceptors that specify the methods to intercept express a limited form of crosscutting, without much support for type-safety or debugging. AspectJ has a number of such expressions and encapsulates them in a special class, an aspect. For example, an aspect can alter the behavior of the base code (the non-aspect part of a program) by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). An aspect can also make binary-compatible structural changes to other classes, like adding members or parents.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Motivation and basic concepts</li>
<li>3 Join point models
<ul>
<li>3.1 AspectJ's join-point model</li>
<li>3.2 Other potential join point models</li>
<li>3.3 Inter-type declarations</li>
</ul>
</li>
<li>4 Implementation
<ul>
<li>4.1 Terminology</li>
</ul>
</li>
<li>5 Comparison to other programming paradigms</li>
<li>6 Adoption issues</li>
<li>7 Implementations</li>
<li>8 See also</li>
<li>9 Notes and references</li>
<li>10 Further reading</li>
<li>11 External links</li>
</ul>
<ul>
<li>3.1 AspectJ's join-point model</li>
<li>3.2 Other potential join point models</li>
<li>3.3 Inter-type declarations</li>
</ul>
<ul>
<li>4.1 Terminology</li>
</ul>
<p></p>
<h2>History</h2>
<p>AOP has several direct antecedents A1 and A2: reflection and metaobject protocols, subject-oriented programming, Composition Filters and Adaptive Programming.</p>
<p>Gregor Kiczales and colleagues at Xerox PARC developed the explicit concept of AOP, and followed this with the AspectJ AOP extension to Java. IBM's research team pursued a tool approach over a language design approach and in 2001 proposed Hyper/J and the Concern Manipulation Environment, which have not seen wide usage. EmacsLisp changelog added AOP related code in version 19.28. The examples in this article use AspectJ as it is the most widely known AOP language.</p>
<p>The Microsoft Transaction Server is considered to be the first major application of AOP followed by Enterprise JavaBean.</p>
<h2>Motivation and basic concepts</h2>
<p>Typically, an aspect is <i>scattered</i> or <i>tangled</i> as code, making it harder to understand and maintain. It is scattered by virtue of the function (such as logging) being spread over a number of unrelated functions that might use <i>its</i> function, possibly in entirely unrelated systems, different source languages, etc. That means to change logging can require modifying all affected modules. Aspects become tangled not only with the mainline function of the systems in which they are expressed but also with each other. That means changing one concern entails understanding all the tangled concerns or having some means by which the effect of changes can be inferred.</p>
<p>For example, consider a banking application with a conceptually very simple method for transferring an amount from one account to another:</p>
<p>WHATSON? a9273f43-76f8-4f21-adf3-16ede51c10e5</p>
<pre>
void transfer(Account fromAcc, Account toAcc, int amount) throws Exception {
  if (fromAcc.getBalance() &lt; amount)
      throw new InsufficientFundsException();
 
  fromAcc.withdraw(amount);
  toAcc.deposit(amount);
}
</pre>
<p>However, this transfer method overlooks certain considerations that a deployed application would require: it lacks security checks to verify that the current user has the authorization to perform this operation; a database transaction should encapsulate the operation in order to prevent accidental data loss; for diagnostics, the operation should be logged to the system log, etc.</p>
<p>A version with all those new concerns, for the sake of example, could look somewhat like this:</p>
<p>WHATSON? c019036c-c4e0-4dc1-a036-3a81d9e4bd34</p>
<pre>
void transfer(Account fromAcc, Account toAcc, int amount, User user,
    Logger logger) throws Exception {
  logger.info("Transferring moneyâ€¦");
 
  if (!isUserAuthorised(user, fromAcc)) {
    logger.info("User has no permission.");
    throw new UnauthorisedUserException();
  }
 
  if (fromAcc.getBalance() &lt; amount) {
    logger.info("Insufficient funds.");
    throw new InsufficientFundsException();
  }
 
  fromAcc.withdraw(amount);
  toAcc.deposit(amount);
 
  database.commitChanges();  // Atomic operation.
 
  logger.info("Transaction successful.");
}
</pre>
<p>In this example other interests have become <i>tangled</i> with the basic functionality (sometimes called the <i>business logic concern</i>). Transactions, security, and logging all exemplify <i>cross-cutting concerns</i>.</p>
<p>Now consider what happens if we suddenly need to change (for example) the security considerations for the application. In the program's current version, security-related operations appear <i>scattered</i> across numerous methods, and such a change would require a major effort.</p>
<p>AOP attempts to solve this problem by allowing the programmer to express cross-cutting concerns in stand-alone modules called <i>aspects</i>. Aspects can contain <i>advice</i> (code joined to specified points in the program) and <i>inter-type declarations</i> (structural members added to other classes). For example, a security module can include advice that performs a security check before accessing a bank account. The pointcut defines the times (join points) when one can access a bank account, and the code in the advice body defines how the security check is implemented. That way, both the check and the places can be maintained in one place. Further, a good pointcut can anticipate later program changes, so if another developer creates a new method to access the bank account, the advice will apply to the new method when it executes.</p>
<p>So for the above example implementing logging in an aspect:</p>
<p>WHATSON? f9b3f3da-a23a-4f3b-a9e1-16fc7c41ec2a</p>
<pre>
aspect Logger {
  void Bank.transfer(Account fromAcc, Account toAcc, int amount, User user, Logger logger)  {
    logger.info("Transferring moneyâ€¦");
  }
 
  void Bank.getMoneyBack(User user, int transactionId, Logger logger)  {
    logger.info("User requested money back.");
  }
 
  // Other crosscutting code.
}
</pre>
<p>One can think of AOP as a debugging tool or as a user-level tool. Advice should be reserved for the cases where you cannot get the function changed (user level) or do not want to change the function in production code (debugging).</p>
<h2>Join point models</h2>
<p>The advice-related component of an aspect-oriented language defines a join point model (JPM). A JPM defines three things:</p>
<ol>
<li>When the advice can run. These are called <i>join points</i> because they are points in a running program where additional behavior can be usefully joined. A join point needs to be addressable and understandable by an ordinary programmer to be useful. It should also be stable across inconsequential program changes in order for an aspect to be stable across such changes. Many AOP implementations support method executions and field references as join points.</li>
<li>A way to specify (or <i>quantify</i>) join points, called <i>pointcuts</i>. Pointcuts determine whether a given join point matches. Most useful pointcut languages use a syntax like the base language (for example, AspectJ uses Java signatures) and allow reuse through naming and combination.</li>
<li>A means of specifying code to run at a join point. AspectJ calls this <i>advice</i>, and can run it before, after, and around join points. Some implementations also support things like defining a method in an aspect on another class.</li>
</ol>
<p>Join-point models can be compared based on the join points exposed, how join points are specified, the operations permitted at the join points, and the structural enhancements that can be expressed.</p>
<h3>AspectJ's join-point model</h3>
<ul>
<li>The join points in AspectJ include method or constructor call or execution, the initialization of a class or object, field read and write access, exception handlers, etc. They do not include loops, super calls, throws clauses, multiple statements, etc.</li>
</ul>
<ul>
<li>Pointcuts are specified by combinations of <i>primitive pointcut designators</i> (PCDs).</li>
</ul>
<p>WHATSON? 76c46bca-cbc3-4828-8810-f4185d144948</p>
<pre>
 execution(* set*(*))
</pre>
<p>"Dynamic" PCDs check runtime types and bind variables. For example</p>
<p>WHATSON? dfd403cf-a194-4cff-8a08-f32c6f78b8d8</p>
<pre>
  this(Point)
</pre>
<p>"Scope" PCDs limit the lexical scope of the join point. For example:</p>
<p>WHATSON? 671259a1-bda6-47cc-922b-bd88d1281af1</p>
<pre>
 within(com.company.*)
</pre>
<p>Pointcuts can be composed and named for reuse. For example</p>
<p>WHATSON? e233580b-2839-423e-9e48-466925cba325</p>
<pre>
pointcut set() : execution(* set*(*) ) &amp;&amp; this(Point) &amp;&amp; within(com.company.*);
</pre>
<ul>
<li>Advice specifies to run at (before, after, or around) a join point (specified with a pointcut) certain code (specified like code in a method). The AOP runtime invokes Advice automatically when the pointcut matches the join point. For example:</li>
</ul>
<p>WHATSON? fb56759b-aca7-41c6-a3d7-57909bcda872</p>
<pre>
after() : set() {
   Display.update();
}
</pre>
<h3>Other potential join point models</h3>
<p>There are other kinds of JPMs. All advice languages can be defined in terms of their JPM. For example, a hypothetical aspect language for UML may have the following JPM:</p>
<ul>
<li>Join points are all model elements.</li>
<li>Pointcuts are some boolean expression combining the model elements.</li>
<li>The means of affect at these points are a visualization of all the matched join points.</li>
</ul>
<h3>Inter-type declarations</h3>
<p><i>Inter-type declarations</i> provide a way to express crosscutting concerns affecting the structure of modules. Also known as <i>open classes</i>, this enables programmers to declare in one place members or parents of another class, typically in order to combine all the code related to a concern in one aspect. For example, if a programmer implemented the crosscutting display-update concern using visitors instead, an inter-type declaration using the visitor pattern might look like this in AspectJ:</p>
<p>WHATSON? 7a8632dd-2db8-4fd6-83fe-65644b7e027c</p>
<pre>
  aspect DisplayUpdate {
    void Point.acceptVisitor(Visitor v) {
      v.visit(this);
    }
    // other crosscutting code...
  }
</pre>
<p>This code snippet adds the <code>acceptVisitor</code> method to the <code>Point</code> class.</p>
<p>It is a requirement that any structural additions be compatible with the original class, so that clients of the existing class continue to operate, unless the AOP implementation can expect to control all clients at all times.</p>
<h2>Implementation</h2>
<p>AOP programs can affect other programs in two different ways, depending on the underlying languages and environments:</p>
<ol>
<li>a combined program is produced, valid in the original language and indistinguishable from an ordinary program to the ultimate interpreter</li>
<li>the ultimate interpreter or environment is updated to understand and implement AOP features.</li>
</ol>
<p>The difficulty of changing environments means most implementations produce compatible combination programs through a process known as <i>weaving</i> - a special case of program transformation. An aspect weaver reads the aspect-oriented code and generates appropriate object-oriented code with the aspects integrated. The same AOP language can be implemented through a variety of weaving methods, so the semantics of a language should never be understood in terms of the weaving implementation. Only the speed of an implementation and its ease of deployment are affected by which method of combination is used.</p>
<p>Systems can implement source-level weaving using preprocessors (as C++ was implemented originally in CFront) that require access to program source files. However, Java's well-defined binary form enables bytecode weavers to work with any Java program in .class-file form. Bytecode weavers can be deployed during the build process or, if the weave model is per-class, during class loading. AspectJ started with source-level weaving in 2001, delivered a per-class bytecode weaver in 2002, and offered advanced load-time support after the integration of AspectWerkz in 2005.</p>
<p>Any solution that combines programs at runtime has to provide views that segregate them properly to maintain the programmer's segregated model. Java's bytecode support for multiple source files enables any debugger to step through a properly woven .class file in a source editor. However, some third-party decompilers cannot process woven code because they expect code produced by Javac rather than all supported bytecode forms (see also "Problems", below).</p>
<p>Deploy-time weaving offers another approach. This basically implies post-processing, but rather than patching the generated code, this weaving approach <i>subclasses</i> existing classes so that the modifications are introduced by method-overriding. The existing classes remain untouched, even at runtime, and all existing tools (debuggers, profilers, etc.) can be used during development. A similar approach has already proven itself in the implementation of many Java EE application servers, such as IBM's WebSphere.</p>
<h3>Terminology</h3>
<p>Standard terminology used in Aspect-oriented programming may include:</p>
<h2>Comparison to other programming paradigms</h2>
<p>Aspects emerged from object-oriented programming and computational reflection. AOP languages have functionality similar to, but more restricted than metaobject protocols. Aspects relate closely to programming concepts like subjects, mixins, and delegation. Other ways to use aspect-oriented programming paradigms include Composition Filters and the hyperslices approach. Since at least the 1970s, developers have been using forms of interception and dispatch-patching that resemble some of the implementation methods for AOP, but these never had the semantics that the crosscutting specifications provide written in one place.</p>
<p>Designers have considered alternative ways to achieve separation of code, such as C#'s partial types, but such approaches lack a quantification mechanism that allows reaching several join points of the code with one declarative statement.</p>
<p>Though it may seem unrelated, in testing, the use of mocks or stubs requires the use of AOP techniques, like around advice, and so forth. Here the collaborating objects are for the purpose of the test, a cross cutting concern. Thus the various Mock Object frameworks provide these features. For example, a process invokes a service to get a balance amount. In the test of the process, where the amount comes from is unimportant, only that the process uses the balance according to the requirements.</p>
<h2>Adoption issues</h2>
<p>Programmers need to be able to read code and understand what is happening in order to prevent errors. Even with proper education, understanding crosscutting concerns can be difficult without proper support for visualizing both static structure and the dynamic flow of a program. Beginning in 2002, AspectJ began to provide IDE plug-ins to support the visualizing of crosscutting concerns. Those features, as well as aspect code assist and refactoring are now common.</p>
<p>Given the power of AOP, if a programmer makes a logical mistake in expressing crosscutting, it can lead to widespread program failure. Conversely, another programmer may change the join points in a program â€“ e.g., by renaming or moving methods â€“ in ways that the aspect writer did not anticipate, with unforeseen consequences. One advantage of modularizing crosscutting concerns is enabling one programmer to affect the entire system easily; as a result, such problems present as a conflict over responsibility between two or more developers for a given failure. However, the solution for these problems can be much easier in the presence of AOP, since only the aspect needs to be changed, whereas the corresponding problems without AOP can be much more spread out.</p>
<h2>Implementations</h2>
<p>The following programming languages have implemented AOP, within the language, or as an external library:</p>
<ul>
<li>.NET Framework languages (C# / VB.NET)
<ul>
<li>Unity, It provides an API to facilitate proven practices in core areas of programming including data access, security, logging, exception handling and others.</li>
</ul>
</li>
<li>ActionScript</li>
<li>Ada</li>
<li>AutoHotkey</li>
<li>C / C++</li>
<li>COBOL</li>
<li>The Cocoa Objective-C frameworks</li>
<li>ColdFusion</li>
<li>Common Lisp</li>
<li>Delphi</li>
<li>Delphi Prism</li>
<li>e (IEEE 1647)</li>
<li>Emacs Lisp</li>
<li>Groovy</li>
<li>Haskell</li>
<li>Java
<ul>
<li>AspectJ</li>
</ul>
</li>
<li>JavaScript</li>
<li>Logtalk</li>
<li>Lua</li>
<li>make</li>
<li>Matlab</li>
<li>ML</li>
<li>Perl</li>
<li>PHP</li>
<li>Prolog</li>
<li>Python</li>
<li>Racket</li>
<li>Ruby</li>
<li>Squeak Smalltalk</li>
<li>UML 2.0</li>
<li>XML</li>
</ul>
<ul>
<li>Unity, It provides an API to facilitate proven practices in core areas of programming including data access, security, logging, exception handling and others.</li>
</ul>
<ul>
<li>AspectJ</li>
</ul>
<h2>See also</h2>
<ul>
<li>Aspect-oriented software development</li>
<li>Distributed AOP</li>
<li>Attribute grammar, a formalism that can be used for aspect-oriented programming on top of functional programming languages</li>
<li>Programming paradigms</li>
<li>Subject-oriented programming, an alternative to Aspect-oriented programming</li>
<li>Role-oriented programming, an alternative to Aspect-oriented programming</li>
<li>Predicate dispatch, an older alternative to Aspect-oriented programming</li>
<li>Executable UML</li>
<li>COMEFROM: Some elements of aspect-oriented programming have been compared to the joke COMEFROM statement.</li>
</ul>
<ul>
<li>Decorator pattern</li>
<li>Domain-driven design</li>
</ul>
<h2>Notes and references</h2>
<ol>
<li><b>^</b> Kiczales, G.; Lamping, J.; Mendhekar, A.; Maeda, C.; Lopes, C.; Loingtier, J. M.; Irwin, J. (1997). "Aspect-oriented programming". ECOOP'97. <i>Proceedings of the 11th European Conference on Object-Oriented Programming</i>. LNCS <b>1241</b>: 220â€“242. doi:10.1007/BFb0053381. ISBNÂ 3-540-63089-9. CiteSeerX: 10.1.1.115.8660.Â  edit</li>
<li><b>^</b> "Adaptive Object Oriented Programming: The Demeter Approach with Propagation Patterns" <i>Karl Liebherr</i> 1996 ISBN 0-534-94602-X presents a well-worked version of essentially the same thing (Lieberherr subsequently recognized this and reframed his approach).</li>
<li><b>^</b> Don Box; Chris Sells (4 November 2002). <i>Essential.NET: The common language runtime</i>. Addison-Wesley Professional. p.Â 206. ISBNÂ 978-0-201-73411-9. Retrieved 4 October 2011.Â </li>
<li><b>^</b> Roman, Ed; Sriganesh, Rima Patel; Brose, Gerald (1 January 2005). <i>Mastering Enterprise JavaBeans</i>. John Wiley and Sons. p.Â 285. ISBNÂ 978-0-7645-8492-3. Retrieved 4 October 2011.Â </li>
<li><b>^</b> Note: The examples in this article appear in a syntax that resembles that of the Java language.</li>
<li><b>^</b> Emacs documentation</li>
<li><b>^</b> http://www.forum2.org/tal/AspectJ2EE.pdf</li>
<li><b>^</b> Edsger Dijkstra, <i>Notes on Structured Programming</i>, pg. 1-2</li>
<li><b>^</b> <i>AOP Considered Harmful</i></li>
<li><b>^</b> Numerous: Afterthought, LOOM.NET, Enterprise Library 3.0 Policy Injection Application Block, AspectDNG, Aspect#, Compose*, PostSharp, Seasar.NET, DotSpect (.SPECT), Spring.NET (as part of its functionality), Wicca and Phx.Morph, SetPoint</li>
<li><b>^</b> as3-commons-bytecode</li>
<li><b>^</b> Ada2012 Rationale</li>
<li><b>^</b> Function Hooks</li>
<li><b>^</b> Several: AspectC++, FeatureC++, AspectC, AspeCt-oriented C, Aspicere</li>
<li><b>^</b> Cobble</li>
<li><b>^</b> AspectCocoa</li>
<li><b>^</b> ColdSpring</li>
<li><b>^</b> AspectL</li>
<li><b>^</b> InfraAspect</li>
<li><b>^</b> MeAOP in MeSDK</li>
<li><b>^</b> DSharp</li>
<li><b>^</b> RemObjects Cirrus</li>
<li><b>^</b> Emacs Advice Functions</li>
<li><b>^</b> monad (functional programming) ("Monads As a theoretical basis for AOP". CiteSeerX: 10.1.1.25.8262.Â ) and Aspect-oriented programming with type classes. A Typed Monadic Embedding of Aspects</li>
<li><b>^</b> Numerous others: CaesarJ, Compose*, Dynaop, JAC, Google Guice (as part of its functionality), Javassist, JAsCo (and AWED), JAML, JBoss AOP, LogicAJ, Object Teams, PROSE, The AspectBench Compiler for AspectJ (abc), Spring framework (as part of its functionality), Seasar, The JMangler Project, InjectJ, GluonJ, Steamloom</li>
<li><b>^</b> Many: Advisable, Ajaxpect, jQuery AOP Plugin, Aspectes, AspectJS, Cerny.js, Dojo Toolkit, Humax Web Framework, Joose, Prototype - Prototype Function#wrap, YUI 3 (Y.Do)</li>
<li><b>^</b> Using built-in support for categories (which allows the encapsulation of aspect code) and event-driven programming (which allows the definition of <i>before</i> and after <i>event</i> handlers).</li>
<li><b>^</b> AspectLua</li>
<li><b>^</b> MAKAO</li>
<li><b>^</b> [1]</li>
<li><b>^</b> AspectML</li>
<li><b>^</b> The Aspect Module</li>
<li><b>^</b> Several: PHP-AOP (AOP.io), Go! AOP framework, PHPaspect, Seasar.PHP, PHP-AOP, TYPO3 Flow, AOP PECL Extension</li>
<li><b>^</b> "Whirl"</li>
<li><b>^</b> Several: PEAK, Aspyct AOP, Lightweight Python AOP, Logilab's aspect module, Pythius, Spring Python's AOP module, Pytilities' AOP module, aspectlib</li>
<li><b>^</b> AspectScheme</li>
<li><b>^</b> AspectR</li>
<li><b>^</b> AspectR-Fork</li>
<li><b>^</b> Aquarium</li>
<li><b>^</b> Aspector</li>
<li><b>^</b> AspectS</li>
<li><b>^</b> MetaclassTalk</li>
<li><b>^</b> WEAVR</li>
<li><b>^</b> AspectXML</li>
<li><b>^</b> C2:ComeFrom</li>
</ol>
<h2>Further reading</h2>
<ul>
<li>Kiczales, G.; Lamping, J.; Mendhekar, A.; Maeda, C.; Lopes, C.; Loingtier, J. M.; Irwin, J. (1997). "Aspect-oriented programming". ECOOP'97. <i>Proceedings of the 11th European Conference on Object-Oriented Programming</i>. LNCS <b>1241</b>: 220â€“242. doi:10.1007/BFb0053381. ISBNÂ 3-540-63089-9. CiteSeerX: 10.1.1.115.8660.Â  edit The paper generally considered to be the authoritative reference for AOP.</li>
<li>Holzinger, Andreas; M. Brugger, W. Slany (2011). <i>Applying Aspect Oriented Programming (AOP) in Usability Engineering processes: On the example of Tracking Usage Information for Remote Usability Testing. In: Marca, D. A., Shishkov, B. &amp; Sinderen, M. v. (Eds.) Proceedings of the 8th International Conference on electronic Business and Telecommunications. Sevilla, 53-56</i>.Â  Cite uses deprecated parameters (help)</li>
<li>Filman, Robert E.; Tzilla Elrad, SiobhÃ¡n Clarke, and Mehmet Aksit (2004). <i>Aspect-Oriented Software Development</i>. ISBNÂ 0-321-21976-7.Â  Cite uses deprecated parameters (help)</li>
<li>Pawlak, Renaud; Lionel Seinturier, and Jean-Philippe RetaillÃ© (2005). <i>Foundations of AOP for J2EE Development</i>. ISBNÂ 1-59059-507-6.Â  Cite uses deprecated parameters (help)</li>
<li>Laddad, Ramnivas (2003). <i>AspectJ in Action: Practical Aspect-Oriented Programming</i>. ISBNÂ 1-930110-93-6.Â </li>
<li>Jacobson, Ivar; Pan-Wei Ng (2005). <i>Aspect-Oriented Software Development with Use Cases</i>. ISBNÂ 0-321-26888-1.Â </li>
<li>Aspect-oriented Software Development and PHP, Dmitry Sheiko, 2006</li>
<li>Clarke, SiobhÃ¡n; Elisa Baniassad (2005). <i>Aspect-Oriented Analysis and Design: The Theme Approach</i>. ISBNÂ 0-321-24674-8.Â </li>
<li>Yedduladoddi, Raghu (2009). <i>Aspect Oriented Software Development: An Approach to Composing UML Design Models</i>. ISBNÂ 3-639-12084-1.Â </li>
<li>"Adaptive Object-Oriented Programming Using Graph-Based Customization" â€“ Lieberherr, Silva-Lepe, et al. - 1994</li>
<li>Zambrano Polo y La Borda, Arturo Federico (June 5, 2013). "Addressing aspect interactions in an industrial setting: experiences, problems and solutions". p.Â 159. Retrieved 30 May 2014.Â </li>
</ul>
<h2>External links</h2>
<ul>
<li>Eric Bodden's list of AOP tools in .net framework</li>
<li>Programming Styles: Procedural, OOP, and AOP</li>
<li>Programming Forum: Procedural, OOP, and AOP</li>
<li>Aspect-Oriented Software Development, annual conference on AOP</li>
<li>AOSD Wiki, Wiki on aspect-oriented software development</li>
<li>AspectJ Programming Guide</li>
<li>The AspectBench Compiler for AspectJ, another Java implementation</li>
<li>Series of IBM developerWorks articles on AOP</li>
<li>A detailed series of articles on basics of aspect-oriented programming and AspectJ</li>
<li>What is Aspect-Oriented Programming?, introduction with RemObjects Taco</li>
<li>Constraint-Specification Aspect Weaver</li>
<li>Aspect- vs. Object-Oriented Programming: Which Technique, When?</li>
<li>Gregor Kiczales, Professor of Computer Science, explaining AOP, video 57 min.</li>
<li>Aspect Oriented Programming in COBOL</li>
<li>Aspect-Oriented Programming in Java with Spring Framework</li>
<li>Wiki dedicated to AOP methods on.NET</li>
<li>Early Aspects for Business Process Modeling (An Aspect Oriented Language for BPMN)</li>
<li>Spring AOP and AspectJ Introduction</li>
<li>AOSD Graduate Course at Bilkent University</li>
<li>Introduction to AOP - Software Engineering Radio Podcast Episode 106</li>
<li>An Objective-C implementation of AOP by Szilveszter Molnar</li>
<li>Apect-Oriented programming for iOS and OS X by Manuel Gebele</li>
<li>DevExpress MVVM Framework. Introduction to POCO ViewModels</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>Advice</li>
<li>Aspect</li>
<li><strong class="selflink">Aspect-oriented programming</strong></li>
<li>Aspect weaver</li>
<li>Cross-cutting concerns</li>
<li>Join point</li>
<li>Pointcut</li>
</ul>
<ul>
<li>AspectC++</li>
<li>AspectJ</li>
<li>AspectWerkz</li>
</ul>
<h1>Aspect-oriented programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li><strong class="selflink">Aspect-oriented</strong></li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computing, <b>aspect-oriented programming</b> (<b>AOP</b>) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. AOP forms a basis for aspect-oriented software development.</p>
<p>AOP includes programming methods and tools that support the modularization of concerns at the level of the source code, while "aspect-oriented software development" refers to a whole engineering discipline.</p>
<p>Aspect-oriented programming entails breaking down program logic into distinct parts (so-called <i>concerns</i>, cohesive areas of functionality). Nearly all programming paradigms support some level of grouping and encapsulation of concerns into separate, independent entities by providing abstractions (e.g., functions, procedures, modules, classes, methods) that can be used for implementing, abstracting and composing these concerns. But some concerns defy these forms of implementation and are called <i>crosscutting concerns</i> because they "cut across" multiple abstractions in a program.</p>
<p>Logging exemplifies a crosscutting concern because a logging strategy necessarily affects every logged part of the system. Logging thereby <i>crosscuts</i> all logged classes and methods.</p>
<p>All AOP implementations have some crosscutting expressions that encapsulate each concern in one place. The difference between implementations lies in the power, safety, and usability of the constructs provided. For example, interceptors that specify the methods to intercept express a limited form of crosscutting, without much support for type-safety or debugging. AspectJ has a number of such expressions and encapsulates them in a special class, an aspect. For example, an aspect can alter the behavior of the base code (the non-aspect part of a program) by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). An aspect can also make binary-compatible structural changes to other classes, like adding members or parents.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Motivation and basic concepts</li>
<li>3 Join point models
<ul>
<li>3.1 AspectJ's join-point model</li>
<li>3.2 Other potential join point models</li>
<li>3.3 Inter-type declarations</li>
</ul>
</li>
<li>4 Implementation
<ul>
<li>4.1 Terminology</li>
</ul>
</li>
<li>5 Comparison to other programming paradigms</li>
<li>6 Adoption issues</li>
<li>7 Implementations</li>
<li>8 See also</li>
<li>9 Notes and references</li>
<li>10 Further reading</li>
<li>11 External links</li>
</ul>
<ul>
<li>3.1 AspectJ's join-point model</li>
<li>3.2 Other potential join point models</li>
<li>3.3 Inter-type declarations</li>
</ul>
<ul>
<li>4.1 Terminology</li>
</ul>
<p></p>
<h2>History</h2>
<p>AOP has several direct antecedents A1 and A2: reflection and metaobject protocols, subject-oriented programming, Composition Filters and Adaptive Programming.</p>
<p>Gregor Kiczales and colleagues at Xerox PARC developed the explicit concept of AOP, and followed this with the AspectJ AOP extension to Java. IBM's research team pursued a tool approach over a language design approach and in 2001 proposed Hyper/J and the Concern Manipulation Environment, which have not seen wide usage. EmacsLisp changelog added AOP related code in version 19.28. The examples in this article use AspectJ as it is the most widely known AOP language.</p>
<p>The Microsoft Transaction Server is considered to be the first major application of AOP followed by Enterprise JavaBean.</p>
<h2>Motivation and basic concepts</h2>
<p>Typically, an aspect is <i>scattered</i> or <i>tangled</i> as code, making it harder to understand and maintain. It is scattered by virtue of the function (such as logging) being spread over a number of unrelated functions that might use <i>its</i> function, possibly in entirely unrelated systems, different source languages, etc. That means to change logging can require modifying all affected modules. Aspects become tangled not only with the mainline function of the systems in which they are expressed but also with each other. That means changing one concern entails understanding all the tangled concerns or having some means by which the effect of changes can be inferred.</p>
<p>For example, consider a banking application with a conceptually very simple method for transferring an amount from one account to another:</p>
<p>WHATSON? 2e467a65-d0c5-418c-af03-32fd0c3f963f</p>
<pre>
void transfer(Account fromAcc, Account toAcc, int amount) throws Exception {
  if (fromAcc.getBalance() &lt; amount)
      throw new InsufficientFundsException();
 
  fromAcc.withdraw(amount);
  toAcc.deposit(amount);
}
</pre>
<p>However, this transfer method overlooks certain considerations that a deployed application would require: it lacks security checks to verify that the current user has the authorization to perform this operation; a database transaction should encapsulate the operation in order to prevent accidental data loss; for diagnostics, the operation should be logged to the system log, etc.</p>
<p>A version with all those new concerns, for the sake of example, could look somewhat like this:</p>
<p>WHATSON? c31f9a34-402a-45dc-b8d8-51c545aa50aa</p>
<pre>
void transfer(Account fromAcc, Account toAcc, int amount, User user,
    Logger logger) throws Exception {
  logger.info("Transferring moneyâ€¦");
 
  if (!isUserAuthorised(user, fromAcc)) {
    logger.info("User has no permission.");
    throw new UnauthorisedUserException();
  }
 
  if (fromAcc.getBalance() &lt; amount) {
    logger.info("Insufficient funds.");
    throw new InsufficientFundsException();
  }
 
  fromAcc.withdraw(amount);
  toAcc.deposit(amount);
 
  database.commitChanges();  // Atomic operation.
 
  logger.info("Transaction successful.");
}
</pre>
<p>In this example other interests have become <i>tangled</i> with the basic functionality (sometimes called the <i>business logic concern</i>). Transactions, security, and logging all exemplify <i>cross-cutting concerns</i>.</p>
<p>Now consider what happens if we suddenly need to change (for example) the security considerations for the application. In the program's current version, security-related operations appear <i>scattered</i> across numerous methods, and such a change would require a major effort.</p>
<p>AOP attempts to solve this problem by allowing the programmer to express cross-cutting concerns in stand-alone modules called <i>aspects</i>. Aspects can contain <i>advice</i> (code joined to specified points in the program) and <i>inter-type declarations</i> (structural members added to other classes). For example, a security module can include advice that performs a security check before accessing a bank account. The pointcut defines the times (join points) when one can access a bank account, and the code in the advice body defines how the security check is implemented. That way, both the check and the places can be maintained in one place. Further, a good pointcut can anticipate later program changes, so if another developer creates a new method to access the bank account, the advice will apply to the new method when it executes.</p>
<p>So for the above example implementing logging in an aspect:</p>
<p>WHATSON? 17a12e5c-f6de-473a-8d9b-0fdd01806a8e</p>
<pre>
aspect Logger {
  void Bank.transfer(Account fromAcc, Account toAcc, int amount, User user, Logger logger)  {
    logger.info("Transferring moneyâ€¦");
  }
 
  void Bank.getMoneyBack(User user, int transactionId, Logger logger)  {
    logger.info("User requested money back.");
  }
 
  // Other crosscutting code.
}
</pre>
<p>One can think of AOP as a debugging tool or as a user-level tool. Advice should be reserved for the cases where you cannot get the function changed (user level) or do not want to change the function in production code (debugging).</p>
<h2>Join point models</h2>
<p>The advice-related component of an aspect-oriented language defines a join point model (JPM). A JPM defines three things:</p>
<ol>
<li>When the advice can run. These are called <i>join points</i> because they are points in a running program where additional behavior can be usefully joined. A join point needs to be addressable and understandable by an ordinary programmer to be useful. It should also be stable across inconsequential program changes in order for an aspect to be stable across such changes. Many AOP implementations support method executions and field references as join points.</li>
<li>A way to specify (or <i>quantify</i>) join points, called <i>pointcuts</i>. Pointcuts determine whether a given join point matches. Most useful pointcut languages use a syntax like the base language (for example, AspectJ uses Java signatures) and allow reuse through naming and combination.</li>
<li>A means of specifying code to run at a join point. AspectJ calls this <i>advice</i>, and can run it before, after, and around join points. Some implementations also support things like defining a method in an aspect on another class.</li>
</ol>
<p>Join-point models can be compared based on the join points exposed, how join points are specified, the operations permitted at the join points, and the structural enhancements that can be expressed.</p>
<h3>AspectJ's join-point model</h3>
<ul>
<li>The join points in AspectJ include method or constructor call or execution, the initialization of a class or object, field read and write access, exception handlers, etc. They do not include loops, super calls, throws clauses, multiple statements, etc.</li>
</ul>
<ul>
<li>Pointcuts are specified by combinations of <i>primitive pointcut designators</i> (PCDs).</li>
</ul>
<p>WHATSON? 62ba3aa0-ca6c-44a4-8aaa-93c97c65fff2</p>
<pre>
 execution(* set*(*))
</pre>
<p>"Dynamic" PCDs check runtime types and bind variables. For example</p>
<p>WHATSON? 808b5eeb-e68c-46b5-a431-f95b8ea3fa05</p>
<pre>
  this(Point)
</pre>
<p>"Scope" PCDs limit the lexical scope of the join point. For example:</p>
<p>WHATSON? e6b3f98f-71d5-43e7-abaf-772ebb1d1795</p>
<pre>
 within(com.company.*)
</pre>
<p>Pointcuts can be composed and named for reuse. For example</p>
<p>WHATSON? 3edebc87-4433-482d-89e4-11991ed55fff</p>
<pre>
pointcut set() : execution(* set*(*) ) &amp;&amp; this(Point) &amp;&amp; within(com.company.*);
</pre>
<ul>
<li>Advice specifies to run at (before, after, or around) a join point (specified with a pointcut) certain code (specified like code in a method). The AOP runtime invokes Advice automatically when the pointcut matches the join point. For example:</li>
</ul>
<p>WHATSON? 1c0c79db-abeb-4cce-9e57-9322df453a1d</p>
<pre>
after() : set() {
   Display.update();
}
</pre>
<h3>Other potential join point models</h3>
<p>There are other kinds of JPMs. All advice languages can be defined in terms of their JPM. For example, a hypothetical aspect language for UML may have the following JPM:</p>
<ul>
<li>Join points are all model elements.</li>
<li>Pointcuts are some boolean expression combining the model elements.</li>
<li>The means of affect at these points are a visualization of all the matched join points.</li>
</ul>
<h3>Inter-type declarations</h3>
<p><i>Inter-type declarations</i> provide a way to express crosscutting concerns affecting the structure of modules. Also known as <i>open classes</i>, this enables programmers to declare in one place members or parents of another class, typically in order to combine all the code related to a concern in one aspect. For example, if a programmer implemented the crosscutting display-update concern using visitors instead, an inter-type declaration using the visitor pattern might look like this in AspectJ:</p>
<p>WHATSON? 6df806c6-4cba-468b-9bc5-de0e2e4f94fb</p>
<pre>
  aspect DisplayUpdate {
    void Point.acceptVisitor(Visitor v) {
      v.visit(this);
    }
    // other crosscutting code...
  }
</pre>
<p>This code snippet adds the <code>acceptVisitor</code> method to the <code>Point</code> class.</p>
<p>It is a requirement that any structural additions be compatible with the original class, so that clients of the existing class continue to operate, unless the AOP implementation can expect to control all clients at all times.</p>
<h2>Implementation</h2>
<p>AOP programs can affect other programs in two different ways, depending on the underlying languages and environments:</p>
<ol>
<li>a combined program is produced, valid in the original language and indistinguishable from an ordinary program to the ultimate interpreter</li>
<li>the ultimate interpreter or environment is updated to understand and implement AOP features.</li>
</ol>
<p>The difficulty of changing environments means most implementations produce compatible combination programs through a process known as <i>weaving</i> - a special case of program transformation. An aspect weaver reads the aspect-oriented code and generates appropriate object-oriented code with the aspects integrated. The same AOP language can be implemented through a variety of weaving methods, so the semantics of a language should never be understood in terms of the weaving implementation. Only the speed of an implementation and its ease of deployment are affected by which method of combination is used.</p>
<p>Systems can implement source-level weaving using preprocessors (as C++ was implemented originally in CFront) that require access to program source files. However, Java's well-defined binary form enables bytecode weavers to work with any Java program in .class-file form. Bytecode weavers can be deployed during the build process or, if the weave model is per-class, during class loading. AspectJ started with source-level weaving in 2001, delivered a per-class bytecode weaver in 2002, and offered advanced load-time support after the integration of AspectWerkz in 2005.</p>
<p>Any solution that combines programs at runtime has to provide views that segregate them properly to maintain the programmer's segregated model. Java's bytecode support for multiple source files enables any debugger to step through a properly woven .class file in a source editor. However, some third-party decompilers cannot process woven code because they expect code produced by Javac rather than all supported bytecode forms (see also "Problems", below).</p>
<p>Deploy-time weaving offers another approach. This basically implies post-processing, but rather than patching the generated code, this weaving approach <i>subclasses</i> existing classes so that the modifications are introduced by method-overriding. The existing classes remain untouched, even at runtime, and all existing tools (debuggers, profilers, etc.) can be used during development. A similar approach has already proven itself in the implementation of many Java EE application servers, such as IBM's WebSphere.</p>
<h3>Terminology</h3>
<p>Standard terminology used in Aspect-oriented programming may include:</p>
<h2>Comparison to other programming paradigms</h2>
<p>Aspects emerged from object-oriented programming and computational reflection. AOP languages have functionality similar to, but more restricted than metaobject protocols. Aspects relate closely to programming concepts like subjects, mixins, and delegation. Other ways to use aspect-oriented programming paradigms include Composition Filters and the hyperslices approach. Since at least the 1970s, developers have been using forms of interception and dispatch-patching that resemble some of the implementation methods for AOP, but these never had the semantics that the crosscutting specifications provide written in one place.</p>
<p>Designers have considered alternative ways to achieve separation of code, such as C#'s partial types, but such approaches lack a quantification mechanism that allows reaching several join points of the code with one declarative statement.</p>
<p>Though it may seem unrelated, in testing, the use of mocks or stubs requires the use of AOP techniques, like around advice, and so forth. Here the collaborating objects are for the purpose of the test, a cross cutting concern. Thus the various Mock Object frameworks provide these features. For example, a process invokes a service to get a balance amount. In the test of the process, where the amount comes from is unimportant, only that the process uses the balance according to the requirements.</p>
<h2>Adoption issues</h2>
<p>Programmers need to be able to read code and understand what is happening in order to prevent errors. Even with proper education, understanding crosscutting concerns can be difficult without proper support for visualizing both static structure and the dynamic flow of a program. Beginning in 2002, AspectJ began to provide IDE plug-ins to support the visualizing of crosscutting concerns. Those features, as well as aspect code assist and refactoring are now common.</p>
<p>Given the power of AOP, if a programmer makes a logical mistake in expressing crosscutting, it can lead to widespread program failure. Conversely, another programmer may change the join points in a program â€“ e.g., by renaming or moving methods â€“ in ways that the aspect writer did not anticipate, with unforeseen consequences. One advantage of modularizing crosscutting concerns is enabling one programmer to affect the entire system easily; as a result, such problems present as a conflict over responsibility between two or more developers for a given failure. However, the solution for these problems can be much easier in the presence of AOP, since only the aspect needs to be changed, whereas the corresponding problems without AOP can be much more spread out.</p>
<h2>Implementations</h2>
<p>The following programming languages have implemented AOP, within the language, or as an external library:</p>
<ul>
<li>.NET Framework languages (C# / VB.NET)
<ul>
<li>Unity, It provides an API to facilitate proven practices in core areas of programming including data access, security, logging, exception handling and others.</li>
</ul>
</li>
<li>ActionScript</li>
<li>Ada</li>
<li>AutoHotkey</li>
<li>C / C++</li>
<li>COBOL</li>
<li>The Cocoa Objective-C frameworks</li>
<li>ColdFusion</li>
<li>Common Lisp</li>
<li>Delphi</li>
<li>Delphi Prism</li>
<li>e (IEEE 1647)</li>
<li>Emacs Lisp</li>
<li>Groovy</li>
<li>Haskell</li>
<li>Java
<ul>
<li>AspectJ</li>
</ul>
</li>
<li>JavaScript</li>
<li>Logtalk</li>
<li>Lua</li>
<li>make</li>
<li>Matlab</li>
<li>ML</li>
<li>Perl</li>
<li>PHP</li>
<li>Prolog</li>
<li>Python</li>
<li>Racket</li>
<li>Ruby</li>
<li>Squeak Smalltalk</li>
<li>UML 2.0</li>
<li>XML</li>
</ul>
<ul>
<li>Unity, It provides an API to facilitate proven practices in core areas of programming including data access, security, logging, exception handling and others.</li>
</ul>
<ul>
<li>AspectJ</li>
</ul>
<h2>See also</h2>
<ul>
<li>Aspect-oriented software development</li>
<li>Distributed AOP</li>
<li>Attribute grammar, a formalism that can be used for aspect-oriented programming on top of functional programming languages</li>
<li>Programming paradigms</li>
<li>Subject-oriented programming, an alternative to Aspect-oriented programming</li>
<li>Role-oriented programming, an alternative to Aspect-oriented programming</li>
<li>Predicate dispatch, an older alternative to Aspect-oriented programming</li>
<li>Executable UML</li>
<li>COMEFROM: Some elements of aspect-oriented programming have been compared to the joke COMEFROM statement.</li>
</ul>
<ul>
<li>Decorator pattern</li>
<li>Domain-driven design</li>
</ul>
<h2>Notes and references</h2>
<ol>
<li><b>^</b> Kiczales, G.; Lamping, J.; Mendhekar, A.; Maeda, C.; Lopes, C.; Loingtier, J. M.; Irwin, J. (1997). "Aspect-oriented programming". ECOOP'97. <i>Proceedings of the 11th European Conference on Object-Oriented Programming</i>. LNCS <b>1241</b>: 220â€“242. doi:10.1007/BFb0053381. ISBNÂ 3-540-63089-9. CiteSeerX: 10.1.1.115.8660.Â  edit</li>
<li><b>^</b> "Adaptive Object Oriented Programming: The Demeter Approach with Propagation Patterns" <i>Karl Liebherr</i> 1996 ISBN 0-534-94602-X presents a well-worked version of essentially the same thing (Lieberherr subsequently recognized this and reframed his approach).</li>
<li><b>^</b> Don Box; Chris Sells (4 November 2002). <i>Essential.NET: The common language runtime</i>. Addison-Wesley Professional. p.Â 206. ISBNÂ 978-0-201-73411-9. Retrieved 4 October 2011.Â </li>
<li><b>^</b> Roman, Ed; Sriganesh, Rima Patel; Brose, Gerald (1 January 2005). <i>Mastering Enterprise JavaBeans</i>. John Wiley and Sons. p.Â 285. ISBNÂ 978-0-7645-8492-3. Retrieved 4 October 2011.Â </li>
<li><b>^</b> Note: The examples in this article appear in a syntax that resembles that of the Java language.</li>
<li><b>^</b> Emacs documentation</li>
<li><b>^</b> http://www.forum2.org/tal/AspectJ2EE.pdf</li>
<li><b>^</b> Edsger Dijkstra, <i>Notes on Structured Programming</i>, pg. 1-2</li>
<li><b>^</b> <i>AOP Considered Harmful</i></li>
<li><b>^</b> Numerous: Afterthought, LOOM.NET, Enterprise Library 3.0 Policy Injection Application Block, AspectDNG, Aspect#, Compose*, PostSharp, Seasar.NET, DotSpect (.SPECT), Spring.NET (as part of its functionality), Wicca and Phx.Morph, SetPoint</li>
<li><b>^</b> as3-commons-bytecode</li>
<li><b>^</b> Ada2012 Rationale</li>
<li><b>^</b> Function Hooks</li>
<li><b>^</b> Several: AspectC++, FeatureC++, AspectC, AspeCt-oriented C, Aspicere</li>
<li><b>^</b> Cobble</li>
<li><b>^</b> AspectCocoa</li>
<li><b>^</b> ColdSpring</li>
<li><b>^</b> AspectL</li>
<li><b>^</b> InfraAspect</li>
<li><b>^</b> MeAOP in MeSDK</li>
<li><b>^</b> DSharp</li>
<li><b>^</b> RemObjects Cirrus</li>
<li><b>^</b> Emacs Advice Functions</li>
<li><b>^</b> monad (functional programming) ("Monads As a theoretical basis for AOP". CiteSeerX: 10.1.1.25.8262.Â ) and Aspect-oriented programming with type classes. A Typed Monadic Embedding of Aspects</li>
<li><b>^</b> Numerous others: CaesarJ, Compose*, Dynaop, JAC, Google Guice (as part of its functionality), Javassist, JAsCo (and AWED), JAML, JBoss AOP, LogicAJ, Object Teams, PROSE, The AspectBench Compiler for AspectJ (abc), Spring framework (as part of its functionality), Seasar, The JMangler Project, InjectJ, GluonJ, Steamloom</li>
<li><b>^</b> Many: Advisable, Ajaxpect, jQuery AOP Plugin, Aspectes, AspectJS, Cerny.js, Dojo Toolkit, Humax Web Framework, Joose, Prototype - Prototype Function#wrap, YUI 3 (Y.Do)</li>
<li><b>^</b> Using built-in support for categories (which allows the encapsulation of aspect code) and event-driven programming (which allows the definition of <i>before</i> and after <i>event</i> handlers).</li>
<li><b>^</b> AspectLua</li>
<li><b>^</b> MAKAO</li>
<li><b>^</b> [1]</li>
<li><b>^</b> AspectML</li>
<li><b>^</b> The Aspect Module</li>
<li><b>^</b> Several: PHP-AOP (AOP.io), Go! AOP framework, PHPaspect, Seasar.PHP, PHP-AOP, TYPO3 Flow, AOP PECL Extension</li>
<li><b>^</b> "Whirl"</li>
<li><b>^</b> Several: PEAK, Aspyct AOP, Lightweight Python AOP, Logilab's aspect module, Pythius, Spring Python's AOP module, Pytilities' AOP module, aspectlib</li>
<li><b>^</b> AspectScheme</li>
<li><b>^</b> AspectR</li>
<li><b>^</b> AspectR-Fork</li>
<li><b>^</b> Aquarium</li>
<li><b>^</b> Aspector</li>
<li><b>^</b> AspectS</li>
<li><b>^</b> MetaclassTalk</li>
<li><b>^</b> WEAVR</li>
<li><b>^</b> AspectXML</li>
<li><b>^</b> C2:ComeFrom</li>
</ol>
<h2>Further reading</h2>
<ul>
<li>Kiczales, G.; Lamping, J.; Mendhekar, A.; Maeda, C.; Lopes, C.; Loingtier, J. M.; Irwin, J. (1997). "Aspect-oriented programming". ECOOP'97. <i>Proceedings of the 11th European Conference on Object-Oriented Programming</i>. LNCS <b>1241</b>: 220â€“242. doi:10.1007/BFb0053381. ISBNÂ 3-540-63089-9. CiteSeerX: 10.1.1.115.8660.Â  edit The paper generally considered to be the authoritative reference for AOP.</li>
<li>Holzinger, Andreas; M. Brugger, W. Slany (2011). <i>Applying Aspect Oriented Programming (AOP) in Usability Engineering processes: On the example of Tracking Usage Information for Remote Usability Testing. In: Marca, D. A., Shishkov, B. &amp; Sinderen, M. v. (Eds.) Proceedings of the 8th International Conference on electronic Business and Telecommunications. Sevilla, 53-56</i>.Â  Cite uses deprecated parameters (help)</li>
<li>Filman, Robert E.; Tzilla Elrad, SiobhÃ¡n Clarke, and Mehmet Aksit (2004). <i>Aspect-Oriented Software Development</i>. ISBNÂ 0-321-21976-7.Â  Cite uses deprecated parameters (help)</li>
<li>Pawlak, Renaud; Lionel Seinturier, and Jean-Philippe RetaillÃ© (2005). <i>Foundations of AOP for J2EE Development</i>. ISBNÂ 1-59059-507-6.Â  Cite uses deprecated parameters (help)</li>
<li>Laddad, Ramnivas (2003). <i>AspectJ in Action: Practical Aspect-Oriented Programming</i>. ISBNÂ 1-930110-93-6.Â </li>
<li>Jacobson, Ivar; Pan-Wei Ng (2005). <i>Aspect-Oriented Software Development with Use Cases</i>. ISBNÂ 0-321-26888-1.Â </li>
<li>Aspect-oriented Software Development and PHP, Dmitry Sheiko, 2006</li>
<li>Clarke, SiobhÃ¡n; Elisa Baniassad (2005). <i>Aspect-Oriented Analysis and Design: The Theme Approach</i>. ISBNÂ 0-321-24674-8.Â </li>
<li>Yedduladoddi, Raghu (2009). <i>Aspect Oriented Software Development: An Approach to Composing UML Design Models</i>. ISBNÂ 3-639-12084-1.Â </li>
<li>"Adaptive Object-Oriented Programming Using Graph-Based Customization" â€“ Lieberherr, Silva-Lepe, et al. - 1994</li>
<li>Zambrano Polo y La Borda, Arturo Federico (June 5, 2013). "Addressing aspect interactions in an industrial setting: experiences, problems and solutions". p.Â 159. Retrieved 30 May 2014.Â </li>
</ul>
<h2>External links</h2>
<ul>
<li>Eric Bodden's list of AOP tools in .net framework</li>
<li>Programming Styles: Procedural, OOP, and AOP</li>
<li>Programming Forum: Procedural, OOP, and AOP</li>
<li>Aspect-Oriented Software Development, annual conference on AOP</li>
<li>AOSD Wiki, Wiki on aspect-oriented software development</li>
<li>AspectJ Programming Guide</li>
<li>The AspectBench Compiler for AspectJ, another Java implementation</li>
<li>Series of IBM developerWorks articles on AOP</li>
<li>A detailed series of articles on basics of aspect-oriented programming and AspectJ</li>
<li>What is Aspect-Oriented Programming?, introduction with RemObjects Taco</li>
<li>Constraint-Specification Aspect Weaver</li>
<li>Aspect- vs. Object-Oriented Programming: Which Technique, When?</li>
<li>Gregor Kiczales, Professor of Computer Science, explaining AOP, video 57 min.</li>
<li>Aspect Oriented Programming in COBOL</li>
<li>Aspect-Oriented Programming in Java with Spring Framework</li>
<li>Wiki dedicated to AOP methods on.NET</li>
<li>Early Aspects for Business Process Modeling (An Aspect Oriented Language for BPMN)</li>
<li>Spring AOP and AspectJ Introduction</li>
<li>AOSD Graduate Course at Bilkent University</li>
<li>Introduction to AOP - Software Engineering Radio Podcast Episode 106</li>
<li>An Objective-C implementation of AOP by Szilveszter Molnar</li>
<li>Apect-Oriented programming for iOS and OS X by Manuel Gebele</li>
<li>DevExpress MVVM Framework. Introduction to POCO ViewModels</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>Advice</li>
<li>Aspect</li>
<li><strong class="selflink">Aspect-oriented programming</strong></li>
<li>Aspect weaver</li>
<li>Cross-cutting concerns</li>
<li>Join point</li>
<li>Pointcut</li>
</ul>
<ul>
<li>AspectC++</li>
<li>AspectJ</li>
<li>AspectWerkz</li>
</ul>
</body>
</html>