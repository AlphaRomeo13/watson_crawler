<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tacit-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Tacit programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li><strong class="selflink">Point-free style</strong>
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Tacit programming</b>, also called <b>point-free style</b>, is a programming paradigm in which function definitions do not identify the arguments (or "points") on which they operate. Instead the definitions merely compose other functions, among which are combinators that manipulate the arguments. Tacit programming is of theoretical interest, because the strict use of composition results in programs that are well adapted for equational reasoning. It is also the natural style of certain programming languages, including APL and its derivatives, and concatenative languages such as Forth. Despite this following, the lack of argument naming gives point-free style a reputation of being unnecessarily obscure, hence the epithet "pointless style."</p>
<p>For example, a sequence of operations in an applicative language like the following:</p>
<p>WHATSON? c0691936-c6ee-4301-875e-bbd002a4ab30</p>
<pre>
def example(x):
  y = foo(x)
  z = bar(y)
  w = baz(z)
  return w
</pre>
<p>...is written in point-free style as the composition of a sequence of functions, without parameters:</p>
<p>WHATSON? 7d184d2f-339a-4055-984f-3d10831d23d1</p>
<pre>
<code>def example: baz bar foo</code>
</pre>
<p>The key idea in tacit programming is to assist in operating at the appropriate level of abstraction. That is, to translate the natural transformation given by currying:</p>
<p>into computer functions, where the left represents the uncurried form of a function and the right the curried. hom(X, Y) denotes the homomorphisms from X to Y while, A × B denotes the Cartesian product of A and B.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Examples
<ul>
<li>1.1 Functional programming</li>
<li>1.2 APL family</li>
<li>1.3 Stack-based</li>
</ul>
</li>
<li>2 See also</li>
<li>3 References</li>
<li>4 External links</li>
</ul>
<ul>
<li>1.1 Functional programming</li>
<li>1.2 APL family</li>
<li>1.3 Stack-based</li>
</ul>
<p></p>
<h2>Examples</h2>
<h3>Functional programming</h3>
<p>A simple example (in Haskell) is a program which takes a sum of a list. A programmer might define a sum recursively using a <i>pointed</i> (cf. <i>value</i>-level programming) method as:</p>
<p>WHATSON? 1c6568ff-836c-43f8-9d61-7a0a2bdc8398</p>
<pre>
sum (x:xs) = x + sum xs
sum [] = 0
</pre>
<p>However by noting this as a fold the programmer could replace this with:</p>
<p>WHATSON? be6571b0-7aa2-4249-855e-824d5e421ef3</p>
<pre>
sum xs = foldr (+) 0 xs
</pre>
<p>And then the argument is not needed, so this can be replaced with</p>
<p>WHATSON? b0656611-0311-4b4f-b4eb-fe7c38f85b50</p>
<pre>
sum  = foldr (+) 0
</pre>
<p>which is point-free.</p>
<p>Another example uses the dot operator:</p>
<p>WHATSON? 25294bd0-f477-4e23-be71-4d977fe01d5e</p>
<pre>
p x y z = f (g x y) z
</pre>
<p>We can simply group</p>
<p>WHATSON? 1d76280d-e3b0-48e5-93ea-5475b94b5d52</p>
<pre>
f (g x y) z ≡ f ((g x) y) z ≡ (f .) (g x) y z ≡ ((f .) . g) x y z
</pre>
<p>so</p>
<p>WHATSON? f4529dd2-bad9-4965-852d-76eb6665e401</p>
<pre>
p = (f .) . g
</pre>
<p>Finally, to see a complex example imagine a map filter program which takes a list, applies a function to it, and then filters the elements based on a criterion</p>
<p>WHATSON? f8e2bc40-2877-408d-b723-65860e9ea662</p>
<pre>
mf criteria operator list = filter criteria (map operator list)
</pre>
<p>It can be expressed point-free as</p>
<p>WHATSON? da1e6474-bf2a-45fb-ba2f-46d8d832d348</p>
<pre>
mf = (. map) . (.) . filter
</pre>
<h3>APL family</h3>
<p>In J, the same sort of point-free code occurs in a function made to compute the average of a list (array) of numbers:</p>
<p>WHATSON? e9b8c61f-9c13-45e8-a4c5-a09a0611b164</p>
<pre>
 avg=: +/ % #
</pre>
<p># counts the number of items in the array. +/ sums the items of the array. % divides the sum by the number of items</p>
<h3>Stack-based</h3>
<p>In stack-oriented programming languages (and concatenative ones, most of which are stack based), point-free methods are commonly used. For example a procedure to compute the Fibonacci numbers might look like:</p>
<p>WHATSON? 576edbad-8886-479d-ac4d-771bf5f4f8f5</p>
<pre>
/fib
{
   dup dup 1 eq exch 0 eq or not
   {
      dup 1 sub fib
      exch 2 sub fib
      add
   } if
} def
</pre>
<h2>See also</h2>
<ul>
<li>Combinatory logic</li>
<li>Concatenative programming language</li>
<li>Function-level programming</li>
<li>Joy (programming language), modern highly tacit language</li>
<li>Pointless topology</li>
</ul>
</body>
</html>