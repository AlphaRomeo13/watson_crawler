<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Media-Playback--Android-Developers.html</title></head>
<body>
<h1>Media Playback</h1>
<h2>In this document</h2>
<ol>
<li>The Basics
</li><li>Manifest Declarations</li>
<li>Using MediaPlayer
   <ol>
      <li>Asynchronous Preparation</li>
      <li>Managing State</li>
      <li>Releasing the MediaPlayer</li>
   </ol>
</li>
<li>Using a Service with MediaPlayer
   <ol>
      <li>Running asynchronously</li>
      <li>Handling asynchronous errors</li>
      <li>Using wake locks</li>
      <li>Running as a foreground service</li>
      <li>Handling audio focus</li>
      <li>Performing cleanup</li>
   </ol>
</li>
<li>Handling the AUDIO_BECOMING_NOISY Intent
</li><li>Retrieving Media from a Content Resolver
</li></ol>
<ol>
      <li>Asynchronous Preparation</li>
      <li>Managing State</li>
      <li>Releasing the MediaPlayer</li>
   </ol>
<ol>
      <li>Running asynchronously</li>
      <li>Handling asynchronous errors</li>
      <li>Using wake locks</li>
      <li>Running as a foreground service</li>
      <li>Handling audio focus</li>
      <li>Performing cleanup</li>
   </ol>
<h2>Key classes</h2>
<ol>
<li><code>MediaPlayer</code></li>
<li><code>AudioManager</code></li>
<li><code>SoundPool</code></li>
</ol>
<h2>See also</h2>
<ol>
<li>JetPlayer</li>
<li>Audio Capture</li>
<li>Android Supported Media Formats</li>
<li>Data Storage</li>
</ol>
<p>The Android multimedia framework includes support for playing variety of common media types, so
that you can easily integrate audio, video and images into your applications. You can play audio or
video from media files stored in your application's resources (raw resources), from standalone files
in the filesystem, or from a data stream arriving over a network connection, all using <code>MediaPlayer</code> APIs.</p>
<p>This document shows you how to write a media-playing application that interacts with the user and
the system in order to obtain good performance and a pleasant user experience.</p>
<p><strong>Note:</strong> You can play back the audio data only to the standard output
device. Currently, that is the mobile device speaker or a Bluetooth headset. You cannot play sound
files in the conversation audio during a call.</p>
<h2>The Basics</h2>
<p>The following classes are used to play sound and video in the Android framework:</p>
<h2>Manifest Declarations</h2>
<p>Before starting development on your application using MediaPlayer, make sure your manifest has
the appropriate declarations to allow use of related features.</p>
<ul>
  <li><strong>Internet Permission</strong> - If you are using MediaPlayer to stream network-based
content, your application must request network access.
<pre>
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
</pre>
  </li>
  <li><strong>Wake Lock Permission</strong> - If your player application needs to keep the screen
from dimming or the processor from sleeping, or uses the <code>MediaPlayer.setScreenOnWhilePlaying()</code> or
<code>MediaPlayer.setWakeMode()</code> methods, you must request this permission.
<pre>
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
</pre>
  </li>
</ul>
<p>WHATSON? 5705dd13-12e1-48a0-9bf5-20f4d3ed39d4</p>
<pre>
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
</pre>
<p>WHATSON? 068cd499-1ca9-4bbc-a11c-728c0b298c25</p>
<pre>
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
</pre>
<h2>Using MediaPlayer</h2>
<p>One of the most important components of the media framework is the
<code>MediaPlayer</code>
class. An object of this class can fetch, decode, and play both audio and video
with minimal setup. It supports several different media sources such as:
</p>
<ul>
   <li>Local resources</li>
   <li>Internal URIs, such as one you might obtain from a Content Resolver</li>
   <li>External URLs (streaming)</li>
</ul>
<p>For a list of media formats that Android supports,
see the Android Supported Media
Formats document. </p>
<p>Here is an example
of how to play audio that's available as a local raw resource (saved in your application's
<code>res/raw/</code> directory):</p>
<p>WHATSON? fb6ad6c1-a05f-4ddf-ae5e-408eddd4105d</p>
<pre>MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);
mediaPlayer.start(); // no need to call prepare(); create() does that for you
</pre>
<p>In this case, a "raw" resource is a file that the system does not
try to parse in any particular way. However, the content of this resource should not
be raw audio. It should be a properly encoded and formatted media file in one
of the supported formats.</p>
<p>And here is how you might play from a URI available locally in the system
(that you obtained through a Content Resolver, for instance):</p>
<p>WHATSON? ca7913af-0cc9-429b-aeb0-f9c0349faf88</p>
<pre>Uri myUri = ....; // initialize Uri here
MediaPlayer mediaPlayer = new MediaPlayer();
mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
mediaPlayer.setDataSource(getApplicationContext(), myUri);
mediaPlayer.prepare();
mediaPlayer.start();</pre>
<p>Playing from a remote URL via HTTP streaming looks like this:</p>
<p>WHATSON? d9ee21b4-dee7-41b5-9c8d-edbf7835237f</p>
<pre>String url = "http://........"; // your URL here
MediaPlayer mediaPlayer = new MediaPlayer();
mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
mediaPlayer.setDataSource(url);
mediaPlayer.prepare(); // might take long! (for buffering, etc)
mediaPlayer.start();</pre>
<p><strong>Note:</strong>
If you're passing a URL to stream an online media file, the file must be capable of
progressive download.</p>
<p><strong>Caution:</strong> You must either catch or pass
<code>IllegalArgumentException</code> and <code>IOException</code> when using
<code>setDataSource()</code>, because
the file you are referencing might not exist.</p>
<h3>Asynchronous Preparation</h3>
<p>Using <code>MediaPlayer</code> can be straightforward in
principle. However, it's important to keep in mind that a few more things are
necessary to integrate it correctly with a typical Android application. For
example, the call to <code>prepare()</code> can
take a long time to execute, because
it might involve fetching and decoding media data. So, as is the case with any
method that may take long to execute, you should <strong>never call it from your
application's UI thread</strong>. Doing that will cause the UI to hang until the method returns,
which is a very bad user experience and can cause an ANR (Application Not Responding) error. Even if
you expect your resource to load quickly, remember that anything that takes more than a tenth
of a second to respond in the UI will cause a noticeable pause and will give
the user the impression that your application is slow.</p>
<p>To avoid hanging your UI thread, spawn another thread to
prepare the <code>MediaPlayer</code> and notify the main thread when done. However, while
you could write the threading logic
yourself, this pattern is so common when using <code>MediaPlayer</code> that the framework
supplies a convenient way to accomplish this task by using the
<code>prepareAsync()</code> method. This method
starts preparing the media in the background and returns immediately. When the media
is done preparing, the <code>onPrepared()</code>
method of the <code>MediaPlayer.OnPreparedListener</code>, configured through
<code>setOnPreparedListener()</code> is called.</p>
<h3>Managing State</h3>
<p>Another aspect of a <code>MediaPlayer</code> that you should keep in mind is
that it's state-based. That is, the <code>MediaPlayer</code> has an internal state
that you must always be aware of when writing your code, because certain operations
are only valid when then player is in specific states. If you perform an operation while in the
wrong state, the system may throw an exception or cause other undesireable behaviors.</p>
<p>The documentation in the
<code>MediaPlayer</code> class shows a complete state diagram,
that clarifies which methods move the <code>MediaPlayer</code> from one state to another.
For example, when you create a new <code>MediaPlayer</code>, it is in the <em>Idle</em>
state. At that point, you should initialize it by calling
<code>setDataSource()</code>, bringing it
to the <em>Initialized</em> state. After that, you have to prepare it using either the
<code>prepare()</code> or
<code>prepareAsync()</code> method. When
the <code>MediaPlayer</code> is done preparing, it will then enter the <em>Prepared</em>
state, which means you can call <code>start()</code>
to make it play the media. At that point, as the diagram illustrates,
you can move between the <em>Started</em>, <em>Paused</em> and <em>PlaybackCompleted</em> states by
calling such methods as
<code>start()</code>,
<code>pause()</code>, and
<code>seekTo()</code>,
amongst others. When you
call <code>stop()</code>, however, notice that you
cannot call <code>start()</code> again until you
prepare the <code>MediaPlayer</code> again.</p>
<p>Always keep the state diagram
in mind when writing code that interacts with a
<code>MediaPlayer</code> object, because calling its methods from the wrong state is a
common cause of bugs.</p>
<h3>Releasing the MediaPlayer</h3>
<p>A <code>MediaPlayer</code> can consume valuable
system resources.
Therefore, you should always take extra precautions to make sure you are not
hanging on to a <code>MediaPlayer</code> instance longer than necessary. When you
are done with it, you should always call
<code>release()</code> to make sure any
system resources allocated to it are properly released. For example, if you are
using a <code>MediaPlayer</code> and your activity receives a call to <code>onStop()</code>, you must release the <code>MediaPlayer</code>,
because it
makes little sense to hold on to it while your activity is not interacting with
the user (unless you are playing media in the background, which is discussed in the next section).
When your activity is resumed or restarted, of course, you need to
create a new <code>MediaPlayer</code> and prepare it again before resuming playback.</p>
<p>Here's how you should release and then nullify your <code>MediaPlayer</code>:</p>
<p>WHATSON? f0cd6b4c-5529-4602-9950-61ecca1f0511</p>
<pre>
mediaPlayer.release();
mediaPlayer = null;
</pre>
<p>As an example, consider the problems that could happen if you
forgot to release the <code>MediaPlayer</code> when your activity is stopped, but create a
new one when the activity starts again. As you may know, when the user changes the
screen orientation (or changes the device configuration in another way),
the system handles that by restarting the activity (by default), so you might quickly
consume all of the system resources as the user
rotates the device back and forth between portrait and landscape, because at each
orientation change, you create a new <code>MediaPlayer</code> that you never
release. (For more information about runtime restarts, see Handling Runtime Changes.)</p>
<p>You may be wondering what happens if you want to continue playing
"background media" even when the user leaves your activity, much in the same
way that the built-in Music application behaves. In this case, what you need is
a <code>MediaPlayer</code> controlled by a <code>Service</code>, as
discussed in Using a Service with MediaPlayer.</p>
<h2>Using a Service with MediaPlayer</h2>
<p>If you want your media to play in the background even when your application
is not onscreen—that is, you want it to continue playing while the user is
interacting with other applications—then you must start a
<code>Service</code> and control the
<code>MediaPlayer</code> instance from there.
You should be careful about this setup, because the user and the system have expectations
about how an application running a background service should interact with the rest of the
system. If your application does not fulfil those expectations, the user may
have a bad experience. This section describes the main issues that you should be
aware of and offers suggestions about how to approach them.</p>
<h3>Running asynchronously</h3>
<p>First of all, like an <code>Activity</code>, all work in a
<code>Service</code> is done in a single thread by
default—in fact, if you're running an activity and a service from the same application, they
use the same thread (the "main thread") by default. Therefore, services need to
process incoming intents quickly
and never perform lengthy computations when responding to them. If any heavy
work or blocking calls are expected, you must do those tasks asynchronously: either from
another thread you implement yourself, or using the framework's many facilities
for asynchronous processing.</p>
<p>For instance, when using a <code>MediaPlayer</code> from your main thread,
you should call <code>prepareAsync()</code> rather than
<code>prepare()</code>, and implement
a <code>MediaPlayer.OnPreparedListener</code>
in order to be notified when the preparation is complete and you can start playing.
For example:</p>
<p>WHATSON? d01e9691-1a88-4611-b196-2dac19b96969</p>
<pre>
public class MyService extends Service implements MediaPlayer.OnPreparedListener {
    private static final String ACTION_PLAY = "com.example.action.PLAY";
    MediaPlayer mMediaPlayer = null;

    public int onStartCommand(Intent intent, int flags, int startId) {
        ...
        if (intent.getAction().equals(ACTION_PLAY)) {
            mMediaPlayer = ... // initialize it here
            mMediaPlayer.setOnPreparedListener(this);
            mMediaPlayer.prepareAsync(); // prepare async to not block main thread
        }
    }

    /** Called when MediaPlayer is ready */
    public void onPrepared(MediaPlayer player) {
        player.start();
    }
}
</pre>
<h3>Handling asynchronous errors</h3>
<p>On synchronous operations, errors would normally
be signaled with an exception or an error code, but whenever you use asynchronous
resources, you should make sure your application is notified
of errors appropriately. In the case of a <code>MediaPlayer</code>,
you can accomplish this by implementing a
<code>MediaPlayer.OnErrorListener</code> and
setting it in your <code>MediaPlayer</code> instance:</p>
<p>WHATSON? 6e5c2172-b6db-44c6-804d-bdfd0688e37b</p>
<pre>
public class MyService extends Service implements MediaPlayer.OnErrorListener {
    MediaPlayer mMediaPlayer;

    public void initMediaPlayer() {
        // ...initialize the MediaPlayer here...

        mMediaPlayer.setOnErrorListener(this);
    }

    @Override
    public boolean onError(MediaPlayer mp, int what, int extra) {
        // ... react appropriately ...
        // The MediaPlayer has moved to the Error state, must be reset!
    }
}
</pre>
<p>It's important to remember that when an error occurs, the <code>MediaPlayer</code>
moves to the <em>Error</em> state (see the documentation for the
<code>MediaPlayer</code> class for the full state diagram)
and you must reset it before you can use it again.


</p>
<h3>Using wake locks</h3>
<p>When designing applications that play media
in the background, the device may go to sleep
while your service is running. Because the Android system tries to conserve
battery while the device is sleeping, the system tries to shut off any
of the phone's features that are
not necessary, including the CPU and the WiFi hardware.
However, if your service is playing or streaming music, you want to prevent
the system from interfering with your playback.</p>
<p>In order to ensure that your service continues to run under
those conditions, you have to use "wake locks." A wake lock is a way to signal to
the system that your application is using some feature that should
stay available even if the phone is idle.</p>
<p><strong>Notice:</strong> You should always use wake locks sparingly and hold them
only for as long as truly necessary, because they significantly reduce the battery life of the
device.</p>
<p>To ensure that the CPU continues running while your <code>MediaPlayer</code> is
playing, call the <code>setWakeMode()</code> method when initializing your <code>MediaPlayer</code>. Once you do,
the <code>MediaPlayer</code> holds the specified lock while playing and releases the lock
when paused or stopped:</p>
<p>WHATSON? eeb727f6-234a-4913-89df-3806c75226c7</p>
<pre>
mMediaPlayer = new MediaPlayer();
// ... other initialization here ...
mMediaPlayer.setWakeMode(getApplicationContext(), PowerManager.PARTIAL_WAKE_LOCK);
</pre>
<p>However, the wake lock acquired in this example guarantees only that the CPU remains awake. If
you are streaming media over the
network and you are using Wi-Fi, you probably want to hold a
<code>WifiLock</code> as
well, which you must acquire and release manually. So, when you start preparing the
<code>MediaPlayer</code> with the remote URL, you should create and acquire the Wi-Fi lock.
For example:</p>
<p>WHATSON? 56059d7b-74ef-489c-a1ea-91d5bb9352f9</p>
<pre>
WifiLock wifiLock = ((WifiManager) getSystemService(Context.WIFI_SERVICE))
    .createWifiLock(WifiManager.WIFI_MODE_FULL, "mylock");

wifiLock.acquire();
</pre>
<p>When you pause or stop your media, or when you no longer need the
network, you should release the lock:</p>
<p>WHATSON? 26e979e3-0856-4ada-8fd8-1eacc2711040</p>
<pre>
wifiLock.release();
</pre>
<h3>Running as a foreground service</h3>
<p>Services are often used for performing background tasks, such as fetching emails,
synchronizing data, downloading content, amongst other possibilities. In these
cases, the user is not actively aware of the service's execution, and probably
wouldn't even notice if some of these services were interrupted and later restarted.</p>
<p>But consider the case of a service that is playing music. Clearly this is a service that the user
is actively aware of and the experience would be severely affected by any interruptions.
Additionally, it's a service that the user will likely wish to interact with during its execution.
In this case, the service should run as a "foreground service." A
foreground service holds a higher level of importance within the system—the system will
almost never kill the service, because it is of immediate importance to the user. When running
in the foreground, the service also must provide a status bar notification to ensure that users are
aware of the running service and allow them to open an activity that can interact with the
service.</p>
<p>In order to turn your service into a foreground service, you must create a
<code>Notification</code> for the status bar and call
<code>startForeground()</code> from the <code>Service</code>. For example:</p>
<p>WHATSON? 97f0a7f2-1ade-487b-bb74-9c32c7d2a271</p>
<pre>String songName;
// assign the song name to songName
PendingIntent pi = PendingIntent.getActivity(getApplicationContext(), 0,
                new Intent(getApplicationContext(), MainActivity.class),
                PendingIntent.FLAG_UPDATE_CURRENT);
Notification notification = new Notification();
notification.tickerText = text;
notification.icon = R.drawable.play0;
notification.flags |= Notification.FLAG_ONGOING_EVENT;
notification.setLatestEventInfo(getApplicationContext(), "MusicPlayerSample",
                "Playing: " + songName, pi);
startForeground(NOTIFICATION_ID, notification);
</pre>
<p>While your service is running in the foreground, the notification you
configured is visible in the notification area of the device. If the user
selects the notification, the system invokes the <code>PendingIntent</code> you supplied. In
the example above, it opens an activity (<code>MainActivity</code>).</p>
<p>Figure 1 shows how your notification appears to the user:</p>
<p><strong>Figure 1.</strong> Screenshots of a foreground service's
notification, showing the notification icon in the status bar (left) and the expanded view
(right).</p>
<p>You should only hold on to the "foreground service" status while your
service is actually performing something the user is actively aware of. Once
that is no longer true, you should release it by calling
<code>stopForeground()</code>:</p>
<p>WHATSON? 722a2f45-3e1a-4652-9c8e-bb18db69eca4</p>
<pre>
stopForeground(true);
</pre>
<p>For more information, see the documentation about Services and
Status Bar Notifications.</p>
<h3>Handling audio focus</h3>
<p>Even though only one activity can run at any given time, Android is a
multi-tasking environment. This poses a particular challenge to applications
that use audio, because there is only one audio output and there may be several
media services competing for its use. Before Android 2.2, there was no built-in
mechanism to address this issue, which could in some cases lead to a bad user
experience. For example, when a user is listening to
music and another application needs to notify the user of something very important,
the user might not hear the notification tone due to the loud music. Starting with
Android 2.2, the platform offers a way for applications to negotiate their
use of the device's audio output. This mechanism is called Audio Focus.</p>
<p>When your application needs to output audio such as music or a notification,
you should always request audio focus. Once it has focus, it can use the sound output freely, but it
should
always listen for focus changes. If it is notified that it has lost the audio
focus, it should immediately either kill the audio or lower it to a quiet level
(known as "ducking"—there is a flag that indicates which one is appropriate) and only resume
loud playback after it receives focus again.</p>
<p>Audio Focus is cooperative in nature. That is, applications are expected
(and highly encouraged) to comply with the audio focus guidelines, but the
rules are not enforced by the system. If an application wants to play loud
music even after losing audio focus, nothing in the system will prevent that.
However, the user is more likely to have a bad experience and will be more
likely to uninstall the misbehaving application.</p>
<p>To request audio focus, you must call
<code>requestAudioFocus()</code> from the <code>AudioManager</code>, as the example below demonstrates:</p>
<p>WHATSON? a1eba2db-ec17-4136-af7b-7e1a50fb03e0</p>
<pre>
AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
int result = audioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC,
    AudioManager.AUDIOFOCUS_GAIN);

if (result != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
    // could not get audio focus.
}
</pre>
<p>The first parameter to <code>requestAudioFocus()</code>
is an <code>AudioManager.OnAudioFocusChangeListener</code>,
whose <code>onAudioFocusChange()</code> method is called whenever there is a change in audio focus. Therefore, you
should also implement this interface on your service and activities. For example:</p>
<p>WHATSON? 8c34fd7e-98e1-4be5-833a-db1b660b20c4</p>
<pre>
class MyService extends Service
                implements AudioManager.OnAudioFocusChangeListener {
    // ....
    public void onAudioFocusChange(int focusChange) {
        // Do something based on focus change...
    }
}
</pre>
<p>The <code>focusChange</code> parameter tells you how the audio focus has changed, and
can be one of the following values (they are all constants defined in
<code>AudioManager</code>):</p>
<ul>
<li><code>AUDIOFOCUS_GAIN</code>: You have gained the audio focus.</li>

<li><code>AUDIOFOCUS_LOSS</code>: You have lost the audio focus for a
presumably long time.
You must stop all audio playback. Because you should expect not to have focus back
for a long time, this would be a good place to clean up your resources as much
as possible. For example, you should release the <code>MediaPlayer</code>.</li>

<li><code>AUDIOFOCUS_LOSS_TRANSIENT</code>: You have
temporarily lost audio focus, but should receive it back shortly. You must stop
all audio playback, but you can keep your resources because you will probably get
focus back shortly.</li>

<li><code>AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK</code>: You have temporarily
lost audio focus,
but you are allowed to continue to play audio quietly (at a low volume) instead
of killing audio completely.</li>
</ul>
<p>Here is an example implementation:</p>
<p>WHATSON? 40a2edf3-b568-4202-aaeb-14fd4f83f8f8</p>
<pre>
public void onAudioFocusChange(int focusChange) {
    switch (focusChange) {
        case AudioManager.AUDIOFOCUS_GAIN:
            // resume playback
            if (mMediaPlayer == null) initMediaPlayer();
            else if (!mMediaPlayer.isPlaying()) mMediaPlayer.start();
            mMediaPlayer.setVolume(1.0f, 1.0f);
            break;

        case AudioManager.AUDIOFOCUS_LOSS:
            // Lost focus for an unbounded amount of time: stop playback and release media player
            if (mMediaPlayer.isPlaying()) mMediaPlayer.stop();
            mMediaPlayer.release();
            mMediaPlayer = null;
            break;

        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
            // Lost focus for a short time, but we have to stop
            // playback. We don't release the media player because playback
            // is likely to resume
            if (mMediaPlayer.isPlaying()) mMediaPlayer.pause();
            break;

        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
            // Lost focus for a short time, but it's ok to keep playing
            // at an attenuated level
            if (mMediaPlayer.isPlaying()) mMediaPlayer.setVolume(0.1f, 0.1f);
            break;
    }
}
</pre>
<p>Keep in mind that the audio focus APIs are available only with API level 8 (Android 2.2)
and above, so if you want to support previous
versions of Android, you should adopt a backward compatibility strategy that
allows you to use this feature if available, and fall back seamlessly if not.</p>
<p>You can achieve backward compatibility either by calling the audio focus methods by reflection
or by implementing all the audio focus features in a separate class (say,
<code>AudioFocusHelper</code>). Here is an example of such a class:</p>
<p>WHATSON? 37e5e492-79ac-4547-bd10-54d7e5c7ca5d</p>
<pre>
public class AudioFocusHelper implements AudioManager.OnAudioFocusChangeListener {
    AudioManager mAudioManager;

    // other fields here, you'll probably hold a reference to an interface
    // that you can use to communicate the focus changes to your Service

    public AudioFocusHelper(Context ctx, /* other arguments here */) {
        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
        // ...
    }

    public boolean requestFocus() {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED ==
            mAudioManager.requestAudioFocus(mContext, AudioManager.STREAM_MUSIC,
            AudioManager.AUDIOFOCUS_GAIN);
    }

    public boolean abandonFocus() {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED ==
            mAudioManager.abandonAudioFocus(this);
    }

    @Override
    public void onAudioFocusChange(int focusChange) {
        // let your service know about the focus change
    }
}
</pre>
<p>You can create an instance of <code>AudioFocusHelper</code> class only if you detect that
the system is running API level 8 or above. For example:</p>
<p>WHATSON? bfe1d5ef-6457-496d-9c69-51ee9b1a8aed</p>
<pre>
if (android.os.Build.VERSION.SDK_INT &gt;= 8) {
    mAudioFocusHelper = new AudioFocusHelper(getApplicationContext(), this);
} else {
    mAudioFocusHelper = null;
}
</pre>
<h3>Performing cleanup</h3>
<p>As mentioned earlier, a <code>MediaPlayer</code> object can consume a significant
amount of system resources, so you should keep it only for as long as you need and call
<code>release()</code> when you are done with it. It's important
to call this cleanup method explicitly rather than rely on system garbage collection because
it might take some time before the garbage collector reclaims the <code>MediaPlayer</code>,
as it's only sensitive to memory needs and not to shortage of other media-related resources.
So, in the case when you're using a service, you should always override the
<code>onDestroy()</code> method to make sure you are releasing
the <code>MediaPlayer</code>:</p>
<p>WHATSON? 3ff273b1-9566-4105-a878-999100173b9d</p>
<pre>
public class MyService extends Service {
   MediaPlayer mMediaPlayer;
   // ...

   @Override
   public void onDestroy() {
       if (mMediaPlayer != null) mMediaPlayer.release();
   }
}
</pre>
<p>You should always look for other opportunities to release your <code>MediaPlayer</code>
as well, apart from releasing it when being shut down. For example, if you expect not
to be able to play media for an extended period of time (after losing audio focus, for example),
you should definitely release your existing <code>MediaPlayer</code> and create it again
later. On the
other hand, if you only expect to stop playback for a very short time, you should probably
hold on to your <code>MediaPlayer</code> to avoid the overhead of creating and preparing it
again.</p>
<h2>Handling the AUDIO_BECOMING_NOISY Intent</h2>
<p>Many well-written applications that play audio automatically stop playback when an event
occurs that causes the audio to become noisy (ouput through external speakers). For instance,
this might happen when a user is listening to music through headphones and accidentally
disconnects the headphones from the device. However, this behavior does not happen automatically.
If you don't implement this feature, audio plays out of the device's external speakers, which
might not be what the user wants.</p>
<p>You can ensure your app stops playing music in these situations by handling
the <code>ACTION_AUDIO_BECOMING_NOISY</code> intent, for which you can
register a receiver by
adding the following to your manifest:</p>
<p>WHATSON? c98cf86c-ccdf-40bf-ac9c-d8ea675128df</p>
<pre>
&lt;receiver android:name=".MusicIntentReceiver"&gt;
   &lt;intent-filter&gt;
      &lt;action android:name="android.media.AUDIO_BECOMING_NOISY" /&gt;
   &lt;/intent-filter&gt;
&lt;/receiver&gt;
</pre>
<p>This registers the <code>MusicIntentReceiver</code> class as a broadcast receiver for that
intent. You should then implement this class:</p>
<p>WHATSON? f748ed5a-70fe-4ce0-9450-762e164bea83</p>
<pre>
public class MusicIntentReceiver extends android.content.BroadcastReceiver {
   @Override
   public void onReceive(Context ctx, Intent intent) {
      if (intent.getAction().equals(
                    android.media.AudioManager.ACTION_AUDIO_BECOMING_NOISY)) {
          // signal your service to stop playback
          // (via an Intent, for instance)
      }
   }
}
</pre>
<h2>Retrieving Media from a Content Resolver</h2>
<p>Another feature that may be useful in a media player application is the ability to
retrieve music that the user has on the device. You can do that by querying the <code>ContentResolver</code> for external media:</p>
<p>WHATSON? 48f6bf28-dd39-4f71-94fc-98d183350972</p>
<pre>
ContentResolver contentResolver = getContentResolver();
Uri uri = android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
Cursor cursor = contentResolver.query(uri, null, null, null, null);
if (cursor == null) {
    // query failed, handle error.
} else if (!cursor.moveToFirst()) {
    // no media on the device
} else {
    int titleColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media.TITLE);
    int idColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media._ID);
    do {
       long thisId = cursor.getLong(idColumn);
       String thisTitle = cursor.getString(titleColumn);
       // ...process entry...
    } while (cursor.moveToNext());
}
</pre>
<p>To use this with the <code>MediaPlayer</code>, you can do this:</p>
<p>WHATSON? 73c386a5-6066-44fa-8c3d-a08ebfa7e4de</p>
<pre>
long id = /* retrieve it from somewhere */;
Uri contentUri = ContentUris.withAppendedId(
        android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);

mMediaPlayer = new MediaPlayer();
mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
mMediaPlayer.setDataSource(getApplicationContext(), contentUri);

// ...prepare and start...
</pre>
<h1>Media Playback</h1>
<h2>In this document</h2>
<ol>
<li>The Basics
</li><li>Manifest Declarations</li>
<li>Using MediaPlayer
   <ol>
      <li>Asynchronous Preparation</li>
      <li>Managing State</li>
      <li>Releasing the MediaPlayer</li>
   </ol>
</li>
<li>Using a Service with MediaPlayer
   <ol>
      <li>Running asynchronously</li>
      <li>Handling asynchronous errors</li>
      <li>Using wake locks</li>
      <li>Running as a foreground service</li>
      <li>Handling audio focus</li>
      <li>Performing cleanup</li>
   </ol>
</li>
<li>Handling the AUDIO_BECOMING_NOISY Intent
</li><li>Retrieving Media from a Content Resolver
</li></ol>
<ol>
      <li>Asynchronous Preparation</li>
      <li>Managing State</li>
      <li>Releasing the MediaPlayer</li>
   </ol>
<ol>
      <li>Running asynchronously</li>
      <li>Handling asynchronous errors</li>
      <li>Using wake locks</li>
      <li>Running as a foreground service</li>
      <li>Handling audio focus</li>
      <li>Performing cleanup</li>
   </ol>
<h2>Key classes</h2>
<ol>
<li><code>MediaPlayer</code></li>
<li><code>AudioManager</code></li>
<li><code>SoundPool</code></li>
</ol>
<h2>See also</h2>
<ol>
<li>JetPlayer</li>
<li>Audio Capture</li>
<li>Android Supported Media Formats</li>
<li>Data Storage</li>
</ol>
<p>The Android multimedia framework includes support for playing variety of common media types, so
that you can easily integrate audio, video and images into your applications. You can play audio or
video from media files stored in your application's resources (raw resources), from standalone files
in the filesystem, or from a data stream arriving over a network connection, all using <code>MediaPlayer</code> APIs.</p>
<p>This document shows you how to write a media-playing application that interacts with the user and
the system in order to obtain good performance and a pleasant user experience.</p>
<p><strong>Note:</strong> You can play back the audio data only to the standard output
device. Currently, that is the mobile device speaker or a Bluetooth headset. You cannot play sound
files in the conversation audio during a call.</p>
<h2>The Basics</h2>
<p>The following classes are used to play sound and video in the Android framework:</p>
<h2>Manifest Declarations</h2>
<p>Before starting development on your application using MediaPlayer, make sure your manifest has
the appropriate declarations to allow use of related features.</p>
<ul>
  <li><strong>Internet Permission</strong> - If you are using MediaPlayer to stream network-based
content, your application must request network access.
<pre>
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
</pre>
  </li>
  <li><strong>Wake Lock Permission</strong> - If your player application needs to keep the screen
from dimming or the processor from sleeping, or uses the <code>MediaPlayer.setScreenOnWhilePlaying()</code> or
<code>MediaPlayer.setWakeMode()</code> methods, you must request this permission.
<pre>
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
</pre>
  </li>
</ul>
<p>WHATSON? 853c47b8-b861-4215-9667-42c442e2c3ce</p>
<pre>
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
</pre>
<p>WHATSON? 6eaa6fc1-052d-44e4-b041-00551e9c2103</p>
<pre>
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
</pre>
<h2>Using MediaPlayer</h2>
<p>One of the most important components of the media framework is the
<code>MediaPlayer</code>
class. An object of this class can fetch, decode, and play both audio and video
with minimal setup. It supports several different media sources such as:
</p>
<ul>
   <li>Local resources</li>
   <li>Internal URIs, such as one you might obtain from a Content Resolver</li>
   <li>External URLs (streaming)</li>
</ul>
<p>For a list of media formats that Android supports,
see the Android Supported Media
Formats document. </p>
<p>Here is an example
of how to play audio that's available as a local raw resource (saved in your application's
<code>res/raw/</code> directory):</p>
<p>WHATSON? e5383a30-2977-4825-8a6e-9b02002c4c1e</p>
<pre>MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);
mediaPlayer.start(); // no need to call prepare(); create() does that for you
</pre>
<p>In this case, a "raw" resource is a file that the system does not
try to parse in any particular way. However, the content of this resource should not
be raw audio. It should be a properly encoded and formatted media file in one
of the supported formats.</p>
<p>And here is how you might play from a URI available locally in the system
(that you obtained through a Content Resolver, for instance):</p>
<p>WHATSON? d0205ccb-bc5d-4c92-b163-5a6c4b31fb90</p>
<pre>Uri myUri = ....; // initialize Uri here
MediaPlayer mediaPlayer = new MediaPlayer();
mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
mediaPlayer.setDataSource(getApplicationContext(), myUri);
mediaPlayer.prepare();
mediaPlayer.start();</pre>
<p>Playing from a remote URL via HTTP streaming looks like this:</p>
<p>WHATSON? 1c5c11f0-b193-4031-9d5c-fc049bb4abe8</p>
<pre>String url = "http://........"; // your URL here
MediaPlayer mediaPlayer = new MediaPlayer();
mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
mediaPlayer.setDataSource(url);
mediaPlayer.prepare(); // might take long! (for buffering, etc)
mediaPlayer.start();</pre>
<p><strong>Note:</strong>
If you're passing a URL to stream an online media file, the file must be capable of
progressive download.</p>
<p><strong>Caution:</strong> You must either catch or pass
<code>IllegalArgumentException</code> and <code>IOException</code> when using
<code>setDataSource()</code>, because
the file you are referencing might not exist.</p>
<h3>Asynchronous Preparation</h3>
<p>Using <code>MediaPlayer</code> can be straightforward in
principle. However, it's important to keep in mind that a few more things are
necessary to integrate it correctly with a typical Android application. For
example, the call to <code>prepare()</code> can
take a long time to execute, because
it might involve fetching and decoding media data. So, as is the case with any
method that may take long to execute, you should <strong>never call it from your
application's UI thread</strong>. Doing that will cause the UI to hang until the method returns,
which is a very bad user experience and can cause an ANR (Application Not Responding) error. Even if
you expect your resource to load quickly, remember that anything that takes more than a tenth
of a second to respond in the UI will cause a noticeable pause and will give
the user the impression that your application is slow.</p>
<p>To avoid hanging your UI thread, spawn another thread to
prepare the <code>MediaPlayer</code> and notify the main thread when done. However, while
you could write the threading logic
yourself, this pattern is so common when using <code>MediaPlayer</code> that the framework
supplies a convenient way to accomplish this task by using the
<code>prepareAsync()</code> method. This method
starts preparing the media in the background and returns immediately. When the media
is done preparing, the <code>onPrepared()</code>
method of the <code>MediaPlayer.OnPreparedListener</code>, configured through
<code>setOnPreparedListener()</code> is called.</p>
<h3>Managing State</h3>
<p>Another aspect of a <code>MediaPlayer</code> that you should keep in mind is
that it's state-based. That is, the <code>MediaPlayer</code> has an internal state
that you must always be aware of when writing your code, because certain operations
are only valid when then player is in specific states. If you perform an operation while in the
wrong state, the system may throw an exception or cause other undesireable behaviors.</p>
<p>The documentation in the
<code>MediaPlayer</code> class shows a complete state diagram,
that clarifies which methods move the <code>MediaPlayer</code> from one state to another.
For example, when you create a new <code>MediaPlayer</code>, it is in the <em>Idle</em>
state. At that point, you should initialize it by calling
<code>setDataSource()</code>, bringing it
to the <em>Initialized</em> state. After that, you have to prepare it using either the
<code>prepare()</code> or
<code>prepareAsync()</code> method. When
the <code>MediaPlayer</code> is done preparing, it will then enter the <em>Prepared</em>
state, which means you can call <code>start()</code>
to make it play the media. At that point, as the diagram illustrates,
you can move between the <em>Started</em>, <em>Paused</em> and <em>PlaybackCompleted</em> states by
calling such methods as
<code>start()</code>,
<code>pause()</code>, and
<code>seekTo()</code>,
amongst others. When you
call <code>stop()</code>, however, notice that you
cannot call <code>start()</code> again until you
prepare the <code>MediaPlayer</code> again.</p>
<p>Always keep the state diagram
in mind when writing code that interacts with a
<code>MediaPlayer</code> object, because calling its methods from the wrong state is a
common cause of bugs.</p>
<h3>Releasing the MediaPlayer</h3>
<p>A <code>MediaPlayer</code> can consume valuable
system resources.
Therefore, you should always take extra precautions to make sure you are not
hanging on to a <code>MediaPlayer</code> instance longer than necessary. When you
are done with it, you should always call
<code>release()</code> to make sure any
system resources allocated to it are properly released. For example, if you are
using a <code>MediaPlayer</code> and your activity receives a call to <code>onStop()</code>, you must release the <code>MediaPlayer</code>,
because it
makes little sense to hold on to it while your activity is not interacting with
the user (unless you are playing media in the background, which is discussed in the next section).
When your activity is resumed or restarted, of course, you need to
create a new <code>MediaPlayer</code> and prepare it again before resuming playback.</p>
<p>Here's how you should release and then nullify your <code>MediaPlayer</code>:</p>
<p>WHATSON? d73a98e0-ca17-47c1-8b38-f0d6b6ded1ba</p>
<pre>
mediaPlayer.release();
mediaPlayer = null;
</pre>
<p>As an example, consider the problems that could happen if you
forgot to release the <code>MediaPlayer</code> when your activity is stopped, but create a
new one when the activity starts again. As you may know, when the user changes the
screen orientation (or changes the device configuration in another way),
the system handles that by restarting the activity (by default), so you might quickly
consume all of the system resources as the user
rotates the device back and forth between portrait and landscape, because at each
orientation change, you create a new <code>MediaPlayer</code> that you never
release. (For more information about runtime restarts, see Handling Runtime Changes.)</p>
<p>You may be wondering what happens if you want to continue playing
"background media" even when the user leaves your activity, much in the same
way that the built-in Music application behaves. In this case, what you need is
a <code>MediaPlayer</code> controlled by a <code>Service</code>, as
discussed in Using a Service with MediaPlayer.</p>
<h2>Using a Service with MediaPlayer</h2>
<p>If you want your media to play in the background even when your application
is not onscreen—that is, you want it to continue playing while the user is
interacting with other applications—then you must start a
<code>Service</code> and control the
<code>MediaPlayer</code> instance from there.
You should be careful about this setup, because the user and the system have expectations
about how an application running a background service should interact with the rest of the
system. If your application does not fulfil those expectations, the user may
have a bad experience. This section describes the main issues that you should be
aware of and offers suggestions about how to approach them.</p>
<h3>Running asynchronously</h3>
<p>First of all, like an <code>Activity</code>, all work in a
<code>Service</code> is done in a single thread by
default—in fact, if you're running an activity and a service from the same application, they
use the same thread (the "main thread") by default. Therefore, services need to
process incoming intents quickly
and never perform lengthy computations when responding to them. If any heavy
work or blocking calls are expected, you must do those tasks asynchronously: either from
another thread you implement yourself, or using the framework's many facilities
for asynchronous processing.</p>
<p>For instance, when using a <code>MediaPlayer</code> from your main thread,
you should call <code>prepareAsync()</code> rather than
<code>prepare()</code>, and implement
a <code>MediaPlayer.OnPreparedListener</code>
in order to be notified when the preparation is complete and you can start playing.
For example:</p>
<p>WHATSON? a3d6b8de-e7dd-42a9-9063-71029e53ce86</p>
<pre>
public class MyService extends Service implements MediaPlayer.OnPreparedListener {
    private static final String ACTION_PLAY = "com.example.action.PLAY";
    MediaPlayer mMediaPlayer = null;

    public int onStartCommand(Intent intent, int flags, int startId) {
        ...
        if (intent.getAction().equals(ACTION_PLAY)) {
            mMediaPlayer = ... // initialize it here
            mMediaPlayer.setOnPreparedListener(this);
            mMediaPlayer.prepareAsync(); // prepare async to not block main thread
        }
    }

    /** Called when MediaPlayer is ready */
    public void onPrepared(MediaPlayer player) {
        player.start();
    }
}
</pre>
<h3>Handling asynchronous errors</h3>
<p>On synchronous operations, errors would normally
be signaled with an exception or an error code, but whenever you use asynchronous
resources, you should make sure your application is notified
of errors appropriately. In the case of a <code>MediaPlayer</code>,
you can accomplish this by implementing a
<code>MediaPlayer.OnErrorListener</code> and
setting it in your <code>MediaPlayer</code> instance:</p>
<p>WHATSON? d3b97a74-915f-490e-b698-ec3dd939f64e</p>
<pre>
public class MyService extends Service implements MediaPlayer.OnErrorListener {
    MediaPlayer mMediaPlayer;

    public void initMediaPlayer() {
        // ...initialize the MediaPlayer here...

        mMediaPlayer.setOnErrorListener(this);
    }

    @Override
    public boolean onError(MediaPlayer mp, int what, int extra) {
        // ... react appropriately ...
        // The MediaPlayer has moved to the Error state, must be reset!
    }
}
</pre>
<p>It's important to remember that when an error occurs, the <code>MediaPlayer</code>
moves to the <em>Error</em> state (see the documentation for the
<code>MediaPlayer</code> class for the full state diagram)
and you must reset it before you can use it again.


</p>
<h3>Using wake locks</h3>
<p>When designing applications that play media
in the background, the device may go to sleep
while your service is running. Because the Android system tries to conserve
battery while the device is sleeping, the system tries to shut off any
of the phone's features that are
not necessary, including the CPU and the WiFi hardware.
However, if your service is playing or streaming music, you want to prevent
the system from interfering with your playback.</p>
<p>In order to ensure that your service continues to run under
those conditions, you have to use "wake locks." A wake lock is a way to signal to
the system that your application is using some feature that should
stay available even if the phone is idle.</p>
<p><strong>Notice:</strong> You should always use wake locks sparingly and hold them
only for as long as truly necessary, because they significantly reduce the battery life of the
device.</p>
<p>To ensure that the CPU continues running while your <code>MediaPlayer</code> is
playing, call the <code>setWakeMode()</code> method when initializing your <code>MediaPlayer</code>. Once you do,
the <code>MediaPlayer</code> holds the specified lock while playing and releases the lock
when paused or stopped:</p>
<p>WHATSON? ea675aac-d5a1-4558-b09c-2bf486cc5a40</p>
<pre>
mMediaPlayer = new MediaPlayer();
// ... other initialization here ...
mMediaPlayer.setWakeMode(getApplicationContext(), PowerManager.PARTIAL_WAKE_LOCK);
</pre>
<p>However, the wake lock acquired in this example guarantees only that the CPU remains awake. If
you are streaming media over the
network and you are using Wi-Fi, you probably want to hold a
<code>WifiLock</code> as
well, which you must acquire and release manually. So, when you start preparing the
<code>MediaPlayer</code> with the remote URL, you should create and acquire the Wi-Fi lock.
For example:</p>
<p>WHATSON? a7b802cd-2f9a-4309-b1d7-4c6c7b7f6572</p>
<pre>
WifiLock wifiLock = ((WifiManager) getSystemService(Context.WIFI_SERVICE))
    .createWifiLock(WifiManager.WIFI_MODE_FULL, "mylock");

wifiLock.acquire();
</pre>
<p>When you pause or stop your media, or when you no longer need the
network, you should release the lock:</p>
<p>WHATSON? fc525387-13b5-4334-ae27-dbf1afefc64e</p>
<pre>
wifiLock.release();
</pre>
<h3>Running as a foreground service</h3>
<p>Services are often used for performing background tasks, such as fetching emails,
synchronizing data, downloading content, amongst other possibilities. In these
cases, the user is not actively aware of the service's execution, and probably
wouldn't even notice if some of these services were interrupted and later restarted.</p>
<p>But consider the case of a service that is playing music. Clearly this is a service that the user
is actively aware of and the experience would be severely affected by any interruptions.
Additionally, it's a service that the user will likely wish to interact with during its execution.
In this case, the service should run as a "foreground service." A
foreground service holds a higher level of importance within the system—the system will
almost never kill the service, because it is of immediate importance to the user. When running
in the foreground, the service also must provide a status bar notification to ensure that users are
aware of the running service and allow them to open an activity that can interact with the
service.</p>
<p>In order to turn your service into a foreground service, you must create a
<code>Notification</code> for the status bar and call
<code>startForeground()</code> from the <code>Service</code>. For example:</p>
<p>WHATSON? a622bb9e-7eb6-4212-aa8d-0a580b817845</p>
<pre>String songName;
// assign the song name to songName
PendingIntent pi = PendingIntent.getActivity(getApplicationContext(), 0,
                new Intent(getApplicationContext(), MainActivity.class),
                PendingIntent.FLAG_UPDATE_CURRENT);
Notification notification = new Notification();
notification.tickerText = text;
notification.icon = R.drawable.play0;
notification.flags |= Notification.FLAG_ONGOING_EVENT;
notification.setLatestEventInfo(getApplicationContext(), "MusicPlayerSample",
                "Playing: " + songName, pi);
startForeground(NOTIFICATION_ID, notification);
</pre>
<p>While your service is running in the foreground, the notification you
configured is visible in the notification area of the device. If the user
selects the notification, the system invokes the <code>PendingIntent</code> you supplied. In
the example above, it opens an activity (<code>MainActivity</code>).</p>
<p>Figure 1 shows how your notification appears to the user:</p>
<p><strong>Figure 1.</strong> Screenshots of a foreground service's
notification, showing the notification icon in the status bar (left) and the expanded view
(right).</p>
<p>You should only hold on to the "foreground service" status while your
service is actually performing something the user is actively aware of. Once
that is no longer true, you should release it by calling
<code>stopForeground()</code>:</p>
<p>WHATSON? dcfb68e3-c6ca-4754-92ec-203b9143a2ea</p>
<pre>
stopForeground(true);
</pre>
<p>For more information, see the documentation about Services and
Status Bar Notifications.</p>
<h3>Handling audio focus</h3>
<p>Even though only one activity can run at any given time, Android is a
multi-tasking environment. This poses a particular challenge to applications
that use audio, because there is only one audio output and there may be several
media services competing for its use. Before Android 2.2, there was no built-in
mechanism to address this issue, which could in some cases lead to a bad user
experience. For example, when a user is listening to
music and another application needs to notify the user of something very important,
the user might not hear the notification tone due to the loud music. Starting with
Android 2.2, the platform offers a way for applications to negotiate their
use of the device's audio output. This mechanism is called Audio Focus.</p>
<p>When your application needs to output audio such as music or a notification,
you should always request audio focus. Once it has focus, it can use the sound output freely, but it
should
always listen for focus changes. If it is notified that it has lost the audio
focus, it should immediately either kill the audio or lower it to a quiet level
(known as "ducking"—there is a flag that indicates which one is appropriate) and only resume
loud playback after it receives focus again.</p>
<p>Audio Focus is cooperative in nature. That is, applications are expected
(and highly encouraged) to comply with the audio focus guidelines, but the
rules are not enforced by the system. If an application wants to play loud
music even after losing audio focus, nothing in the system will prevent that.
However, the user is more likely to have a bad experience and will be more
likely to uninstall the misbehaving application.</p>
<p>To request audio focus, you must call
<code>requestAudioFocus()</code> from the <code>AudioManager</code>, as the example below demonstrates:</p>
<p>WHATSON? 9215f004-a431-49e1-9c83-699bfdf9dddd</p>
<pre>
AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
int result = audioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC,
    AudioManager.AUDIOFOCUS_GAIN);

if (result != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
    // could not get audio focus.
}
</pre>
<p>The first parameter to <code>requestAudioFocus()</code>
is an <code>AudioManager.OnAudioFocusChangeListener</code>,
whose <code>onAudioFocusChange()</code> method is called whenever there is a change in audio focus. Therefore, you
should also implement this interface on your service and activities. For example:</p>
<p>WHATSON? 9370eec0-c152-4319-b42f-d559058f9e6c</p>
<pre>
class MyService extends Service
                implements AudioManager.OnAudioFocusChangeListener {
    // ....
    public void onAudioFocusChange(int focusChange) {
        // Do something based on focus change...
    }
}
</pre>
<p>The <code>focusChange</code> parameter tells you how the audio focus has changed, and
can be one of the following values (they are all constants defined in
<code>AudioManager</code>):</p>
<ul>
<li><code>AUDIOFOCUS_GAIN</code>: You have gained the audio focus.</li>

<li><code>AUDIOFOCUS_LOSS</code>: You have lost the audio focus for a
presumably long time.
You must stop all audio playback. Because you should expect not to have focus back
for a long time, this would be a good place to clean up your resources as much
as possible. For example, you should release the <code>MediaPlayer</code>.</li>

<li><code>AUDIOFOCUS_LOSS_TRANSIENT</code>: You have
temporarily lost audio focus, but should receive it back shortly. You must stop
all audio playback, but you can keep your resources because you will probably get
focus back shortly.</li>

<li><code>AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK</code>: You have temporarily
lost audio focus,
but you are allowed to continue to play audio quietly (at a low volume) instead
of killing audio completely.</li>
</ul>
<p>Here is an example implementation:</p>
<p>WHATSON? 0562a294-8a3b-49df-a450-aca423d7f167</p>
<pre>
public void onAudioFocusChange(int focusChange) {
    switch (focusChange) {
        case AudioManager.AUDIOFOCUS_GAIN:
            // resume playback
            if (mMediaPlayer == null) initMediaPlayer();
            else if (!mMediaPlayer.isPlaying()) mMediaPlayer.start();
            mMediaPlayer.setVolume(1.0f, 1.0f);
            break;

        case AudioManager.AUDIOFOCUS_LOSS:
            // Lost focus for an unbounded amount of time: stop playback and release media player
            if (mMediaPlayer.isPlaying()) mMediaPlayer.stop();
            mMediaPlayer.release();
            mMediaPlayer = null;
            break;

        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
            // Lost focus for a short time, but we have to stop
            // playback. We don't release the media player because playback
            // is likely to resume
            if (mMediaPlayer.isPlaying()) mMediaPlayer.pause();
            break;

        case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
            // Lost focus for a short time, but it's ok to keep playing
            // at an attenuated level
            if (mMediaPlayer.isPlaying()) mMediaPlayer.setVolume(0.1f, 0.1f);
            break;
    }
}
</pre>
<p>Keep in mind that the audio focus APIs are available only with API level 8 (Android 2.2)
and above, so if you want to support previous
versions of Android, you should adopt a backward compatibility strategy that
allows you to use this feature if available, and fall back seamlessly if not.</p>
<p>You can achieve backward compatibility either by calling the audio focus methods by reflection
or by implementing all the audio focus features in a separate class (say,
<code>AudioFocusHelper</code>). Here is an example of such a class:</p>
<p>WHATSON? 94aed3cf-860a-4a1f-8549-cfef52c23800</p>
<pre>
public class AudioFocusHelper implements AudioManager.OnAudioFocusChangeListener {
    AudioManager mAudioManager;

    // other fields here, you'll probably hold a reference to an interface
    // that you can use to communicate the focus changes to your Service

    public AudioFocusHelper(Context ctx, /* other arguments here */) {
        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
        // ...
    }

    public boolean requestFocus() {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED ==
            mAudioManager.requestAudioFocus(mContext, AudioManager.STREAM_MUSIC,
            AudioManager.AUDIOFOCUS_GAIN);
    }

    public boolean abandonFocus() {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED ==
            mAudioManager.abandonAudioFocus(this);
    }

    @Override
    public void onAudioFocusChange(int focusChange) {
        // let your service know about the focus change
    }
}
</pre>
<p>You can create an instance of <code>AudioFocusHelper</code> class only if you detect that
the system is running API level 8 or above. For example:</p>
<p>WHATSON? 230f2249-750b-490e-bc43-78a1b80cc969</p>
<pre>
if (android.os.Build.VERSION.SDK_INT &gt;= 8) {
    mAudioFocusHelper = new AudioFocusHelper(getApplicationContext(), this);
} else {
    mAudioFocusHelper = null;
}
</pre>
<h3>Performing cleanup</h3>
<p>As mentioned earlier, a <code>MediaPlayer</code> object can consume a significant
amount of system resources, so you should keep it only for as long as you need and call
<code>release()</code> when you are done with it. It's important
to call this cleanup method explicitly rather than rely on system garbage collection because
it might take some time before the garbage collector reclaims the <code>MediaPlayer</code>,
as it's only sensitive to memory needs and not to shortage of other media-related resources.
So, in the case when you're using a service, you should always override the
<code>onDestroy()</code> method to make sure you are releasing
the <code>MediaPlayer</code>:</p>
<p>WHATSON? ce0dc7d5-1f46-407b-b6a1-35f2345e710e</p>
<pre>
public class MyService extends Service {
   MediaPlayer mMediaPlayer;
   // ...

   @Override
   public void onDestroy() {
       if (mMediaPlayer != null) mMediaPlayer.release();
   }
}
</pre>
<p>You should always look for other opportunities to release your <code>MediaPlayer</code>
as well, apart from releasing it when being shut down. For example, if you expect not
to be able to play media for an extended period of time (after losing audio focus, for example),
you should definitely release your existing <code>MediaPlayer</code> and create it again
later. On the
other hand, if you only expect to stop playback for a very short time, you should probably
hold on to your <code>MediaPlayer</code> to avoid the overhead of creating and preparing it
again.</p>
<h2>Handling the AUDIO_BECOMING_NOISY Intent</h2>
<p>Many well-written applications that play audio automatically stop playback when an event
occurs that causes the audio to become noisy (ouput through external speakers). For instance,
this might happen when a user is listening to music through headphones and accidentally
disconnects the headphones from the device. However, this behavior does not happen automatically.
If you don't implement this feature, audio plays out of the device's external speakers, which
might not be what the user wants.</p>
<p>You can ensure your app stops playing music in these situations by handling
the <code>ACTION_AUDIO_BECOMING_NOISY</code> intent, for which you can
register a receiver by
adding the following to your manifest:</p>
<p>WHATSON? 11811271-3f6f-41c5-b0bb-b0512fbc08a9</p>
<pre>
&lt;receiver android:name=".MusicIntentReceiver"&gt;
   &lt;intent-filter&gt;
      &lt;action android:name="android.media.AUDIO_BECOMING_NOISY" /&gt;
   &lt;/intent-filter&gt;
&lt;/receiver&gt;
</pre>
<p>This registers the <code>MusicIntentReceiver</code> class as a broadcast receiver for that
intent. You should then implement this class:</p>
<p>WHATSON? 3ec66506-403c-4535-b3c4-9fcb0cb0bede</p>
<pre>
public class MusicIntentReceiver extends android.content.BroadcastReceiver {
   @Override
   public void onReceive(Context ctx, Intent intent) {
      if (intent.getAction().equals(
                    android.media.AudioManager.ACTION_AUDIO_BECOMING_NOISY)) {
          // signal your service to stop playback
          // (via an Intent, for instance)
      }
   }
}
</pre>
<h2>Retrieving Media from a Content Resolver</h2>
<p>Another feature that may be useful in a media player application is the ability to
retrieve music that the user has on the device. You can do that by querying the <code>ContentResolver</code> for external media:</p>
<p>WHATSON? 6f267077-2e20-4fe0-a99c-850340db5b64</p>
<pre>
ContentResolver contentResolver = getContentResolver();
Uri uri = android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
Cursor cursor = contentResolver.query(uri, null, null, null, null);
if (cursor == null) {
    // query failed, handle error.
} else if (!cursor.moveToFirst()) {
    // no media on the device
} else {
    int titleColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media.TITLE);
    int idColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media._ID);
    do {
       long thisId = cursor.getLong(idColumn);
       String thisTitle = cursor.getString(titleColumn);
       // ...process entry...
    } while (cursor.moveToNext());
}
</pre>
<p>To use this with the <code>MediaPlayer</code>, you can do this:</p>
<p>WHATSON? 01d7eda6-610b-414f-be16-07862dce5180</p>
<pre>
long id = /* retrieve it from somewhere */;
Uri contentUri = ContentUris.withAppendedId(
        android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);

mMediaPlayer = new MediaPlayer();
mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
mMediaPlayer.setDataSource(getApplicationContext(), contentUri);

// ...prepare and start...
</pre>
</body>
</html>