<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Fiber-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Fiber (computer science)</h1>
<p>In computer science, a <b>fiber</b> is a particularly lightweight thread of execution.</p>
<p>Like threads, fibers share address space. However, fibers use co-operative multitasking while threads use pre-emptive multitasking. Threads often depend on the kernel's thread scheduler to preempt a busy thread and resume another thread; fibers yield themselves to run another fiber while executing. The article on threads contains more on the distinction between threads and fibers.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Fibers and coroutines</li>
<li>2 Advantages and disadvantages</li>
<li>3 Operating system support</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<p></p>
<h2>Fibers and coroutines</h2>
<p>Fibers describe essentially the same concept as coroutines. The distinction, if there is any, is that coroutines are a language-level construct, a form of control flow, while fibers are a systems-level construct, viewed as threads that happen not to run concurrently. Priority is contentious; fibers may be viewed as an implementation of coroutines, or as a substrate on which to implement coroutines.</p>
<h2>Advantages and disadvantages</h2>
<p>Because fibers multitask cooperatively, thread safety is less of an issue than with preemptively scheduled threads, and synchronization constructs including spinlocks and atomic operations are unnecessary when writing fibered code, as they are implicitly synchronized. However, many libraries yield a fiber implicitly as a method of conducting non-blocking I/O; as such, some caution and documentation reading is advised. A disadvantage is that fibers cannot utilize multiprocessor machines without also using preemptive threads; however, an M:N threading model with no more preemptive threads than CPU cores can be more efficient than either pure fibers or pure preemptive threading.</p>
<p>In modern server programs fibers are being used to soft block themselves to allow their one threaded parent programs to continue working. In this design, fibers are being used mostly for i/o access which does not need cpu processing. So, the main program can go on what it is doing. Fibers yield control to the one threaded main program and when related i/o operation event occurred in the operating system like i/o operation has been completed; fibers go on where they left off.</p>
<h2>Operating system support</h2>
<p>Less support from the operating system is needed for fibers than for threads. They can be implemented in modern Unix systems using the library functions getcontext, setcontext and swapcontext in ucontext.h, as in GNU Portable Threads.</p>
<p>On Microsoft Windows, fibers are created using the ConvertThreadToFiber and CreateFiber calls; a fiber that is currently suspended may be resumed in any thread. Fiber-local storage, analogous to thread-local storage, may be used to create unique copies of variables.</p>
<p>Symbian OS uses a similar concept to fibers in its Active Scheduler. An active object contains one fiber to be executed by the Active Scheduler when one of several outstanding asynchronous calls complete. Several Active objects can be waiting to execute (based on priority) and each one must restrict its own execution time.</p>
<h2>See also</h2>
<ul>
<li>getcontext/setcontext library routines</li>
<li>Green threads</li>
</ul>
</body>
</html>