<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Relational-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Relational programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li><strong class="selflink">Relational</strong></li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li><strong class="selflink">Relational</strong></li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>Relational programming is based on the mathematical relation. A relation is a table of which has a column, or columns for inputs and a column for outputs. A function is a type of relation.</p>
<p>Logic programming is based on a restricted implementation of <b>relational programming</b>. The output value of all relations is always boolean. Resulting values are interpreted using negation as failure. Relation programming does not require this. Some logic programming systems extend this model with the use of constraints.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Logic programming</li>
<li>3 Narrowing
<ul>
<li>3.1 The relational model</li>
<li>3.2 Relational evaluation</li>
<li>3.3 Known and unknown values</li>
<li>3.4 Deductions
<ul>
<li>3.4.1 Comparison
<ul>
<li>3.4.1.1 Equality</li>
</ul>
</li>
<li>3.4.2 Boolean
<ul>
<li>3.4.2.1 Not</li>
<li>3.4.2.2 And</li>
<li>3.4.2.3 Or</li>
<li>3.4.2.4 If</li>
</ul>
</li>
<li>3.4.3 Rational number
<ul>
<li>3.4.3.1 Addition</li>
<li>3.4.3.2 Subtraction</li>
<li>3.4.3.3 Multiplicition</li>
<li>3.4.3.4 Division</li>
<li>3.4.3.5 Square</li>
<li>3.4.3.6 Square root</li>
<li>3.4.3.7 Exponential</li>
<li>3.4.3.8 Natual logarithm</li>
</ul>
</li>
<li>3.4.4 String
<ul>
<li>3.4.4.1 Concatenation</li>
<li>3.4.4.2 SelectLeftChar</li>
<li>3.4.4.3 SelectRightChar</li>
<li>3.4.4.4 SubtractLeft</li>
<li>3.4.4.5 SubtractRight</li>
</ul>
</li>
<li>3.4.5 String reference
<ul>
<li>3.4.5.1 Concatenation</li>
</ul>
</li>
<li>3.4.6 Function
<ul>
<li>3.4.6.1 Function application</li>
</ul>
</li>
</ul>
</li>
<li>3.5 Value sets</li>
<li>3.6 Order of evaluation</li>
<li>3.7 The relational model of state
<ul>
<li>3.7.1 Transformations on imperative programs</li>
<li>3.7.2 State holder</li>
<li>3.7.3 The use-mention distinction</li>
<li>3.7.4 Expressions
<ul>
<li>3.7.4.1 Assignment</li>
<li>3.7.4.2 State lookup</li>
<li>3.7.4.3 State transfer</li>
<li>3.7.4.4 Example</li>
</ul>
</li>
<li>3.7.5 Control statements
<ul>
<li>3.7.5.1 Statement composition</li>
<li>3.7.5.2 If statement</li>
</ul>
</li>
<li>3.7.6 While statement</li>
</ul>
</li>
<li>3.8 Functions and return values
<ul>
<li>3.8.1 Return frame</li>
<li>3.8.2 Declaration frame</li>
<li>3.8.3 Return statement</li>
</ul>
</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<ul>
<li>3.1 The relational model</li>
<li>3.2 Relational evaluation</li>
<li>3.3 Known and unknown values</li>
<li>3.4 Deductions
<ul>
<li>3.4.1 Comparison
<ul>
<li>3.4.1.1 Equality</li>
</ul>
</li>
<li>3.4.2 Boolean
<ul>
<li>3.4.2.1 Not</li>
<li>3.4.2.2 And</li>
<li>3.4.2.3 Or</li>
<li>3.4.2.4 If</li>
</ul>
</li>
<li>3.4.3 Rational number
<ul>
<li>3.4.3.1 Addition</li>
<li>3.4.3.2 Subtraction</li>
<li>3.4.3.3 Multiplicition</li>
<li>3.4.3.4 Division</li>
<li>3.4.3.5 Square</li>
<li>3.4.3.6 Square root</li>
<li>3.4.3.7 Exponential</li>
<li>3.4.3.8 Natual logarithm</li>
</ul>
</li>
<li>3.4.4 String
<ul>
<li>3.4.4.1 Concatenation</li>
<li>3.4.4.2 SelectLeftChar</li>
<li>3.4.4.3 SelectRightChar</li>
<li>3.4.4.4 SubtractLeft</li>
<li>3.4.4.5 SubtractRight</li>
</ul>
</li>
<li>3.4.5 String reference
<ul>
<li>3.4.5.1 Concatenation</li>
</ul>
</li>
<li>3.4.6 Function
<ul>
<li>3.4.6.1 Function application</li>
</ul>
</li>
</ul>
</li>
<li>3.5 Value sets</li>
<li>3.6 Order of evaluation</li>
<li>3.7 The relational model of state
<ul>
<li>3.7.1 Transformations on imperative programs</li>
<li>3.7.2 State holder</li>
<li>3.7.3 The use-mention distinction</li>
<li>3.7.4 Expressions
<ul>
<li>3.7.4.1 Assignment</li>
<li>3.7.4.2 State lookup</li>
<li>3.7.4.3 State transfer</li>
<li>3.7.4.4 Example</li>
</ul>
</li>
<li>3.7.5 Control statements
<ul>
<li>3.7.5.1 Statement composition</li>
<li>3.7.5.2 If statement</li>
</ul>
</li>
<li>3.7.6 While statement</li>
</ul>
</li>
<li>3.8 Functions and return values
<ul>
<li>3.8.1 Return frame</li>
<li>3.8.2 Declaration frame</li>
<li>3.8.3 Return statement</li>
</ul>
</li>
</ul>
<ul>
<li>3.4.1 Comparison
<ul>
<li>3.4.1.1 Equality</li>
</ul>
</li>
<li>3.4.2 Boolean
<ul>
<li>3.4.2.1 Not</li>
<li>3.4.2.2 And</li>
<li>3.4.2.3 Or</li>
<li>3.4.2.4 If</li>
</ul>
</li>
<li>3.4.3 Rational number
<ul>
<li>3.4.3.1 Addition</li>
<li>3.4.3.2 Subtraction</li>
<li>3.4.3.3 Multiplicition</li>
<li>3.4.3.4 Division</li>
<li>3.4.3.5 Square</li>
<li>3.4.3.6 Square root</li>
<li>3.4.3.7 Exponential</li>
<li>3.4.3.8 Natual logarithm</li>
</ul>
</li>
<li>3.4.4 String
<ul>
<li>3.4.4.1 Concatenation</li>
<li>3.4.4.2 SelectLeftChar</li>
<li>3.4.4.3 SelectRightChar</li>
<li>3.4.4.4 SubtractLeft</li>
<li>3.4.4.5 SubtractRight</li>
</ul>
</li>
<li>3.4.5 String reference
<ul>
<li>3.4.5.1 Concatenation</li>
</ul>
</li>
<li>3.4.6 Function
<ul>
<li>3.4.6.1 Function application</li>
</ul>
</li>
</ul>
<ul>
<li>3.4.1.1 Equality</li>
</ul>
<ul>
<li>3.4.2.1 Not</li>
<li>3.4.2.2 And</li>
<li>3.4.2.3 Or</li>
<li>3.4.2.4 If</li>
</ul>
<ul>
<li>3.4.3.1 Addition</li>
<li>3.4.3.2 Subtraction</li>
<li>3.4.3.3 Multiplicition</li>
<li>3.4.3.4 Division</li>
<li>3.4.3.5 Square</li>
<li>3.4.3.6 Square root</li>
<li>3.4.3.7 Exponential</li>
<li>3.4.3.8 Natual logarithm</li>
</ul>
<ul>
<li>3.4.4.1 Concatenation</li>
<li>3.4.4.2 SelectLeftChar</li>
<li>3.4.4.3 SelectRightChar</li>
<li>3.4.4.4 SubtractLeft</li>
<li>3.4.4.5 SubtractRight</li>
</ul>
<ul>
<li>3.4.5.1 Concatenation</li>
</ul>
<ul>
<li>3.4.6.1 Function application</li>
</ul>
<ul>
<li>3.7.1 Transformations on imperative programs</li>
<li>3.7.2 State holder</li>
<li>3.7.3 The use-mention distinction</li>
<li>3.7.4 Expressions
<ul>
<li>3.7.4.1 Assignment</li>
<li>3.7.4.2 State lookup</li>
<li>3.7.4.3 State transfer</li>
<li>3.7.4.4 Example</li>
</ul>
</li>
<li>3.7.5 Control statements
<ul>
<li>3.7.5.1 Statement composition</li>
<li>3.7.5.2 If statement</li>
</ul>
</li>
<li>3.7.6 While statement</li>
</ul>
<ul>
<li>3.7.4.1 Assignment</li>
<li>3.7.4.2 State lookup</li>
<li>3.7.4.3 State transfer</li>
<li>3.7.4.4 Example</li>
</ul>
<ul>
<li>3.7.5.1 Statement composition</li>
<li>3.7.5.2 If statement</li>
</ul>
<ul>
<li>3.8.1 Return frame</li>
<li>3.8.2 Declaration frame</li>
<li>3.8.3 Return statement</li>
</ul>
<p></p>
<h2>History</h2>
<p>The Turing machine started computers with imperative programming. Imperative programming is an order sequence of statements, where each one calculates outputs from inputs.</p>
<p>Functional programming extends the model by making the statements independent and un-ordered. But still each statement defines only how to calculate the output from the input. Many different paths may be used in calculating the input from the output.</p>
<p>Many real life situations in computer programming require the computer to model changes in the world. Input and output streams needed to be included in functional languages. Initial implementations used imperative features to implement I/O. Later functional languages like haskell used monads to model change within functional programming paradigm.</p>
<p>Logic programming languages based on unification and resolution first provided the possibility of a statement defining different values depending on what values are given. But logic programming restricts the output to Boolean true values, and forces all results to be produced as side effects of the application of statements. Constraints fill in the gaps to some extent.</p>
<p>Languages based on narrowing  provide a general implementation of relational programming.</p>
<h2>Logic programming</h2>
<p>By far the majoratory of relational programming languages are base on logic programming. The success of logic programming is due to efficient implementations based on unification and resolution.</p>
<p>These techniques implement a restricted subset of relational programming. The addition of constraints led to Constraint logic programming. These languages are closer to relational programming.</p>
<h2>Narrowing</h2>
<p>The other method used in implementing relational programming is <b>narrowing</b>. Narrowing extends functional programming to provide relation programming.</p>
<h3>The relational model</h3>
<p>The relational model puts the inputs and outputs on equal symmetrical footing.</p>
<p>The relationship <img class="mwe-math-fallback-image-inline tex" alt="F_r" src="//upload.wikimedia.org/math/0/3/8/038c2a9cc436a789f6bba50d11a03c1b.png"> is a constraint on the inputs and the outputs where the output O assumes an equal role with any of the inputs.</p>
<p>If F is a function then the output O is a single value. But as a relation or constraint, providing n values, leaving one free does not always restrict the remaining variable to one value.</p>
<p>A general method for representing multiple value for a variable as a value set is described in narrowing of algebraic value sets. The value set is treated as a single value by recording context information about the conditions under which each value in the value set is held.</p>
<p>Recording multiple values in a single container allows multiple values to be recorded as a single "value". Recorded relationships between values and possible worlds restrict each value to its proper context.</p>
<p>The model is then extended to allow each input and output to be a value set. A function is then modeled as a constraint between value sets.</p>
<h3>Relational evaluation</h3>
<p>An assertion is an expression that is deemed true. So an expression like,</p>
<p>is a relationship between the values <i>x</i>, <i>5</i>, and <i>true</i>. Because <i>x</i> is unknown, the relationship defines the value of <i>x</i> as <i>5</i>. For another example,</p>
<p>This may be seen as two relationships; a relationship between <i>y</i>, <i>3</i> and another value which we may call <i>x</i>, and a relationship between <i>x</i>, <i>5</i>, and true. The second relationship tells us that <i>x</i> is <i>5</i>, so the first relationship between <i>y</i>, <i>3</i> and <i>5</i>, which gives <i>y</i> is <i>2</i>.</p>
<p><i>y</i> is <i>2</i> is used to represent that <i>y</i> has already been found to have the value <i>2</i>, but <img class="mwe-math-fallback-image-inline tex" alt="y = 2" src="//upload.wikimedia.org/math/9/8/3/9830b0ed5a957ff5ebfc7624a5ed45c5.png"> is a relationship, that implies that <i>y</i> is <i>2</i>.</p>
<p>A relationship has a function, and one or more inverse functions. This set of functions may be used to calculate the unknown value from the known values. What values may be calculated from given inputs depends on the relation.</p>
<p>If the value of a particular value is required, or requested, then a relationship including the variable may be found. That relationship may have more unknowns. These unknowns may then be requested, chaining back eventually to known values.</p>
<p>There are limitations to this strategy. If a variable for a function is given twice, perhaps a recursive function is defined. But in general where a variable appears multiple times, the strategy fails, and the equation may need to be solved by other means.</p>
<h3>Known and unknown values</h3>
<p>Relational programming calculates known from unknown values. This means that this status must be recorded. But in a functional or mathematically based language, it is not possible to access this status, because it will change when a deduction calculates the value. The representation of unknown values is an implicit part of the language implementation that cannot be directly accessed.</p>
<h3>Deductions</h3>
<p>The values that can be calculated are different for each relationship. What values may be calculated also depends on what values are known, and may even depend on the particular value.</p>
<p>The following sections summarize the deductions for various types. Lower case letters are unknown values. Upper case letters are known values.</p>
<p>Deductions other than direct calculation are shown. A direct calculation is calculating the output from the inputs.</p>
<h4>Comparison</h4>
<p>The comparison relations are equal, not equal, less than, less than or equal, greater than, greater than or equal. Of these only equality allows a deduction other than direct calculation.</p>
<p>For comparing trees or lists deductions may be extended by the equality deduction on each component. This is unification.</p>
<h4>Boolean</h4>
<p>Note that in the last case, the "or" operator gives a value set, not a set. A value set differs from a set in that it behaves as a single value, but manages the context in which each value applies (see value set).</p>
<ul>
<li>In the possible world M, x is true and so y must be false.</li>
<li>In the possible world N, x is false, y is either true or false.</li>
</ul>
<p>Note that in the last case, the "or" operator gives a value set, not a set. A value set differs from a set in that it behaves as a single value, but manages the context in which each value applies (see value set).</p>
<ul>
<li>In the possible world K, x is true and y is either true or false.</li>
<li>In the possible world L, x is false, so y must be true.</li>
</ul>
<h4>Rational number</h4>
<p>Note that inverse of the square gives a value set, not a set. A value set differs from a set in that it behaves as a single value, but manages the context in which each value applies (see value set).</p>
<h4>String</h4>
<h4>String reference</h4>
<p>A string reference (StringRef) is a sub string of another string, whose start and end positions within the string are represented by variables. In concatenating two unknown strings to be equal to a string constant it is not known where the start of the first string ends, and the start of second string starts.</p>
<p>However it is known that the second string will start immediately after the end of the first string. A string reference allows this information to be captured.</p>
<p>Note C can be a string or a string reference. A string reference describes a string as a start and end position in another string. If C is a string reference in the example above, then the string reference positions are calculated for positions in the original string that C is a reference to.</p>
<h4>Function</h4>
<p>The lambda abstraction may be used as the inverse of function application.</p>
<p>There are restrictions on this deduction. See Curry's paradox and deductive lambda calculus.</p>
<h3>Value sets</h3>
<p>The deductions for the "or" operator and the "square" function may give value sets. A value set is a of values that is managed so that context in which value is found is recorded. If the context was not managed then the combination of values from different contexts would give rise to incorrect calculations.</p>
<p>For example if,</p>
<p>then</p>
<p>So a naive person might deduce,</p>
<p>this, of course, is incorrect because in reality,</p>
<p>The managing of value sets so as to avoid incorrect combinations of values is explained in narrowing of algebraic value sets.</p>
<h3>Order of evaluation</h3>
<p>Evaluation does not need to follow a fixed evaluation path. Deductions may be made where ever they are possible to calculate unknown values from known values.</p>
<p>All calculations that do not reply on value sets as the known value should be done first. Deductions on value sets should be ordered so that deductions that produce the smallest value set are done first. The product of the sizes of the value sets in the relation, other than the unknown value, gives an estimate of the size of the value set created for the unknown value. This is the optimal strategy for limiting the Combinatorial explosion.</p>
<p>As evaluating any relation may contribute to reduce the size of other value sets by narrowing, the best strategy is to evaluate expressions with the smallest value set size first, as this may lead to narrowing that reduces the size of other vale sets.</p>
<p>The evaluation should proceed on a list of relations for which values have been requested, ordered by the predicted size of the value set to be created. This predicted size will change over time leading to the need for periodic re-ordering. For value sets with one value, this strategy is lazy. For values sets with multiple values the strategy minimizes the combinatorial explosion.</p>
<p>Unlike constraint logic programming there is no backtracking required for this algorithm. All possible values are contained in value sets, and are considered at the same time. The lack of backtracking may be of benefit, or a disadvantage, depending on the problem. The use of value sets forces the consideration of all values, which allows the full benefits of narrowing in reducing the size of value sets. However it forces the solving of the whole problem at once, which if a problem may be naturally divided up, may be a disadvantage.</p>
<h3>The relational model of state</h3>
<p>Imperative programs are characterized by having implicit state. On the surface imperative programs are very different from functional programs. However monads provide a way of introducing imperative commands into a functional language, by hiding the state in the monad object.</p>
<p>But monads do not give a completely natural way of representing imperative programming. They do not provide a general model for translating an imperative program into a functional language.</p>
<h4>Transformations on imperative programs</h4>
<p>Mathematical expressions may be transformed using mathematical laws to give equivalent expressions. The same ability is needed for imperative programs. A mathematical model for an imperative program allows a change in the execution order of the program, without changing the overall effect of the program.</p>
<h4>State holder</h4>
<p>Using the relational evaluation model, a simple model of state transfer may be given. A statement in an imperative program has,</p>
<ul>
<li>Input state</li>
<li>Input parameters</li>
<li>return value</li>
<li>Output state</li>
</ul>
<p>It is natural in a functional to consider the input state as another parameter. But using the relational evaluation model this is not necessary. the relation model allows the output to be used in determining the input. For example in,</p>
<p><i>x</i> is determined to be 3, when it is only input to the function.</p>
<p>Let the "state holder" be a triple consisting of,</p>
<ul>
<li>Input state</li>
<li>return value</li>
<li>Output state</li>
</ul>
<p>Because a state holder takes its input from its output, it does not behave in the same way as other mathematical objects. But with its own set of laws it may be included in a mathematical framework.</p>
<p>The advantage of using a state holder is that state may be transferred through any parameter, providing a full model of imperative programming. The state transfer is completely hidden, and there is a direct translation between imperative programs and state holder programs. State only needs to be transferred where needed.</p>
<p>In comparison monads provide only a linear transfer through primary parameters, but not through every parameter.</p>
<p>A disadvantage is that translating an imperative program to a state holder form does not make it obey the fundamental axioms of equality. Different equality axioms are followed by state holders. Separate transformations must be applied to put the code in a functional form.</p>
<h4>The use-mention distinction</h4>
<p>In mathematics, quantification is over values, not formulas. To define the assignment statement it is necessary to refer to both the formula and the identity of the formula. The distinction between the formula representing a value and the identity of the formula is the use–mention distinction. The notation,</p>
<p>is introduced to mean quantification over formula <i>X</i> where <i>X</i> refers to the value, as a use, and <i>U</i> refers to the identity of the formula as represented or mentioned.</p>
<h4>Expressions</h4>
<p>For the purposes of describing state, lower case letters will represent symbols and upper case letters will represent variables.</p>
<p>An assignment statement, represented by :=, is defined by,</p>
<p>where,</p>
<p>The notation <img class="mwe-math-fallback-image-inline tex" alt="\forall X\#U" src="//upload.wikimedia.org/math/e/2/3/e238b05b11961c6f4d6577c0f1c8c68e.png"> gives access to the identity of the variable <i>X</i>, in <i>U</i>. This identity is then used to look up the state.</p>
<p>State lookup is represented by,</p>
<p>This definition uses the identity of the variable <i>X</i> (as <i>U</i>) to lookup the state, and return the value for that identity.</p>
<p>In a typical imperative language, state lookup is implicit. But that would cause some problems in describing state in mathematics.</p>
<p>The following definitions give a version of any function that manages state,</p>
<p>where the variables <i>I, F, X, Y, O</i> are not state holders.</p>
<p>To avoid contradiction the standard definitions of functions would not apply to state holders. That is,</p>
<p>instead it only is defined by,</p>
<p>This may be achieved given a class hierarchy. Standard equality may be defined for standard objects, but not for state holders.</p>
<p>State holder objects do not obey the substitution rule,</p>
<p>This is a fundamental principle of mathematics. This rule must be suspended for state holders.</p>
<p>Take for example,</p>
<p>WHATSON? 45cac6f6-ee6e-4534-8347-0ef2ea8f66a6</p>
<pre>
#include &lt;stdio.h&gt;
long x;
 
long f()
{
  return (x = x + 5)+(x = x + 5);
}
 
void main()
{
  x = 2;
  long r = f();
  printf("x = %ld, r = %ld\n", x, r);
}
</pre>
<p>The function <i>f</i> may be represented as,</p>
<p>where,</p>
<p>Suppose in the initial state <img class="mwe-math-fallback-image-inline tex" alt="I_1[x] = 2" src="//upload.wikimedia.org/math/8/b/a/8bad6aad4e1389ca96a24fba788ad10e.png">. Then,</p>
<p>where, <img class="mwe-math-fallback-image-inline tex" alt=" I_2 = I_1[x:=5+2]" src="//upload.wikimedia.org/math/7/d/8/7d8da84eda192d0603664c651a14f144.png"></p>
<p>So the C++ program should return,</p>
<p>WHATSON? c3295d6f-2570-401d-94df-1b98f1543a61</p>
<pre>
 x = 12, r = 19
</pre>
<h4>Control statements</h4>
<p>Two statements are composed together, by feeding the output state from one statement into the input state of the next.</p>
<p>An if statement may be regarded as a function, with 3 parameters. Currying may be applied. The condition function may be state-full or stateless. Stateless is defined by,</p>
<p>where <i>A</i> and <i>B</i> may be state holders, or other types.</p>
<p>State-full is defined by</p>
<p>For example,</p>
<h4>While statement</h4>
<p>The while statement is defined by,</p>
<p>If <i>B</i> and <i>C</i> are not a state holders this statement either does nothing or expands recursively forever. If <i>B</i> or <i>C</i> are state holders, the value returned by <i>C</i> does not need to be the same each time, even though the expression is the same.</p>
<h3>Functions and return values</h3>
<p>Many imperative languages use a fairly unnatural structure for defining functions. The natural structure is that the body of the function is an expression. The return value of the function is the value of the expression. The function call is then equal to the body of the function, with formal parameters replaced by actual parameters. The return value may be stateless, or it may be a state holder.</p>
<p>However imperative languages use statement composition which composes a state holder, which has no sensible return value. The return statement is then needed to capture a value from a state. An extra structure called the return frame is needed to get the value from a return statement.</p>
<h4>Return frame</h4>
<p>The return frame accepts the return value. The value may be stateless, or a state holder.</p>
<h4>Declaration frame</h4>
<p>The declaration frame is required to insure the calling of destructors. It is defined by,</p>
<h4>Return statement</h4>
<p>The return statement is defined by,</p>
<h2>See also</h2>
<ul>
<li>Functional programming</li>
<li>Imperative programming</li>
<li>Libra programming language</li>
<li>Logic programming</li>
<li>miniKanren</li>
<li>Monads</li>
<li>Narrowing of algebraic value sets</li>
<li>Programming paradigm</li>
</ul>
</body>
</html>