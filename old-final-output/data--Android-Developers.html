<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>data--Android-Developers.html</title></head>
<body>
<h1>&lt;data&gt;</h1>
<p>WHATSON? 4ff327ed-274f-42d7-b8d2-bb693c54de8f</p>
<pre>&lt;data android:scheme="<i>string</i>"
      android:host="<i>string</i>"
      android:port="<i>string</i>"
      android:path="<i>string</i>"
      android:pathPattern="<i>string</i>"
      android:pathPrefix="<i>string</i>"
      android:mimeType="<i>string</i>" /&gt;</pre>
<p>
<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code></p>
<p>
These attributes that specify the URL format are optional, but also mutually dependent:
</p>
<ul>
  <li>If a <code>scheme</code>
is not specified for the intent filter, all the other URI attributes are ignored.</li>
  <li>If a <code>host</code>
is not specified for the filter, the <code>port</code> attribute and all the path attributes are ignored.
</li></ul>
<p>
All the <code>&lt;data&gt;</code> elements contained within the same
<code>&lt;intent-filter&gt;</code> element contribute to
the same filter.  So, for example, the following filter specification,
</p>
<p>WHATSON? c0fde319-ee4b-4d38-9e5f-e7e09a455fa1</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>is equivalent to this one:</p>
<p>WHATSON? 18430ddc-28f3-4dd2-8c56-4b073ce277a6</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" /&amp;gt
    &lt;data android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>
You can place any number of <code>&lt;data&gt;</code> elements inside an
<code>&lt;intent-filter&gt;</code> to give it multiple data
options.  None of its attributes have default values.
</p>
<p>
Information on how intent filters work, including the rules for how Intent objects
are matched against filters, can be found in another document,
Intents and
Intent Filters.  See also the
Intent Filters
section in the manifest file overview.
</p>
<p>
A scheme is specified without the trailing colon (for example,
<code>http</code>, rather than <code>http:</code>).
</p>
<p>
If the filter has a data type set (the <code>mimeType</code>
attribute) but no scheme, the <code>content:</code> and <code>file:</code> schemes are
assumed.
</p>
<p><strong>Note</strong>: Scheme matching in the Android framework is
case-sensitive, unlike the RFC.  As a result, you should always specify schemes
using lowercase letters.</p>
<p><strong>Note</strong>: host name matching in the Android framework is
case-sensitive, unlike the formal RFC.  As a result, you should always specify
host names using lowercase letters.</p>
<ul>
<li>An asterisk ('<code>*</code>') matches a sequence of 0 to many occurrences of
the immediately preceding character.</li>

<li>A period followed by an asterisk ("<code>.*</code>") matches any sequence of
0 to many characters.</li>
</ul>
<p>
Because '<code>\</code>' is used as an escape character when the string is read
from XML (before it is parsed as a pattern), you will need to double-escape:
For example, a literal '<code>*</code>' would be written as "<code>\\*</code>" and a
literal '<code>\</code>' would be written as "<code>\\\\</code>".  This is basically
the same as what you would need to write if constructing the string in Java code.
</p>
<p>
For more information on these three types of patterns, see the descriptions of
<code>PATTERN_LITERAL</code>,
<code>PATTERN_PREFIX</code>, and
<code>PATTERN_SIMPLE_GLOB</code> in the
<code>PatternMatcher</code> class.
</p>
<p>These attributes are meaningful only if the
<code>scheme</code> and <code>host</code>
attributes are also specified for the filter.
</p>
<p>It's common for an intent filter to declare a <code>&lt;data&gt;</code> that includes
only the <code>android:mimeType</code> attribute.</p>
<p><strong>Note</strong>: MIME type matching in the Android framework is
case-sensitive, unlike formal RFC MIME types.  As a result, you should always
specify MIME types using lowercase letters.</p>
<h1>&lt;data&gt;</h1>
<p>WHATSON? afcb057a-6d62-4200-aa8c-9e78fd8e846a</p>
<pre>&lt;data android:scheme="<i>string</i>"
      android:host="<i>string</i>"
      android:port="<i>string</i>"
      android:path="<i>string</i>"
      android:pathPattern="<i>string</i>"
      android:pathPrefix="<i>string</i>"
      android:mimeType="<i>string</i>" /&gt;</pre>
<p>
<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code></p>
<p>
These attributes that specify the URL format are optional, but also mutually dependent:
</p>
<ul>
  <li>If a <code>scheme</code>
is not specified for the intent filter, all the other URI attributes are ignored.</li>
  <li>If a <code>host</code>
is not specified for the filter, the <code>port</code> attribute and all the path attributes are ignored.
</li></ul>
<p>
All the <code>&lt;data&gt;</code> elements contained within the same
<code>&lt;intent-filter&gt;</code> element contribute to
the same filter.  So, for example, the following filter specification,
</p>
<p>WHATSON? 77983d67-a55d-431c-971d-0f75192faec4</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>is equivalent to this one:</p>
<p>WHATSON? 4c9dcd09-58a9-40e1-ac79-261fbb9a6dcc</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" /&amp;gt
    &lt;data android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>
You can place any number of <code>&lt;data&gt;</code> elements inside an
<code>&lt;intent-filter&gt;</code> to give it multiple data
options.  None of its attributes have default values.
</p>
<p>
Information on how intent filters work, including the rules for how Intent objects
are matched against filters, can be found in another document,
Intents and
Intent Filters.  See also the
Intent Filters
section in the manifest file overview.
</p>
<p>
A scheme is specified without the trailing colon (for example,
<code>http</code>, rather than <code>http:</code>).
</p>
<p>
If the filter has a data type set (the <code>mimeType</code>
attribute) but no scheme, the <code>content:</code> and <code>file:</code> schemes are
assumed.
</p>
<p><strong>Note</strong>: Scheme matching in the Android framework is
case-sensitive, unlike the RFC.  As a result, you should always specify schemes
using lowercase letters.</p>
<p><strong>Note</strong>: host name matching in the Android framework is
case-sensitive, unlike the formal RFC.  As a result, you should always specify
host names using lowercase letters.</p>
<ul>
<li>An asterisk ('<code>*</code>') matches a sequence of 0 to many occurrences of
the immediately preceding character.</li>

<li>A period followed by an asterisk ("<code>.*</code>") matches any sequence of
0 to many characters.</li>
</ul>
<p>
Because '<code>\</code>' is used as an escape character when the string is read
from XML (before it is parsed as a pattern), you will need to double-escape:
For example, a literal '<code>*</code>' would be written as "<code>\\*</code>" and a
literal '<code>\</code>' would be written as "<code>\\\\</code>".  This is basically
the same as what you would need to write if constructing the string in Java code.
</p>
<p>
For more information on these three types of patterns, see the descriptions of
<code>PATTERN_LITERAL</code>,
<code>PATTERN_PREFIX</code>, and
<code>PATTERN_SIMPLE_GLOB</code> in the
<code>PatternMatcher</code> class.
</p>
<p>These attributes are meaningful only if the
<code>scheme</code> and <code>host</code>
attributes are also specified for the filter.
</p>
<p>It's common for an intent filter to declare a <code>&lt;data&gt;</code> that includes
only the <code>android:mimeType</code> attribute.</p>
<p><strong>Note</strong>: MIME type matching in the Android framework is
case-sensitive, unlike formal RFC MIME types.  As a result, you should always
specify MIME types using lowercase letters.</p>
</body>
</html>