<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Thrashing-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Thrashing (computer science)</h1>
<p>In computer science, <b>thrashing</b> occurs when a computer's virtual memory subsystem is in a constant state of paging, rapidly exchanging data in memory for data on disk, to the exclusion of most application-level processing. This causes the performance of the computer to degrade or collapse. The situation may continue indefinitely until the underlying cause is addressed.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Overview</li>
<li>2 Causes</li>
<li>3 Solutions</li>
<li>4 Other uses</li>
<li>5 See also</li>
<li>6 References</li>
</ul>
<p></p>
<h2>Overview</h2>
<p>If a process does not have enough pages, thrashing is a high paging activity, and the page fault rate is high. This leads to low CPU utilization. In modern computers, thrashing may occur in the paging system (if there is not sufficient physical memory or the disk access time is overly long), or in the communications system (especially in conflicts over internal bus access), etc. Depending on the configuration and algorithms involved, the <i>throughput</i> and <i>latency</i> of a system may degrade by multiple orders of magnitude. <i>Thrashing</i> is a state in which the CPU performs 'productive' work less and 'swapping' more. The CPU is busy in swapping pages, so much that it can not respond to users' programs as much as required. <i>Thrashing</i> occurs when there are too many pages in memory, and each page refers to another page. The real memory shortens in capacity to have all the pages in it, so it uses 'virtual memory'. When each page in execution demands that page that is not currently in real memory (RAM) it places some pages on virtual memory and adjusts the required page on RAM. If the CPU is too busy in doing this task, thrashing occurs.</p>
<h2>Causes</h2>
<p>In virtual memory systems, thrashing may be caused by programs or workloads that present insufficient locality of reference: if the working set of a program or a workload cannot be effectively held within physical memory, then constant data swapping, <i>i.e.,</i> thrashing, may occur. The term was first used during the tape operating system days to describe the sound the tapes made when data was being rapidly written to and read from them. Many older low-end computers have insufficient RAM (memory) for modern usage patterns and increasing the amount of memory can often cause the computer to run noticeably faster. This speed increase is due to the reduced amount of paging necessary.</p>
<p>An example of this sort of situation occurred on the IBM System/370 series mainframe computer, in which a particular instruction could consist of an execute instruction (which crosses a page boundary) that points to a move instruction (which itself also crosses a page boundary), targeting a move of data from a source that crosses a page boundary, to a target of data that also crosses a page boundary. The total number of pages thus being used by this particular instruction is eight, and all eight pages must be present in memory at the same time. If the operating system allocates fewer than eight pages of actual memory, when it attempts to swap out some part of the instruction or data to bring in the remainder, the instruction will again page fault, and it will thrash on every attempt to restart the failing instruction.</p>
<h2>Solutions</h2>
<p>To resolve thrashing due to excessive paging, a user can do any of the following:</p>
<ul>
<li>Increase the amount of RAM in the computer (generally the best long-term solution).</li>
<li>Decrease the number of programs being run on the computer.</li>
<li>Replace programs that are memory-heavy with equivalents that use less memory.</li>
<li>Assign working priorities to programs, i.e. low,normal,high.</li>
<li>Improve spatial locality by replacing loops like:</li>
</ul>
<p>WHATSON? 42ea3877-6f68-4934-bbef-53d60d982ef8</p>
<pre>
 // recall that in C, arrays use Row-major order
 int m[256][256]; 
 for (k=0; k&lt;256; k++) { 
   for (i=0; i&lt;256; i++) { 
     m[i][k] = something(); 
   } 
 }
</pre>
<p>WHATSON? b9db8acc-9b84-4280-bc03-d8ba0d713b9d</p>
<pre>
  int m[256][256]; 
  for (i=0; i&lt;256; i++) { 
    for (k=0; k&lt;256; k++) {
      // consecutive values of k reside in adjacent memory locations 
      m[i][k] = something(); 
    } 
  }
</pre>
<h2>Other uses</h2>
<p>The term is also used for misses between other levels of the memory hierarchy, not just paging (memory to disk): when a small set of faster storage space, intended to be used to speed up access to a larger set of slower storage space, is accessed in a way that cancels out any benefits from the faster storage. An example of this is <b>cache thrashing</b>, where main memory is accessed in a pattern that leads to multiple main memory locations competing for the same cache lines, resulting in excessive cache misses. This is most problematic for caches that have low associativity. Quite similar is <b>TLB thrashing</b>, where the translation lookaside buffer (TLB) is overrun by more requests than it can handle efficiently.</p>
<h2>See also</h2>
<ul>
<li>Congestion collapse</li>
<li>Resource contention</li>
<li>Out of memory</li>
<li>Software aging</li>
</ul>
</body>
</html>