<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Action-Bar--Android-Developers.html</title></head>
<body>
<h1>Action Bar</h1>
<h3>Design Guide</h3>
<p>Action Bar</p>
<h2>In this document</h2>
<ol>
  <li>Adding the Action Bar
    <ol>
      <li>Removing the action bar</li>
      <li>Using a logo instead of an icon</li>
    </ol>
  </li>
  <li>Adding Action Items
    <ol>
      <li>Handling clicks on action items</li>
      <li>Using split action bar</li>
    </ol>
  </li>
  <li>Navigating Up with the App Icon</li>
  <li>Adding an Action View
    <ol>
      <li>Handling collapsible action views</li>
    </ol>
  </li>
  <li>Adding an Action Provider
    <ol>
      <li>Using the ShareActionProvider</li>
      <li>Creating a custom action provider</li>
    </ol>
  </li>
  <li>Adding Navigation Tabs</li>
  <li>Adding Drop-down Navigation</li>
  <li>Styling the Action Bar
    <ol>
      <li>General appearance</li>
      <li>Action items</li>
      <li>Navigation tabs</li>
      <li>Drop-down lists</li>
      <li>Example theme</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Removing the action bar</li>
      <li>Using a logo instead of an icon</li>
    </ol>
<ol>
      <li>Handling clicks on action items</li>
      <li>Using split action bar</li>
    </ol>
<ol>
      <li>Handling collapsible action views</li>
    </ol>
<ol>
      <li>Using the ShareActionProvider</li>
      <li>Creating a custom action provider</li>
    </ol>
<ol>
      <li>General appearance</li>
      <li>Action items</li>
      <li>Navigation tabs</li>
      <li>Drop-down lists</li>
      <li>Example theme</li>
    </ol>
<h2>Key classes</h2>
<ol>
    <li><code>ActionBar</code></li>
    <li><code>Menu</code></li>
  </ol>
<p>The action bar is a window feature that identifies the user location, and
provides user actions and navigation modes. Using the action bar offers your users a
familiar interface across applications that the system gracefully adapts
for different screen configurations.</p>
<p><strong>Figure 1.</strong> An action bar that includes the [1] app icon,
[2] two action items, and [3] action overflow.</p>
<p>The action bar provides several key functions:</p>
<ul>
  <li>Provides a dedicated space for giving your app an identity and indicating the user's
  location in the app.</li>
  <li>Makes important actions prominent and accessible in a predictable way
  (such as <em>Search</em>).</li>
  <li>Supports consistent navigation and view switching within apps (with tabs or drop-down
  lists).</li>
</ul>
<p>For more information about the action bar's interaction patterns and design guidelines,
see the Action Bar
design guide.</p>
<p>The <code>ActionBar</code> APIs were first added in Android 3.0 (API level 11) but they
are also available in the Support Library
for compatibility with Android 2.1 (API level 7) and above.</p>
<p><b>This guide focuses on how to use the
support library's action bar</b>, but if your app supports <em>only</em> Android 3.0 or higher, you
should use the <code>ActionBar</code> APIs in the framework. Most of the APIs are
the same—but reside in a different package namespace—with a few exceptions to method
names or signatures that are noted in the sections below.</p>
<p><strong>Caution:</strong> Be certain you import
the <code>ActionBar</code> class (and related APIs) from the appropriate package:</p>
<ul>
<li>If supporting API levels <em>lower than</em> 11: <br>
<code>import android.support.v7.app.ActionBar</code></li>
<li>If supporting <em>only</em> API level 11 and higher: <br>
<code>import android.app.ActionBar</code></li>
</ul>
<p><strong>Note:</strong> If you're looking for information about the <em>contextual
action bar</em> for displaying contextual action items, see the Menu guide.</p>
<h2>Adding the Action Bar</h2>
<p>As mentioned above, this guide focuses on how to use the <code>ActionBar</code> APIs in the support library. So before you can add the action
bar, you must set up your project with the <strong>appcompat v7</strong> support library by
following the instructions in the Support
Library Setup.</p>
<p>Once your project is set up with the support library, here's how to add the action bar:</p>
<ol>
  <li>Create your activity by extending <code>ActionBarActivity</code>.</li>
  <li>Use (or extend) one of the <code>Theme.AppCompat</code> themes for your activity. For example:
  <pre>&lt;activity android:theme="@style/Theme.AppCompat.Light" ... &gt;</pre>
  </li>
</ol>
<p>WHATSON? 4210ef92-e452-4e68-adb5-8e6e139e1490</p>
<pre>&lt;activity android:theme="@style/Theme.AppCompat.Light" ... &gt;</pre>
<p>Now your activity includes the action bar when running on Android 2.1 (API level 7) or higher.
</p>
<p><b>On API level 11 or higher</b></p>
<p>The action bar is included in all activities that use the
<code>Theme.Holo</code> theme (or one of its
descendants), which is the default theme when either the <code>targetSdkVersion</code> or
<code>minSdkVersion</code>
attribute is set to <code>"11"</code> or higher. If you don't want the action bar for an
activity, set the activity theme to <code>Theme.Holo.NoActionBar</code>.</p>
<h3>Removing the action bar</h3>
<p>You can hide the action bar at runtime by calling <code>hide()</code>.
For example:</p>
<p>WHATSON? 7763a295-7662-42d3-968f-4b4f0bfd3b34</p>
<pre>
ActionBar actionBar = <code>getSupportActionBar()</code>;
actionBar.hide();
</pre>
<p><b>On API level 11 or higher</b></p>
<p>Get the <code>ActionBar</code> with the <code>getActionBar()</code>
method.</p>
<p>When the action bar hides, the system adjusts your layout to fill the
screen space now available. You can bring the action bar back by calling <code>show()</code>.</p>
<p>Beware that hiding and removing the action bar causes your activity to re-layout in order to
account for the space consumed by the action bar. If your activity often hides and shows the
action bar, you might want to enable <em>overlay mode</em>. Overlay mode
draws the action bar in front of your activity layout, obscuring the top portion. This
way, your layout remains fixed when the action bar hides and re-appears. To enable overlay mode,
create a custom theme for your activity and set <code>windowActionBarOverlay</code> to <code>true</code>. For more information, see the section below about Styling the Action Bar.</p>
<h3>Using a logo instead of an icon</h3>
<p>By default, the system uses your application icon in the action bar, as specified by the <code>icon</code>
attribute in the <code>&lt;application&gt;</code> or <code>&lt;activity&gt;</code> element. However, if you also specify the <code>logo</code>
attribute, then the action bar uses the logo image instead of the icon.</p>
<p>A logo should usually be wider than the icon, but should not include unnecessary text. You
should generally use a logo only when it represents your brand in a traditional format that users
recognize. A good example is the YouTube app's logo—the logo represents the expected user
brand, whereas the app's icon is a modified version that conforms to the square requirement
for the launcher icon.</p>
<h2>Adding Action Items</h2>
<p><strong>Figure 2.</strong> Action bar with three action buttons and
the overflow button.</p>
<p>The action bar provides users access to the most important action
items relating to the app's current
context. Those that appear directly in the action bar with an icon and/or text are known
as <em>action buttons</em>. Actions that can't fit in the action bar or aren't
important enough are hidden in the action overflow.
The user can reveal a list of the other actions by pressing the overflow button
on the right side (or the device <em>Menu</em> button, if available).</p>
<p>When your activity starts, the system populates the action items by calling your activity's
<code>onCreateOptionsMenu()</code> method. Use this
method to inflate a menu resource that defines all the
action items. For example, here's a menu resource defining a couple of menu items:</p>
<p>res/menu/main_activity_actions.xml</p>
<p>WHATSON? 34c85d01-0142-4b09-a7d3-8268b7d8761d</p>
<pre>
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt;
    &lt;item android:id="@+id/action_search"
          android:icon="@drawable/ic_action_search"
          android:title="@string/action_search"/&gt;
    &lt;item android:id="@+id/action_compose"
          android:icon="@drawable/ic_action_compose"
          android:title="@string/action_compose" /&gt;
&lt;/menu&gt;
</pre>
<p>Then in your activity's <code>onCreateOptionsMenu()</code>
method, inflate the menu resource into the given <code>Menu</code>
to add each item to the action bar:</p>
<p>WHATSON? 2d6f8bd3-b15a-4a97-a6e9-e3991da83cab</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu items for use in the action bar
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.main_activity_actions, menu);
    return super.onCreateOptionsMenu(menu);
}
</pre>
<p>To request that an item appear directly in the action bar
as an action button, include <code>showAsAction="ifRoom"</code> in the <code>&lt;item&gt;</code> tag. For example:</p>
<p>WHATSON? 301b9caf-0755-4971-99bd-17b0cab56b01</p>
<pre>
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
      <strong>xmlns:yourapp="http://schemas.android.com/apk/res-auto"</strong> &gt;
    &lt;item android:id="@+id/action_search"
          android:icon="@drawable/ic_action_search"
          android:title="@string/action_search"
          <strong>yourapp:showAsAction="ifRoom"</strong>  /&gt;
    ...
&lt;/menu&gt;
</pre>
<p>If there's not enough room for the item in the action bar, it will appear in the action
overflow.</p>
<p><strong>Using XML attributes from the support library</strong></p>
<p>If your menu item supplies both a title and an icon—with the <code>title</code> and
<code>icon</code> attributes—then the action item shows only the icon by default. If you
want to display the text title, add <code>"withText"</code> to the <code>showAsAction</code>
attribute. For example:</p>
<p>WHATSON? 5388eb9f-0d66-4166-8b7d-4f70314c612f</p>
<pre>
&lt;item yourapp:showAsAction="ifRoom|withText" ... /&gt;
</pre>
<p><strong>Note:</strong> The <code>"withText"</code> value is a <em>hint</em> to the
action bar that the text title should appear. The action bar will show the title when possible, but
might not if an icon is available and the action bar is constrained for space.</p>
<p>You should always define the <code>title</code> for each item even if you don't declare that
the title appear with the action item, for the following reasons:</p>
<ul>
  <li>If there's not enough room in the action bar for the action item, the menu item appears
in the overflow where only the title appears.</li>
  <li>Screen readers for sight-impaired users read the menu item's title.</li>
  <li>If the action item appears with only the icon, a user can long-press the item to reveal a
tool-tip that displays the action title.</li>
</ul>
<p>The <code>icon</code> is optional, but recommended. For icon design recommendations,
see the Iconography design
guide. You can also download a set of standard action bar icons (such as for Search or Discard)
from the Downloads page.</p>
<p>You can also use <code>"always"</code> to declare that an item always appear as an action button.
However, you <strong>should not</strong> force an item to appear in the action bar this
way. Doing so can create layout problems on devices with a narrow screen. It's best to instead
use <code>"ifRoom"</code> to request that an item appear in the action bar, but allow the system to move
it into the overflow when there's not enough room. However, it might be necessary to use this value
if the item includes an action view that cannot be collapsed and
must always be visible to provide access to a critical feature.</p>
<h3>Handling clicks on action items</h3>
<p>When the user presses an action, the system calls your activity's <code>onOptionsItemSelected()</code> method. Using the
<code>MenuItem</code> passed to this method, you can identify the action by calling <code>getItemId()</code>. This returns the unique ID provided by the <code>&lt;item&gt;</code>
tag's <code>id</code> attribute so you can perform the appropriate action. For example:</p>
<p>WHATSON? a11d4be4-6bdc-4cc7-b05d-8be30c13b600</p>
<pre>
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle presses on the action bar items
    switch (item.getItemId()) {
        case R.id.action_search:
            openSearch();
            return true;
        case R.id.action_compose:
            composeMessage();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}
</pre>
<p><strong>Note:</strong> If you inflate menu items from a fragment, via the <code>Fragment</code> class's <code>onCreateOptionsMenu()</code>
callback, the system calls <code>onOptionsItemSelected()</code> for that
fragment when the user selects one of those items. However, the activity gets a chance to
handle the event first, so the system first calls <code>onOptionsItemSelected()</code> on the activity,
before calling the same callback for the fragment. To ensure that any fragments in the
activity also have a chance to handle the callback, always pass the call to the superclass
as the default behavior instead of returning <code>false</code> when you do not handle the item.</p>
<p><strong>Figure 3.</strong> Mock-ups showing an action bar with
tabs (left), then with split action bar (middle); and with the app icon and title disabled
(right).</p>
<h3>Using split action bar</h3>
<p>Split action bar provides a separate
bar at the bottom of the screen to display all action items when the activity is running on
a narrow screen (such as a portrait-oriented handset).</p>
<p>Separating the action items this way
ensures that a reasonable amount of space is available to display all your action
items on a narrow screen, while leaving room for navigation and title elements at the top.</p>
<p>To enable split action bar when using the support library, you must do two things:</p>
<ol>
  <li>Add <code>uiOptions="splitActionBarWhenNarrow"</code> to each
<code>&lt;activity&gt;</code>
element or to the
<code>&lt;application&gt;</code>
element. This attribute is understood only by API level 14 and higher (it is ignored
by older versions).</li>
  <li>To support older versions, add a <code>&lt;meta-data&gt;</code>
  element as a child of each
  <code>&lt;activity&gt;</code>
  element that declares the same value for <code>"android.support.UI_OPTIONS"</code>.</li>
</ol>
<p>For example:</p>
<p>WHATSON? 2331a94e-0758-49b0-b74c-93246d69df4f</p>
<pre>
&lt;manifest ...&gt;
    &lt;activity uiOptions="splitActionBarWhenNarrow" ... &gt;
        &lt;meta-data android:name="android.support.UI_OPTIONS"
                   android:value="splitActionBarWhenNarrow" /&gt;
    &lt;/activity&gt;
&lt;/manifest&gt;
</pre>
<p>Using split action bar also allows navigation tabs to collapse into the
main action bar if you remove the icon and title (as shown on the right in figure 3).
To create this effect, disable the action bar
icon and title with <code>setDisplayShowHomeEnabled(false)</code> and <code>setDisplayShowTitleEnabled(false)</code>.</p>
<h2>Navigating Up with the App Icon</h2>
<h3>Design Guide</h3>
<p>Navigation with Back and Up</p>
<p><strong>Figure 4.</strong> The <em>Up</em> button in Gmail.</p>
<p>Enabling the app icon as an <em>Up</em> button allows the user to navigate your app based
on the hierarchical relationships between screens. For instance, if screen A displays a list of
items, and selecting an item leads to screen B, then
screen B should include the <em>Up</em> button, which returns to screen A.</p>
<p><strong>Note:</strong> Up navigation is distinct from the back navigation provided
by the system <em>Back</em> button. The <em>Back</em> button is used to navigate in reverse
chronological order through the history of screens the user has recently worked with. It is
generally based on the temporal relationships between screens, rather than the app's hierarchy
structure (which is the basis for up navigation).</p>
<p>To enable the app icon as an <em>Up</em> button, call <code>setDisplayHomeAsUpEnabled()</code>.
For example:</p>
<p>WHATSON? ca7a2d92-b6a7-46a8-9a5e-6faa731c611f</p>
<pre>
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_details);

    ActionBar actionBar = getSupportActionBar();
    actionBar.setDisplayHomeAsUpEnabled(true);
    ...
}
</pre>
<p>Now the icon in the action bar appears with the <em>Up</em> caret (as shown in figure 4).
However, it won't do anything by default. To specify the activity to open when the
user presses <em>Up</em> button, you have two options:</p>
<ul>
  <li><b>Specify the parent activity in the manifest file.</b>
    <p>This is the best option when <strong>the parent activity is always the same</strong>. By
declaring in the manifest which activity is the parent, the action bar automatically performs the
correct action when the user presses the <em>Up</em> button.</p>

    <p>Beginning in Android 4.1 (API level 16), you can declare the parent with the <code>parentActivityName</code>
attribute in the <code>&lt;activity&gt;</code> element.</p>
    <p>To support older devices with the support library, also
include a <code>&lt;meta-data&gt;</code> element that specifies
the parent activity as the value for <code>android.support.PARENT_ACTIVITY</code>. For example:</p>
<pre>
&lt;application ... &gt;
    ...
    &lt;!-- The main/home activity (has no parent activity) --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.MainActivity" ...&gt;
        ...
    &lt;/activity&gt;
    &lt;!-- A child of the main activity --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.example.myfirstapp.MainActivity" &gt;
        &lt;!-- Parent activity meta-data to support API level 7+ --&gt;
        &lt;meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" /&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</pre>

  <p>Once the parent activity is specified in the manifest like this and you enable the <em>Up</em>
  button with <code>setDisplayHomeAsUpEnabled()</code>, your work
is done and the action bar properly navigates up.</p>
  </li>


  <li><strong>Or, override <code>getSupportParentActivityIntent()</code> and <code>onCreateSupportNavigateUpTaskStack()</code> in your activity</strong>.</li>

    <p>This is appropriate when <strong>the parent activity may be different</strong> depending
    on how the user arrived at the current screen. That is, if there are many paths that the user
    could have taken to reach the current screen, the <em>Up</em> button should navigate
    backward along the path the user actually followed to get there.</p>

    <p>The system calls <code>getSupportParentActivityIntent()</code> when the user presses
the <em>Up</em> button while navigating your app (within your app's own task). If the activity that
should open upon up navigation differs depending on how the user arrived at the current location,
then you should override this method to return the <code>Intent</code> that starts the appropriate parent activity.</p>

    <p>The system calls <code>onCreateSupportNavigateUpTaskStack()</code> for your activity when the user presses the <em>Up</em>
button while your activity is running in a task that does <em>not</em> belong to your app. Thus,
you must use the <code>TaskStackBuilder</code> passed to this method to construct
the appropriate back stack that should be synthesized when the user navigates up.</p>

    <p>Even if you override <code>getSupportParentActivityIntent()</code> to specify up navigation
as the user navigates your app, you can avoid the need to implement <code>onCreateSupportNavigateUpTaskStack()</code> by declaring "default" parent activities in the manifest file
as shown above. Then the default implementation of <code>onCreateSupportNavigateUpTaskStack()</code> will synthesize a back stack based on the parent activities
declared in the manifest.</p>

  
</ul>
<p>This is the best option when <strong>the parent activity is always the same</strong>. By
declaring in the manifest which activity is the parent, the action bar automatically performs the
correct action when the user presses the <em>Up</em> button.</p>
<p>Beginning in Android 4.1 (API level 16), you can declare the parent with the <code>parentActivityName</code>
attribute in the <code>&lt;activity&gt;</code> element.</p>
<p>To support older devices with the support library, also
include a <code>&lt;meta-data&gt;</code> element that specifies
the parent activity as the value for <code>android.support.PARENT_ACTIVITY</code>. For example:</p>
<p>WHATSON? 634357e2-3d85-4edb-9e42-ec012cbc7e65</p>
<pre>
&lt;application ... &gt;
    ...
    &lt;!-- The main/home activity (has no parent activity) --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.MainActivity" ...&gt;
        ...
    &lt;/activity&gt;
    &lt;!-- A child of the main activity --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.example.myfirstapp.MainActivity" &gt;
        &lt;!-- Parent activity meta-data to support API level 7+ --&gt;
        &lt;meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" /&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</pre>
<p>Once the parent activity is specified in the manifest like this and you enable the <em>Up</em>
  button with <code>setDisplayHomeAsUpEnabled()</code>, your work
is done and the action bar properly navigates up.</p>
<p>This is appropriate when <strong>the parent activity may be different</strong> depending
    on how the user arrived at the current screen. That is, if there are many paths that the user
    could have taken to reach the current screen, the <em>Up</em> button should navigate
    backward along the path the user actually followed to get there.</p>
<p>The system calls <code>getSupportParentActivityIntent()</code> when the user presses
the <em>Up</em> button while navigating your app (within your app's own task). If the activity that
should open upon up navigation differs depending on how the user arrived at the current location,
then you should override this method to return the <code>Intent</code> that starts the appropriate parent activity.</p>
<p>The system calls <code>onCreateSupportNavigateUpTaskStack()</code> for your activity when the user presses the <em>Up</em>
button while your activity is running in a task that does <em>not</em> belong to your app. Thus,
you must use the <code>TaskStackBuilder</code> passed to this method to construct
the appropriate back stack that should be synthesized when the user navigates up.</p>
<p>Even if you override <code>getSupportParentActivityIntent()</code> to specify up navigation
as the user navigates your app, you can avoid the need to implement <code>onCreateSupportNavigateUpTaskStack()</code> by declaring "default" parent activities in the manifest file
as shown above. Then the default implementation of <code>onCreateSupportNavigateUpTaskStack()</code> will synthesize a back stack based on the parent activities
declared in the manifest.</p>
<p><strong>Note:</strong>
If you've built your app hierarchy using a series of fragments instead of multiple
activities, then neither of the above options will work. Instead, to navigate up through your
fragments, override <code>onSupportNavigateUp()</code>
to perform the appropriate fragment transaction—usually by popping
the current fragment from the back stack by calling <code>popBackStack()</code>.</p>
<p>For more information about implementing <em>Up</em> navigation, read
Providing Up Navigation.</p>
<h2>Adding an Action View</h2>
<p><strong>Figure 5.</strong> An action bar with a collapsible
<code>SearchView</code>.</p>
<p>An <em>action view</em> is a widget that appears in the action bar as a substitute for an action
button. An action view provides fast access to rich actions without changing activities or
fragments, and without replacing the action bar. For example, if you have an action for Search, you
can add an action view to
embeds a <code>SearchView</code> widget in the action bar, as shown in figure
5.</p>
<p>To declare an action view, use either the <code>actionLayout</code> or <code>actionViewClass</code> attribute to specify either a layout
resource or widget class to use, respectively. For example, here's how to add
the <code>SearchView</code> widget:</p>
<p>WHATSON? 8dcb62f6-2afb-413b-8736-4af8eb396c60</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:yourapp="http://schemas.android.com/apk/res-auto" &gt;
    &lt;item android:id="@+id/action_search"
          android:title="@string/action_search"
          android:icon="@drawable/ic_action_search"
          yourapp:showAsAction="ifRoom|collapseActionView"
          <b>yourapp:actionViewClass="android.support.v7.widget.SearchView"</b> /&gt;
&lt;/menu&gt;
</pre>
<p>Notice that the <code>showAsAction</code> attribute also includes the <code>"collapseActionView"</code>
value. This is optional and declares that the action view should be collapsed into a
button. (This behavior is explained further in the following section about
Handling collapsible action views.)</p>
<p>If you need to configure the action view (such as to add event listeners), you can do so during
the <code>onCreateOptionsMenu()</code> callback. You can
acquire the action view object by calling the static method <code>MenuItemCompat.getActionView()</code> and passing it
the corresponding <code>MenuItem</code>. For example, the search widget from the above
sample is acquired like this:</p>
<p>WHATSON? 9f0f8cd0-1f4a-4897-974f-299198cd0209</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_activity_actions, menu);
    MenuItem searchItem = menu.findItem(R.id.action_search);
    SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
    // Configure the search info and add any event listeners
    ...
    return super.onCreateOptionsMenu(menu);
}
</pre>
<p><b>On API level 11 or higher</b></p>
<p>Get the action view by calling <code>getActionView()</code> on the
corresponding <code>MenuItem</code>:</p>
<p>WHATSON? 5aba545e-afbe-454b-a6db-47cbcfc3726f</p>
<pre>menu.findItem(R.id.action_search).getActionView()</pre>
<p>For more information about using the search widget, see Creating a Search Interface.</p>
<h3>Handling collapsible action views</h3>
<p>To preserve the action bar space, you can collapse your action view into an action button.
When collapsed, the system might place the action
into the action overflow, but the
action view still appears in the action bar when the user selects it. You can make your action
view collapsible by adding <code>"collapseActionView"</code> to the <code>showAsAction</code>
attribute, as shown in the XML above.</p>
<p>Because the system expands the action view when the user selects the action, you
<em>do not</em> need to respond to the item in the <code>onOptionsItemSelected()</code> callback. The system still calls
<code>onOptionsItemSelected()</code>, but if
you return <code>true</code> (indicating you've handled the event instead), then the
action view will <em>not</em> expand.</p>
<p>The system also collapses your action view when the user presses the <em>Up</em> button
or <em>Back</em> button.</p>
<p>If you need to update your activity based on the visibility of your action view, you can receive
callbacks when the action is expanded and collapsed by defining an <code>OnActionExpandListener</code> and
passing it to <code>setOnActionExpandListener()</code>. For example:</p>
<p>WHATSON? ed230869-ed64-4579-9287-649594878d2f</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.options, menu);
    MenuItem menuItem = menu.findItem(R.id.actionItem);
    ...

    // When using the support library, the setOnActionExpandListener() method is
    // static and accepts the MenuItem object as an argument
    MenuItemCompat.setOnActionExpandListener(menuItem, new OnActionExpandListener() {
        @Override
        public boolean onMenuItemActionCollapse(MenuItem item) {
            // Do something when collapsed
            return true;  // Return true to collapse action view
        }

        @Override
        public boolean onMenuItemActionExpand(MenuItem item) {
            // Do something when expanded
            return true;  // Return true to expand action view
        }
    });
}
</pre>
<h2>Adding an Action Provider</h2>
<p><strong>Figure 6.</strong> An action bar with
  <code>ShareActionProvider</code> expanded to show share targets.</p>
<p>Similar to an action view, an <em>action provider</em>
replaces an action button with a customized layout. However,
unlike an action view, an action provider takes control of all the action's behaviors
and an action provider can display a submenu when pressed.</p>
<p>To declare an action provider, supply the <code>actionViewClass</code> attribute in the
menu <code>&lt;item&gt;</code> tag with a fully-qualified class name for an
<code>ActionProvider</code>.</p>
<p>You can build your own action provider by extending the <code>ActionProvider</code> class, but Android provides some pre-built action providers
such as <code>ShareActionProvider</code>, which facilitates a "share" action
by showing a list of possible apps for sharing directly in the action bar (as shown in figure
6).</p>
<p>Because each <code>ActionProvider</code> class defines its own action
behaviors, you don't need to listen for the action in the <code>onOptionsItemSelected()</code> method. If necessary though,
you can still listen for the click event in the <code>onOptionsItemSelected()</code> method in case you need to simultaneously perform another action. But be
sure to return <code>false</code> so that the the action provider still receives the <code>onPerformDefaultAction()</code> callback to perform its intended
action.</p>
<p>However, if the action provider provides a submenu of actions, then your
activity does not receive a call to <code>onOptionsItemSelected()</code> when the user opens the list or selects one of the submenu items.</p>
<h3>Using the ShareActionProvider</h3>
<p>To add a "share" action with <code>ShareActionProvider</code>,
define the <code>actionProviderClass</code> for an <code>&lt;item&gt;</code> tag with
the <code>ShareActionProvider</code> class. For example:</p>
<p>WHATSON? e1af0ed3-6455-43a9-ad69-a56d6c2d1668</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:yourapp="http://schemas.android.com/apk/res-auto" &gt;
    &lt;item android:id="@+id/action_share"
          android:title="@string/share"
          yourapp:showAsAction="ifRoom"
          <strong>yourapp:actionProviderClass="android.support.v7.widget.ShareActionProvider"</strong>
          /&gt;
    ...
&lt;/menu&gt;
</pre>
<p>Now the action provider takes control of the action item and handles both
its appearance and behavior. But you must
still provide a title for the item to be used when it appears in the action overflow.</p>
<p>The only thing left to do is define
the <code>Intent</code> you want to use for sharing. To do so, edit
your <code>onCreateOptionsMenu()</code> method to call <code>MenuItemCompat.getActionProvider()</code>
and pass it the <code>MenuItem</code> holding the action provider. Then call <code>setShareIntent()</code> on the
returned <code>ShareActionProvider</code> and pass it an
<code>ACTION_SEND</code> intent with the appropriate content attached.</p>
<p>You should call <code>setShareIntent()</code> once during <code>onCreateOptionsMenu()</code> to initialize the share action,
but because the user context might change, you must update the intent any time the shareable
content changes by again calling <code>setShareIntent()</code>.</p>
<p>For example:</p>
<p>WHATSON? 731ffeb2-f12e-4870-ac4a-00b7d429efd8</p>
<pre>
private ShareActionProvider mShareActionProvider;

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_activity_actions, menu);

    // Set up ShareActionProvider's default share intent
    MenuItem shareItem = menu.findItem(R.id.action_share);
    mShareActionProvider = (ShareActionProvider)
            MenuItemCompat.getActionProvider(shareItem);
    mShareActionProvider.setShareIntent(getDefaultIntent());

    return super.onCreateOptionsMenu(menu);
}

/** Defines a default (dummy) share intent to initialize the action provider.
  * However, as soon as the actual content to be used in the intent
  * is known or changes, you must update the share intent by again calling
  * mShareActionProvider.<code>setShareIntent()</code>
  */
private Intent getDefaultIntent() {
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.setType("image/*");
    return intent;
}
</pre>
<p>The <code>ShareActionProvider</code> now handles all user interaction with
the item and you <em>do not</em> need to handle click events from the <code>onOptionsItemSelected()</code> callback method.</p>
<p>By default, the <code>ShareActionProvider</code> retains a ranking for each
share target based on how often the user selects each one. The share targets used more frequently
appear at the top of the drop-down list and the target used most often appears directly in the
action bar as the default share target. By default, the ranking information is saved in a private
file with a name specified by <code>DEFAULT_SHARE_HISTORY_FILE_NAME</code>. If you use the
<code>ShareActionProvider</code> or an extension of it for only one type of
action, then you should continue to use this default history file and there's nothing you need to
do. However, if you use <code>ShareActionProvider</code> or an extension of it
for multiple actions with semantically different meanings, then each <code>ShareActionProvider</code> should specify its own history file in order to
maintain its own history. To specify a different history file for the <code>ShareActionProvider</code>, call <code>setShareHistoryFileName()</code>
and provide an XML file name (for example, <code>"custom_share_history.xml"</code>).</p>
<p><strong>Note:</strong> Although the <code>ShareActionProvider</code> ranks share targets based on frequency of use, the
behavior is extensible and extensions of <code>ShareActionProvider</code> can
perform different behaviors and ranking based on the history file (if appropriate).</p>
<h3>Creating a custom action provider</h3>
<p>Creating your own action provider allows you to re-use and manage dynamic action item
behaviors in a self-contained module, rather than handle action item transformations and
behaviors in your fragment or activity
code. As shown in the previous section, Android already provides an implementation of <code>ActionProvider</code> for share actions: the <code>ShareActionProvider</code>.</p>
<p>To create your own action provider for a different action, simply extend the
<code>ActionProvider</code> class and implement
its callback methods as appropriate. Most importantly, you should implement the following:</p>
<p>WHATSON? 5aed70eb-4c79-43af-9b58-0da4c9992dee</p>
<pre>
public View onCreateActionView(MenuItem forItem) {
    // Inflate the action view to be shown on the action bar.
    LayoutInflater layoutInflater = LayoutInflater.from(mContext);
    View view = layoutInflater.inflate(R.layout.action_provider, null);
    ImageButton button = (ImageButton) view.findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // Do something...
        }
    });
    return view;
}
</pre>
<p>However, if your action provider provides a submenu, through the <code>onPrepareSubMenu()</code> callback, then the
submenu appears even when the action provider is placed in the action overflow. Thus, <code>onPerformDefaultAction()</code> is never called when there is a
submenu.</p>
<p><strong>Note:</strong> An activity or a fragment that implements <code>onOptionsItemSelected()</code> can override the action
provider's default behavior (unless it uses a submenu) by handling the item-selected event (and
returning <code>true</code>), in which case, the system does not call <code>onPerformDefaultAction()</code>.</p>
<p>For an example extension of <code>ActionProvider</code>, see ActionBarSettingsActionProviderActivity.</p>
<h2>Adding Navigation Tabs</h2>
<p><strong>Figure 7.</strong> Action bar tabs on a wide screen.</p>
<h3>Design Guide</h3>
<p>Tabs</p>
<h3>Also read</h3>
<p>Creating Swipe Views with Tabs</p>
<p><strong>Figure 8.</strong> Tabs on a narrow screen.</p>
<p>Tabs in the action bar make it easy for users to explore and switch between different views in
your app. The tabs provided by the <code>ActionBar</code> are ideal because they
adapt to different screen sizes. For example, when the screen is wide enough the tabs appear in the
action bar alongside the action buttons (such as when on a tablet, shown in figure 7), while when
on a narrow screen they appear in a separate bar (known as the "stacked action bar", shown in
figure 8). In some cases, the Android system will instead show your tab items as a drop-down list
to ensure the best fit in the action bar.</p>
<p>To get started, your layout must include a <code>ViewGroup</code> in which you place
each <code>Fragment</code> associated with a tab. Be sure the <code>ViewGroup</code>
has a resource ID so you can reference it from your code and swap the tabs within it.
Alternatively, if the tab content will fill the activity layout, then your activity doesn't need a
layout at all (you don't even need to call <code>setContentView()</code>). Instead, you can place each fragment in the default root view, which you can
refer to with the <code>android.R.id.content</code> ID.</p>
<p>Once you determine where the fragments appear in the layout, the basic procedure to add tabs
is:</p>
<ol>
  <li>Implement the <code>ActionBar.TabListener</code> interface. This interface
  provides callbacks for tab events, such as when the user presses one so you can swap the
  tabs.</li>
  <li>For each tab you want to add, instantiate an <code>ActionBar.Tab</code>
  and set the <code>ActionBar.TabListener</code> by calling <code>setTabListener()</code>. Also set the tab's title
  and with <code>setText()</code> (and optionally, an icon with
  <code>setIcon()</code>).</li>
  <li>Then add each tab to the action bar by calling <code>addTab()</code>.</li>
</ol>
<p>Notice that the <code>ActionBar.TabListener</code>
callback methods don't specify which fragment is associated with the tab, but merely which
<code>ActionBar.Tab</code> was selected.
You must define your own association
between each <code>ActionBar.Tab</code> and the appropriate <code>Fragment</code> that
it represents. There are several ways you
can define the association, depending on your design.</p>
<p>For example, here's how you might implement the <code>ActionBar.TabListener</code>
such that each tab uses its own instance of the listener:</p>
<p>WHATSON? feec7dd2-01aa-4526-a860-7b50ff611403</p>
<pre>
public static class TabListener&lt;T extends Fragment&gt; implements ActionBar.TabListener {
    private Fragment mFragment;
    private final Activity mActivity;
    private final String mTag;
    private final Class&lt;T&gt; mClass;

    /** Constructor used each time a new tab is created.
      * @param activity  The host Activity, used to instantiate the fragment
      * @param tag  The identifier tag for the fragment
      * @param clz  The fragment's Class, used to instantiate the fragment
      */
    public TabListener(Activity activity, String tag, Class&lt;T&gt; clz) {
        mActivity = activity;
        mTag = tag;
        mClass = clz;
    }

    /* The following are each of the <code>ActionBar.TabListener</code> callbacks */

    public void onTabSelected(Tab tab, FragmentTransaction ft) {
        // Check if the fragment is already initialized
        if (mFragment == null) {
            // If not, instantiate and add it to the activity
            mFragment = Fragment.instantiate(mActivity, mClass.getName());
            ft.add(android.R.id.content, mFragment, mTag);
        } else {
            // If it exists, simply attach it in order to show it
            ft.attach(mFragment);
        }
    }

    public void onTabUnselected(Tab tab, FragmentTransaction ft) {
        if (mFragment != null) {
            // Detach the fragment, because another one is being attached
            ft.detach(mFragment);
        }
    }

    public void onTabReselected(Tab tab, FragmentTransaction ft) {
        // User selected the already selected tab. Usually do nothing.
    }
}
</pre>
<p><strong>Caution:</strong> You <strong>must not</strong> call <code>commit()</code> for the fragment transaction in each of these
callbacks—the system calls it for you and it may throw an exception if you call it yourself.
You also <strong>cannot</strong> add these fragment transactions to the back stack.</p>
<p>In this example, the listener simply attaches (<code>attach()</code>) a fragment to the activity layout—or if not instantiated, creates the fragment and
adds (<code>add()</code>) it to the layout (as a child of the <code>android.R.id.content</code> view group)—when the respective tab is selected, and detaches (<code>detach()</code>) it when the tab is unselected.</p>
<p>All that remains is to create each <code>ActionBar.Tab</code> and add it to the <code>ActionBar</code>. Additionally, you must call <code>setNavigationMode(NAVIGATION_MODE_TABS)</code> to make the
tabs visible.</p>
<p>For example, the following code adds two tabs using the listener defined above:</p>
<p>WHATSON? 2c174ba0-27a5-4e99-b27a-16e780713f71</p>
<pre>
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Notice that setContentView() is not used, because we use the root
    // android.R.id.content as the container for each fragment

    // setup action bar for tabs
    ActionBar actionBar = getSupportActionBar();
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
    actionBar.setDisplayShowTitleEnabled(false);

    Tab tab = actionBar.newTab()
                       .setText(R.string.artist)
                       .setTabListener(new TabListener&lt;ArtistFragment&gt;(
                               this, "artist", ArtistFragment.class));
    actionBar.addTab(tab);

    tab = actionBar.newTab()
                   .setText(R.string.album)
                   .setTabListener(new TabListener&lt;AlbumFragment&gt;(
                           this, "album", AlbumFragment.class));
    actionBar.addTab(tab);
}
</pre>
<p>If your activity stops, you should retain the currently selected tab with the saved instance state so you
can open the appropriate tab when the user returns. When it's time to save the state, you can query
the currently selected tab with <code>getSelectedNavigationIndex()</code>. This returns the index position of
the selected tab.</p>
<p><strong>Caution:</strong> It's important that you save the state of each fragment
so when users switch fragments with the tabs and then return to a previous
fragment, it looks the way it did when they left. Some of the state is saved by default, but you
may need to manually save state for customized views. For information about saving the state of your
fragment, see the Fragments
API guide.</p>
<p><strong>Note:</strong> The above implementation for <code>ActionBar.TabListener</code> is one of several possible techniques. Another popular
option is to use <code>ViewPager</code> to manage the fragments so users
can also use a swipe gesture to switch tabs. In this case, you simply tell the
<code>ViewPager</code> the current tab position in the
<code>onTabSelected()</code> callback.
For more information, read
Creating Swipe Views with Tabs.</p>
<h2>Adding Drop-down Navigation</h2>
<p><strong>Figure 9.</strong> A drop-down navigation list in the
action bar.</p>
<p>As another mode of navigation (or filtering) for your activity, the action bar offers a built
in drop-down list (also known as a "spinner"). For example, the drop-down list can offer different
modes by which content in the activity is sorted.</p>
<p>Using the drop-down list is useful when changing the content is important but not necessarily a
frequent occurrence. In cases where switching the content is more frequent,
you should use navigation tabs instead.</p>
<p>The basic procedure to enable drop-down navigation is:</p>
<ol>
  <li>Create a <code>SpinnerAdapter</code> that provides the
list of selectable items for the drop-down and the layout to use when drawing each item in the
list.</li>
  <li>Implement <code>ActionBar.OnNavigationListener</code> to define the
  behavior that occurs when the user selects an item from the list.</li>
  <li>During your activity's <code>onCreate()</code> method, enable the action bar's drop-down list by calling <code>setNavigationMode(NAVIGATION_MODE_LIST)</code>.
  </li>
  <li>Set the callback for the drop-down list with <code>setListNavigationCallbacks()</code>.
For example:
<pre>
actionBar.setListNavigationCallbacks(mSpinnerAdapter, mNavigationCallback);
</pre>
<p>This method takes your <code>SpinnerAdapter</code> and <code>ActionBar.OnNavigationListener</code>.</p>
</li>
</ol>
<p>WHATSON? 0083ee33-2f86-4b35-b809-508545181691</p>
<pre>
actionBar.setListNavigationCallbacks(mSpinnerAdapter, mNavigationCallback);
</pre>
<p>This method takes your <code>SpinnerAdapter</code> and <code>ActionBar.OnNavigationListener</code>.</p>
<p>This procedure is relatively short, but implementing the <code>SpinnerAdapter</code>
and <code>ActionBar.OnNavigationListener</code> is where most of the work is done. There are
many ways you can implement these to define the functionality for your drop-down navigation and
implementing various types of <code>SpinnerAdapter</code> is beyond the scope of this
document (you should refer to the <code>SpinnerAdapter</code> class reference for more
information). However, below is an example for a <code>SpinnerAdapter</code> and <code>ActionBar.OnNavigationListener</code> to get you started (click the title to reveal the
sample).</p>
<h3>
    <img src="/assets/images/triangle-closed.png" class="toggle-content-img" alt="">
    Example SpinnerAdapter and OnNavigationListener
  </h3>
<p><code>SpinnerAdapter</code> is an adapter that provides data for a spinner widget,
such as the drop-down list in the action bar. <code>SpinnerAdapter</code> is an interface
that you can implement, but Android includes some useful implementations that you can extend, such
as <code>ArrayAdapter</code> and <code>SimpleCursorAdapter</code>. For example, here's an easy way to create a <code>SpinnerAdapter</code> by using <code>ArrayAdapter</code> implementation, which
uses a string array as the data source:</p>
<p>WHATSON? 458f2aa1-3c99-45a3-8794-781865cead5f</p>
<pre>
SpinnerAdapter mSpinnerAdapter = ArrayAdapter.createFromResource(this,
        R.array.action_list, android.R.layout.simple_spinner_dropdown_item);
</pre>
<p>The <code>createFromResource()</code> method takes
three parameters: the application <code>Context</code>, the resource ID for the string
array, and the layout to use for each list item.</p>
<p>A string array
defined in a resource looks like this:</p>
<p>WHATSON? c00263a4-9e53-464e-982a-d65147c242eb</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;string-array name="action_list"&gt;
        &lt;item&gt;Mercury&lt;/item&gt;
        &lt;item&gt;Venus&lt;/item&gt;
        &lt;item&gt;Earth&lt;/item&gt;
    &lt;/string-array&gt;
&lt;/resources&gt;
</pre>
<p>The <code>ArrayAdapter</code> returned by <code>createFromResource()</code> is complete and ready for you
to pass it to <code>setListNavigationCallbacks()</code>
(in step 4 from above). Before you do, though, you need to create the <code>OnNavigationListener</code>.</p>
<p>Your implementation of <code>ActionBar.OnNavigationListener</code> is where you handle
fragment changes or other modifications to your activity when the user selects an item from the
drop-down list. There's only one callback method to implement in the listener: <code>onNavigationItemSelected()</code>.</p>
<p>The <code>onNavigationItemSelected()</code>
method receives the position of the item in the list and a unique item ID provided by the <code>SpinnerAdapter</code>.</p>
<p>Here's an example that instantiates an anonymous implementation of <code>OnNavigationListener</code>, which inserts a <code>Fragment</code> into the
layout container identified by <code>R.id.fragment_container</code>:</p>
<p>WHATSON? b0b97df5-9aa4-4d75-8969-b5cedfce2f86</p>
<pre>
mOnNavigationListener = new OnNavigationListener() {
  // Get the same strings provided for the drop-down's ArrayAdapter
  String[] strings = getResources().getStringArray(R.array.action_list);

  @Override
  public boolean onNavigationItemSelected(int position, long itemId) {
    // Create new fragment from our own Fragment class
    ListContentFragment newFragment = new ListContentFragment();
    FragmentTransaction ft = getSupportFragmentManager().beginTransaction();

    // Replace whatever is in the fragment container with this fragment
    // and give the fragment a tag name equal to the string at the position
    // selected
    ft.replace(R.id.fragment_container, newFragment, strings[position]);

    // Apply changes
    ft.commit();
    return true;
  }
};
</pre>
<p>This instance of <code>OnNavigationListener</code> is
complete and you can now call <code>setListNavigationCallbacks()</code> (in step 4), passing the <code>ArrayAdapter</code> and this
<code>OnNavigationListener</code>.</p>
<p>In this example, when the user selects an item from the drop-down list, a fragment is added to
the layout (replacing the current fragment in the <code>R.id.fragment_container</code> view). The
fragment added is given a tag that uniquely identifies it, which is the same string used to
identify the fragment in the drop-down list.</p>
<p>Here's a look at the <code>ListContentFragment</code> class that defines each fragment in this
example:</p>
<p>WHATSON? 019a270b-9f8e-4bdf-8110-2878fce3e482</p>
<pre>
public class ListContentFragment extends Fragment {
    private String mText;

    @Override
    public void onAttach(Activity activity) {
      // This is the first callback received; here we can set the text for
      // the fragment as defined by the tag specified during the fragment
      // transaction
      super.onAttach(activity);
      mText = getTag();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        // This is called to define the layout for the fragment;
        // we just create a TextView and set its text to be the fragment tag
        TextView text = new TextView(getActivity());
        text.setText(mText);
        return text;
    }
}
</pre>
<h2>Styling the Action Bar</h2>
<p>If you want to implement a visual design that represents your app's brand, the action bar allows
you to customize each detail of its appearance, including the action bar color, text colors, button
styles, and more. To do so, you need to use Android's style and theme framework to restyle the action bar
using special style properties.</p>
<p><strong>Caution:</strong> For all background drawables you provide, be sure to
use Nine-Patch drawables
to allow stretching. The nine-patch image should be <em>smaller</em> than 40dp tall and 30dp
wide.</p>
<h3>General appearance</h3>
<p>The default for this style for this
      is <code>Widget.AppCompat.ActionBar</code>, which is what you should use as the parent style.</p>
<p>Supported styles include:</p>
<p>The default for this style for this
      is <code>Widget.AppCompat.ActionButton</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
      is <code>Widget.AppCompat.ActionButton.Overflow</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
      is <code>TextAppearance.AppCompat.Widget.ActionBar.Title</code>, which is what you should use as the parent
      style.</p>
<p>Normally, the action bar requires its own space on the screen and your activity layout fills in
what's left over. When the action bar is in overlay mode, your activity layout uses all the
available space and the system draws the action bar on top. Overlay mode can be useful if you want
your content to keep a fixed size and position when the action bar is hidden and shown. You might
also like to use it purely as a visual effect, because you can use a semi-transparent background
for the action bar so the user can still see some of your activity layout behind the action
bar.</p>
<p><strong>Note:</strong> The <code>Holo</code> theme families
draw the action bar with a semi-transparent background by default. However, you can modify it with
your own styles and the <code>DeviceDefault</code> theme on
different devices might use an opaque background by default.</p>
<p>When overlay mode is enabled, your activity layout has no awareness of the action bar lying on
top of it. So, you must be careful not to place any important information or UI components in the
area overlaid by the action bar. If appropriate, you can refer to the platform's value for <code>actionBarSize</code> to determine the height of the action bar, by referencing it
in your XML layout. For example:</p>
<p>WHATSON? 6a1f01bf-fb3f-4cde-bed2-e22e0be79ac6</p>
<pre>
&lt;SomeView
    ...
    android:layout_marginTop="?android:attr/actionBarSize" /&gt;
</pre>
<p>You can also retrieve the action bar height at runtime with <code>getHeight()</code>. This reflects the height of the action bar at the time it's
called, which might not include the stacked action bar (due to navigation tabs) if called during
early activity lifecycle methods. To see how you can determine the total height at runtime,
including the stacked action bar, see the 
<code>TitlesFragment</code> class in the Honeycomb Gallery sample app.</p>
<h3>Action items</h3>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionButton</code>, which is what you should use as the parent style.</p>
<h3>Navigation tabs</h3>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionBar.TabView</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionBar.TabBar</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionBar.TabText</code>, which is what you should use as the parent style.</p>
<h3>Drop-down lists</h3>
<p>The default for this style for this
  is <code>Widget.AppCompat.Spinner.DropDown.ActionBar</code>, which is what you should use as the parent
  style.</p>
<h3>Example theme</h3>
<p>Here's an example that defines a custom theme for an activity, <code>CustomActivityTheme</code>,
that includes several styles to customize the action bar.</p>
<p>Notice that there are two versions for each action bar style property. The first one
includes the <code>android:</code> prefix on the property name to support API levels 11 and higher
that include these properties in the framework. The second version does <em>not</em>
include the <code>android:</code> prefix and is for older versions of the platform, on which
the system uses the style property from the support library. The effect for each is the same.</p>
<p>WHATSON? 7ec382c8-7520-4570-960c-4a29aedfda40</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;!-- the theme applied to the application or activity --&gt;
    &lt;style name="CustomActionBarTheme"
           parent="@style/Theme.AppCompat.Light"&gt;
        &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
        &lt;item name="android:actionBarTabTextStyle"&gt;@style/TabTextStyle&lt;/item&gt;
        &lt;item name="android:actionMenuTextColor"&gt;@color/actionbar_text&lt;/item&gt;

        &lt;!-- Support library compatibility --&gt;
        &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
        &lt;item name="actionBarTabTextStyle"&gt;@style/TabTextStyle&lt;/item&gt;
        &lt;item name="actionMenuTextColor"&gt;@color/actionbar_text&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- general styles for the action bar --&gt;
    &lt;style name="MyActionBar"
           parent="@style/Widget.AppCompat.ActionBar"&gt;
        &lt;item name="android:titleTextStyle"&gt;@style/TitleTextStyle&lt;/item&gt;
        &lt;item name="android:background"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="android:backgroundStacked"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="android:backgroundSplit"&gt;@drawable/actionbar_background&lt;/item&gt;

        &lt;!-- Support library compatibility --&gt;
        &lt;item name="titleTextStyle"&gt;@style/TitleTextStyle&lt;/item&gt;
        &lt;item name="background"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="backgroundStacked"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="backgroundSplit"&gt;@drawable/actionbar_background&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- action bar title text --&gt;
    &lt;style name="TitleTextStyle"
           parent="@style/TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
        &lt;item name="android:textColor"&gt;@color/actionbar_text&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- action bar tab text --&gt;
    &lt;style name="TabTextStyle"
           parent="@style/Widget.AppCompat.ActionBar.TabText"&gt;
        &lt;item name="android:textColor"&gt;@color/actionbar_text&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;

</pre>
<p>In your manifest file, you can apply the theme to your entire app:</p>
<p>WHATSON? dd5e254f-42d7-44bf-ac1f-344691ef94af</p>
<pre>
&lt;application android:theme="@style/CustomActionBarTheme" ... /&gt;
</pre>
<p>Or to individual activities:</p>
<p>WHATSON? beeffba2-8e79-431c-9e91-32eea15b97dd</p>
<pre>
&lt;activity android:theme="@style/CustomActionBarTheme" ... /&gt;
</pre>
<p><strong>Caution:</strong> Be certain that each theme and style declares a parent
theme in the <code>&lt;style&gt;</code> tag, from which it inherits all styles not explicitly declared
by your theme. When modifying the action bar, using a parent theme is important so that you can
simply override the action bar styles you want to change without re-implementing the styles you
want to leave alone (such as text size or padding in action items).</p>
<p>For more information about using style and theme resources in your application, read Styles and Themes.</p>
<h1>Action Bar</h1>
<h3>Design Guide</h3>
<p>Action Bar</p>
<h2>In this document</h2>
<ol>
  <li>Adding the Action Bar
    <ol>
      <li>Removing the action bar</li>
      <li>Using a logo instead of an icon</li>
    </ol>
  </li>
  <li>Adding Action Items
    <ol>
      <li>Handling clicks on action items</li>
      <li>Using split action bar</li>
    </ol>
  </li>
  <li>Navigating Up with the App Icon</li>
  <li>Adding an Action View
    <ol>
      <li>Handling collapsible action views</li>
    </ol>
  </li>
  <li>Adding an Action Provider
    <ol>
      <li>Using the ShareActionProvider</li>
      <li>Creating a custom action provider</li>
    </ol>
  </li>
  <li>Adding Navigation Tabs</li>
  <li>Adding Drop-down Navigation</li>
  <li>Styling the Action Bar
    <ol>
      <li>General appearance</li>
      <li>Action items</li>
      <li>Navigation tabs</li>
      <li>Drop-down lists</li>
      <li>Example theme</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Removing the action bar</li>
      <li>Using a logo instead of an icon</li>
    </ol>
<ol>
      <li>Handling clicks on action items</li>
      <li>Using split action bar</li>
    </ol>
<ol>
      <li>Handling collapsible action views</li>
    </ol>
<ol>
      <li>Using the ShareActionProvider</li>
      <li>Creating a custom action provider</li>
    </ol>
<ol>
      <li>General appearance</li>
      <li>Action items</li>
      <li>Navigation tabs</li>
      <li>Drop-down lists</li>
      <li>Example theme</li>
    </ol>
<h2>Key classes</h2>
<ol>
    <li><code>ActionBar</code></li>
    <li><code>Menu</code></li>
  </ol>
<p>The action bar is a window feature that identifies the user location, and
provides user actions and navigation modes. Using the action bar offers your users a
familiar interface across applications that the system gracefully adapts
for different screen configurations.</p>
<p><strong>Figure 1.</strong> An action bar that includes the [1] app icon,
[2] two action items, and [3] action overflow.</p>
<p>The action bar provides several key functions:</p>
<ul>
  <li>Provides a dedicated space for giving your app an identity and indicating the user's
  location in the app.</li>
  <li>Makes important actions prominent and accessible in a predictable way
  (such as <em>Search</em>).</li>
  <li>Supports consistent navigation and view switching within apps (with tabs or drop-down
  lists).</li>
</ul>
<p>For more information about the action bar's interaction patterns and design guidelines,
see the Action Bar
design guide.</p>
<p>The <code>ActionBar</code> APIs were first added in Android 3.0 (API level 11) but they
are also available in the Support Library
for compatibility with Android 2.1 (API level 7) and above.</p>
<p><b>This guide focuses on how to use the
support library's action bar</b>, but if your app supports <em>only</em> Android 3.0 or higher, you
should use the <code>ActionBar</code> APIs in the framework. Most of the APIs are
the same—but reside in a different package namespace—with a few exceptions to method
names or signatures that are noted in the sections below.</p>
<p><strong>Caution:</strong> Be certain you import
the <code>ActionBar</code> class (and related APIs) from the appropriate package:</p>
<ul>
<li>If supporting API levels <em>lower than</em> 11: <br>
<code>import android.support.v7.app.ActionBar</code></li>
<li>If supporting <em>only</em> API level 11 and higher: <br>
<code>import android.app.ActionBar</code></li>
</ul>
<p><strong>Note:</strong> If you're looking for information about the <em>contextual
action bar</em> for displaying contextual action items, see the Menu guide.</p>
<h2>Adding the Action Bar</h2>
<p>As mentioned above, this guide focuses on how to use the <code>ActionBar</code> APIs in the support library. So before you can add the action
bar, you must set up your project with the <strong>appcompat v7</strong> support library by
following the instructions in the Support
Library Setup.</p>
<p>Once your project is set up with the support library, here's how to add the action bar:</p>
<ol>
  <li>Create your activity by extending <code>ActionBarActivity</code>.</li>
  <li>Use (or extend) one of the <code>Theme.AppCompat</code> themes for your activity. For example:
  <pre>&lt;activity android:theme="@style/Theme.AppCompat.Light" ... &gt;</pre>
  </li>
</ol>
<p>WHATSON? 6bbcf653-0420-4688-8200-e265e1e59cba</p>
<pre>&lt;activity android:theme="@style/Theme.AppCompat.Light" ... &gt;</pre>
<p>Now your activity includes the action bar when running on Android 2.1 (API level 7) or higher.
</p>
<p><b>On API level 11 or higher</b></p>
<p>The action bar is included in all activities that use the
<code>Theme.Holo</code> theme (or one of its
descendants), which is the default theme when either the <code>targetSdkVersion</code> or
<code>minSdkVersion</code>
attribute is set to <code>"11"</code> or higher. If you don't want the action bar for an
activity, set the activity theme to <code>Theme.Holo.NoActionBar</code>.</p>
<h3>Removing the action bar</h3>
<p>You can hide the action bar at runtime by calling <code>hide()</code>.
For example:</p>
<p>WHATSON? 2d917a91-ce10-4c5a-9f68-0b8b0824ad2b</p>
<pre>
ActionBar actionBar = <code>getSupportActionBar()</code>;
actionBar.hide();
</pre>
<p><b>On API level 11 or higher</b></p>
<p>Get the <code>ActionBar</code> with the <code>getActionBar()</code>
method.</p>
<p>When the action bar hides, the system adjusts your layout to fill the
screen space now available. You can bring the action bar back by calling <code>show()</code>.</p>
<p>Beware that hiding and removing the action bar causes your activity to re-layout in order to
account for the space consumed by the action bar. If your activity often hides and shows the
action bar, you might want to enable <em>overlay mode</em>. Overlay mode
draws the action bar in front of your activity layout, obscuring the top portion. This
way, your layout remains fixed when the action bar hides and re-appears. To enable overlay mode,
create a custom theme for your activity and set <code>windowActionBarOverlay</code> to <code>true</code>. For more information, see the section below about Styling the Action Bar.</p>
<h3>Using a logo instead of an icon</h3>
<p>By default, the system uses your application icon in the action bar, as specified by the <code>icon</code>
attribute in the <code>&lt;application&gt;</code> or <code>&lt;activity&gt;</code> element. However, if you also specify the <code>logo</code>
attribute, then the action bar uses the logo image instead of the icon.</p>
<p>A logo should usually be wider than the icon, but should not include unnecessary text. You
should generally use a logo only when it represents your brand in a traditional format that users
recognize. A good example is the YouTube app's logo—the logo represents the expected user
brand, whereas the app's icon is a modified version that conforms to the square requirement
for the launcher icon.</p>
<h2>Adding Action Items</h2>
<p><strong>Figure 2.</strong> Action bar with three action buttons and
the overflow button.</p>
<p>The action bar provides users access to the most important action
items relating to the app's current
context. Those that appear directly in the action bar with an icon and/or text are known
as <em>action buttons</em>. Actions that can't fit in the action bar or aren't
important enough are hidden in the action overflow.
The user can reveal a list of the other actions by pressing the overflow button
on the right side (or the device <em>Menu</em> button, if available).</p>
<p>When your activity starts, the system populates the action items by calling your activity's
<code>onCreateOptionsMenu()</code> method. Use this
method to inflate a menu resource that defines all the
action items. For example, here's a menu resource defining a couple of menu items:</p>
<p>res/menu/main_activity_actions.xml</p>
<p>WHATSON? 356277e4-fa2e-4fef-b6e0-b13270883b27</p>
<pre>
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt;
    &lt;item android:id="@+id/action_search"
          android:icon="@drawable/ic_action_search"
          android:title="@string/action_search"/&gt;
    &lt;item android:id="@+id/action_compose"
          android:icon="@drawable/ic_action_compose"
          android:title="@string/action_compose" /&gt;
&lt;/menu&gt;
</pre>
<p>Then in your activity's <code>onCreateOptionsMenu()</code>
method, inflate the menu resource into the given <code>Menu</code>
to add each item to the action bar:</p>
<p>WHATSON? e4ca4d8e-8215-4b4b-8c10-65cf978c5e98</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu items for use in the action bar
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.main_activity_actions, menu);
    return super.onCreateOptionsMenu(menu);
}
</pre>
<p>To request that an item appear directly in the action bar
as an action button, include <code>showAsAction="ifRoom"</code> in the <code>&lt;item&gt;</code> tag. For example:</p>
<p>WHATSON? ab0511c9-11cd-4c21-ad62-a55910e89f51</p>
<pre>
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
      <strong>xmlns:yourapp="http://schemas.android.com/apk/res-auto"</strong> &gt;
    &lt;item android:id="@+id/action_search"
          android:icon="@drawable/ic_action_search"
          android:title="@string/action_search"
          <strong>yourapp:showAsAction="ifRoom"</strong>  /&gt;
    ...
&lt;/menu&gt;
</pre>
<p>If there's not enough room for the item in the action bar, it will appear in the action
overflow.</p>
<p><strong>Using XML attributes from the support library</strong></p>
<p>If your menu item supplies both a title and an icon—with the <code>title</code> and
<code>icon</code> attributes—then the action item shows only the icon by default. If you
want to display the text title, add <code>"withText"</code> to the <code>showAsAction</code>
attribute. For example:</p>
<p>WHATSON? 14401082-393a-4441-b9f8-f02a7b130ca6</p>
<pre>
&lt;item yourapp:showAsAction="ifRoom|withText" ... /&gt;
</pre>
<p><strong>Note:</strong> The <code>"withText"</code> value is a <em>hint</em> to the
action bar that the text title should appear. The action bar will show the title when possible, but
might not if an icon is available and the action bar is constrained for space.</p>
<p>You should always define the <code>title</code> for each item even if you don't declare that
the title appear with the action item, for the following reasons:</p>
<ul>
  <li>If there's not enough room in the action bar for the action item, the menu item appears
in the overflow where only the title appears.</li>
  <li>Screen readers for sight-impaired users read the menu item's title.</li>
  <li>If the action item appears with only the icon, a user can long-press the item to reveal a
tool-tip that displays the action title.</li>
</ul>
<p>The <code>icon</code> is optional, but recommended. For icon design recommendations,
see the Iconography design
guide. You can also download a set of standard action bar icons (such as for Search or Discard)
from the Downloads page.</p>
<p>You can also use <code>"always"</code> to declare that an item always appear as an action button.
However, you <strong>should not</strong> force an item to appear in the action bar this
way. Doing so can create layout problems on devices with a narrow screen. It's best to instead
use <code>"ifRoom"</code> to request that an item appear in the action bar, but allow the system to move
it into the overflow when there's not enough room. However, it might be necessary to use this value
if the item includes an action view that cannot be collapsed and
must always be visible to provide access to a critical feature.</p>
<h3>Handling clicks on action items</h3>
<p>When the user presses an action, the system calls your activity's <code>onOptionsItemSelected()</code> method. Using the
<code>MenuItem</code> passed to this method, you can identify the action by calling <code>getItemId()</code>. This returns the unique ID provided by the <code>&lt;item&gt;</code>
tag's <code>id</code> attribute so you can perform the appropriate action. For example:</p>
<p>WHATSON? 0b5b308f-9f68-41cb-8c72-35fb96f42c10</p>
<pre>
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle presses on the action bar items
    switch (item.getItemId()) {
        case R.id.action_search:
            openSearch();
            return true;
        case R.id.action_compose:
            composeMessage();
            return true;
        default:
            return super.onOptionsItemSelected(item);
    }
}
</pre>
<p><strong>Note:</strong> If you inflate menu items from a fragment, via the <code>Fragment</code> class's <code>onCreateOptionsMenu()</code>
callback, the system calls <code>onOptionsItemSelected()</code> for that
fragment when the user selects one of those items. However, the activity gets a chance to
handle the event first, so the system first calls <code>onOptionsItemSelected()</code> on the activity,
before calling the same callback for the fragment. To ensure that any fragments in the
activity also have a chance to handle the callback, always pass the call to the superclass
as the default behavior instead of returning <code>false</code> when you do not handle the item.</p>
<p><strong>Figure 3.</strong> Mock-ups showing an action bar with
tabs (left), then with split action bar (middle); and with the app icon and title disabled
(right).</p>
<h3>Using split action bar</h3>
<p>Split action bar provides a separate
bar at the bottom of the screen to display all action items when the activity is running on
a narrow screen (such as a portrait-oriented handset).</p>
<p>Separating the action items this way
ensures that a reasonable amount of space is available to display all your action
items on a narrow screen, while leaving room for navigation and title elements at the top.</p>
<p>To enable split action bar when using the support library, you must do two things:</p>
<ol>
  <li>Add <code>uiOptions="splitActionBarWhenNarrow"</code> to each
<code>&lt;activity&gt;</code>
element or to the
<code>&lt;application&gt;</code>
element. This attribute is understood only by API level 14 and higher (it is ignored
by older versions).</li>
  <li>To support older versions, add a <code>&lt;meta-data&gt;</code>
  element as a child of each
  <code>&lt;activity&gt;</code>
  element that declares the same value for <code>"android.support.UI_OPTIONS"</code>.</li>
</ol>
<p>For example:</p>
<p>WHATSON? 15268113-fa43-4d0f-bda6-c315c5fb25ab</p>
<pre>
&lt;manifest ...&gt;
    &lt;activity uiOptions="splitActionBarWhenNarrow" ... &gt;
        &lt;meta-data android:name="android.support.UI_OPTIONS"
                   android:value="splitActionBarWhenNarrow" /&gt;
    &lt;/activity&gt;
&lt;/manifest&gt;
</pre>
<p>Using split action bar also allows navigation tabs to collapse into the
main action bar if you remove the icon and title (as shown on the right in figure 3).
To create this effect, disable the action bar
icon and title with <code>setDisplayShowHomeEnabled(false)</code> and <code>setDisplayShowTitleEnabled(false)</code>.</p>
<h2>Navigating Up with the App Icon</h2>
<h3>Design Guide</h3>
<p>Navigation with Back and Up</p>
<p><strong>Figure 4.</strong> The <em>Up</em> button in Gmail.</p>
<p>Enabling the app icon as an <em>Up</em> button allows the user to navigate your app based
on the hierarchical relationships between screens. For instance, if screen A displays a list of
items, and selecting an item leads to screen B, then
screen B should include the <em>Up</em> button, which returns to screen A.</p>
<p><strong>Note:</strong> Up navigation is distinct from the back navigation provided
by the system <em>Back</em> button. The <em>Back</em> button is used to navigate in reverse
chronological order through the history of screens the user has recently worked with. It is
generally based on the temporal relationships between screens, rather than the app's hierarchy
structure (which is the basis for up navigation).</p>
<p>To enable the app icon as an <em>Up</em> button, call <code>setDisplayHomeAsUpEnabled()</code>.
For example:</p>
<p>WHATSON? 910840b1-ad00-4190-96c4-b54b4d5a41be</p>
<pre>
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_details);

    ActionBar actionBar = getSupportActionBar();
    actionBar.setDisplayHomeAsUpEnabled(true);
    ...
}
</pre>
<p>Now the icon in the action bar appears with the <em>Up</em> caret (as shown in figure 4).
However, it won't do anything by default. To specify the activity to open when the
user presses <em>Up</em> button, you have two options:</p>
<ul>
  <li><b>Specify the parent activity in the manifest file.</b>
    <p>This is the best option when <strong>the parent activity is always the same</strong>. By
declaring in the manifest which activity is the parent, the action bar automatically performs the
correct action when the user presses the <em>Up</em> button.</p>

    <p>Beginning in Android 4.1 (API level 16), you can declare the parent with the <code>parentActivityName</code>
attribute in the <code>&lt;activity&gt;</code> element.</p>
    <p>To support older devices with the support library, also
include a <code>&lt;meta-data&gt;</code> element that specifies
the parent activity as the value for <code>android.support.PARENT_ACTIVITY</code>. For example:</p>
<pre>
&lt;application ... &gt;
    ...
    &lt;!-- The main/home activity (has no parent activity) --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.MainActivity" ...&gt;
        ...
    &lt;/activity&gt;
    &lt;!-- A child of the main activity --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.example.myfirstapp.MainActivity" &gt;
        &lt;!-- Parent activity meta-data to support API level 7+ --&gt;
        &lt;meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" /&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</pre>

  <p>Once the parent activity is specified in the manifest like this and you enable the <em>Up</em>
  button with <code>setDisplayHomeAsUpEnabled()</code>, your work
is done and the action bar properly navigates up.</p>
  </li>


  <li><strong>Or, override <code>getSupportParentActivityIntent()</code> and <code>onCreateSupportNavigateUpTaskStack()</code> in your activity</strong>.</li>

    <p>This is appropriate when <strong>the parent activity may be different</strong> depending
    on how the user arrived at the current screen. That is, if there are many paths that the user
    could have taken to reach the current screen, the <em>Up</em> button should navigate
    backward along the path the user actually followed to get there.</p>

    <p>The system calls <code>getSupportParentActivityIntent()</code> when the user presses
the <em>Up</em> button while navigating your app (within your app's own task). If the activity that
should open upon up navigation differs depending on how the user arrived at the current location,
then you should override this method to return the <code>Intent</code> that starts the appropriate parent activity.</p>

    <p>The system calls <code>onCreateSupportNavigateUpTaskStack()</code> for your activity when the user presses the <em>Up</em>
button while your activity is running in a task that does <em>not</em> belong to your app. Thus,
you must use the <code>TaskStackBuilder</code> passed to this method to construct
the appropriate back stack that should be synthesized when the user navigates up.</p>

    <p>Even if you override <code>getSupportParentActivityIntent()</code> to specify up navigation
as the user navigates your app, you can avoid the need to implement <code>onCreateSupportNavigateUpTaskStack()</code> by declaring "default" parent activities in the manifest file
as shown above. Then the default implementation of <code>onCreateSupportNavigateUpTaskStack()</code> will synthesize a back stack based on the parent activities
declared in the manifest.</p>

  
</ul>
<p>This is the best option when <strong>the parent activity is always the same</strong>. By
declaring in the manifest which activity is the parent, the action bar automatically performs the
correct action when the user presses the <em>Up</em> button.</p>
<p>Beginning in Android 4.1 (API level 16), you can declare the parent with the <code>parentActivityName</code>
attribute in the <code>&lt;activity&gt;</code> element.</p>
<p>To support older devices with the support library, also
include a <code>&lt;meta-data&gt;</code> element that specifies
the parent activity as the value for <code>android.support.PARENT_ACTIVITY</code>. For example:</p>
<p>WHATSON? 1785e65d-21b1-4c8a-babe-8cb0c140f3a5</p>
<pre>
&lt;application ... &gt;
    ...
    &lt;!-- The main/home activity (has no parent activity) --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.MainActivity" ...&gt;
        ...
    &lt;/activity&gt;
    &lt;!-- A child of the main activity --&gt;
    &lt;activity
        android:name="com.example.myfirstapp.DisplayMessageActivity"
        android:label="@string/title_activity_display_message"
        android:parentActivityName="com.example.myfirstapp.MainActivity" &gt;
        &lt;!-- Parent activity meta-data to support API level 7+ --&gt;
        &lt;meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" /&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</pre>
<p>Once the parent activity is specified in the manifest like this and you enable the <em>Up</em>
  button with <code>setDisplayHomeAsUpEnabled()</code>, your work
is done and the action bar properly navigates up.</p>
<p>This is appropriate when <strong>the parent activity may be different</strong> depending
    on how the user arrived at the current screen. That is, if there are many paths that the user
    could have taken to reach the current screen, the <em>Up</em> button should navigate
    backward along the path the user actually followed to get there.</p>
<p>The system calls <code>getSupportParentActivityIntent()</code> when the user presses
the <em>Up</em> button while navigating your app (within your app's own task). If the activity that
should open upon up navigation differs depending on how the user arrived at the current location,
then you should override this method to return the <code>Intent</code> that starts the appropriate parent activity.</p>
<p>The system calls <code>onCreateSupportNavigateUpTaskStack()</code> for your activity when the user presses the <em>Up</em>
button while your activity is running in a task that does <em>not</em> belong to your app. Thus,
you must use the <code>TaskStackBuilder</code> passed to this method to construct
the appropriate back stack that should be synthesized when the user navigates up.</p>
<p>Even if you override <code>getSupportParentActivityIntent()</code> to specify up navigation
as the user navigates your app, you can avoid the need to implement <code>onCreateSupportNavigateUpTaskStack()</code> by declaring "default" parent activities in the manifest file
as shown above. Then the default implementation of <code>onCreateSupportNavigateUpTaskStack()</code> will synthesize a back stack based on the parent activities
declared in the manifest.</p>
<p><strong>Note:</strong>
If you've built your app hierarchy using a series of fragments instead of multiple
activities, then neither of the above options will work. Instead, to navigate up through your
fragments, override <code>onSupportNavigateUp()</code>
to perform the appropriate fragment transaction—usually by popping
the current fragment from the back stack by calling <code>popBackStack()</code>.</p>
<p>For more information about implementing <em>Up</em> navigation, read
Providing Up Navigation.</p>
<h2>Adding an Action View</h2>
<p><strong>Figure 5.</strong> An action bar with a collapsible
<code>SearchView</code>.</p>
<p>An <em>action view</em> is a widget that appears in the action bar as a substitute for an action
button. An action view provides fast access to rich actions without changing activities or
fragments, and without replacing the action bar. For example, if you have an action for Search, you
can add an action view to
embeds a <code>SearchView</code> widget in the action bar, as shown in figure
5.</p>
<p>To declare an action view, use either the <code>actionLayout</code> or <code>actionViewClass</code> attribute to specify either a layout
resource or widget class to use, respectively. For example, here's how to add
the <code>SearchView</code> widget:</p>
<p>WHATSON? 4a3dd91c-ffb9-40a2-a782-b838d7714b05</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:yourapp="http://schemas.android.com/apk/res-auto" &gt;
    &lt;item android:id="@+id/action_search"
          android:title="@string/action_search"
          android:icon="@drawable/ic_action_search"
          yourapp:showAsAction="ifRoom|collapseActionView"
          <b>yourapp:actionViewClass="android.support.v7.widget.SearchView"</b> /&gt;
&lt;/menu&gt;
</pre>
<p>Notice that the <code>showAsAction</code> attribute also includes the <code>"collapseActionView"</code>
value. This is optional and declares that the action view should be collapsed into a
button. (This behavior is explained further in the following section about
Handling collapsible action views.)</p>
<p>If you need to configure the action view (such as to add event listeners), you can do so during
the <code>onCreateOptionsMenu()</code> callback. You can
acquire the action view object by calling the static method <code>MenuItemCompat.getActionView()</code> and passing it
the corresponding <code>MenuItem</code>. For example, the search widget from the above
sample is acquired like this:</p>
<p>WHATSON? 1796adcc-d1d0-464b-bb76-93b125d81ebe</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_activity_actions, menu);
    MenuItem searchItem = menu.findItem(R.id.action_search);
    SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
    // Configure the search info and add any event listeners
    ...
    return super.onCreateOptionsMenu(menu);
}
</pre>
<p><b>On API level 11 or higher</b></p>
<p>Get the action view by calling <code>getActionView()</code> on the
corresponding <code>MenuItem</code>:</p>
<p>WHATSON? 33b9ebd2-c2b7-4750-89a6-4332e7334d82</p>
<pre>menu.findItem(R.id.action_search).getActionView()</pre>
<p>For more information about using the search widget, see Creating a Search Interface.</p>
<h3>Handling collapsible action views</h3>
<p>To preserve the action bar space, you can collapse your action view into an action button.
When collapsed, the system might place the action
into the action overflow, but the
action view still appears in the action bar when the user selects it. You can make your action
view collapsible by adding <code>"collapseActionView"</code> to the <code>showAsAction</code>
attribute, as shown in the XML above.</p>
<p>Because the system expands the action view when the user selects the action, you
<em>do not</em> need to respond to the item in the <code>onOptionsItemSelected()</code> callback. The system still calls
<code>onOptionsItemSelected()</code>, but if
you return <code>true</code> (indicating you've handled the event instead), then the
action view will <em>not</em> expand.</p>
<p>The system also collapses your action view when the user presses the <em>Up</em> button
or <em>Back</em> button.</p>
<p>If you need to update your activity based on the visibility of your action view, you can receive
callbacks when the action is expanded and collapsed by defining an <code>OnActionExpandListener</code> and
passing it to <code>setOnActionExpandListener()</code>. For example:</p>
<p>WHATSON? 6fa20bdd-dd6f-4270-b4ba-1be9854994c4</p>
<pre>
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.options, menu);
    MenuItem menuItem = menu.findItem(R.id.actionItem);
    ...

    // When using the support library, the setOnActionExpandListener() method is
    // static and accepts the MenuItem object as an argument
    MenuItemCompat.setOnActionExpandListener(menuItem, new OnActionExpandListener() {
        @Override
        public boolean onMenuItemActionCollapse(MenuItem item) {
            // Do something when collapsed
            return true;  // Return true to collapse action view
        }

        @Override
        public boolean onMenuItemActionExpand(MenuItem item) {
            // Do something when expanded
            return true;  // Return true to expand action view
        }
    });
}
</pre>
<h2>Adding an Action Provider</h2>
<p><strong>Figure 6.</strong> An action bar with
  <code>ShareActionProvider</code> expanded to show share targets.</p>
<p>Similar to an action view, an <em>action provider</em>
replaces an action button with a customized layout. However,
unlike an action view, an action provider takes control of all the action's behaviors
and an action provider can display a submenu when pressed.</p>
<p>To declare an action provider, supply the <code>actionViewClass</code> attribute in the
menu <code>&lt;item&gt;</code> tag with a fully-qualified class name for an
<code>ActionProvider</code>.</p>
<p>You can build your own action provider by extending the <code>ActionProvider</code> class, but Android provides some pre-built action providers
such as <code>ShareActionProvider</code>, which facilitates a "share" action
by showing a list of possible apps for sharing directly in the action bar (as shown in figure
6).</p>
<p>Because each <code>ActionProvider</code> class defines its own action
behaviors, you don't need to listen for the action in the <code>onOptionsItemSelected()</code> method. If necessary though,
you can still listen for the click event in the <code>onOptionsItemSelected()</code> method in case you need to simultaneously perform another action. But be
sure to return <code>false</code> so that the the action provider still receives the <code>onPerformDefaultAction()</code> callback to perform its intended
action.</p>
<p>However, if the action provider provides a submenu of actions, then your
activity does not receive a call to <code>onOptionsItemSelected()</code> when the user opens the list or selects one of the submenu items.</p>
<h3>Using the ShareActionProvider</h3>
<p>To add a "share" action with <code>ShareActionProvider</code>,
define the <code>actionProviderClass</code> for an <code>&lt;item&gt;</code> tag with
the <code>ShareActionProvider</code> class. For example:</p>
<p>WHATSON? 3303556d-c123-4b12-a8cf-bb53f2562089</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:yourapp="http://schemas.android.com/apk/res-auto" &gt;
    &lt;item android:id="@+id/action_share"
          android:title="@string/share"
          yourapp:showAsAction="ifRoom"
          <strong>yourapp:actionProviderClass="android.support.v7.widget.ShareActionProvider"</strong>
          /&gt;
    ...
&lt;/menu&gt;
</pre>
<p>Now the action provider takes control of the action item and handles both
its appearance and behavior. But you must
still provide a title for the item to be used when it appears in the action overflow.</p>
<p>The only thing left to do is define
the <code>Intent</code> you want to use for sharing. To do so, edit
your <code>onCreateOptionsMenu()</code> method to call <code>MenuItemCompat.getActionProvider()</code>
and pass it the <code>MenuItem</code> holding the action provider. Then call <code>setShareIntent()</code> on the
returned <code>ShareActionProvider</code> and pass it an
<code>ACTION_SEND</code> intent with the appropriate content attached.</p>
<p>You should call <code>setShareIntent()</code> once during <code>onCreateOptionsMenu()</code> to initialize the share action,
but because the user context might change, you must update the intent any time the shareable
content changes by again calling <code>setShareIntent()</code>.</p>
<p>For example:</p>
<p>WHATSON? 79229b93-f949-45c6-b3b6-94e3306f308b</p>
<pre>
private ShareActionProvider mShareActionProvider;

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_activity_actions, menu);

    // Set up ShareActionProvider's default share intent
    MenuItem shareItem = menu.findItem(R.id.action_share);
    mShareActionProvider = (ShareActionProvider)
            MenuItemCompat.getActionProvider(shareItem);
    mShareActionProvider.setShareIntent(getDefaultIntent());

    return super.onCreateOptionsMenu(menu);
}

/** Defines a default (dummy) share intent to initialize the action provider.
  * However, as soon as the actual content to be used in the intent
  * is known or changes, you must update the share intent by again calling
  * mShareActionProvider.<code>setShareIntent()</code>
  */
private Intent getDefaultIntent() {
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.setType("image/*");
    return intent;
}
</pre>
<p>The <code>ShareActionProvider</code> now handles all user interaction with
the item and you <em>do not</em> need to handle click events from the <code>onOptionsItemSelected()</code> callback method.</p>
<p>By default, the <code>ShareActionProvider</code> retains a ranking for each
share target based on how often the user selects each one. The share targets used more frequently
appear at the top of the drop-down list and the target used most often appears directly in the
action bar as the default share target. By default, the ranking information is saved in a private
file with a name specified by <code>DEFAULT_SHARE_HISTORY_FILE_NAME</code>. If you use the
<code>ShareActionProvider</code> or an extension of it for only one type of
action, then you should continue to use this default history file and there's nothing you need to
do. However, if you use <code>ShareActionProvider</code> or an extension of it
for multiple actions with semantically different meanings, then each <code>ShareActionProvider</code> should specify its own history file in order to
maintain its own history. To specify a different history file for the <code>ShareActionProvider</code>, call <code>setShareHistoryFileName()</code>
and provide an XML file name (for example, <code>"custom_share_history.xml"</code>).</p>
<p><strong>Note:</strong> Although the <code>ShareActionProvider</code> ranks share targets based on frequency of use, the
behavior is extensible and extensions of <code>ShareActionProvider</code> can
perform different behaviors and ranking based on the history file (if appropriate).</p>
<h3>Creating a custom action provider</h3>
<p>Creating your own action provider allows you to re-use and manage dynamic action item
behaviors in a self-contained module, rather than handle action item transformations and
behaviors in your fragment or activity
code. As shown in the previous section, Android already provides an implementation of <code>ActionProvider</code> for share actions: the <code>ShareActionProvider</code>.</p>
<p>To create your own action provider for a different action, simply extend the
<code>ActionProvider</code> class and implement
its callback methods as appropriate. Most importantly, you should implement the following:</p>
<p>WHATSON? 9e08a743-e14c-4dca-bb64-eb613ee0e6a8</p>
<pre>
public View onCreateActionView(MenuItem forItem) {
    // Inflate the action view to be shown on the action bar.
    LayoutInflater layoutInflater = LayoutInflater.from(mContext);
    View view = layoutInflater.inflate(R.layout.action_provider, null);
    ImageButton button = (ImageButton) view.findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // Do something...
        }
    });
    return view;
}
</pre>
<p>However, if your action provider provides a submenu, through the <code>onPrepareSubMenu()</code> callback, then the
submenu appears even when the action provider is placed in the action overflow. Thus, <code>onPerformDefaultAction()</code> is never called when there is a
submenu.</p>
<p><strong>Note:</strong> An activity or a fragment that implements <code>onOptionsItemSelected()</code> can override the action
provider's default behavior (unless it uses a submenu) by handling the item-selected event (and
returning <code>true</code>), in which case, the system does not call <code>onPerformDefaultAction()</code>.</p>
<p>For an example extension of <code>ActionProvider</code>, see ActionBarSettingsActionProviderActivity.</p>
<h2>Adding Navigation Tabs</h2>
<p><strong>Figure 7.</strong> Action bar tabs on a wide screen.</p>
<h3>Design Guide</h3>
<p>Tabs</p>
<h3>Also read</h3>
<p>Creating Swipe Views with Tabs</p>
<p><strong>Figure 8.</strong> Tabs on a narrow screen.</p>
<p>Tabs in the action bar make it easy for users to explore and switch between different views in
your app. The tabs provided by the <code>ActionBar</code> are ideal because they
adapt to different screen sizes. For example, when the screen is wide enough the tabs appear in the
action bar alongside the action buttons (such as when on a tablet, shown in figure 7), while when
on a narrow screen they appear in a separate bar (known as the "stacked action bar", shown in
figure 8). In some cases, the Android system will instead show your tab items as a drop-down list
to ensure the best fit in the action bar.</p>
<p>To get started, your layout must include a <code>ViewGroup</code> in which you place
each <code>Fragment</code> associated with a tab. Be sure the <code>ViewGroup</code>
has a resource ID so you can reference it from your code and swap the tabs within it.
Alternatively, if the tab content will fill the activity layout, then your activity doesn't need a
layout at all (you don't even need to call <code>setContentView()</code>). Instead, you can place each fragment in the default root view, which you can
refer to with the <code>android.R.id.content</code> ID.</p>
<p>Once you determine where the fragments appear in the layout, the basic procedure to add tabs
is:</p>
<ol>
  <li>Implement the <code>ActionBar.TabListener</code> interface. This interface
  provides callbacks for tab events, such as when the user presses one so you can swap the
  tabs.</li>
  <li>For each tab you want to add, instantiate an <code>ActionBar.Tab</code>
  and set the <code>ActionBar.TabListener</code> by calling <code>setTabListener()</code>. Also set the tab's title
  and with <code>setText()</code> (and optionally, an icon with
  <code>setIcon()</code>).</li>
  <li>Then add each tab to the action bar by calling <code>addTab()</code>.</li>
</ol>
<p>Notice that the <code>ActionBar.TabListener</code>
callback methods don't specify which fragment is associated with the tab, but merely which
<code>ActionBar.Tab</code> was selected.
You must define your own association
between each <code>ActionBar.Tab</code> and the appropriate <code>Fragment</code> that
it represents. There are several ways you
can define the association, depending on your design.</p>
<p>For example, here's how you might implement the <code>ActionBar.TabListener</code>
such that each tab uses its own instance of the listener:</p>
<p>WHATSON? 569f7fc4-4282-48af-a449-d8d79e9828f7</p>
<pre>
public static class TabListener&lt;T extends Fragment&gt; implements ActionBar.TabListener {
    private Fragment mFragment;
    private final Activity mActivity;
    private final String mTag;
    private final Class&lt;T&gt; mClass;

    /** Constructor used each time a new tab is created.
      * @param activity  The host Activity, used to instantiate the fragment
      * @param tag  The identifier tag for the fragment
      * @param clz  The fragment's Class, used to instantiate the fragment
      */
    public TabListener(Activity activity, String tag, Class&lt;T&gt; clz) {
        mActivity = activity;
        mTag = tag;
        mClass = clz;
    }

    /* The following are each of the <code>ActionBar.TabListener</code> callbacks */

    public void onTabSelected(Tab tab, FragmentTransaction ft) {
        // Check if the fragment is already initialized
        if (mFragment == null) {
            // If not, instantiate and add it to the activity
            mFragment = Fragment.instantiate(mActivity, mClass.getName());
            ft.add(android.R.id.content, mFragment, mTag);
        } else {
            // If it exists, simply attach it in order to show it
            ft.attach(mFragment);
        }
    }

    public void onTabUnselected(Tab tab, FragmentTransaction ft) {
        if (mFragment != null) {
            // Detach the fragment, because another one is being attached
            ft.detach(mFragment);
        }
    }

    public void onTabReselected(Tab tab, FragmentTransaction ft) {
        // User selected the already selected tab. Usually do nothing.
    }
}
</pre>
<p><strong>Caution:</strong> You <strong>must not</strong> call <code>commit()</code> for the fragment transaction in each of these
callbacks—the system calls it for you and it may throw an exception if you call it yourself.
You also <strong>cannot</strong> add these fragment transactions to the back stack.</p>
<p>In this example, the listener simply attaches (<code>attach()</code>) a fragment to the activity layout—or if not instantiated, creates the fragment and
adds (<code>add()</code>) it to the layout (as a child of the <code>android.R.id.content</code> view group)—when the respective tab is selected, and detaches (<code>detach()</code>) it when the tab is unselected.</p>
<p>All that remains is to create each <code>ActionBar.Tab</code> and add it to the <code>ActionBar</code>. Additionally, you must call <code>setNavigationMode(NAVIGATION_MODE_TABS)</code> to make the
tabs visible.</p>
<p>For example, the following code adds two tabs using the listener defined above:</p>
<p>WHATSON? c3d5ede9-8051-461d-847e-c1a1248b3ea7</p>
<pre>
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Notice that setContentView() is not used, because we use the root
    // android.R.id.content as the container for each fragment

    // setup action bar for tabs
    ActionBar actionBar = getSupportActionBar();
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
    actionBar.setDisplayShowTitleEnabled(false);

    Tab tab = actionBar.newTab()
                       .setText(R.string.artist)
                       .setTabListener(new TabListener&lt;ArtistFragment&gt;(
                               this, "artist", ArtistFragment.class));
    actionBar.addTab(tab);

    tab = actionBar.newTab()
                   .setText(R.string.album)
                   .setTabListener(new TabListener&lt;AlbumFragment&gt;(
                           this, "album", AlbumFragment.class));
    actionBar.addTab(tab);
}
</pre>
<p>If your activity stops, you should retain the currently selected tab with the saved instance state so you
can open the appropriate tab when the user returns. When it's time to save the state, you can query
the currently selected tab with <code>getSelectedNavigationIndex()</code>. This returns the index position of
the selected tab.</p>
<p><strong>Caution:</strong> It's important that you save the state of each fragment
so when users switch fragments with the tabs and then return to a previous
fragment, it looks the way it did when they left. Some of the state is saved by default, but you
may need to manually save state for customized views. For information about saving the state of your
fragment, see the Fragments
API guide.</p>
<p><strong>Note:</strong> The above implementation for <code>ActionBar.TabListener</code> is one of several possible techniques. Another popular
option is to use <code>ViewPager</code> to manage the fragments so users
can also use a swipe gesture to switch tabs. In this case, you simply tell the
<code>ViewPager</code> the current tab position in the
<code>onTabSelected()</code> callback.
For more information, read
Creating Swipe Views with Tabs.</p>
<h2>Adding Drop-down Navigation</h2>
<p><strong>Figure 9.</strong> A drop-down navigation list in the
action bar.</p>
<p>As another mode of navigation (or filtering) for your activity, the action bar offers a built
in drop-down list (also known as a "spinner"). For example, the drop-down list can offer different
modes by which content in the activity is sorted.</p>
<p>Using the drop-down list is useful when changing the content is important but not necessarily a
frequent occurrence. In cases where switching the content is more frequent,
you should use navigation tabs instead.</p>
<p>The basic procedure to enable drop-down navigation is:</p>
<ol>
  <li>Create a <code>SpinnerAdapter</code> that provides the
list of selectable items for the drop-down and the layout to use when drawing each item in the
list.</li>
  <li>Implement <code>ActionBar.OnNavigationListener</code> to define the
  behavior that occurs when the user selects an item from the list.</li>
  <li>During your activity's <code>onCreate()</code> method, enable the action bar's drop-down list by calling <code>setNavigationMode(NAVIGATION_MODE_LIST)</code>.
  </li>
  <li>Set the callback for the drop-down list with <code>setListNavigationCallbacks()</code>.
For example:
<pre>
actionBar.setListNavigationCallbacks(mSpinnerAdapter, mNavigationCallback);
</pre>
<p>This method takes your <code>SpinnerAdapter</code> and <code>ActionBar.OnNavigationListener</code>.</p>
</li>
</ol>
<p>WHATSON? fa13a89e-dda0-439c-88ea-1d614d87c9b9</p>
<pre>
actionBar.setListNavigationCallbacks(mSpinnerAdapter, mNavigationCallback);
</pre>
<p>This method takes your <code>SpinnerAdapter</code> and <code>ActionBar.OnNavigationListener</code>.</p>
<p>This procedure is relatively short, but implementing the <code>SpinnerAdapter</code>
and <code>ActionBar.OnNavigationListener</code> is where most of the work is done. There are
many ways you can implement these to define the functionality for your drop-down navigation and
implementing various types of <code>SpinnerAdapter</code> is beyond the scope of this
document (you should refer to the <code>SpinnerAdapter</code> class reference for more
information). However, below is an example for a <code>SpinnerAdapter</code> and <code>ActionBar.OnNavigationListener</code> to get you started (click the title to reveal the
sample).</p>
<h3>
    <img src="/assets/images/triangle-closed.png" class="toggle-content-img" alt="">
    Example SpinnerAdapter and OnNavigationListener
  </h3>
<p><code>SpinnerAdapter</code> is an adapter that provides data for a spinner widget,
such as the drop-down list in the action bar. <code>SpinnerAdapter</code> is an interface
that you can implement, but Android includes some useful implementations that you can extend, such
as <code>ArrayAdapter</code> and <code>SimpleCursorAdapter</code>. For example, here's an easy way to create a <code>SpinnerAdapter</code> by using <code>ArrayAdapter</code> implementation, which
uses a string array as the data source:</p>
<p>WHATSON? 89807a40-bcce-4691-9489-741bcae24a76</p>
<pre>
SpinnerAdapter mSpinnerAdapter = ArrayAdapter.createFromResource(this,
        R.array.action_list, android.R.layout.simple_spinner_dropdown_item);
</pre>
<p>The <code>createFromResource()</code> method takes
three parameters: the application <code>Context</code>, the resource ID for the string
array, and the layout to use for each list item.</p>
<p>A string array
defined in a resource looks like this:</p>
<p>WHATSON? b19cd337-8a52-4b66-80da-dcce8e520a53</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;string-array name="action_list"&gt;
        &lt;item&gt;Mercury&lt;/item&gt;
        &lt;item&gt;Venus&lt;/item&gt;
        &lt;item&gt;Earth&lt;/item&gt;
    &lt;/string-array&gt;
&lt;/resources&gt;
</pre>
<p>The <code>ArrayAdapter</code> returned by <code>createFromResource()</code> is complete and ready for you
to pass it to <code>setListNavigationCallbacks()</code>
(in step 4 from above). Before you do, though, you need to create the <code>OnNavigationListener</code>.</p>
<p>Your implementation of <code>ActionBar.OnNavigationListener</code> is where you handle
fragment changes or other modifications to your activity when the user selects an item from the
drop-down list. There's only one callback method to implement in the listener: <code>onNavigationItemSelected()</code>.</p>
<p>The <code>onNavigationItemSelected()</code>
method receives the position of the item in the list and a unique item ID provided by the <code>SpinnerAdapter</code>.</p>
<p>Here's an example that instantiates an anonymous implementation of <code>OnNavigationListener</code>, which inserts a <code>Fragment</code> into the
layout container identified by <code>R.id.fragment_container</code>:</p>
<p>WHATSON? 8d16ab3d-3d8c-4b44-912d-730eb219a598</p>
<pre>
mOnNavigationListener = new OnNavigationListener() {
  // Get the same strings provided for the drop-down's ArrayAdapter
  String[] strings = getResources().getStringArray(R.array.action_list);

  @Override
  public boolean onNavigationItemSelected(int position, long itemId) {
    // Create new fragment from our own Fragment class
    ListContentFragment newFragment = new ListContentFragment();
    FragmentTransaction ft = getSupportFragmentManager().beginTransaction();

    // Replace whatever is in the fragment container with this fragment
    // and give the fragment a tag name equal to the string at the position
    // selected
    ft.replace(R.id.fragment_container, newFragment, strings[position]);

    // Apply changes
    ft.commit();
    return true;
  }
};
</pre>
<p>This instance of <code>OnNavigationListener</code> is
complete and you can now call <code>setListNavigationCallbacks()</code> (in step 4), passing the <code>ArrayAdapter</code> and this
<code>OnNavigationListener</code>.</p>
<p>In this example, when the user selects an item from the drop-down list, a fragment is added to
the layout (replacing the current fragment in the <code>R.id.fragment_container</code> view). The
fragment added is given a tag that uniquely identifies it, which is the same string used to
identify the fragment in the drop-down list.</p>
<p>Here's a look at the <code>ListContentFragment</code> class that defines each fragment in this
example:</p>
<p>WHATSON? 5544afc6-8e94-4cbd-bf0a-ca9272ed5460</p>
<pre>
public class ListContentFragment extends Fragment {
    private String mText;

    @Override
    public void onAttach(Activity activity) {
      // This is the first callback received; here we can set the text for
      // the fragment as defined by the tag specified during the fragment
      // transaction
      super.onAttach(activity);
      mText = getTag();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        // This is called to define the layout for the fragment;
        // we just create a TextView and set its text to be the fragment tag
        TextView text = new TextView(getActivity());
        text.setText(mText);
        return text;
    }
}
</pre>
<h2>Styling the Action Bar</h2>
<p>If you want to implement a visual design that represents your app's brand, the action bar allows
you to customize each detail of its appearance, including the action bar color, text colors, button
styles, and more. To do so, you need to use Android's style and theme framework to restyle the action bar
using special style properties.</p>
<p><strong>Caution:</strong> For all background drawables you provide, be sure to
use Nine-Patch drawables
to allow stretching. The nine-patch image should be <em>smaller</em> than 40dp tall and 30dp
wide.</p>
<h3>General appearance</h3>
<p>The default for this style for this
      is <code>Widget.AppCompat.ActionBar</code>, which is what you should use as the parent style.</p>
<p>Supported styles include:</p>
<p>The default for this style for this
      is <code>Widget.AppCompat.ActionButton</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
      is <code>Widget.AppCompat.ActionButton.Overflow</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
      is <code>TextAppearance.AppCompat.Widget.ActionBar.Title</code>, which is what you should use as the parent
      style.</p>
<p>Normally, the action bar requires its own space on the screen and your activity layout fills in
what's left over. When the action bar is in overlay mode, your activity layout uses all the
available space and the system draws the action bar on top. Overlay mode can be useful if you want
your content to keep a fixed size and position when the action bar is hidden and shown. You might
also like to use it purely as a visual effect, because you can use a semi-transparent background
for the action bar so the user can still see some of your activity layout behind the action
bar.</p>
<p><strong>Note:</strong> The <code>Holo</code> theme families
draw the action bar with a semi-transparent background by default. However, you can modify it with
your own styles and the <code>DeviceDefault</code> theme on
different devices might use an opaque background by default.</p>
<p>When overlay mode is enabled, your activity layout has no awareness of the action bar lying on
top of it. So, you must be careful not to place any important information or UI components in the
area overlaid by the action bar. If appropriate, you can refer to the platform's value for <code>actionBarSize</code> to determine the height of the action bar, by referencing it
in your XML layout. For example:</p>
<p>WHATSON? 28b0feb2-211a-4a7d-a994-d2d08393e105</p>
<pre>
&lt;SomeView
    ...
    android:layout_marginTop="?android:attr/actionBarSize" /&gt;
</pre>
<p>You can also retrieve the action bar height at runtime with <code>getHeight()</code>. This reflects the height of the action bar at the time it's
called, which might not include the stacked action bar (due to navigation tabs) if called during
early activity lifecycle methods. To see how you can determine the total height at runtime,
including the stacked action bar, see the 
<code>TitlesFragment</code> class in the Honeycomb Gallery sample app.</p>
<h3>Action items</h3>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionButton</code>, which is what you should use as the parent style.</p>
<h3>Navigation tabs</h3>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionBar.TabView</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionBar.TabBar</code>, which is what you should use as the parent style.</p>
<p>The default for this style for this
  is <code>Widget.AppCompat.ActionBar.TabText</code>, which is what you should use as the parent style.</p>
<h3>Drop-down lists</h3>
<p>The default for this style for this
  is <code>Widget.AppCompat.Spinner.DropDown.ActionBar</code>, which is what you should use as the parent
  style.</p>
<h3>Example theme</h3>
<p>Here's an example that defines a custom theme for an activity, <code>CustomActivityTheme</code>,
that includes several styles to customize the action bar.</p>
<p>Notice that there are two versions for each action bar style property. The first one
includes the <code>android:</code> prefix on the property name to support API levels 11 and higher
that include these properties in the framework. The second version does <em>not</em>
include the <code>android:</code> prefix and is for older versions of the platform, on which
the system uses the style property from the support library. The effect for each is the same.</p>
<p>WHATSON? 58eee54a-f7cc-4318-b28e-bf271fd508e6</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;!-- the theme applied to the application or activity --&gt;
    &lt;style name="CustomActionBarTheme"
           parent="@style/Theme.AppCompat.Light"&gt;
        &lt;item name="android:actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
        &lt;item name="android:actionBarTabTextStyle"&gt;@style/TabTextStyle&lt;/item&gt;
        &lt;item name="android:actionMenuTextColor"&gt;@color/actionbar_text&lt;/item&gt;

        &lt;!-- Support library compatibility --&gt;
        &lt;item name="actionBarStyle"&gt;@style/MyActionBar&lt;/item&gt;
        &lt;item name="actionBarTabTextStyle"&gt;@style/TabTextStyle&lt;/item&gt;
        &lt;item name="actionMenuTextColor"&gt;@color/actionbar_text&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- general styles for the action bar --&gt;
    &lt;style name="MyActionBar"
           parent="@style/Widget.AppCompat.ActionBar"&gt;
        &lt;item name="android:titleTextStyle"&gt;@style/TitleTextStyle&lt;/item&gt;
        &lt;item name="android:background"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="android:backgroundStacked"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="android:backgroundSplit"&gt;@drawable/actionbar_background&lt;/item&gt;

        &lt;!-- Support library compatibility --&gt;
        &lt;item name="titleTextStyle"&gt;@style/TitleTextStyle&lt;/item&gt;
        &lt;item name="background"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="backgroundStacked"&gt;@drawable/actionbar_background&lt;/item&gt;
        &lt;item name="backgroundSplit"&gt;@drawable/actionbar_background&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- action bar title text --&gt;
    &lt;style name="TitleTextStyle"
           parent="@style/TextAppearance.AppCompat.Widget.ActionBar.Title"&gt;
        &lt;item name="android:textColor"&gt;@color/actionbar_text&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- action bar tab text --&gt;
    &lt;style name="TabTextStyle"
           parent="@style/Widget.AppCompat.ActionBar.TabText"&gt;
        &lt;item name="android:textColor"&gt;@color/actionbar_text&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;

</pre>
<p>In your manifest file, you can apply the theme to your entire app:</p>
<p>WHATSON? eb1ca9fa-3a1f-4619-92e6-b94b01e3084a</p>
<pre>
&lt;application android:theme="@style/CustomActionBarTheme" ... /&gt;
</pre>
<p>Or to individual activities:</p>
<p>WHATSON? 022bab0e-9364-4af1-82b5-7266af8abd37</p>
<pre>
&lt;activity android:theme="@style/CustomActionBarTheme" ... /&gt;
</pre>
<p><strong>Caution:</strong> Be certain that each theme and style declares a parent
theme in the <code>&lt;style&gt;</code> tag, from which it inherits all styles not explicitly declared
by your theme. When modifying the action bar, using a parent theme is important so that you can
simply override the action bar styles you want to change without re-implementing the styles you
want to leave alone (such as text size or padding in action items).</p>
<p>For more information about using style and theme resources in your application, read Styles and Themes.</p>
</body>
</html>