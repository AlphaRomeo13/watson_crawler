<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Inner-class---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Inner class</h1>
<p>In object-oriented programming (OOP), an <b>inner class</b> or <b>nested class</b> is a class declared entirely within the body of another class or interface. It is distinguished from a subclass.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Overview</li>
<li>2 Types of nested classes in Java</li>
<li>3 Programming languages</li>
<li>4 GUI code</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<p></p>
<h2>Overview</h2>
<p>An instance of a normal or top-level class can exist on its own. By contrast, an instance of an inner class cannot be instantiated without being bound to a top-level class.</p>
<p>Let us take the abstract notion of a <code>Car</code> with four <code>Wheel</code>s. Our <code>Wheel</code>s have a specific feature that relies on being part of our <code>Car</code>. This notion does not represent the <code>Wheel</code>s as <code>Wheel</code>s in a more general form that could be part of a vehicle. Instead, it represents them as specific to this one. We can model this notion using inner classes as follows:</p>
<p>We have the top-level class <code>Car</code>. Instances of Class <code>Car</code> are composed of four instances of the class <code>Wheel</code>. This particular implementation of <code>Wheel</code> is specific to the car, so the code does not model the general notion of a wheel that would be better represented as a top-level class. Therefore, it is semantically connected to the class <code>Car</code> and the code of <code>Wheel</code> is in some way coupled to its outer class.The wheel is more like composition unit to a car. The wheel for a particular car is unique to the car, but for generalization the wheel is aggregation unit to the car.</p>
<p>Inner classes provide us with a mechanism to accurately model this connection. We say that our <code>Wheel</code> class is <code>Car.Wheel</code>, <code>Car</code> being the top-level class and <code>Wheel</code> being the inner class.</p>
<p>Inner classes therefore allow for the object orientation of certain parts of the program that would otherwise not be encapsulated into a class.</p>
<p>Larger segments of code within a class might be better modeled or refactored as a separate top-level class, rather than an inner class. This would make the code more general in its application and therefore more re-usable but potentially might be premature generalization. This may prove more effective, if code has many inner classes with the shared functionality.</p>
<h2>Types of nested classes in Java</h2>
<p>In Java there are four types of <b>nested</b> class:</p>
<ul>
<li>Static member class, also called <i>static nested classes</i> - They are declared <code>static</code>. Like other things in static scope (i.e. static methods), they do not have an enclosing instance, and cannot access instance variables and methods of the enclosing class. They are almost identical to non-nested classes except for scope details (they can refer to static variables and methods of the enclosing class without qualifying the name; other classes that are not one of its enclosing classes have to qualify its name with its enclosing class's name). Nested interfaces are implicitly static.</li>
</ul>
<p>Inner class - The following categories are called <i>inner classes</i>. Each instance of these classes has a reference to an <i>enclosing instance</i> (i.e. an instance of the enclosing class), except for local and anonymous classes declared in static context. Hence, they can implicitly refer to instance variables and methods of the enclosing class. The enclosing instance reference can be explicitly obtained via <code>EnclosingClassName.this</code>. Inner classes may not have static variables or methods, except for compile-time constant variables. When they are created, they must have a reference to an instance of the enclosing class; which means they must either be created within an instance method or constructor of the enclosing class, or (for member and anonymous classes) be created using the syntax <code>enclosingInstance.new InnerClass()</code>.</p>
<ul>
<li>Member class - They are declared outside a function (hence a "member") and not declared "static".</li>
<li>Local class - These are classes that are declared in the body of a function. They can only be referred to in the rest of the function. They can use local variables and parameters of the function, but only ones that are declared "final". (This is because the local class instance must maintain a separate copy of the variable, as it may out-live the function; so as not to have the confusion of two modifiable variables with the same name in the same scope, the variable is forced to be non-modifiable.)</li>
<li>Anonymous class - These are local classes that are automatically declared and instantiated in the middle of an expression. They can only directly extend one class or implement one interface. They can specify arguments to the constructor of the superclass, but cannot otherwise have a constructor (however, this is not a limitation, since it can have an instance initializer block to perform any initialization).</li>
</ul>
<h2>Programming languages</h2>
<ul>
<li>Inner classes became a feature of the Java programming language starting with version 1.1.</li>
<li>Nested classes are also a feature of the D programming language, Visual Basic .NET, Ruby, C++ and C#.</li>
<li>In Python, it is possible to nest a class within another class, method or function.</li>
<li>C++ has nested classes that are like Java's static member classes, except that they are not declared with "static".</li>
</ul>
<h2>GUI code</h2>
<p>Local inner classes are often used in Java to define callbacks for GUI code. Components can then share an object that implements an event handling interface or extends an abstract adapter class, containing the code to be executed when a given event is triggered.</p>
<p>Anonymous inner classes are also used where the event handling code is only used by one component and therefore does not need a named reference.</p>
<p>This avoids a large monolithic <b><code>actionPerformed(ActionEvent)</code></b> method with multiple if-else branches to identify the source of the event. This type of code is often considered messy and the inner class variations are considered to be better in all regards.</p>
</body>
</html>