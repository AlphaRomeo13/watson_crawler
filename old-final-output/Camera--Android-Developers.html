<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Camera--Android-Developers.html</title></head>
<body>
<h1>Camera</h1>
<h2>In this document</h2>
<ol>
    <li>Considerations</li>
    <li>The Basics
    </li><li>Manifest Declarations</li>
    <li>Using Existing Camera Apps
      <ol>
        <li>Image capture intent</li>
        <li>Video capture intent</li>
        <li>Receiving camera intent result</li>
      </ol>
    </li><li>Building a Camera App
      <ol>
        <li>Detecting camera hardware</li>
        <li>Accessing cameras</li>
        <li>Checking camera features</li>
        <li>Creating a preview class</li>
        <li>Placing preview in a layout</li>
        <li>Capturing pictures</li>
        <li>Capturing videos</li>
        <li>Releasing the camera</li>
      </ol>
    </li>
    <li>Saving Media Files</li>
    <li>Camera Features
      <ol>
        <li>Checking feature availability</li>
        <li>Using camera features</li>
        <li>Metering and focus areas</li>
        <li>Face detection</li>
        <li>Time lapse video</li>
      </ol>
    </li>
  </ol>
<ol>
        <li>Image capture intent</li>
        <li>Video capture intent</li>
        <li>Receiving camera intent result</li>
      </ol>
<ol>
        <li>Detecting camera hardware</li>
        <li>Accessing cameras</li>
        <li>Checking camera features</li>
        <li>Creating a preview class</li>
        <li>Placing preview in a layout</li>
        <li>Capturing pictures</li>
        <li>Capturing videos</li>
        <li>Releasing the camera</li>
      </ol>
<ol>
        <li>Checking feature availability</li>
        <li>Using camera features</li>
        <li>Metering and focus areas</li>
        <li>Face detection</li>
        <li>Time lapse video</li>
      </ol>
<h2>Key Classes</h2>
<ol>
    <li><code>Camera</code></li>
    <li><code>SurfaceView</code></li>
    <li><code>MediaRecorder</code></li>
    <li><code>Intent</code></li>
  </ol>
<h2>See also</h2>
<ol>
    <li>Media Playback</li>
    <li>Data Storage</li>
  </ol>
<p>The Android framework includes support for various cameras and camera features available on
devices, allowing you to capture pictures and videos in your applications. This document discusses a
quick, simple approach to image and video capture and outlines an advanced approach for creating
custom camera experiences for your users.</p>
<h2>Considerations</h2>
<p>Before enabling your application to use cameras on Android devices, you should consider a few
questions about how your app intends to use this hardware feature.</p>
<ul>
  <li><strong>Camera Requirement</strong> - Is the use of a camera so important to your
application that you do not want your application installed on a device that does not have a
camera? If so, you should declare the camera requirement in your
manifest.</li>

  <li><strong>Quick Picture or Customized Camera</strong> - How will your application use the
camera? Are you just interested in snapping a quick picture or video clip, or will your application
provide a new way to use cameras? For a getting a quick snap or clip, consider
Using Existing Camera Apps. For developing a customized camera feature, check
out the Building a Camera App section.</li>

  <li><strong>Storage</strong> - Are the images or videos your application generates intended to be
only visible to your application or shared so that other applications such as Gallery or other
media and social apps can use them? Do you want the pictures and videos to be available even if your
application is uninstalled? Check out the Saving Media Files section to
see how to implement these options.</li>
</ul>
<h2>The Basics</h2>
<p>The Android framework supports capturing images and video through the
<code>android.hardware.camera2</code> API or camera <code>Intent</code>. Here are the relevant
classes:</p>
<h2>Manifest Declarations</h2>
<p>Before starting development on your application with the Camera API, you should make sure
your manifest has the appropriate declarations to allow use of camera hardware and other
related features.</p>
<ul>
  <li><strong>Camera Permission</strong> - Your application must request permission to use a device
camera.
<pre>
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</pre>
  <p><strong>Note:</strong> If you are using the camera via an
intent, your application does not need to request this permission.</p>
  </li>
  <li><strong>Camera Features</strong> - Your application must also declare use of camera features,
for example:
<pre>
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</pre>
  <p>For a list of camera features, see the manifest
Features
Reference.</p>
  <p>Adding camera features to your manifest causes Google Play to prevent your application from
being installed to devices that do not include a camera or do not support the camera features you
specify. For more information about using feature-based filtering with Google Play, see Google
Play and Feature-Based Filtering.</p>
  <p>If your application <em>can use</em> a camera or camera feature for proper operation, but does
not <em>require</em> it, you should specify this in the manifest by including the <code>android:required</code> attribute, and setting it to <code>false</code>:</p>
<pre>
&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;
</pre>

  </li>
  <li><strong>Storage Permission</strong> - If your application saves images or videos to the
device's external storage (SD Card), you must also specify this in the manifest.
<pre>
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</pre>
  </li>
  <li><strong>Audio Recording Permission</strong> - For recording audio with video capture, your
application must request the audio capture permission.
<pre>
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</pre>
  </li>
  <li><strong>Location Permission</strong> - If your application tags images with GPS location
information, you must request location permission:
<pre>
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
</pre>
<p>For more information about getting user location, see
Location Strategies.</p>
  </li>
</ul>
<p>WHATSON? 712bc074-7bd0-4321-ac3c-1dd120bc870c</p>
<pre>
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</pre>
<p><strong>Note:</strong> If you are using the camera via an
intent, your application does not need to request this permission.</p>
<p>WHATSON? 4766deb4-6178-4657-b56b-c026e8b28702</p>
<pre>
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</pre>
<p>For a list of camera features, see the manifest
Features
Reference.</p>
<p>Adding camera features to your manifest causes Google Play to prevent your application from
being installed to devices that do not include a camera or do not support the camera features you
specify. For more information about using feature-based filtering with Google Play, see Google
Play and Feature-Based Filtering.</p>
<p>If your application <em>can use</em> a camera or camera feature for proper operation, but does
not <em>require</em> it, you should specify this in the manifest by including the <code>android:required</code> attribute, and setting it to <code>false</code>:</p>
<p>WHATSON? 9b2baef4-8494-4b1a-9c53-f2bb2bd354bf</p>
<pre>
&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;
</pre>
<p>WHATSON? 24eb2fc3-480f-4db3-9682-b5f86453409a</p>
<pre>
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</pre>
<p>WHATSON? 76c34f55-56e8-47f6-aac1-6643fd15077c</p>
<pre>
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</pre>
<p>WHATSON? c07fc539-5140-49f7-92c4-201b999267f3</p>
<pre>
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
</pre>
<p>For more information about getting user location, see
Location Strategies.</p>
<h2>Using Existing Camera Apps</h2>
<p>A quick way to enable taking pictures or videos in your application without a lot of extra code
is to use an <code>Intent</code> to invoke an existing Android camera application. A
camera intent makes a request to capture a picture or video clip through an existing camera app and
then returns control back to your application. This section shows you how to capture an image or
video using this technique.</p>
<p>The procedure for invoking a camera intent follows these general steps:</p>
<ol>
  <li><strong>Compose a Camera Intent</strong> - Create an <code>Intent</code> that
requests an image or video, using one of these intent types:
    <ul>
      <li><code>MediaStore.ACTION_IMAGE_CAPTURE</code> -
Intent action type for requesting an image from an existing camera application.</li>
      <li><code>MediaStore.ACTION_VIDEO_CAPTURE</code> -
Intent action type for requesting a video from an existing camera application. </li>
    </ul>
  </li>
  <li><strong>Start the Camera Intent</strong> - Use the <code>startActivityForResult()</code>
method to execute the camera intent. After you start the intent, the Camera application user
interface appears on the device screen and the user can take a picture or video.</li>
  <li><strong>Receive the Intent Result</strong> - Set up an <code>onActivityResult()</code> method
in your application to receive the callback and data from the camera intent. When the user
finishes taking a picture or video (or cancels the operation), the system calls this method.</li>
</ol>
<ul>
      <li><code>MediaStore.ACTION_IMAGE_CAPTURE</code> -
Intent action type for requesting an image from an existing camera application.</li>
      <li><code>MediaStore.ACTION_VIDEO_CAPTURE</code> -
Intent action type for requesting a video from an existing camera application. </li>
    </ul>
<h3>Image capture intent</h3>
<p>Capturing images using a camera intent is quick way to enable your application to take pictures
with minimal coding. An image capture intent can include the following extra information:</p>
<ul>
  <li><code>MediaStore.EXTRA_OUTPUT</code> - This setting
requires a <code>Uri</code> object specifying a path and file name where you'd like to
save the picture. This setting is optional but strongly recommended. If you do not specify this
value, the camera application saves the requested picture in the default location with a default
name, specified in the returned intent's <code>Intent.getData()</code>
field.</li>
</ul>
<p>The following example demonstrates how to construct a image capture intent and execute it.
The <code>getOutputMediaFileUri()</code> method in this example refers to the sample code shown in Saving Media Files.</p>
<p>WHATSON? f2d2fdd1-ee1f-4210-9268-d4fb6c412f1b</p>
<pre>
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private Uri fileUri;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // create Intent to take a picture and return control to the calling application
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

    fileUri = getOutputMediaFileUri(MEDIA_TYPE_IMAGE); // create a file to save the image
    intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); // set the image file name

    // start the image capture Intent
    startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE);
}
</pre>
<p>When the <code>startActivityForResult()</code> method is executed, users see a camera application interface.
After the user finishes taking a picture (or cancels the operation), the user interface returns to
your application, and you must intercept the <code>onActivityResult()</code>
method to receive the result of the intent and continue your application execution. For information
on how to receive the completed intent, see Receiving camera intent
result.</p>
<h3>Video capture intent</h3>
<p>Capturing video using a camera intent is a quick way to enable your application to take videos
with minimal coding. A video capture intent can include the following extra information:</p>
<ul>
  <li><code>MediaStore.EXTRA_OUTPUT</code> - This setting
requires a <code>Uri</code> specifying a path and file name where you'd like to save the
video. This setting is optional but strongly recommended. If you do not specify this value, the
Camera application saves the requested video in the default location with a default name, specified
in the returned intent's <code>Intent.getData()</code> field.</li>
  <li><code>MediaStore.EXTRA_VIDEO_QUALITY</code> -
This value can be 0 for lowest quality and smallest file size or 1 for highest quality and
larger file size.</li>
  <li><code>MediaStore.EXTRA_DURATION_LIMIT</code> -
Set this value to limit the length, in seconds, of the video being captured.</li>
  <li><code>MediaStore.EXTRA_SIZE_LIMIT</code> -
Set this value to limit the file size, in bytes, of the video being captured.
</li>
</ul>
<p>The following example demonstrates how to construct a video capture intent and execute it.
The <code>getOutputMediaFileUri()</code> method in this example refers to the sample code shown in Saving Media Files.</p>
<p>WHATSON? bfa45594-3bb8-4fca-ba1f-a3e56ac5d5e6</p>
<pre>
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;
private Uri fileUri;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    //create new Intent
    Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);

    fileUri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  // create a file to save the video
    intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);  // set the image file name

    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); // set the video image quality to high

    // start the Video Capture Intent
    startActivityForResult(intent, CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE);
}
</pre>
<p>When the <code>startActivityForResult()</code> method is executed, users see a modified camera application interface.
After the user finishes taking a video (or cancels the operation), the user interface
returns to your application, and you must intercept the <code>onActivityResult()</code>
method to receive the result of the intent and continue your application execution. For information
on how to receive the completed intent, see the next section.</p>
<h3>Receiving camera intent result</h3>
<p>Once you have constructed and executed an image or video camera intent, your application must be
configured to receive the result of the intent. This section shows you how to intercept the callback
from a camera intent so your application can do further processing of the captured image or
video.</p>
<p>In order to receive the result of an intent, you must override the <code>onActivityResult()</code> in the
activity that started the intent. The following example demonstrates how to override <code>onActivityResult()</code> to
capture the result of the image camera intent or video camera intent examples shown in the previous sections.</p>
<p>WHATSON? 3042fc91-9376-46e6-8051-a31cf7dd43ca</p>
<pre>
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {
        if (resultCode == RESULT_OK) {
            // Image captured and saved to fileUri specified in the Intent
            Toast.makeText(this, "Image saved to:\n" +
                     data.getData(), Toast.LENGTH_LONG).show();
        } else if (resultCode == RESULT_CANCELED) {
            // User cancelled the image capture
        } else {
            // Image capture failed, advise user
        }
    }

    if (requestCode == CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE) {
        if (resultCode == RESULT_OK) {
            // Video captured and saved to fileUri specified in the Intent
            Toast.makeText(this, "Video saved to:\n" +
                     data.getData(), Toast.LENGTH_LONG).show();
        } else if (resultCode == RESULT_CANCELED) {
            // User cancelled the video capture
        } else {
            // Video capture failed, advise user
        }
    }
}
</pre>
<p>Once your activity receives a successful result, the captured image or video is available in the
specified location for your application to access.</p>
<h2>Building a Camera App</h2>
<p>Some developers may require a camera user interface that is customized to the look of their
application or provides special features. Creating a customized camera activity requires more
code than using an intent, but it can provide a more compelling experience
for your users.</p>
<p><strong> Note: The following guide is for the older, deprecated <code>Camera</code>
API. For new or advanced camera applications, the newer <code>android.hardware.camera2</code> API is
recommended.</strong></p>
<p>The general steps for creating a custom camera interface for your application are as follows:</p>
<ul>
   <li><strong>Detect and Access Camera</strong> - Create code to check for the existence of
cameras and request access.</li>
   <li><strong>Create a Preview Class</strong> - Create a camera preview class that extends <code>SurfaceView</code> and implements the <code>SurfaceHolder</code> interface. This
class previews the live images from the camera.</li>
   <li><strong>Build a Preview Layout</strong> - Once you have the camera preview class, create a
view layout that incorporates the preview and the user interface controls you want.</li>
   <li><strong>Setup Listeners for Capture</strong> - Connect listeners for your interface
controls to start image or video capture in response to user actions, such as pressing a
button.</li>
   <li><strong>Capture and Save Files</strong> - Setup the code for capturing pictures or
videos and saving the output.</li>
   <li><strong>Release the Camera</strong> - After using the camera, your application must
properly release it for use by other applications.</li>
</ul>
<p>Camera hardware is a shared resource that must be carefully managed so your application does
not collide with other applications that may also want to use it. The following sections discusses
how to detect camera hardware, how to request access to a camera, how to capture pictures or video
and how to release the camera when your application is done using it.</p>
<p><strong>Caution:</strong> Remember to release the <code>Camera</code>
object by calling the <code>Camera.release()</code> when your
application is done using it! If your application does not properly release the camera, all
subsequent attempts to access the camera, including those by your own application, will fail and may
cause your or other applications to be shut down.</p>
<h3>Detecting camera hardware</h3>
<p>If your application does not specifically require a camera using a manifest declaration, you
should check to see if a camera is available at runtime. To perform this check, use the <code>PackageManager.hasSystemFeature()</code> method, as shown in the example code below:</p>
<p>WHATSON? 3fecb152-21c8-4460-8c90-41ed779a6568</p>
<pre>
/** Check if this device has a camera */
private boolean checkCameraHardware(Context context) {
    if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
        // this device has a camera
        return true;
    } else {
        // no camera on this device
        return false;
    }
}
</pre>
<p>Android devices can have multiple cameras, for example a back-facing camera for photography and a
front-facing camera for video calls. Android 2.3 (API Level 9) and later allows you to check the
number of cameras available on a device using the <code>Camera.getNumberOfCameras()</code> method.</p>
<h3>Accessing cameras</h3>
<p>If you have determined that the device on which your application is running has a camera, you
must request to access it by getting an instance of <code>Camera</code> (unless you
are using an intent to access the camera). </p>
<p>To access the primary camera, use the <code>Camera.open()</code> method
and be sure to catch any exceptions, as shown in the code below:</p>
<p>WHATSON? 2a27a810-a8c2-444b-b699-5ec950d9e74d</p>
<pre>
/** A safe way to get an instance of the Camera object. */
public static Camera getCameraInstance(){
    Camera c = null;
    try {
        c = Camera.open(); // attempt to get a Camera instance
    }
    catch (Exception e){
        // Camera is not available (in use or does not exist)
    }
    return c; // returns null if camera is unavailable
}
</pre>
<p><strong>Caution:</strong> Always check for exceptions when using <code>Camera.open()</code>. Failing to check for exceptions if the camera is in
use or does not exist will cause your application to be shut down by the system.</p>
<p>On devices running Android 2.3 (API Level 9) or higher, you can access specific cameras using
<code>Camera.open(int)</code>. The example code above will access
the first, back-facing camera on a device with more than one camera.</p>
<h3>Checking camera features</h3>
<p>Once you obtain access to a camera, you can get further information about its capabilities using
the <code>Camera.getParameters()</code> method and checking the
returned <code>Camera.Parameters</code> object for supported capabilities. When using
API Level 9 or higher, use the <code>Camera.getCameraInfo()</code> to determine if a camera is on the front
or back of the device, and the orientation of the image.</p>
<h3>Creating a preview class</h3>
<p>For users to effectively take pictures or video, they must be able to see what the device camera
sees. A camera preview class is a <code>SurfaceView</code> that can display the live image
data coming from a camera, so users can frame and capture a picture or video.</p>
<p>The following example code demonstrates how to create a basic camera preview class that can be
included in a <code>View</code> layout. This class implements <code>SurfaceHolder.Callback</code> in order to capture the callback events
for creating and destroying the view, which are needed for assigning the camera preview input.</p>
<p>WHATSON? 0091abc5-68ca-4976-bb76-7c8f6cd08c8d</p>
<pre>
/** A basic Camera preview class */
public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
    private SurfaceHolder mHolder;
    private Camera mCamera;

    public CameraPreview(Context context, Camera camera) {
        super(context);
        mCamera = camera;

        // Install a SurfaceHolder.Callback so we get notified when the
        // underlying surface is created and destroyed.
        mHolder = getHolder();
        mHolder.addCallback(this);
        // deprecated setting, but required on Android versions prior to 3.0
        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    }

    public void surfaceCreated(SurfaceHolder holder) {
        // The Surface has been created, now tell the camera where to draw the preview.
        try {
            mCamera.setPreviewDisplay(holder);
            mCamera.startPreview();
        } catch (IOException e) {
            Log.d(TAG, "Error setting camera preview: " + e.getMessage());
        }
    }

    public void surfaceDestroyed(SurfaceHolder holder) {
        // empty. Take care of releasing the Camera preview in your activity.
    }

    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
        // If your preview can change or rotate, take care of those events here.
        // Make sure to stop the preview before resizing or reformatting it.

        if (mHolder.getSurface() == null){
          // preview surface does not exist
          return;
        }

        // stop preview before making changes
        try {
            mCamera.stopPreview();
        } catch (Exception e){
          // ignore: tried to stop a non-existent preview
        }

        // set preview size and make any resize, rotate or
        // reformatting changes here

        // start preview with new settings
        try {
            mCamera.setPreviewDisplay(mHolder);
            mCamera.startPreview();

        } catch (Exception e){
            Log.d(TAG, "Error starting camera preview: " + e.getMessage());
        }
    }
}
</pre>
<p>If you want to set a specific size for your camera preview, set this in the <code>surfaceChanged()</code> method as noted in the comments above. When setting preview size, you
<em>must use</em> values from <code>getSupportedPreviewSizes()</code>.
<em>Do not</em> set arbitrary values in the <code>setPreviewSize()</code> method.</p>
<h3>Placing preview in a layout</h3>
<p>A camera preview class, such as the example shown in the previous section, must be placed in the
layout of an activity along with other user interface controls for taking a picture or video. This
section shows you how to build a basic layout and activity for the preview.</p>
<p>The following layout code provides a very basic view that can be used to display a camera
preview. In this example, the <code>FrameLayout</code> element is meant to be the
container for the camera preview class. This layout type is used so that additional picture
information or controls can be overlayed on the live camera preview images.</p>
<p>WHATSON? 0cd36cd5-3b2c-44c2-997b-ed4367e4b95c</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    &gt;
  &lt;FrameLayout
    android:id="@+id/camera_preview"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:layout_weight="1"
    /&gt;

  &lt;Button
    android:id="@+id/button_capture"
    android:text="Capture"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    /&gt;
&lt;/LinearLayout&gt;
</pre>
<p>On most devices, the default orientation of the camera preview is landscape. This example layout
specifies a horizontal (landscape) layout and the code below fixes the orientation of the
application to landscape. For simplicity in rendering a camera preview, you should change your
application's preview activity orientation to landscape by adding the following to your
manifest.</p>
<p>WHATSON? e043e5ce-8c72-46ae-90a5-e7c4971ad786</p>
<pre>
&lt;activity android:name=".CameraActivity"
          android:label="@string/app_name"

          android:screenOrientation="landscape"&gt;
          &lt;!-- configure this activity to use landscape orientation --&gt;

          &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p><strong>Note:</strong> A camera preview does not have to be in landscape mode.
Starting in Android 2.2 (API Level 8), you can use the <code>setDisplayOrientation()</code> method to set the
rotation of the preview image. In order to change preview orientation as the user re-orients the
phone, within the <code>surfaceChanged()</code> method of your preview class, first stop the preview with <code>Camera.stopPreview()</code> change the orientation and then
start the preview again with <code>Camera.startPreview()</code>.</p>
<p>In the activity for your camera view, add your preview class to the <code>FrameLayout</code> element shown in the example above. Your camera activity must also
ensure that it releases the camera when it is paused or shut down. The following example shows how
to modify a camera activity to attach the preview class shown in Creating
a preview class.</p>
<p>WHATSON? 2123d4fb-1766-453e-ac8b-c371080f3cab</p>
<pre>
public class CameraActivity extends Activity {

    private Camera mCamera;
    private CameraPreview mPreview;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // Create an instance of Camera
        mCamera = getCameraInstance();

        // Create our Preview view and set it as the content of our activity.
        mPreview = new CameraPreview(this, mCamera);
        FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
        preview.addView(mPreview);
    }
}
</pre>
<p><strong>Note:</strong> The <code>getCameraInstance()</code> method in the example above
refers to the example method shown in Accessing cameras.</p>
<h3>Capturing pictures</h3>
<p>Once you have built a preview class and a view layout in which to display it, you are ready to
start capturing images with your application. In your application code, you must set up listeners
for your user interface controls to respond to a user action by taking a picture.</p>
<p>In order to retrieve a picture, use the <code>Camera.takePicture()</code> method. This method takes three parameters which receive data from the camera.
In order to receive data in a JPEG format, you must implement an <code>Camera.PictureCallback</code> interface to receive the image data and
write it to a file. The following code shows a basic implementation of the <code>Camera.PictureCallback</code> interface to save an image received from the camera.</p>
<p>WHATSON? 402d0a1b-afa6-47bd-b666-68d8207c041f</p>
<pre>
private PictureCallback mPicture = new PictureCallback() {

    @Override
    public void onPictureTaken(byte[] data, Camera camera) {

        File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
        if (pictureFile == null){
            Log.d(TAG, "Error creating media file, check storage permissions: " +
                e.getMessage());
            return;
        }

        try {
            FileOutputStream fos = new FileOutputStream(pictureFile);
            fos.write(data);
            fos.close();
        } catch (FileNotFoundException e) {
            Log.d(TAG, "File not found: " + e.getMessage());
        } catch (IOException e) {
            Log.d(TAG, "Error accessing file: " + e.getMessage());
        }
    }
};
</pre>
<p>Trigger capturing an image by calling the <code>Camera.takePicture()</code> method. The following example code shows how to call this method from a
button <code>View.OnClickListener</code>.</p>
<p>WHATSON? 67442116-eec3-42f0-8bcb-8e00dd9a1220</p>
<pre>
// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(
    new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // get an image from the camera
            mCamera.takePicture(null, null, mPicture);
        }
    }
);
</pre>
<p><strong>Note:</strong> The <code>mPicture</code> member in the following example refers
to the example code above.</p>
<p><strong>Caution:</strong> Remember to release the <code>Camera</code>
object by calling the <code>Camera.release()</code> when your
application is done using it! For information about how to release the camera, see Releasing the camera.</p>
<h3>Capturing videos</h3>
<p>Video capture using the Android framework requires careful management of the <code>Camera</code> object and coordination with the <code>MediaRecorder</code>
class. When recording video with <code>Camera</code>, you must manage the <code>Camera.lock()</code> and <code>Camera.unlock()</code> calls to allow <code>MediaRecorder</code> access to the camera hardware,
in addition to the <code>Camera.open()</code> and <code>Camera.release()</code> calls.</p>
<p><strong>Note:</strong> Starting with Android 4.0 (API level 14), the <code>Camera.lock()</code> and <code>Camera.unlock()</code> calls are managed for you automatically.</p>
<p>Unlike taking pictures with a device camera, capturing video requires a very particular call
order. You must follow a specific order of execution to successfully prepare for and capture video
with your application, as detailed below.</p>
<ol>
  <li><strong>Open Camera</strong> - Use the <code>Camera.open()</code>
to get an instance of the camera object.</li>
  <li><strong>Connect Preview</strong> - Prepare a live camera image preview by connecting a <code>SurfaceView</code> to the camera using <code>Camera.setPreviewDisplay()</code>.
  </li>
  <li><strong>Start Preview</strong> - Call <code>Camera.startPreview()</code> to begin displaying the live camera images.</li>
  <li><strong>Start Recording Video</strong> - The following steps must be completed <em>in
order</em> to successfully record video:
    <ol>
      <li><strong>Unlock the Camera</strong> - Unlock the camera for use by <code>MediaRecorder</code> by calling <code>Camera.unlock()</code>.</li>
      <li><strong>Configure MediaRecorder</strong> - Call in the following <code>MediaRecorder</code> methods <em>in this order</em>. For more information, see the <code>MediaRecorder</code> reference documentation.
        <ol>
          <li><code>setCamera()</code> - Set the camera to be used for video capture, use your application's current instance
of <code>Camera</code>.</li>
          <li><code>setAudioSource()</code> - Set the
audio source, use <code>MediaRecorder.AudioSource.CAMCORDER</code>. </li>
          <li><code>setVideoSource()</code> - Set
the video source, use <code>MediaRecorder.VideoSource.CAMERA</code>.</li>
          <li>Set the video output format and encoding. For Android 2.2 (API Level 8) and
higher, use the <code>MediaRecorder.setProfile</code> method, and get a profile instance using <code>CamcorderProfile.get()</code>. For versions of Android prior to
2.2, you must set the video output format and encoding parameters:
          <ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
          </li>
          <li><code>setOutputFile()</code> -
Set the output file, use <code>getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()</code> from the example
method in the Saving Media Files section.</li>
          <li><code>setPreviewDisplay()</code> - Specify the <code>SurfaceView</code> preview layout element for
your application. Use the same object you specified for <strong>Connect Preview</strong>.</li>
        </ol>
        <p><strong>Caution:</strong> You must call these <code>MediaRecorder</code> configuration methods <em>in this order</em>, otherwise your
application will encounter errors and the recording will fail.</p>
      </li>
      <li><strong>Prepare MediaRecorder</strong> - Prepare the <code>MediaRecorder</code>
with provided configuration settings by calling <code>MediaRecorder.prepare()</code>.</li>
      <li><strong>Start MediaRecorder</strong> - Start recording video by calling <code>MediaRecorder.start()</code>.</li>
    </ol>
  </li>
  <li><strong>Stop Recording Video</strong> - Call the following methods <em>in order</em>, to
successfully complete a video recording:
    <ol>
      <li><strong>Stop MediaRecorder</strong> - Stop recording video by calling <code>MediaRecorder.stop()</code>.</li>
      <li><strong>Reset MediaRecorder</strong> - Optionally, remove the configuration settings from
the recorder by calling <code>MediaRecorder.reset()</code>.</li>
      <li><strong>Release MediaRecorder</strong> - Release the <code>MediaRecorder</code>
by calling <code>MediaRecorder.release()</code>.</li>
      <li><strong>Lock the Camera</strong> - Lock the camera so that future <code>MediaRecorder</code> sessions can use it by calling <code>Camera.lock()</code>. Starting with Android 4.0 (API level 14), this call is not required unless the
<code>MediaRecorder.prepare()</code> call fails.</li>
    </ol>
  </li>
  <li><strong>Stop the Preview</strong> - When your activity has finished using the camera, stop the
preview using <code>Camera.stopPreview()</code>.</li>
  <li><strong>Release Camera</strong> - Release the camera so that other applications can use
it by calling <code>Camera.release()</code>.</li>
</ol>
<ol>
      <li><strong>Unlock the Camera</strong> - Unlock the camera for use by <code>MediaRecorder</code> by calling <code>Camera.unlock()</code>.</li>
      <li><strong>Configure MediaRecorder</strong> - Call in the following <code>MediaRecorder</code> methods <em>in this order</em>. For more information, see the <code>MediaRecorder</code> reference documentation.
        <ol>
          <li><code>setCamera()</code> - Set the camera to be used for video capture, use your application's current instance
of <code>Camera</code>.</li>
          <li><code>setAudioSource()</code> - Set the
audio source, use <code>MediaRecorder.AudioSource.CAMCORDER</code>. </li>
          <li><code>setVideoSource()</code> - Set
the video source, use <code>MediaRecorder.VideoSource.CAMERA</code>.</li>
          <li>Set the video output format and encoding. For Android 2.2 (API Level 8) and
higher, use the <code>MediaRecorder.setProfile</code> method, and get a profile instance using <code>CamcorderProfile.get()</code>. For versions of Android prior to
2.2, you must set the video output format and encoding parameters:
          <ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
          </li>
          <li><code>setOutputFile()</code> -
Set the output file, use <code>getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()</code> from the example
method in the Saving Media Files section.</li>
          <li><code>setPreviewDisplay()</code> - Specify the <code>SurfaceView</code> preview layout element for
your application. Use the same object you specified for <strong>Connect Preview</strong>.</li>
        </ol>
        <p><strong>Caution:</strong> You must call these <code>MediaRecorder</code> configuration methods <em>in this order</em>, otherwise your
application will encounter errors and the recording will fail.</p>
      </li>
      <li><strong>Prepare MediaRecorder</strong> - Prepare the <code>MediaRecorder</code>
with provided configuration settings by calling <code>MediaRecorder.prepare()</code>.</li>
      <li><strong>Start MediaRecorder</strong> - Start recording video by calling <code>MediaRecorder.start()</code>.</li>
    </ol>
<ol>
          <li><code>setCamera()</code> - Set the camera to be used for video capture, use your application's current instance
of <code>Camera</code>.</li>
          <li><code>setAudioSource()</code> - Set the
audio source, use <code>MediaRecorder.AudioSource.CAMCORDER</code>. </li>
          <li><code>setVideoSource()</code> - Set
the video source, use <code>MediaRecorder.VideoSource.CAMERA</code>.</li>
          <li>Set the video output format and encoding. For Android 2.2 (API Level 8) and
higher, use the <code>MediaRecorder.setProfile</code> method, and get a profile instance using <code>CamcorderProfile.get()</code>. For versions of Android prior to
2.2, you must set the video output format and encoding parameters:
          <ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
          </li>
          <li><code>setOutputFile()</code> -
Set the output file, use <code>getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()</code> from the example
method in the Saving Media Files section.</li>
          <li><code>setPreviewDisplay()</code> - Specify the <code>SurfaceView</code> preview layout element for
your application. Use the same object you specified for <strong>Connect Preview</strong>.</li>
        </ol>
<ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
<p><strong>Caution:</strong> You must call these <code>MediaRecorder</code> configuration methods <em>in this order</em>, otherwise your
application will encounter errors and the recording will fail.</p>
<ol>
      <li><strong>Stop MediaRecorder</strong> - Stop recording video by calling <code>MediaRecorder.stop()</code>.</li>
      <li><strong>Reset MediaRecorder</strong> - Optionally, remove the configuration settings from
the recorder by calling <code>MediaRecorder.reset()</code>.</li>
      <li><strong>Release MediaRecorder</strong> - Release the <code>MediaRecorder</code>
by calling <code>MediaRecorder.release()</code>.</li>
      <li><strong>Lock the Camera</strong> - Lock the camera so that future <code>MediaRecorder</code> sessions can use it by calling <code>Camera.lock()</code>. Starting with Android 4.0 (API level 14), this call is not required unless the
<code>MediaRecorder.prepare()</code> call fails.</li>
    </ol>
<p><strong>Note:</strong> It is possible to use <code>MediaRecorder</code>
without creating a camera preview first and skip the first few steps of this process. However,
since users typically prefer to see a preview before starting a recording, that process is not
discussed here.</p>
<p><strong>Tip:</strong> If your application is typically used for recording video, set
<code>setRecordingHint(boolean)</code> to <code>true</code> prior to starting your
preview. This setting can help reduce the time it takes to start recording.</p>
<h4>Configuring MediaRecorder</h4>
<p>When using the <code>MediaRecorder</code> class to record video, you must perform
configuration steps in a <em>specific order</em> and then call the <code>MediaRecorder.prepare()</code> method to check and implement the
configuration. The following example code demonstrates how to properly configure and prepare the
<code>MediaRecorder</code> class for video recording.</p>
<p>WHATSON? cffee269-2598-4ad1-84d8-f9f507d18089</p>
<pre>
private boolean prepareVideoRecorder(){

    mCamera = getCameraInstance();
    mMediaRecorder = new MediaRecorder();

    // Step 1: Unlock and set camera to MediaRecorder
    mCamera.unlock();
    mMediaRecorder.setCamera(mCamera);

    // Step 2: Set sources
    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);

    // Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
    mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH));

    // Step 4: Set output file
    mMediaRecorder.setOutputFile(getOutputMediaFile(MEDIA_TYPE_VIDEO).toString());

    // Step 5: Set the preview output
    mMediaRecorder.setPreviewDisplay(mPreview.getHolder().getSurface());

    // Step 6: Prepare configured MediaRecorder
    try {
        mMediaRecorder.prepare();
    } catch (IllegalStateException e) {
        Log.d(TAG, "IllegalStateException preparing MediaRecorder: " + e.getMessage());
        releaseMediaRecorder();
        return false;
    } catch (IOException e) {
        Log.d(TAG, "IOException preparing MediaRecorder: " + e.getMessage());
        releaseMediaRecorder();
        return false;
    }
    return true;
}
</pre>
<p>Prior to Android 2.2 (API Level 8), you must set the output format and encoding formats
parameters directly, instead of using <code>CamcorderProfile</code>. This approach is
demonstrated in the following code:</p>
<p>WHATSON? 9ff76d0f-3545-48e5-ba65-2a6dd8bc0b61</p>
<pre>
    // Step 3: Set output format and encoding (for versions prior to API Level 8)
    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT);
</pre>
<p>The following video recording parameters for <code>MediaRecorder</code> are given
default settings, however, you may want to adjust these settings for your application:</p>
<ul>
  <li><code>setVideoEncodingBitRate()</code></li>
  <li><code>setVideoSize()</code></li>
  <li><code>setVideoFrameRate()</code></li>
  <li><code>setAudioEncodingBitRate()</code></li>  <li><code>setAudioChannels()</code></li>
  <li><code>setAudioSamplingRate()</code></li>
</ul>
<h4>Starting and stopping MediaRecorder</h4>
<p>When starting and stopping video recording using the <code>MediaRecorder</code> class,
you must follow a specific order, as listed below.</p>
<ol>
  <li>Unlock the camera with <code>Camera.unlock()</code></li>
  <li>Configure <code>MediaRecorder</code> as shown in the code example above</li>
  <li>Start recording using <code>MediaRecorder.start()</code></li>
  <li>Record the video</li>
  <li>Stop recording using <code>MediaRecorder.stop()</code></li>
  <li>Release the media recorder with <code>MediaRecorder.release()</code></li>
  <li>Lock the camera using <code>Camera.lock()</code></li>
</ol>
<p>The following example code demonstrates how to wire up a button to properly start and stop
video recording using the camera and the <code>MediaRecorder</code> class.</p>
<p><strong>Note:</strong> When completing a video recording, do not release the camera
or else your preview will be stopped.</p>
<p>WHATSON? 9e97afd8-b2aa-46d0-93cb-2e45cea96aa2</p>
<pre>
private boolean isRecording = false;

// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(
    new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            if (isRecording) {
                // stop recording and release camera
                mMediaRecorder.stop();  // stop the recording
                releaseMediaRecorder(); // release the MediaRecorder object
                mCamera.lock();         // take camera access back from MediaRecorder

                // inform the user that recording has stopped
                setCaptureButtonText("Capture");
                isRecording = false;
            } else {
                // initialize video camera
                if (prepareVideoRecorder()) {
                    // Camera is available and unlocked, MediaRecorder is prepared,
                    // now you can start recording
                    mMediaRecorder.start();

                    // inform the user that recording has started
                    setCaptureButtonText("Stop");
                    isRecording = true;
                } else {
                    // prepare didn't work, release the camera
                    releaseMediaRecorder();
                    // inform user
                }
            }
        }
    }
);
</pre>
<p><strong>Note:</strong> In the above example, the <code>prepareVideoRecorder()</code>
method refers to the example code shown in Configuring MediaRecorder. This method takes care of locking
the camera, configuring and preparing the <code>MediaRecorder</code> instance.</p>
<h3>Releasing the camera</h3>
<p>Cameras are a resource that is shared by applications on a device. Your application can make
use of the camera after getting an instance of <code>Camera</code>, and you must be
particularly careful to release the camera object when your application stops using it, and as
soon as your application is paused (<code>Activity.onPause()</code>). If
your application does not properly release the camera, all subsequent attempts to access the camera,
including those by your own application, will fail and may cause your or other applications to be
shut down.</p>
<p>To release an instance of the <code>Camera</code> object, use the <code>Camera.release()</code> method, as shown in the example code below.</p>
<p>WHATSON? fb4750fe-7702-4d05-8b54-d948cb5fa8b5</p>
<pre>
public class CameraActivity extends Activity {
    private Camera mCamera;
    private SurfaceView mPreview;
    private MediaRecorder mMediaRecorder;

    ...

    @Override
    protected void onPause() {
        super.onPause();
        releaseMediaRecorder();       // if you are using MediaRecorder, release it first
        releaseCamera();              // release the camera immediately on pause event
    }

    private void releaseMediaRecorder(){
        if (mMediaRecorder != null) {
            mMediaRecorder.reset();   // clear recorder configuration
            mMediaRecorder.release(); // release the recorder object
            mMediaRecorder = null;
            mCamera.lock();           // lock camera for later use
        }
    }

    private void releaseCamera(){
        if (mCamera != null){
            mCamera.release();        // release the camera for other applications
            mCamera = null;
        }
    }
}
</pre>
<p><strong>Caution:</strong> If your application does not properly release the
camera, all subsequent attempts to access the camera, including those by your own application, will
fail and may cause your or other applications to be shut down.</p>
<h2>Saving Media Files</h2>
<p>Media files created by users such as pictures and videos should be saved to a device's external
storage directory (SD Card) to conserve system space and to allow users to access these files
without their device. There are many possible directory locations to save media files on a device,
however there are only two standard locations you should consider as a developer:</p>
<ul>
  <li><strong><code>Environment.getExternalStoragePublicDirectory</code>(<code>Environment.DIRECTORY_PICTURES</code>)</strong> - This method returns the standard, shared and recommended
location for saving pictures and videos. This directory is shared (public), so other applications
can easily discover, read, change and delete files saved in this location. If your application is
uninstalled by the user, media files saved to this location will not be removed. To avoid
interfering with users existing pictures and videos, you should create a sub-directory for your
application's media files within this directory, as shown in the code sample below. This method is
available in Android 2.2 (API Level 8), for equivalent calls in earlier API versions, see Saving Shared Files.</li>
  <li><strong><code>Context.getExternalFilesDir</code>(<code>Environment.DIRECTORY_PICTURES</code>)</strong> - This method returns a standard location for saving
pictures and videos which are associated with your application. If your application is uninstalled,
any files saved in this location are removed. Security is not enforced for files in this
location and other applications may read, change and delete them.</li>
</ul>
<p>The following example code demonstrates how to create a <code>File</code> or <code>Uri</code> location for a media file that can be used when invoking a device's camera with
an <code>Intent</code> or as part of a Building a Camera
App.</p>
<p>WHATSON? 729d80d7-98c4-4862-b5a4-9e3362d5c66f</p>
<pre>
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;

/** Create a file Uri for saving an image or video */
private static Uri getOutputMediaFileUri(int type){
      return Uri.fromFile(getOutputMediaFile(type));
}

/** Create a File for saving an image or video */
private static File getOutputMediaFile(int type){
    // To be safe, you should check that the SDCard is mounted
    // using Environment.getExternalStorageState() before doing this.

    File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
              Environment.DIRECTORY_PICTURES), "MyCameraApp");
    // This location works best if you want the created images to be shared
    // between applications and persist after your app has been uninstalled.

    // Create the storage directory if it does not exist
    if (! mediaStorageDir.exists()){
        if (! mediaStorageDir.mkdirs()){
            Log.d("MyCameraApp", "failed to create directory");
            return null;
        }
    }

    // Create a media file name
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File mediaFile;
    if (type == MEDIA_TYPE_IMAGE){
        mediaFile = new File(mediaStorageDir.getPath() + File.separator +
        "IMG_"+ timeStamp + ".jpg");
    } else if(type == MEDIA_TYPE_VIDEO) {
        mediaFile = new File(mediaStorageDir.getPath() + File.separator +
        "VID_"+ timeStamp + ".mp4");
    } else {
        return null;
    }

    return mediaFile;
}
</pre>
<p><strong>Note:</strong> <code>Environment.getExternalStoragePublicDirectory()</code> is available in Android 2.2 (API Level 8) or
higher. If you are targeting devices with earlier versions of Android, use <code>Environment.getExternalStorageDirectory()</code>
instead. For more information, see Saving Shared Files.</p>
<p>For more information about saving files on an Android device, see Data Storage.</p>
<h2>Camera Features</h2>
<p>Android supports a wide array of camera features you can control with your camera application,
such as picture format, flash mode, focus settings, and many more. This section lists the common
camera features, and briefly discusses how to use them. Most camera features can be accessed and set
using the through <code>Camera.Parameters</code> object. However, there are several
important features that require more than simple settings in <code>Camera.Parameters</code>. These features are covered in the following sections:</p>
<p>

</p>
<ul>
  <li>Metering and focus areas</li>
  <li>Face detection</li>
  <li>Time lapse video</li>
</ul>
<p>For general information about how to use features that are controlled through <code>Camera.Parameters</code>, review the Using camera
features section. For more detailed information about how to use features controlled through the
camera parameters object, follow the links in the feature list below to the API reference
documentation.</p>
<p>
  <strong>Table 1.</strong> Common camera features sorted by the Android API Level in which they
were introduced.</p>
<p><strong>Note:</strong> These features are not supported on all devices due to
hardware differences and software implementation. For information on checking the availability
of features on the device where your application is running, see Checking
feature availability.</p>
<h3>Checking feature availability</h3>
<p>The first thing to understand when setting out to use camera features on Android devices is that
not all camera features are supported on all devices. In addition, devices that support a particular
feature may support them to different levels or with different options. Therefore, part of your
decision process as you develop a camera application is to decide what camera features you want to
support and to what level. After making that decision, you should plan on including code in your
camera application that checks to see if device hardware supports those features and fails
gracefully if a feature is not available.</p>
<p>You can check the availabilty of camera features by getting an instance of a cameras parameters
object, and checking the relevant methods. The following code sample shows you how to obtain a
<code>Camera.Parameters</code> object and check if the camera supports the autofocus
feature:</p>
<p>WHATSON? 315ef271-cae4-42d2-9b60-64ecf1759aac</p>
<pre>
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();

List&lt;String&gt; focusModes = params.getSupportedFocusModes();
if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
  // Autofocus mode is supported
}
</pre>
<p>You can use the technique shown above for most camera features. The
<code>Camera.Parameters</code> object provides a <code>getSupported...()</code>, <code>is...Supported()</code> or <code>getMax...()</code> method to determine if (and to what extent) a feature is
supported.</p>
<p>If your application requires certain camera features in order to function properly, you can
require them through additions to your application manifest. When you declare the use of specific
camera features, such as flash and auto-focus, Google Play restricts your application from
being installed on devices which do not support these features. For a list of camera features that
can be declared in your app manifest, see the manifest
 Features
Reference.</p>
<h3>Using camera features</h3>
<p>Most camera features are activated and controlled using a <code>Camera.Parameters</code> object. You obtain this object by first getting an instance of
the <code>Camera</code> object, calling the <code>getParameters()</code> method, changing the returned parameter
object and then setting it back into the camera object, as demonstrated in the following example
code:</p>
<p>WHATSON? 2c0b9987-fa71-40a3-ba93-20ae86adb7a4</p>
<pre>
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();
// set the focus mode
params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
// set Camera parameters
mCamera.setParameters(params);
</pre>
<p>This technique works for nearly all camera features, and most parameters can be changed at any
time after you have obtained an instance of the <code>Camera</code> object. Changes to
parameters are typically visible to the user immediately in the applications camera preview.
On the software side, parameter changes may take several frames to actually take effect as the
camera hardware processes the new instructions and then sends updated image data.</p>
<p><strong>Important:</strong> Some camera features cannot be changed at will. In
particular, changing the size or orientation of the camera preview requires that you first stop the
preview, change the preview size, and then restart the preview. Starting with Android 4.0 (API
Level 14) preview orientation can be changed without restarting the preview.</p>
<p>Other camera features require more code in order to implement, including:</p>
<ul>
  <li>Metering and focus areas</li>
  <li>Face detection</li>
  <li>Time lapse video</li>
</ul>
<p>A quick outline of how to implement these features is provided in the following sections.</p>
<h3>Metering and focus areas</h3>
<p>In some photographic scenarios, automatic focusing and light metering may not produce the
desired results. Starting with Android 4.0 (API Level 14), your camera application can provide
additional controls to allow your app or users to specify areas in an image to use for determining
focus or light level settings and pass these values to the camera hardware for use in capturing
images or video.</p>
<p>Areas for metering and focus work very similarly to other camera features, in that you control
them through methods in the <code>Camera.Parameters</code> object. The following code
demonstrates setting two light metering areas for an instance of
<code>Camera</code>:</p>
<p>WHATSON? bb4468aa-5ce4-4e1d-9fd6-6e51a4e35fcf</p>
<pre>
// Create an instance of Camera
mCamera = getCameraInstance();

// set Camera parameters
Camera.Parameters params = mCamera.getParameters();

if (params.getMaxNumMeteringAreas() &gt; 0){ // check that metering areas are supported
    List&lt;Camera.Area&gt; meteringAreas = new ArrayList&lt;Camera.Area&gt;();

    Rect areaRect1 = new Rect(-100, -100, 100, 100);    // specify an area in center of image
    meteringAreas.add(new Camera.Area(areaRect1, 600)); // set weight to 60%
    Rect areaRect2 = new Rect(800, -1000, 1000, -800);  // specify an area in upper right of image
    meteringAreas.add(new Camera.Area(areaRect2, 400)); // set weight to 40%
    params.setMeteringAreas(meteringAreas);
}

mCamera.setParameters(params);
</pre>
<p>The <code>Camera.Area</code> object contains two data parameters: A <code>Rect</code> object for specifying an area within the cameras field of view and a weight
value, which tells the camera what level of importance this area should be given in light metering
or focus calculations.</p>
<p>The <code>Rect</code> field in a <code>Camera.Area</code> object
describes a rectangular shape mapped on a 2000 x 2000 unit grid. The coordinates -1000, -1000
represent the top, left corner of the camera image, and coordinates 1000, 1000 represent the
bottom, right corner of the camera image, as shown in the illustration below.</p>
<p>
  <strong>Figure 1.</strong> The red lines illustrate the coordinate system for specifying a
<code>Camera.Area</code> within a camera preview. The blue box shows the location and
shape of an camera area with the <code>Rect</code> values 333,333,667,667.
</p>
<p>The bounds of this coordinate system always correspond to the outer edge of the image visible in
the camera preview and do not shrink or expand with the zoom level. Similarly, rotation of the image
preview using <code>Camera.setDisplayOrientation()</code>
does not remap the coordinate system.</p>
<h3>Face detection</h3>
<p>For pictures that include people, faces are usually the most important part of the picture, and
should be used for determining both focus and white balance when capturing an image. The Android 4.0
(API Level 14) framework provides APIs for identifying faces and calculating picture settings using
face recognition technology.</p>
<p><strong>Note:</strong> While the face detection feature is running,
<code>setWhiteBalance(String)</code>,
<code>setFocusAreas(List<camera.area>)</camera.area></code> and
<code>setMeteringAreas(List<camera.area>)</camera.area></code> have no effect.</p>
<p>Using the face detection feature in your camera application requires a few general steps:</p>
<ul>
  <li>Check that face detection is supported on the device</li>
  <li>Create a face detection listener</li>
  <li>Add the face detection listener to your camera object</li>
  <li>Start face detection after preview (and after <em>every</em> preview restart)</li>
</ul>
<p>The face detection feature is not supported on all devices. You can check that this feature is
supported by calling <code>getMaxNumDetectedFaces()</code>. An
example of this check is shown in the <code>startFaceDetection()</code> sample method below.</p>
<p>In order to be notified and respond to the detection of a face, your camera application must set
a listener for face detection events. In order to do this, you must create a listener class that
implements the <code>Camera.FaceDetectionListener</code> interface as shown in the
example code below.</p>
<p>WHATSON? 2eff48f0-fe88-43a0-ae40-d509fcea127f</p>
<pre>
class MyFaceDetectionListener implements Camera.FaceDetectionListener {

    @Override
    public void onFaceDetection(Face[] faces, Camera camera) {
        if (faces.length &gt; 0){
            Log.d("FaceDetection", "face detected: "+ faces.length +
                    " Face 1 Location X: " + faces[0].rect.centerX() +
                    "Y: " + faces[0].rect.centerY() );
        }
    }
}
</pre>
<p>After creating this class, you then set it into your applications
<code>Camera</code> object, as shown in the example code below:</p>
<p>WHATSON? 4d6d0dbc-23a1-40d4-a126-755e2d3aea5c</p>
<pre>
mCamera.setFaceDetectionListener(new MyFaceDetectionListener());
</pre>
<p>Your application must start the face detection function each time you start (or restart) the
camera preview. Create a method for starting face detection so you can call it as needed, as shown
in the example code below.</p>
<p>WHATSON? 941bf62a-7753-41b1-992e-9e1075a00a91</p>
<pre>
public void startFaceDetection(){
    // Try starting Face Detection
    Camera.Parameters params = mCamera.getParameters();

    // start face detection only *after* preview has started
    if (params.getMaxNumDetectedFaces() &gt; 0){
        // camera supports face detection, so can start it:
        mCamera.startFaceDetection();
    }
}
</pre>
<p>You must start face detection <em>each time</em> you start (or restart) the camera preview. If
you use the preview class shown in Creating a preview class, add your
<code>startFaceDetection()</code> method to both the
<code>surfaceCreated()</code> and <code>surfaceChanged()</code> methods in your preview class,
as shown in the sample code below.</p>
<p>WHATSON? d90fdf7f-bb88-42fd-bde0-b0b35d8a1a24</p>
<pre>
public void surfaceCreated(SurfaceHolder holder) {
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();

        startFaceDetection(); // start face detection feature

    } catch (IOException e) {
        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
    }
}

public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {

    if (mHolder.getSurface() == null){
        // preview surface does not exist
        Log.d(TAG, "mHolder.getSurface() == null");
        return;
    }

    try {
        mCamera.stopPreview();

    } catch (Exception e){
        // ignore: tried to stop a non-existent preview
        Log.d(TAG, "Error stopping camera preview: " + e.getMessage());
    }

    try {
        mCamera.setPreviewDisplay(mHolder);
        mCamera.startPreview();

        startFaceDetection(); // re-start face detection feature

    } catch (Exception e){
        // ignore: tried to stop a non-existent preview
        Log.d(TAG, "Error starting camera preview: " + e.getMessage());
    }
}
</pre>
<p><strong>Note:</strong> Remember to call this method <em>after</em> calling
<code>startPreview()</code>. Do not attempt to start face detection
in the <code>onCreate()</code> method of your camera apps main activity,
as the preview is not available by this point in your application's the execution.</p>
<h3>Time lapse video</h3>
<p>Time lapse video allows users to create video clips that combine pictures taken a few seconds or
minutes apart. This feature uses <code>MediaRecorder</code> to record the images for a time
lapse sequence. </p>
<p>To record a time lapse video with <code>MediaRecorder</code>, you must configure the
recorder object as if you are recording a normal video, setting the captured frames per second to a
low number and using one of the time lapse quality settings, as shown in the code example below.</p>
<p>WHATSON? f59edfaf-d054-41b7-85e0-8fff604136f0</p>
<pre>
// Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_TIME_LAPSE_HIGH));
...
// Step 5.5: Set the video capture rate to a low number
mMediaRecorder.setCaptureRate(0.1); // capture a frame every 10 seconds
</pre>
<p>These settings must be done as part of a larger configuration procedure for <code>MediaRecorder</code>. For  a full configuration code example, see Configuring MediaRecorder. Once the configuration is complete,
you start the video recording as if you were recording a normal video clip. For more information
about configuring and running <code>MediaRecorder</code>, see Capturing videos.</p>
<h1>Camera</h1>
<h2>In this document</h2>
<ol>
    <li>Considerations</li>
    <li>The Basics
    </li><li>Manifest Declarations</li>
    <li>Using Existing Camera Apps
      <ol>
        <li>Image capture intent</li>
        <li>Video capture intent</li>
        <li>Receiving camera intent result</li>
      </ol>
    </li><li>Building a Camera App
      <ol>
        <li>Detecting camera hardware</li>
        <li>Accessing cameras</li>
        <li>Checking camera features</li>
        <li>Creating a preview class</li>
        <li>Placing preview in a layout</li>
        <li>Capturing pictures</li>
        <li>Capturing videos</li>
        <li>Releasing the camera</li>
      </ol>
    </li>
    <li>Saving Media Files</li>
    <li>Camera Features
      <ol>
        <li>Checking feature availability</li>
        <li>Using camera features</li>
        <li>Metering and focus areas</li>
        <li>Face detection</li>
        <li>Time lapse video</li>
      </ol>
    </li>
  </ol>
<ol>
        <li>Image capture intent</li>
        <li>Video capture intent</li>
        <li>Receiving camera intent result</li>
      </ol>
<ol>
        <li>Detecting camera hardware</li>
        <li>Accessing cameras</li>
        <li>Checking camera features</li>
        <li>Creating a preview class</li>
        <li>Placing preview in a layout</li>
        <li>Capturing pictures</li>
        <li>Capturing videos</li>
        <li>Releasing the camera</li>
      </ol>
<ol>
        <li>Checking feature availability</li>
        <li>Using camera features</li>
        <li>Metering and focus areas</li>
        <li>Face detection</li>
        <li>Time lapse video</li>
      </ol>
<h2>Key Classes</h2>
<ol>
    <li><code>Camera</code></li>
    <li><code>SurfaceView</code></li>
    <li><code>MediaRecorder</code></li>
    <li><code>Intent</code></li>
  </ol>
<h2>See also</h2>
<ol>
    <li>Media Playback</li>
    <li>Data Storage</li>
  </ol>
<p>The Android framework includes support for various cameras and camera features available on
devices, allowing you to capture pictures and videos in your applications. This document discusses a
quick, simple approach to image and video capture and outlines an advanced approach for creating
custom camera experiences for your users.</p>
<h2>Considerations</h2>
<p>Before enabling your application to use cameras on Android devices, you should consider a few
questions about how your app intends to use this hardware feature.</p>
<ul>
  <li><strong>Camera Requirement</strong> - Is the use of a camera so important to your
application that you do not want your application installed on a device that does not have a
camera? If so, you should declare the camera requirement in your
manifest.</li>

  <li><strong>Quick Picture or Customized Camera</strong> - How will your application use the
camera? Are you just interested in snapping a quick picture or video clip, or will your application
provide a new way to use cameras? For a getting a quick snap or clip, consider
Using Existing Camera Apps. For developing a customized camera feature, check
out the Building a Camera App section.</li>

  <li><strong>Storage</strong> - Are the images or videos your application generates intended to be
only visible to your application or shared so that other applications such as Gallery or other
media and social apps can use them? Do you want the pictures and videos to be available even if your
application is uninstalled? Check out the Saving Media Files section to
see how to implement these options.</li>
</ul>
<h2>The Basics</h2>
<p>The Android framework supports capturing images and video through the
<code>android.hardware.camera2</code> API or camera <code>Intent</code>. Here are the relevant
classes:</p>
<h2>Manifest Declarations</h2>
<p>Before starting development on your application with the Camera API, you should make sure
your manifest has the appropriate declarations to allow use of camera hardware and other
related features.</p>
<ul>
  <li><strong>Camera Permission</strong> - Your application must request permission to use a device
camera.
<pre>
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</pre>
  <p><strong>Note:</strong> If you are using the camera via an
intent, your application does not need to request this permission.</p>
  </li>
  <li><strong>Camera Features</strong> - Your application must also declare use of camera features,
for example:
<pre>
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</pre>
  <p>For a list of camera features, see the manifest
Features
Reference.</p>
  <p>Adding camera features to your manifest causes Google Play to prevent your application from
being installed to devices that do not include a camera or do not support the camera features you
specify. For more information about using feature-based filtering with Google Play, see Google
Play and Feature-Based Filtering.</p>
  <p>If your application <em>can use</em> a camera or camera feature for proper operation, but does
not <em>require</em> it, you should specify this in the manifest by including the <code>android:required</code> attribute, and setting it to <code>false</code>:</p>
<pre>
&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;
</pre>

  </li>
  <li><strong>Storage Permission</strong> - If your application saves images or videos to the
device's external storage (SD Card), you must also specify this in the manifest.
<pre>
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</pre>
  </li>
  <li><strong>Audio Recording Permission</strong> - For recording audio with video capture, your
application must request the audio capture permission.
<pre>
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</pre>
  </li>
  <li><strong>Location Permission</strong> - If your application tags images with GPS location
information, you must request location permission:
<pre>
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
</pre>
<p>For more information about getting user location, see
Location Strategies.</p>
  </li>
</ul>
<p>WHATSON? 4c231b07-a5ce-4f32-be61-52afc834353f</p>
<pre>
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</pre>
<p><strong>Note:</strong> If you are using the camera via an
intent, your application does not need to request this permission.</p>
<p>WHATSON? 4049cb15-58e7-481d-aff2-8611c99f0124</p>
<pre>
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</pre>
<p>For a list of camera features, see the manifest
Features
Reference.</p>
<p>Adding camera features to your manifest causes Google Play to prevent your application from
being installed to devices that do not include a camera or do not support the camera features you
specify. For more information about using feature-based filtering with Google Play, see Google
Play and Feature-Based Filtering.</p>
<p>If your application <em>can use</em> a camera or camera feature for proper operation, but does
not <em>require</em> it, you should specify this in the manifest by including the <code>android:required</code> attribute, and setting it to <code>false</code>:</p>
<p>WHATSON? 6f652829-8216-475a-92d9-899d9ed32944</p>
<pre>
&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;
</pre>
<p>WHATSON? c9f61cce-0ce2-44de-bc59-7e4f54ed868b</p>
<pre>
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</pre>
<p>WHATSON? 0534c432-1e27-47b3-8953-700eb1cf3303</p>
<pre>
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</pre>
<p>WHATSON? 4413ba89-4884-4088-a4c1-cb1784a69a6d</p>
<pre>
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
</pre>
<p>For more information about getting user location, see
Location Strategies.</p>
<h2>Using Existing Camera Apps</h2>
<p>A quick way to enable taking pictures or videos in your application without a lot of extra code
is to use an <code>Intent</code> to invoke an existing Android camera application. A
camera intent makes a request to capture a picture or video clip through an existing camera app and
then returns control back to your application. This section shows you how to capture an image or
video using this technique.</p>
<p>The procedure for invoking a camera intent follows these general steps:</p>
<ol>
  <li><strong>Compose a Camera Intent</strong> - Create an <code>Intent</code> that
requests an image or video, using one of these intent types:
    <ul>
      <li><code>MediaStore.ACTION_IMAGE_CAPTURE</code> -
Intent action type for requesting an image from an existing camera application.</li>
      <li><code>MediaStore.ACTION_VIDEO_CAPTURE</code> -
Intent action type for requesting a video from an existing camera application. </li>
    </ul>
  </li>
  <li><strong>Start the Camera Intent</strong> - Use the <code>startActivityForResult()</code>
method to execute the camera intent. After you start the intent, the Camera application user
interface appears on the device screen and the user can take a picture or video.</li>
  <li><strong>Receive the Intent Result</strong> - Set up an <code>onActivityResult()</code> method
in your application to receive the callback and data from the camera intent. When the user
finishes taking a picture or video (or cancels the operation), the system calls this method.</li>
</ol>
<ul>
      <li><code>MediaStore.ACTION_IMAGE_CAPTURE</code> -
Intent action type for requesting an image from an existing camera application.</li>
      <li><code>MediaStore.ACTION_VIDEO_CAPTURE</code> -
Intent action type for requesting a video from an existing camera application. </li>
    </ul>
<h3>Image capture intent</h3>
<p>Capturing images using a camera intent is quick way to enable your application to take pictures
with minimal coding. An image capture intent can include the following extra information:</p>
<ul>
  <li><code>MediaStore.EXTRA_OUTPUT</code> - This setting
requires a <code>Uri</code> object specifying a path and file name where you'd like to
save the picture. This setting is optional but strongly recommended. If you do not specify this
value, the camera application saves the requested picture in the default location with a default
name, specified in the returned intent's <code>Intent.getData()</code>
field.</li>
</ul>
<p>The following example demonstrates how to construct a image capture intent and execute it.
The <code>getOutputMediaFileUri()</code> method in this example refers to the sample code shown in Saving Media Files.</p>
<p>WHATSON? aef1d11b-4e63-4cf1-b9e6-54f01f39dc0b</p>
<pre>
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private Uri fileUri;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // create Intent to take a picture and return control to the calling application
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

    fileUri = getOutputMediaFileUri(MEDIA_TYPE_IMAGE); // create a file to save the image
    intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); // set the image file name

    // start the image capture Intent
    startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE);
}
</pre>
<p>When the <code>startActivityForResult()</code> method is executed, users see a camera application interface.
After the user finishes taking a picture (or cancels the operation), the user interface returns to
your application, and you must intercept the <code>onActivityResult()</code>
method to receive the result of the intent and continue your application execution. For information
on how to receive the completed intent, see Receiving camera intent
result.</p>
<h3>Video capture intent</h3>
<p>Capturing video using a camera intent is a quick way to enable your application to take videos
with minimal coding. A video capture intent can include the following extra information:</p>
<ul>
  <li><code>MediaStore.EXTRA_OUTPUT</code> - This setting
requires a <code>Uri</code> specifying a path and file name where you'd like to save the
video. This setting is optional but strongly recommended. If you do not specify this value, the
Camera application saves the requested video in the default location with a default name, specified
in the returned intent's <code>Intent.getData()</code> field.</li>
  <li><code>MediaStore.EXTRA_VIDEO_QUALITY</code> -
This value can be 0 for lowest quality and smallest file size or 1 for highest quality and
larger file size.</li>
  <li><code>MediaStore.EXTRA_DURATION_LIMIT</code> -
Set this value to limit the length, in seconds, of the video being captured.</li>
  <li><code>MediaStore.EXTRA_SIZE_LIMIT</code> -
Set this value to limit the file size, in bytes, of the video being captured.
</li>
</ul>
<p>The following example demonstrates how to construct a video capture intent and execute it.
The <code>getOutputMediaFileUri()</code> method in this example refers to the sample code shown in Saving Media Files.</p>
<p>WHATSON? 72385d8b-40e5-4311-8625-de9751783af3</p>
<pre>
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;
private Uri fileUri;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    //create new Intent
    Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);

    fileUri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  // create a file to save the video
    intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);  // set the image file name

    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); // set the video image quality to high

    // start the Video Capture Intent
    startActivityForResult(intent, CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE);
}
</pre>
<p>When the <code>startActivityForResult()</code> method is executed, users see a modified camera application interface.
After the user finishes taking a video (or cancels the operation), the user interface
returns to your application, and you must intercept the <code>onActivityResult()</code>
method to receive the result of the intent and continue your application execution. For information
on how to receive the completed intent, see the next section.</p>
<h3>Receiving camera intent result</h3>
<p>Once you have constructed and executed an image or video camera intent, your application must be
configured to receive the result of the intent. This section shows you how to intercept the callback
from a camera intent so your application can do further processing of the captured image or
video.</p>
<p>In order to receive the result of an intent, you must override the <code>onActivityResult()</code> in the
activity that started the intent. The following example demonstrates how to override <code>onActivityResult()</code> to
capture the result of the image camera intent or video camera intent examples shown in the previous sections.</p>
<p>WHATSON? 3fce9854-4aa4-452b-af0b-c418985f5c27</p>
<pre>
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {
        if (resultCode == RESULT_OK) {
            // Image captured and saved to fileUri specified in the Intent
            Toast.makeText(this, "Image saved to:\n" +
                     data.getData(), Toast.LENGTH_LONG).show();
        } else if (resultCode == RESULT_CANCELED) {
            // User cancelled the image capture
        } else {
            // Image capture failed, advise user
        }
    }

    if (requestCode == CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE) {
        if (resultCode == RESULT_OK) {
            // Video captured and saved to fileUri specified in the Intent
            Toast.makeText(this, "Video saved to:\n" +
                     data.getData(), Toast.LENGTH_LONG).show();
        } else if (resultCode == RESULT_CANCELED) {
            // User cancelled the video capture
        } else {
            // Video capture failed, advise user
        }
    }
}
</pre>
<p>Once your activity receives a successful result, the captured image or video is available in the
specified location for your application to access.</p>
<h2>Building a Camera App</h2>
<p>Some developers may require a camera user interface that is customized to the look of their
application or provides special features. Creating a customized camera activity requires more
code than using an intent, but it can provide a more compelling experience
for your users.</p>
<p><strong> Note: The following guide is for the older, deprecated <code>Camera</code>
API. For new or advanced camera applications, the newer <code>android.hardware.camera2</code> API is
recommended.</strong></p>
<p>The general steps for creating a custom camera interface for your application are as follows:</p>
<ul>
   <li><strong>Detect and Access Camera</strong> - Create code to check for the existence of
cameras and request access.</li>
   <li><strong>Create a Preview Class</strong> - Create a camera preview class that extends <code>SurfaceView</code> and implements the <code>SurfaceHolder</code> interface. This
class previews the live images from the camera.</li>
   <li><strong>Build a Preview Layout</strong> - Once you have the camera preview class, create a
view layout that incorporates the preview and the user interface controls you want.</li>
   <li><strong>Setup Listeners for Capture</strong> - Connect listeners for your interface
controls to start image or video capture in response to user actions, such as pressing a
button.</li>
   <li><strong>Capture and Save Files</strong> - Setup the code for capturing pictures or
videos and saving the output.</li>
   <li><strong>Release the Camera</strong> - After using the camera, your application must
properly release it for use by other applications.</li>
</ul>
<p>Camera hardware is a shared resource that must be carefully managed so your application does
not collide with other applications that may also want to use it. The following sections discusses
how to detect camera hardware, how to request access to a camera, how to capture pictures or video
and how to release the camera when your application is done using it.</p>
<p><strong>Caution:</strong> Remember to release the <code>Camera</code>
object by calling the <code>Camera.release()</code> when your
application is done using it! If your application does not properly release the camera, all
subsequent attempts to access the camera, including those by your own application, will fail and may
cause your or other applications to be shut down.</p>
<h3>Detecting camera hardware</h3>
<p>If your application does not specifically require a camera using a manifest declaration, you
should check to see if a camera is available at runtime. To perform this check, use the <code>PackageManager.hasSystemFeature()</code> method, as shown in the example code below:</p>
<p>WHATSON? d1d735c9-7d47-43b0-bb1a-ef7cfaff4e0d</p>
<pre>
/** Check if this device has a camera */
private boolean checkCameraHardware(Context context) {
    if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
        // this device has a camera
        return true;
    } else {
        // no camera on this device
        return false;
    }
}
</pre>
<p>Android devices can have multiple cameras, for example a back-facing camera for photography and a
front-facing camera for video calls. Android 2.3 (API Level 9) and later allows you to check the
number of cameras available on a device using the <code>Camera.getNumberOfCameras()</code> method.</p>
<h3>Accessing cameras</h3>
<p>If you have determined that the device on which your application is running has a camera, you
must request to access it by getting an instance of <code>Camera</code> (unless you
are using an intent to access the camera). </p>
<p>To access the primary camera, use the <code>Camera.open()</code> method
and be sure to catch any exceptions, as shown in the code below:</p>
<p>WHATSON? eab1a3ad-9c38-4bbd-8515-64ad5295e6f5</p>
<pre>
/** A safe way to get an instance of the Camera object. */
public static Camera getCameraInstance(){
    Camera c = null;
    try {
        c = Camera.open(); // attempt to get a Camera instance
    }
    catch (Exception e){
        // Camera is not available (in use or does not exist)
    }
    return c; // returns null if camera is unavailable
}
</pre>
<p><strong>Caution:</strong> Always check for exceptions when using <code>Camera.open()</code>. Failing to check for exceptions if the camera is in
use or does not exist will cause your application to be shut down by the system.</p>
<p>On devices running Android 2.3 (API Level 9) or higher, you can access specific cameras using
<code>Camera.open(int)</code>. The example code above will access
the first, back-facing camera on a device with more than one camera.</p>
<h3>Checking camera features</h3>
<p>Once you obtain access to a camera, you can get further information about its capabilities using
the <code>Camera.getParameters()</code> method and checking the
returned <code>Camera.Parameters</code> object for supported capabilities. When using
API Level 9 or higher, use the <code>Camera.getCameraInfo()</code> to determine if a camera is on the front
or back of the device, and the orientation of the image.</p>
<h3>Creating a preview class</h3>
<p>For users to effectively take pictures or video, they must be able to see what the device camera
sees. A camera preview class is a <code>SurfaceView</code> that can display the live image
data coming from a camera, so users can frame and capture a picture or video.</p>
<p>The following example code demonstrates how to create a basic camera preview class that can be
included in a <code>View</code> layout. This class implements <code>SurfaceHolder.Callback</code> in order to capture the callback events
for creating and destroying the view, which are needed for assigning the camera preview input.</p>
<p>WHATSON? 1b2f48ae-10ba-4c7d-aa95-8bb4b335d6da</p>
<pre>
/** A basic Camera preview class */
public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
    private SurfaceHolder mHolder;
    private Camera mCamera;

    public CameraPreview(Context context, Camera camera) {
        super(context);
        mCamera = camera;

        // Install a SurfaceHolder.Callback so we get notified when the
        // underlying surface is created and destroyed.
        mHolder = getHolder();
        mHolder.addCallback(this);
        // deprecated setting, but required on Android versions prior to 3.0
        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    }

    public void surfaceCreated(SurfaceHolder holder) {
        // The Surface has been created, now tell the camera where to draw the preview.
        try {
            mCamera.setPreviewDisplay(holder);
            mCamera.startPreview();
        } catch (IOException e) {
            Log.d(TAG, "Error setting camera preview: " + e.getMessage());
        }
    }

    public void surfaceDestroyed(SurfaceHolder holder) {
        // empty. Take care of releasing the Camera preview in your activity.
    }

    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
        // If your preview can change or rotate, take care of those events here.
        // Make sure to stop the preview before resizing or reformatting it.

        if (mHolder.getSurface() == null){
          // preview surface does not exist
          return;
        }

        // stop preview before making changes
        try {
            mCamera.stopPreview();
        } catch (Exception e){
          // ignore: tried to stop a non-existent preview
        }

        // set preview size and make any resize, rotate or
        // reformatting changes here

        // start preview with new settings
        try {
            mCamera.setPreviewDisplay(mHolder);
            mCamera.startPreview();

        } catch (Exception e){
            Log.d(TAG, "Error starting camera preview: " + e.getMessage());
        }
    }
}
</pre>
<p>If you want to set a specific size for your camera preview, set this in the <code>surfaceChanged()</code> method as noted in the comments above. When setting preview size, you
<em>must use</em> values from <code>getSupportedPreviewSizes()</code>.
<em>Do not</em> set arbitrary values in the <code>setPreviewSize()</code> method.</p>
<h3>Placing preview in a layout</h3>
<p>A camera preview class, such as the example shown in the previous section, must be placed in the
layout of an activity along with other user interface controls for taking a picture or video. This
section shows you how to build a basic layout and activity for the preview.</p>
<p>The following layout code provides a very basic view that can be used to display a camera
preview. In this example, the <code>FrameLayout</code> element is meant to be the
container for the camera preview class. This layout type is used so that additional picture
information or controls can be overlayed on the live camera preview images.</p>
<p>WHATSON? 19206cfc-fe65-40ec-bcad-a65600a587a3</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    &gt;
  &lt;FrameLayout
    android:id="@+id/camera_preview"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:layout_weight="1"
    /&gt;

  &lt;Button
    android:id="@+id/button_capture"
    android:text="Capture"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    /&gt;
&lt;/LinearLayout&gt;
</pre>
<p>On most devices, the default orientation of the camera preview is landscape. This example layout
specifies a horizontal (landscape) layout and the code below fixes the orientation of the
application to landscape. For simplicity in rendering a camera preview, you should change your
application's preview activity orientation to landscape by adding the following to your
manifest.</p>
<p>WHATSON? 5624b657-584e-491e-a652-3d59bf28f8e8</p>
<pre>
&lt;activity android:name=".CameraActivity"
          android:label="@string/app_name"

          android:screenOrientation="landscape"&gt;
          &lt;!-- configure this activity to use landscape orientation --&gt;

          &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p><strong>Note:</strong> A camera preview does not have to be in landscape mode.
Starting in Android 2.2 (API Level 8), you can use the <code>setDisplayOrientation()</code> method to set the
rotation of the preview image. In order to change preview orientation as the user re-orients the
phone, within the <code>surfaceChanged()</code> method of your preview class, first stop the preview with <code>Camera.stopPreview()</code> change the orientation and then
start the preview again with <code>Camera.startPreview()</code>.</p>
<p>In the activity for your camera view, add your preview class to the <code>FrameLayout</code> element shown in the example above. Your camera activity must also
ensure that it releases the camera when it is paused or shut down. The following example shows how
to modify a camera activity to attach the preview class shown in Creating
a preview class.</p>
<p>WHATSON? d5cca848-4d94-4bdd-bbb0-5919df0c5f1e</p>
<pre>
public class CameraActivity extends Activity {

    private Camera mCamera;
    private CameraPreview mPreview;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        // Create an instance of Camera
        mCamera = getCameraInstance();

        // Create our Preview view and set it as the content of our activity.
        mPreview = new CameraPreview(this, mCamera);
        FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
        preview.addView(mPreview);
    }
}
</pre>
<p><strong>Note:</strong> The <code>getCameraInstance()</code> method in the example above
refers to the example method shown in Accessing cameras.</p>
<h3>Capturing pictures</h3>
<p>Once you have built a preview class and a view layout in which to display it, you are ready to
start capturing images with your application. In your application code, you must set up listeners
for your user interface controls to respond to a user action by taking a picture.</p>
<p>In order to retrieve a picture, use the <code>Camera.takePicture()</code> method. This method takes three parameters which receive data from the camera.
In order to receive data in a JPEG format, you must implement an <code>Camera.PictureCallback</code> interface to receive the image data and
write it to a file. The following code shows a basic implementation of the <code>Camera.PictureCallback</code> interface to save an image received from the camera.</p>
<p>WHATSON? 3698d286-71c6-4a3c-bf5e-a9de80c82aff</p>
<pre>
private PictureCallback mPicture = new PictureCallback() {

    @Override
    public void onPictureTaken(byte[] data, Camera camera) {

        File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
        if (pictureFile == null){
            Log.d(TAG, "Error creating media file, check storage permissions: " +
                e.getMessage());
            return;
        }

        try {
            FileOutputStream fos = new FileOutputStream(pictureFile);
            fos.write(data);
            fos.close();
        } catch (FileNotFoundException e) {
            Log.d(TAG, "File not found: " + e.getMessage());
        } catch (IOException e) {
            Log.d(TAG, "Error accessing file: " + e.getMessage());
        }
    }
};
</pre>
<p>Trigger capturing an image by calling the <code>Camera.takePicture()</code> method. The following example code shows how to call this method from a
button <code>View.OnClickListener</code>.</p>
<p>WHATSON? 02e3a953-733c-4904-a28e-5399887d2100</p>
<pre>
// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(
    new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            // get an image from the camera
            mCamera.takePicture(null, null, mPicture);
        }
    }
);
</pre>
<p><strong>Note:</strong> The <code>mPicture</code> member in the following example refers
to the example code above.</p>
<p><strong>Caution:</strong> Remember to release the <code>Camera</code>
object by calling the <code>Camera.release()</code> when your
application is done using it! For information about how to release the camera, see Releasing the camera.</p>
<h3>Capturing videos</h3>
<p>Video capture using the Android framework requires careful management of the <code>Camera</code> object and coordination with the <code>MediaRecorder</code>
class. When recording video with <code>Camera</code>, you must manage the <code>Camera.lock()</code> and <code>Camera.unlock()</code> calls to allow <code>MediaRecorder</code> access to the camera hardware,
in addition to the <code>Camera.open()</code> and <code>Camera.release()</code> calls.</p>
<p><strong>Note:</strong> Starting with Android 4.0 (API level 14), the <code>Camera.lock()</code> and <code>Camera.unlock()</code> calls are managed for you automatically.</p>
<p>Unlike taking pictures with a device camera, capturing video requires a very particular call
order. You must follow a specific order of execution to successfully prepare for and capture video
with your application, as detailed below.</p>
<ol>
  <li><strong>Open Camera</strong> - Use the <code>Camera.open()</code>
to get an instance of the camera object.</li>
  <li><strong>Connect Preview</strong> - Prepare a live camera image preview by connecting a <code>SurfaceView</code> to the camera using <code>Camera.setPreviewDisplay()</code>.
  </li>
  <li><strong>Start Preview</strong> - Call <code>Camera.startPreview()</code> to begin displaying the live camera images.</li>
  <li><strong>Start Recording Video</strong> - The following steps must be completed <em>in
order</em> to successfully record video:
    <ol>
      <li><strong>Unlock the Camera</strong> - Unlock the camera for use by <code>MediaRecorder</code> by calling <code>Camera.unlock()</code>.</li>
      <li><strong>Configure MediaRecorder</strong> - Call in the following <code>MediaRecorder</code> methods <em>in this order</em>. For more information, see the <code>MediaRecorder</code> reference documentation.
        <ol>
          <li><code>setCamera()</code> - Set the camera to be used for video capture, use your application's current instance
of <code>Camera</code>.</li>
          <li><code>setAudioSource()</code> - Set the
audio source, use <code>MediaRecorder.AudioSource.CAMCORDER</code>. </li>
          <li><code>setVideoSource()</code> - Set
the video source, use <code>MediaRecorder.VideoSource.CAMERA</code>.</li>
          <li>Set the video output format and encoding. For Android 2.2 (API Level 8) and
higher, use the <code>MediaRecorder.setProfile</code> method, and get a profile instance using <code>CamcorderProfile.get()</code>. For versions of Android prior to
2.2, you must set the video output format and encoding parameters:
          <ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
          </li>
          <li><code>setOutputFile()</code> -
Set the output file, use <code>getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()</code> from the example
method in the Saving Media Files section.</li>
          <li><code>setPreviewDisplay()</code> - Specify the <code>SurfaceView</code> preview layout element for
your application. Use the same object you specified for <strong>Connect Preview</strong>.</li>
        </ol>
        <p><strong>Caution:</strong> You must call these <code>MediaRecorder</code> configuration methods <em>in this order</em>, otherwise your
application will encounter errors and the recording will fail.</p>
      </li>
      <li><strong>Prepare MediaRecorder</strong> - Prepare the <code>MediaRecorder</code>
with provided configuration settings by calling <code>MediaRecorder.prepare()</code>.</li>
      <li><strong>Start MediaRecorder</strong> - Start recording video by calling <code>MediaRecorder.start()</code>.</li>
    </ol>
  </li>
  <li><strong>Stop Recording Video</strong> - Call the following methods <em>in order</em>, to
successfully complete a video recording:
    <ol>
      <li><strong>Stop MediaRecorder</strong> - Stop recording video by calling <code>MediaRecorder.stop()</code>.</li>
      <li><strong>Reset MediaRecorder</strong> - Optionally, remove the configuration settings from
the recorder by calling <code>MediaRecorder.reset()</code>.</li>
      <li><strong>Release MediaRecorder</strong> - Release the <code>MediaRecorder</code>
by calling <code>MediaRecorder.release()</code>.</li>
      <li><strong>Lock the Camera</strong> - Lock the camera so that future <code>MediaRecorder</code> sessions can use it by calling <code>Camera.lock()</code>. Starting with Android 4.0 (API level 14), this call is not required unless the
<code>MediaRecorder.prepare()</code> call fails.</li>
    </ol>
  </li>
  <li><strong>Stop the Preview</strong> - When your activity has finished using the camera, stop the
preview using <code>Camera.stopPreview()</code>.</li>
  <li><strong>Release Camera</strong> - Release the camera so that other applications can use
it by calling <code>Camera.release()</code>.</li>
</ol>
<ol>
      <li><strong>Unlock the Camera</strong> - Unlock the camera for use by <code>MediaRecorder</code> by calling <code>Camera.unlock()</code>.</li>
      <li><strong>Configure MediaRecorder</strong> - Call in the following <code>MediaRecorder</code> methods <em>in this order</em>. For more information, see the <code>MediaRecorder</code> reference documentation.
        <ol>
          <li><code>setCamera()</code> - Set the camera to be used for video capture, use your application's current instance
of <code>Camera</code>.</li>
          <li><code>setAudioSource()</code> - Set the
audio source, use <code>MediaRecorder.AudioSource.CAMCORDER</code>. </li>
          <li><code>setVideoSource()</code> - Set
the video source, use <code>MediaRecorder.VideoSource.CAMERA</code>.</li>
          <li>Set the video output format and encoding. For Android 2.2 (API Level 8) and
higher, use the <code>MediaRecorder.setProfile</code> method, and get a profile instance using <code>CamcorderProfile.get()</code>. For versions of Android prior to
2.2, you must set the video output format and encoding parameters:
          <ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
          </li>
          <li><code>setOutputFile()</code> -
Set the output file, use <code>getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()</code> from the example
method in the Saving Media Files section.</li>
          <li><code>setPreviewDisplay()</code> - Specify the <code>SurfaceView</code> preview layout element for
your application. Use the same object you specified for <strong>Connect Preview</strong>.</li>
        </ol>
        <p><strong>Caution:</strong> You must call these <code>MediaRecorder</code> configuration methods <em>in this order</em>, otherwise your
application will encounter errors and the recording will fail.</p>
      </li>
      <li><strong>Prepare MediaRecorder</strong> - Prepare the <code>MediaRecorder</code>
with provided configuration settings by calling <code>MediaRecorder.prepare()</code>.</li>
      <li><strong>Start MediaRecorder</strong> - Start recording video by calling <code>MediaRecorder.start()</code>.</li>
    </ol>
<ol>
          <li><code>setCamera()</code> - Set the camera to be used for video capture, use your application's current instance
of <code>Camera</code>.</li>
          <li><code>setAudioSource()</code> - Set the
audio source, use <code>MediaRecorder.AudioSource.CAMCORDER</code>. </li>
          <li><code>setVideoSource()</code> - Set
the video source, use <code>MediaRecorder.VideoSource.CAMERA</code>.</li>
          <li>Set the video output format and encoding. For Android 2.2 (API Level 8) and
higher, use the <code>MediaRecorder.setProfile</code> method, and get a profile instance using <code>CamcorderProfile.get()</code>. For versions of Android prior to
2.2, you must set the video output format and encoding parameters:
          <ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
          </li>
          <li><code>setOutputFile()</code> -
Set the output file, use <code>getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()</code> from the example
method in the Saving Media Files section.</li>
          <li><code>setPreviewDisplay()</code> - Specify the <code>SurfaceView</code> preview layout element for
your application. Use the same object you specified for <strong>Connect Preview</strong>.</li>
        </ol>
<ol>
            <li><code>setOutputFormat()</code> - Set
the output format, specify the default setting or <code>MediaRecorder.OutputFormat.MPEG_4</code>.</li>
            <li><code>setAudioEncoder()</code> - Set
the sound encoding type, specify the default setting or <code>MediaRecorder.AudioEncoder.AMR_NB</code>.</li>
            <li><code>setVideoEncoder()</code> - Set
the video encoding type, specify the default setting or <code>MediaRecorder.VideoEncoder.MPEG_4_SP</code>.</li>
          </ol>
<p><strong>Caution:</strong> You must call these <code>MediaRecorder</code> configuration methods <em>in this order</em>, otherwise your
application will encounter errors and the recording will fail.</p>
<ol>
      <li><strong>Stop MediaRecorder</strong> - Stop recording video by calling <code>MediaRecorder.stop()</code>.</li>
      <li><strong>Reset MediaRecorder</strong> - Optionally, remove the configuration settings from
the recorder by calling <code>MediaRecorder.reset()</code>.</li>
      <li><strong>Release MediaRecorder</strong> - Release the <code>MediaRecorder</code>
by calling <code>MediaRecorder.release()</code>.</li>
      <li><strong>Lock the Camera</strong> - Lock the camera so that future <code>MediaRecorder</code> sessions can use it by calling <code>Camera.lock()</code>. Starting with Android 4.0 (API level 14), this call is not required unless the
<code>MediaRecorder.prepare()</code> call fails.</li>
    </ol>
<p><strong>Note:</strong> It is possible to use <code>MediaRecorder</code>
without creating a camera preview first and skip the first few steps of this process. However,
since users typically prefer to see a preview before starting a recording, that process is not
discussed here.</p>
<p><strong>Tip:</strong> If your application is typically used for recording video, set
<code>setRecordingHint(boolean)</code> to <code>true</code> prior to starting your
preview. This setting can help reduce the time it takes to start recording.</p>
<h4>Configuring MediaRecorder</h4>
<p>When using the <code>MediaRecorder</code> class to record video, you must perform
configuration steps in a <em>specific order</em> and then call the <code>MediaRecorder.prepare()</code> method to check and implement the
configuration. The following example code demonstrates how to properly configure and prepare the
<code>MediaRecorder</code> class for video recording.</p>
<p>WHATSON? 4435bf17-cdd0-4e0e-a281-64e62de6cb74</p>
<pre>
private boolean prepareVideoRecorder(){

    mCamera = getCameraInstance();
    mMediaRecorder = new MediaRecorder();

    // Step 1: Unlock and set camera to MediaRecorder
    mCamera.unlock();
    mMediaRecorder.setCamera(mCamera);

    // Step 2: Set sources
    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);

    // Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
    mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH));

    // Step 4: Set output file
    mMediaRecorder.setOutputFile(getOutputMediaFile(MEDIA_TYPE_VIDEO).toString());

    // Step 5: Set the preview output
    mMediaRecorder.setPreviewDisplay(mPreview.getHolder().getSurface());

    // Step 6: Prepare configured MediaRecorder
    try {
        mMediaRecorder.prepare();
    } catch (IllegalStateException e) {
        Log.d(TAG, "IllegalStateException preparing MediaRecorder: " + e.getMessage());
        releaseMediaRecorder();
        return false;
    } catch (IOException e) {
        Log.d(TAG, "IOException preparing MediaRecorder: " + e.getMessage());
        releaseMediaRecorder();
        return false;
    }
    return true;
}
</pre>
<p>Prior to Android 2.2 (API Level 8), you must set the output format and encoding formats
parameters directly, instead of using <code>CamcorderProfile</code>. This approach is
demonstrated in the following code:</p>
<p>WHATSON? 5dcb6c78-60a1-40d9-a6c1-c925358fc387</p>
<pre>
    // Step 3: Set output format and encoding (for versions prior to API Level 8)
    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT);
</pre>
<p>The following video recording parameters for <code>MediaRecorder</code> are given
default settings, however, you may want to adjust these settings for your application:</p>
<ul>
  <li><code>setVideoEncodingBitRate()</code></li>
  <li><code>setVideoSize()</code></li>
  <li><code>setVideoFrameRate()</code></li>
  <li><code>setAudioEncodingBitRate()</code></li>  <li><code>setAudioChannels()</code></li>
  <li><code>setAudioSamplingRate()</code></li>
</ul>
<h4>Starting and stopping MediaRecorder</h4>
<p>When starting and stopping video recording using the <code>MediaRecorder</code> class,
you must follow a specific order, as listed below.</p>
<ol>
  <li>Unlock the camera with <code>Camera.unlock()</code></li>
  <li>Configure <code>MediaRecorder</code> as shown in the code example above</li>
  <li>Start recording using <code>MediaRecorder.start()</code></li>
  <li>Record the video</li>
  <li>Stop recording using <code>MediaRecorder.stop()</code></li>
  <li>Release the media recorder with <code>MediaRecorder.release()</code></li>
  <li>Lock the camera using <code>Camera.lock()</code></li>
</ol>
<p>The following example code demonstrates how to wire up a button to properly start and stop
video recording using the camera and the <code>MediaRecorder</code> class.</p>
<p><strong>Note:</strong> When completing a video recording, do not release the camera
or else your preview will be stopped.</p>
<p>WHATSON? 37368df8-0b27-4520-a010-defea608cbd6</p>
<pre>
private boolean isRecording = false;

// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(
    new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            if (isRecording) {
                // stop recording and release camera
                mMediaRecorder.stop();  // stop the recording
                releaseMediaRecorder(); // release the MediaRecorder object
                mCamera.lock();         // take camera access back from MediaRecorder

                // inform the user that recording has stopped
                setCaptureButtonText("Capture");
                isRecording = false;
            } else {
                // initialize video camera
                if (prepareVideoRecorder()) {
                    // Camera is available and unlocked, MediaRecorder is prepared,
                    // now you can start recording
                    mMediaRecorder.start();

                    // inform the user that recording has started
                    setCaptureButtonText("Stop");
                    isRecording = true;
                } else {
                    // prepare didn't work, release the camera
                    releaseMediaRecorder();
                    // inform user
                }
            }
        }
    }
);
</pre>
<p><strong>Note:</strong> In the above example, the <code>prepareVideoRecorder()</code>
method refers to the example code shown in Configuring MediaRecorder. This method takes care of locking
the camera, configuring and preparing the <code>MediaRecorder</code> instance.</p>
<h3>Releasing the camera</h3>
<p>Cameras are a resource that is shared by applications on a device. Your application can make
use of the camera after getting an instance of <code>Camera</code>, and you must be
particularly careful to release the camera object when your application stops using it, and as
soon as your application is paused (<code>Activity.onPause()</code>). If
your application does not properly release the camera, all subsequent attempts to access the camera,
including those by your own application, will fail and may cause your or other applications to be
shut down.</p>
<p>To release an instance of the <code>Camera</code> object, use the <code>Camera.release()</code> method, as shown in the example code below.</p>
<p>WHATSON? 5d4b20ef-7b1f-4d6b-8a10-df1c32ba6071</p>
<pre>
public class CameraActivity extends Activity {
    private Camera mCamera;
    private SurfaceView mPreview;
    private MediaRecorder mMediaRecorder;

    ...

    @Override
    protected void onPause() {
        super.onPause();
        releaseMediaRecorder();       // if you are using MediaRecorder, release it first
        releaseCamera();              // release the camera immediately on pause event
    }

    private void releaseMediaRecorder(){
        if (mMediaRecorder != null) {
            mMediaRecorder.reset();   // clear recorder configuration
            mMediaRecorder.release(); // release the recorder object
            mMediaRecorder = null;
            mCamera.lock();           // lock camera for later use
        }
    }

    private void releaseCamera(){
        if (mCamera != null){
            mCamera.release();        // release the camera for other applications
            mCamera = null;
        }
    }
}
</pre>
<p><strong>Caution:</strong> If your application does not properly release the
camera, all subsequent attempts to access the camera, including those by your own application, will
fail and may cause your or other applications to be shut down.</p>
<h2>Saving Media Files</h2>
<p>Media files created by users such as pictures and videos should be saved to a device's external
storage directory (SD Card) to conserve system space and to allow users to access these files
without their device. There are many possible directory locations to save media files on a device,
however there are only two standard locations you should consider as a developer:</p>
<ul>
  <li><strong><code>Environment.getExternalStoragePublicDirectory</code>(<code>Environment.DIRECTORY_PICTURES</code>)</strong> - This method returns the standard, shared and recommended
location for saving pictures and videos. This directory is shared (public), so other applications
can easily discover, read, change and delete files saved in this location. If your application is
uninstalled by the user, media files saved to this location will not be removed. To avoid
interfering with users existing pictures and videos, you should create a sub-directory for your
application's media files within this directory, as shown in the code sample below. This method is
available in Android 2.2 (API Level 8), for equivalent calls in earlier API versions, see Saving Shared Files.</li>
  <li><strong><code>Context.getExternalFilesDir</code>(<code>Environment.DIRECTORY_PICTURES</code>)</strong> - This method returns a standard location for saving
pictures and videos which are associated with your application. If your application is uninstalled,
any files saved in this location are removed. Security is not enforced for files in this
location and other applications may read, change and delete them.</li>
</ul>
<p>The following example code demonstrates how to create a <code>File</code> or <code>Uri</code> location for a media file that can be used when invoking a device's camera with
an <code>Intent</code> or as part of a Building a Camera
App.</p>
<p>WHATSON? d1b86a9e-be7c-4a96-b644-113b4a6a19e6</p>
<pre>
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;

/** Create a file Uri for saving an image or video */
private static Uri getOutputMediaFileUri(int type){
      return Uri.fromFile(getOutputMediaFile(type));
}

/** Create a File for saving an image or video */
private static File getOutputMediaFile(int type){
    // To be safe, you should check that the SDCard is mounted
    // using Environment.getExternalStorageState() before doing this.

    File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
              Environment.DIRECTORY_PICTURES), "MyCameraApp");
    // This location works best if you want the created images to be shared
    // between applications and persist after your app has been uninstalled.

    // Create the storage directory if it does not exist
    if (! mediaStorageDir.exists()){
        if (! mediaStorageDir.mkdirs()){
            Log.d("MyCameraApp", "failed to create directory");
            return null;
        }
    }

    // Create a media file name
    String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File mediaFile;
    if (type == MEDIA_TYPE_IMAGE){
        mediaFile = new File(mediaStorageDir.getPath() + File.separator +
        "IMG_"+ timeStamp + ".jpg");
    } else if(type == MEDIA_TYPE_VIDEO) {
        mediaFile = new File(mediaStorageDir.getPath() + File.separator +
        "VID_"+ timeStamp + ".mp4");
    } else {
        return null;
    }

    return mediaFile;
}
</pre>
<p><strong>Note:</strong> <code>Environment.getExternalStoragePublicDirectory()</code> is available in Android 2.2 (API Level 8) or
higher. If you are targeting devices with earlier versions of Android, use <code>Environment.getExternalStorageDirectory()</code>
instead. For more information, see Saving Shared Files.</p>
<p>For more information about saving files on an Android device, see Data Storage.</p>
<h2>Camera Features</h2>
<p>Android supports a wide array of camera features you can control with your camera application,
such as picture format, flash mode, focus settings, and many more. This section lists the common
camera features, and briefly discusses how to use them. Most camera features can be accessed and set
using the through <code>Camera.Parameters</code> object. However, there are several
important features that require more than simple settings in <code>Camera.Parameters</code>. These features are covered in the following sections:</p>
<p>

</p>
<ul>
  <li>Metering and focus areas</li>
  <li>Face detection</li>
  <li>Time lapse video</li>
</ul>
<p>For general information about how to use features that are controlled through <code>Camera.Parameters</code>, review the Using camera
features section. For more detailed information about how to use features controlled through the
camera parameters object, follow the links in the feature list below to the API reference
documentation.</p>
<p>
  <strong>Table 1.</strong> Common camera features sorted by the Android API Level in which they
were introduced.</p>
<p><strong>Note:</strong> These features are not supported on all devices due to
hardware differences and software implementation. For information on checking the availability
of features on the device where your application is running, see Checking
feature availability.</p>
<h3>Checking feature availability</h3>
<p>The first thing to understand when setting out to use camera features on Android devices is that
not all camera features are supported on all devices. In addition, devices that support a particular
feature may support them to different levels or with different options. Therefore, part of your
decision process as you develop a camera application is to decide what camera features you want to
support and to what level. After making that decision, you should plan on including code in your
camera application that checks to see if device hardware supports those features and fails
gracefully if a feature is not available.</p>
<p>You can check the availabilty of camera features by getting an instance of a cameras parameters
object, and checking the relevant methods. The following code sample shows you how to obtain a
<code>Camera.Parameters</code> object and check if the camera supports the autofocus
feature:</p>
<p>WHATSON? 6b0ce05f-b0f2-44f3-9294-f4d1c6304736</p>
<pre>
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();

List&lt;String&gt; focusModes = params.getSupportedFocusModes();
if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
  // Autofocus mode is supported
}
</pre>
<p>You can use the technique shown above for most camera features. The
<code>Camera.Parameters</code> object provides a <code>getSupported...()</code>, <code>is...Supported()</code> or <code>getMax...()</code> method to determine if (and to what extent) a feature is
supported.</p>
<p>If your application requires certain camera features in order to function properly, you can
require them through additions to your application manifest. When you declare the use of specific
camera features, such as flash and auto-focus, Google Play restricts your application from
being installed on devices which do not support these features. For a list of camera features that
can be declared in your app manifest, see the manifest
 Features
Reference.</p>
<h3>Using camera features</h3>
<p>Most camera features are activated and controlled using a <code>Camera.Parameters</code> object. You obtain this object by first getting an instance of
the <code>Camera</code> object, calling the <code>getParameters()</code> method, changing the returned parameter
object and then setting it back into the camera object, as demonstrated in the following example
code:</p>
<p>WHATSON? 469f9183-0d60-42b4-aa55-c74a78095576</p>
<pre>
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();
// set the focus mode
params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
// set Camera parameters
mCamera.setParameters(params);
</pre>
<p>This technique works for nearly all camera features, and most parameters can be changed at any
time after you have obtained an instance of the <code>Camera</code> object. Changes to
parameters are typically visible to the user immediately in the applications camera preview.
On the software side, parameter changes may take several frames to actually take effect as the
camera hardware processes the new instructions and then sends updated image data.</p>
<p><strong>Important:</strong> Some camera features cannot be changed at will. In
particular, changing the size or orientation of the camera preview requires that you first stop the
preview, change the preview size, and then restart the preview. Starting with Android 4.0 (API
Level 14) preview orientation can be changed without restarting the preview.</p>
<p>Other camera features require more code in order to implement, including:</p>
<ul>
  <li>Metering and focus areas</li>
  <li>Face detection</li>
  <li>Time lapse video</li>
</ul>
<p>A quick outline of how to implement these features is provided in the following sections.</p>
<h3>Metering and focus areas</h3>
<p>In some photographic scenarios, automatic focusing and light metering may not produce the
desired results. Starting with Android 4.0 (API Level 14), your camera application can provide
additional controls to allow your app or users to specify areas in an image to use for determining
focus or light level settings and pass these values to the camera hardware for use in capturing
images or video.</p>
<p>Areas for metering and focus work very similarly to other camera features, in that you control
them through methods in the <code>Camera.Parameters</code> object. The following code
demonstrates setting two light metering areas for an instance of
<code>Camera</code>:</p>
<p>WHATSON? c6b48d7e-356b-499f-9c3d-0e9f846d486d</p>
<pre>
// Create an instance of Camera
mCamera = getCameraInstance();

// set Camera parameters
Camera.Parameters params = mCamera.getParameters();

if (params.getMaxNumMeteringAreas() &gt; 0){ // check that metering areas are supported
    List&lt;Camera.Area&gt; meteringAreas = new ArrayList&lt;Camera.Area&gt;();

    Rect areaRect1 = new Rect(-100, -100, 100, 100);    // specify an area in center of image
    meteringAreas.add(new Camera.Area(areaRect1, 600)); // set weight to 60%
    Rect areaRect2 = new Rect(800, -1000, 1000, -800);  // specify an area in upper right of image
    meteringAreas.add(new Camera.Area(areaRect2, 400)); // set weight to 40%
    params.setMeteringAreas(meteringAreas);
}

mCamera.setParameters(params);
</pre>
<p>The <code>Camera.Area</code> object contains two data parameters: A <code>Rect</code> object for specifying an area within the cameras field of view and a weight
value, which tells the camera what level of importance this area should be given in light metering
or focus calculations.</p>
<p>The <code>Rect</code> field in a <code>Camera.Area</code> object
describes a rectangular shape mapped on a 2000 x 2000 unit grid. The coordinates -1000, -1000
represent the top, left corner of the camera image, and coordinates 1000, 1000 represent the
bottom, right corner of the camera image, as shown in the illustration below.</p>
<p>
  <strong>Figure 1.</strong> The red lines illustrate the coordinate system for specifying a
<code>Camera.Area</code> within a camera preview. The blue box shows the location and
shape of an camera area with the <code>Rect</code> values 333,333,667,667.
</p>
<p>The bounds of this coordinate system always correspond to the outer edge of the image visible in
the camera preview and do not shrink or expand with the zoom level. Similarly, rotation of the image
preview using <code>Camera.setDisplayOrientation()</code>
does not remap the coordinate system.</p>
<h3>Face detection</h3>
<p>For pictures that include people, faces are usually the most important part of the picture, and
should be used for determining both focus and white balance when capturing an image. The Android 4.0
(API Level 14) framework provides APIs for identifying faces and calculating picture settings using
face recognition technology.</p>
<p><strong>Note:</strong> While the face detection feature is running,
<code>setWhiteBalance(String)</code>,
<code>setFocusAreas(List<camera.area>)</camera.area></code> and
<code>setMeteringAreas(List<camera.area>)</camera.area></code> have no effect.</p>
<p>Using the face detection feature in your camera application requires a few general steps:</p>
<ul>
  <li>Check that face detection is supported on the device</li>
  <li>Create a face detection listener</li>
  <li>Add the face detection listener to your camera object</li>
  <li>Start face detection after preview (and after <em>every</em> preview restart)</li>
</ul>
<p>The face detection feature is not supported on all devices. You can check that this feature is
supported by calling <code>getMaxNumDetectedFaces()</code>. An
example of this check is shown in the <code>startFaceDetection()</code> sample method below.</p>
<p>In order to be notified and respond to the detection of a face, your camera application must set
a listener for face detection events. In order to do this, you must create a listener class that
implements the <code>Camera.FaceDetectionListener</code> interface as shown in the
example code below.</p>
<p>WHATSON? 1bd38cf9-362c-4b52-9ccf-adc582ad1e56</p>
<pre>
class MyFaceDetectionListener implements Camera.FaceDetectionListener {

    @Override
    public void onFaceDetection(Face[] faces, Camera camera) {
        if (faces.length &gt; 0){
            Log.d("FaceDetection", "face detected: "+ faces.length +
                    " Face 1 Location X: " + faces[0].rect.centerX() +
                    "Y: " + faces[0].rect.centerY() );
        }
    }
}
</pre>
<p>After creating this class, you then set it into your applications
<code>Camera</code> object, as shown in the example code below:</p>
<p>WHATSON? a1fa9fcb-1894-4a75-8ac4-46ce9e4e2478</p>
<pre>
mCamera.setFaceDetectionListener(new MyFaceDetectionListener());
</pre>
<p>Your application must start the face detection function each time you start (or restart) the
camera preview. Create a method for starting face detection so you can call it as needed, as shown
in the example code below.</p>
<p>WHATSON? 57df7bf5-0f8f-4520-8856-2c62cd71e787</p>
<pre>
public void startFaceDetection(){
    // Try starting Face Detection
    Camera.Parameters params = mCamera.getParameters();

    // start face detection only *after* preview has started
    if (params.getMaxNumDetectedFaces() &gt; 0){
        // camera supports face detection, so can start it:
        mCamera.startFaceDetection();
    }
}
</pre>
<p>You must start face detection <em>each time</em> you start (or restart) the camera preview. If
you use the preview class shown in Creating a preview class, add your
<code>startFaceDetection()</code> method to both the
<code>surfaceCreated()</code> and <code>surfaceChanged()</code> methods in your preview class,
as shown in the sample code below.</p>
<p>WHATSON? a314229e-c308-4a53-bf99-e2fbfd64c669</p>
<pre>
public void surfaceCreated(SurfaceHolder holder) {
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();

        startFaceDetection(); // start face detection feature

    } catch (IOException e) {
        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
    }
}

public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {

    if (mHolder.getSurface() == null){
        // preview surface does not exist
        Log.d(TAG, "mHolder.getSurface() == null");
        return;
    }

    try {
        mCamera.stopPreview();

    } catch (Exception e){
        // ignore: tried to stop a non-existent preview
        Log.d(TAG, "Error stopping camera preview: " + e.getMessage());
    }

    try {
        mCamera.setPreviewDisplay(mHolder);
        mCamera.startPreview();

        startFaceDetection(); // re-start face detection feature

    } catch (Exception e){
        // ignore: tried to stop a non-existent preview
        Log.d(TAG, "Error starting camera preview: " + e.getMessage());
    }
}
</pre>
<p><strong>Note:</strong> Remember to call this method <em>after</em> calling
<code>startPreview()</code>. Do not attempt to start face detection
in the <code>onCreate()</code> method of your camera apps main activity,
as the preview is not available by this point in your application's the execution.</p>
<h3>Time lapse video</h3>
<p>Time lapse video allows users to create video clips that combine pictures taken a few seconds or
minutes apart. This feature uses <code>MediaRecorder</code> to record the images for a time
lapse sequence. </p>
<p>To record a time lapse video with <code>MediaRecorder</code>, you must configure the
recorder object as if you are recording a normal video, setting the captured frames per second to a
low number and using one of the time lapse quality settings, as shown in the code example below.</p>
<p>WHATSON? f316209a-03f4-49b1-a3e1-6cfe70f79c6b</p>
<pre>
// Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_TIME_LAPSE_HIGH));
...
// Step 5.5: Set the video capture rate to a low number
mMediaRecorder.setCaptureRate(0.1); // capture a frame every 10 seconds
</pre>
<p>These settings must be done as part of a larger configuration procedure for <code>MediaRecorder</code>. For  a full configuration code example, see Configuring MediaRecorder. Once the configuration is complete,
you start the video recording as if you were recording a normal video clip. For more information
about configuring and running <code>MediaRecorder</code>, see Capturing videos.</p>
</body>
</html>