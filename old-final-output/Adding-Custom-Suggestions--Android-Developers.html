<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Adding-Custom-Suggestions--Android-Developers.html</title></head>
<body>
<h1>Adding Custom Suggestions</h1>
<h2>In this document</h2>
<ol>
<li>The Basics</li>
<li>Modifying the Searchable Configuration</li>
<li>Creating a Content Provider
  <ol>
    <li>Handling a suggestion query</li>
    <li>Building a suggestion table</li>
  </ol>
</li>
<li>Declaring an Intent for Suggestions
  <ol>
    <li>Declaring the intent action</li>
    <li>Declaring the intent data</li>
  </ol>
</li>
<li>Handling the Intent</li>
<li>Rewriting the Query Text</li>
<li>Exposing Search Suggestions to Quick Search Box</li>
</ol>
<ol>
    <li>Handling a suggestion query</li>
    <li>Building a suggestion table</li>
  </ol>
<ol>
    <li>Declaring the intent action</li>
    <li>Declaring the intent data</li>
  </ol>
<h2>Key classes</h2>
<ol>
<li><code>SearchManager</code></li>
<li><code>SearchRecentSuggestionsProvider</code></li>
<li><code>ContentProvider</code></li>
</ol>
<h2>Related samples</h2>
<ol>
<li>Searchable
Dictionary</li>
</ol>
<h2>See also</h2>
<ol>
<li>Searchable Configuration</li>
<li>Content Providers</li>
</ol>
<p>When using the Android search dialog or search widget, you can provide custom search suggestions
that are created from data in your application. For example, if your application is a word
dictionary, you can suggest words from the
dictionary that match the text entered so far. These are the most valuable suggestions, because you
can effectively predict what the user wants and provide instant access to it. Figure 1 shows
an example of a search dialog with custom suggestions.</p>
<p>Once you provide custom suggestions, you can also make them available to the system-wide Quick
Search Box, providing access to your content from outside your application.</p>
<p>Before you begin with this guide to add custom suggestions, you need to have implemented the
Android search dialog or a search widget for searches in your
application. If you haven't, see Creating a Search Interface.</p>
<h2>The Basics</h2>
<p><strong>Figure 1.</strong> Screenshot of a search dialog with custom
search suggestions.</p>
<p>When the user selects a custom suggestion, the Android system sends an <code>Intent</code> to
your searchable activity. Whereas a normal search query sends an intent with the <code>ACTION_SEARCH</code> action, you can instead define your custom suggestions to use
<code>ACTION_VIEW</code> (or any other intent action), and also include data
that's relevant to the selected suggestion. Continuing
the dictionary example, when the user selects a suggestion, your application can immediately
open the definition for that word, instead of searching the dictionary for matches.</p>
<p>To provide custom suggestions, do the following:</p>
<ul>
  <li>Implement a basic searchable activity, as described in Creating a Search Interface.</li>
  <li>Modify the searchable configuration with information about the content provider that
provides custom suggestions.</li>
  <li>Build a table (such as in an <code>SQLiteDatabase</code>) for your
suggestions and format the table with required columns.</li>
  <li>Create a Content
Provider that has access to your suggestions table and declare the provider
in your manifest.</li>
  <li>Declare the type of <code>Intent</code> to be sent when the user selects a
suggestion (including a custom action and custom data). </li>
</ul>
<p>Just as the Android system displays the search dialog, it also displays your search
suggestions. All you need is a content provider from which the system can retrieve your
suggestions. If you're not familiar with creating content
providers, read the Content
Providers developer guide before you continue.</p>
<p>When the system identifies that your activity is searchable and provides search
suggestions, the following procedure takes place when the user types a query:</p>
<ol>
  <li>The system takes the search query text (whatever has been typed so far) and performs a
query to your content provider that manages your suggestions.</li>
  <li>Your content provider returns a <code>Cursor</code> that points to all
suggestions that are relevant to the search query text.</li>
  <li>The system displays the list of suggestions provided by the Cursor.</li>
</ol>
<p>Once the custom suggestions are displayed, the following might happen:</p>
<ul>
  <li>If the user types another key, or changes the query in any way, the above steps are repeated
and the suggestion list is updated as appropriate. </li>
  <li>If the user executes the search, the suggestions are ignored and the search is delivered
to your searchable activity using the normal <code>ACTION_SEARCH</code>
intent.</li>
  <li>If the user selects a suggestion, an intent is sent to your searchable activity, carrying a
custom action and custom data so that your application can open the suggested content.</li>
</ul>
<h2>Modifying the searchable configuration</h2>
<p>To add support for custom suggestions, add the <code>android:searchSuggestAuthority</code> attribute
to the <code>&lt;searchable&gt;</code> element in your searchable configuration file. For example:</p>
<p>WHATSON? f0cb563d-c15b-4851-af9a-888c758fdb58</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    <b>android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"</b>&gt;
&lt;/searchable&gt;
</pre>
<p>You might need some additional attributes, depending on the type of intent you attach
to each suggestion and how you want to format queries to your content provider. The other optional
attributes are discussed in the following sections.</p>
<h2>Creating a Content Provider</h2>
<p>Creating a content provider for custom suggestions requires previous knowledge about content
providers that's covered in the Content Provider developer
guide. For the most part, a content provider for custom suggestions is the
same as any other content provider. However, for each suggestion you provide, the respective row in
the <code>Cursor</code> must include specific columns that the system
understands and uses to format the suggestions.</p>
<p>When the user starts typing into the search dialog or search widget, the system queries
your content provider for suggestions by calling <code>query()</code> each time
a letter is typed. In your implementation of <code>query()</code>, your
content provider must search your suggestion data and return a <code>Cursor</code> that points to the rows you have determined to be good suggestions.</p>
<p>Details about creating a content provider for custom suggestions are discussed in the following
two sections:</p>
<h3>Handling the suggestion query</h3>
<p>When the system requests suggestions from your content provider, it calls your content
provider's <code>query()</code> method. You must
implement this method to search your suggestion data and return a
<code>Cursor</code> pointing to the suggestions you deem relevant.</p>
<p>Here's a summary of the parameters that the system passes to your <code>query()</code> method
(listed in order):</p>
<p>WHATSON? 03abfd7d-8c8f-4918-b32d-72fb25cad66f</p>
<pre>
content://<em>your.authority</em>/<em>optional.suggest.path</em>/<em><code>SUGGEST_URI_PATH_QUERY</code></em>
</pre>
<p>The default behavior is for system to pass this URI and append it with the query text.
For example:</p>
<p>WHATSON? 8330edc5-bb51-4569-a267-58c469596592</p>
<pre>
content://<em>your.authority</em>/<em>optional.suggest.path</em>/<em><code>SUGGEST_URI_PATH_QUERY</code></em>/puppies
</pre>
<p>The query text on the end is encoded using URI encoding rules, so you might need to decode
it before performing a search.</p>
<p>The <em><code>optional.suggest.path</code></em> portion is only included in the URI if you have set
such a path in your searchable configuration file with the <code>android:searchSuggestPath</code>
attribute. This is only needed if you use the same content provider for multiple searchable
activities, in which case, you need to disambiguate the source of the suggestion query.</p>
<p><strong>Note:</strong> <code>SUGGEST_URI_PATH_QUERY</code> is not the literal
string provided in the URI, but a constant that you should use if you need to refer to this
path.</p>
<p>The system can send you the search query text in two ways. The
default manner is for the query text to be included as the last path of the content
URI passed in the <code>uri</code> parameter. However, if you include a selection value in your
searchable configuration's <code>android:searchSuggestSelection</code> attribute, then the query text is instead passed as the first
element of the <code>selectionArgs</code> string array. Both options are summarized next.</p>
<h4>Get the query in the Uri</h4>
<p>By default, the query is appended as the last segment of the <code>uri</code>
parameter (a <code>Uri</code> object). To retrieve the query text in this case, simply use
<code>getLastPathSegment()</code>. For example:</p>
<p>WHATSON? f1d85b50-f6a1-46be-82a3-0a11f76979c7</p>
<pre>
String query = uri.getLastPathSegment().toLowerCase();
</pre>
<p>This returns the last segment of the <code>Uri</code>, which is the query text entered
by the user.</p>
<h4>Get the query in the selection arguments</h4>
<p>Instead of using the URI, you might decide it makes more sense for your <code>query()</code> method to
receive everything it needs to perform the look-up and you want the
<code>selection</code> and <code>selectionArgs</code> parameters to carry the appropriate values. In such a
case, add the <code>android:searchSuggestSelection</code> attribute to your searchable configuration with
your SQLite selection string. In the selection string, include a question mark ("?") as
a placeholder for the actual search query. The system calls <code>query()</code> with the
selection string as the <code>selection</code> parameter and the search query as the first
element in the <code>selectionArgs</code> array.</p>
<p>For example, here's how you might form the <code>android:searchSuggestSelection</code> attribute to
create a full-text search statement:</p>
<p>WHATSON? 068a59eb-23d0-479f-9055-039679c31afe</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    <b>android:searchSuggestSelection="word MATCH ?"</b>&gt;
&lt;/searchable&gt;
</pre>
<p>With this configuration, your <code>query()</code> method
delivers the <code>selection</code> parameter as <code>"word MATCH ?"</code> and the <code>selectionArgs</code>
parameter as the search query. When you pass these to an SQLite
<code>query()</code> method, as their respective arguments, they are synthesized together (the
question mark is replaced with the query
text). If you chose to receive suggestion queries this way and need to add wildcards to
the query text, append (and/or prefix) them to the <code>selectionArgs</code>
parameter, because this value is wrapped in quotes and inserted in place of the
question mark.</p>
<p>Another new attribute in the example above is <code>android:searchSuggestIntentAction</code>, which
defines the intent action sent with each intent when the user selects a suggestion. It is
discussed further in the section about Declaring an Intent for
Suggestions.</p>
<p><strong>Tip:</strong> If you don't want to define a selection clause in
the <code>android:searchSuggestSelection</code> attribute, but would still like to receive the query
text in the <code>selectionArgs</code> parameter, simply provide a non-null value for the <code>android:searchSuggestSelection</code> attribute. This triggers the query to be passed in <code>selectionArgs</code> and you can ignore the <code>selection</code> parameter. In this way, you can instead
define the actual selection clause at a lower level so that your content provider doesn't have to
handle it.</p>
<h3>Building a suggestion table</h3>
<h2>Creating a Cursor without a table</h2>
<p>If your search suggestions are not stored in a table format (such as an SQLite table) using the
columns required by the
system, then you can search your suggestion data for matches and then format them
into the necessary table on each request. To do so, create a <code>MatrixCursor</code>
using the required column names and then add a row for each suggestion using <code>addRow(Object[])</code>. Return the final product from your Content
Provider's <code>query()</code> method.</p>
<p>When you return suggestions to the system with a <code>Cursor</code>, the
system expects specific columns in each row. So, regardless of whether you
decide to store
your suggestion data in an SQLite database on the device, a database on a web server, or another
format on the device or web, you must format the suggestions as rows in a table and
present them with a <code>Cursor</code>. The system understands several columns, but
only two are required:</p>
<p>The following columns are all optional (and most are discussed further in the following
sections):</p>
<p>Some of these columns are discussed more in the following sections.</p>
<h2>Declaring an Intent for Suggestions</h2>
<p>When the user selects a suggestion from the list that appears below the search dialog or widget,
the system sends a custom <code>Intent</code> to your searchable activity. You
must define the action and data for the intent.</p>
<h3>Declaring the intent action</h3>
<p>The most common intent action for a custom suggestion is <code>ACTION_VIEW</code>, which is appropriate when
you want to open something, like the definition for a word, a person's contact information, or a web
page. However, the intent action can be any other action and can even be different for each
suggestion.</p>
<p>Depending on whether you want all suggestions to use the same intent action, you
can define the action in two ways:</p>
<ol>
  <li>Use the <code>android:searchSuggestIntentAction</code> attribute of your searchable configuration
file to define the action for all suggestions. <p>For example:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    <b>android:searchSuggestIntentAction="android.Intent.action.VIEW"</b> &gt;
&lt;/searchable&gt;
</pre>

  </li>
  <li>Use the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column to define the
action for individual suggestions.
  <p>Add the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column to
your suggestions table and, for each suggestion, place in it the action to use (such as
<code>"android.Intent.action.VIEW"</code>).</p>

  </li>
</ol>
<p>For example:</p>
<p>WHATSON? a4f4dd70-9cca-4f06-b0e8-349289a63472</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    <b>android:searchSuggestIntentAction="android.Intent.action.VIEW"</b> &gt;
&lt;/searchable&gt;
</pre>
<p>Add the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column to
your suggestions table and, for each suggestion, place in it the action to use (such as
<code>"android.Intent.action.VIEW"</code>).</p>
<p>You can also combine these two techniques. For instance, you can include the <code>android:searchSuggestIntentAction</code> attribute with an action to be used with all suggestions by
default, then override this action for some suggestions by declaring a different action in the
<code>SUGGEST_COLUMN_INTENT_ACTION</code> column. If you do not include
a value in the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column, then the
intent provided in the <code>android:searchSuggestIntentAction</code> attribute is used.</p>
<p><strong>Note</strong>: If you do not include the
<code>android:searchSuggestIntentAction</code> attribute in your searchable configuration, then you
<em>must</em> include a value in the <code>SUGGEST_COLUMN_INTENT_ACTION</code>
column for every suggestion, or the intent will fail.</p>
<h3>Declaring intent data</h3>
<p>When the user selects a suggestion, your searchable activity receives the intent with the
action you've defined (as discussed in the previous section), but the intent must also carry
data in order for your activity to identify which suggestion was selected. Specifically,
the data should be something unique for each suggestion, such as the row ID for the suggestion in
your SQLite table. When the intent is received,
you can retrieve the attached data with <code>getData()</code> or <code>getDataString()</code>.</p>
<p>You can define the data included with the intent in two ways:</p>
<ol>
  <li>Define the data for each suggestion inside the <code>SUGGEST_COLUMN_INTENT_DATA</code> column of your suggestions table.

<p>Provide all necessary data information for each intent in the suggestions table by including the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column and then populating it with
unique data for each row. The data from this column is attached to the intent exactly as you
define it in this column. You can then retrieve it with with <code>getData()</code> or <code>getDataString()</code>.</p>

<p><strong>Tip</strong>: It's usually easiest to use the table's row ID as the
Intent data, because it's always unique. And the easiest way to do that is by using the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column name as an alias for the row ID
column. See the Searchable Dictionary sample
app for an example in which <code>SQLiteQueryBuilder</code> creates a
projection map of column names to aliases.</p>
  </li>

  <li>Fragment a data URI into two pieces: the portion common to all suggestions and the portion
unique to each suggestion. Place these parts into the <code>android:searchSuggestintentData</code>
attribute of the searchable configuration and the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column of your
suggestions table, respectively.

<p>Declare the piece of the URI that is common to all suggestions in the <code>android:searchSuggestIntentData</code> attribute of your searchable configuration. For example:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    <b>android:searchSuggestIntentData="content://com.example/datatable"</b> &gt;
&lt;/searchable&gt;
</pre>

<p>Then include the final path for each suggestion (the unique part) in the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code>
column of your suggestions table. When the user selects a suggestion, the system takes
the string from <code>android:searchSuggestIntentData</code>, appends a slash ("/") and then adds the
respective value from the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column to
form a complete content URI. You can then retrieve the <code>Uri</code> with with <code>getData()</code>.</p>

  </li>
</ol>
<p>Provide all necessary data information for each intent in the suggestions table by including the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column and then populating it with
unique data for each row. The data from this column is attached to the intent exactly as you
define it in this column. You can then retrieve it with with <code>getData()</code> or <code>getDataString()</code>.</p>
<p><strong>Tip</strong>: It's usually easiest to use the table's row ID as the
Intent data, because it's always unique. And the easiest way to do that is by using the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column name as an alias for the row ID
column. See the Searchable Dictionary sample
app for an example in which <code>SQLiteQueryBuilder</code> creates a
projection map of column names to aliases.</p>
<p>Declare the piece of the URI that is common to all suggestions in the <code>android:searchSuggestIntentData</code> attribute of your searchable configuration. For example:</p>
<p>WHATSON? 148061a4-ccd3-4785-98f1-d0c11a2c4180</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    <b>android:searchSuggestIntentData="content://com.example/datatable"</b> &gt;
&lt;/searchable&gt;
</pre>
<p>Then include the final path for each suggestion (the unique part) in the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code>
column of your suggestions table. When the user selects a suggestion, the system takes
the string from <code>android:searchSuggestIntentData</code>, appends a slash ("/") and then adds the
respective value from the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column to
form a complete content URI. You can then retrieve the <code>Uri</code> with with <code>getData()</code>.</p>
<h4>Add more data</h4>
<p>If you need to express even more information with your intent, you can add another table column,
<code>SUGGEST_COLUMN_INTENT_EXTRA_DATA</code>, which can store additional
information about the suggestion. The data saved in this column is placed in <code>EXTRA_DATA_KEY</code> of the intent's extra Bundle.</p>
<h2>Handling the Intent</h2>
<p>Now that you provide custom search suggestions with custom intents, you
need your searchable activity to handle these intents when the user selects a
suggestion. This is in addition to handling the <code>ACTION_SEARCH</code> intent, which your searchable activity already does.
Here's an example of how you can handle the intents during your activity <code>onCreate()</code> callback:</p>
<p>WHATSON? efe2e1d7-7c79-4de6-9fda-334ca9664556</p>
<pre>
Intent intent = getIntent();
if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
    // Handle the normal search query case
    String query = intent.getStringExtra(SearchManager.QUERY);
    doSearch(query);
} else if (Intent.ACTION_VIEW.equals(intent.getAction())) {
    // Handle a suggestions click (because the suggestions all use ACTION_VIEW)
    Uri data = intent.getData();
    showResult(data);
}
</pre>
<p>In this example, the intent action is <code>ACTION_VIEW</code> and the data carries a complete URI pointing to the suggested
item, as synthesized by the <code>android:searchSuggestIntentData</code> string and <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column. The URI is then passed to the local
<code>showResult()</code> method that queries the content provider for the item specified by the URI.</p>
<p><strong>Note:</strong> You do <em>not</em> need to add an intent filter to your
Android manifest file for the intent action you defined with the <code>android:searchSuggestIntentAction</code> attribute or <code>SUGGEST_COLUMN_INTENT_ACTION</code> column. The system opens your
searchable activity by name to deliver the suggestion's intent, so the activity does not need to
declare the accepted action.</p>
<h2>Rewriting the query text</h2>
<p>If the user navigates through the suggestions list using the directional controls (such
as with a trackball or d-pad), the query text does not update, by default. However, you
can temporarily rewrite the user's query text as it appears in the text box with
a query that matches the suggestion currently in focus. This enables the user to see what query is
being suggested (if appropriate) and then select the search box and edit the query before
dispatching it as a search.</p>
<p>You can rewrite the query text in the following ways:</p>
<ol>
  <li>Add the <code>android:searchMode</code> attribute to your searchable configuration with the
"queryRewriteFromText" value. In this case, the content from the suggestion's <code>SUGGEST_COLUMN_TEXT_1</code>
column is used to rewrite the query text.</li>
  <li>Add the <code>android:searchMode</code> attribute to your searchable configuration with the
"queryRewriteFromData" value. In this case, the content from the suggestion's
<code>SUGGEST_COLUMN_INTENT_DATA</code> column is used to rewrite the
query text. This should only
be used with URI's or other data formats that are intended to be user-visible, such as HTTP URLs.
Internal URI schemes should not be used to rewrite the query in this way.</li>
  <li>Provide a unique query text string in the <code>SUGGEST_COLUMN_QUERY</code> column of your suggestions table. If this column is
present and contains a value for the current suggestion, it is used to rewrite the query text
(and override either of the previous implementations).</li>
</ol>
<h2>Exposing search suggestions to Quick Search Box</h2>
<p>Once you configure your application to provide custom search suggestions, making them available
to the globally accessible Quick Search Box is as easy as modifying your searchable configuration to
include <code>android:includeInGlobalSearch</code> as "true".</p>
<p>The only scenario in which additional work is necessary is when your content provider demands a
read permission. In which case, you need to add a special
<code>&lt;path-permission&gt;</code> element for the provider to grant Quick Search Box read access to
your content provider. For example:</p>
<p>WHATSON? bbc5a88f-413b-47a1-8597-db9e75cdb21f</p>
<pre>
&lt;provider android:name="MySuggestionProvider"
          android:authorities="com.example.MyCustomSuggestionProvider"
          android:readPermission="com.example.provider.READ_MY_DATA"
          android:writePermission="com.example.provider.WRITE_MY_DATA"&gt;
  &lt;path-permission android:pathPrefix="/search_suggest_query"
                   android:readPermission="android.permission.GLOBAL_SEARCH" /&gt;
&lt;/provider&gt;
</pre>
<p>In this example, the provider restricts read and write access to the content. The
<code>&lt;path-permission&gt;</code> element amends the restriction by granting read access to content
inside the <code>"/search_suggest_query"</code> path prefix when the <code>"android.permission.GLOBAL_SEARCH"</code> permission exists. This grants access to Quick Search Box
so that it may query your content provider for suggestions.</p>
<p>If your content provider does not enforce read permissions, then Quick Search Box can read
it by default.</p>
<h3>Enabling suggestions on a device</h3>
<p>When your application is configured to provide suggestions in Quick Search Box, it is not
actually enabled to provide suggestions in Quick Search Box, by default. It is the user's choice
whether to include suggestions from your application in the Quick Search Box. To enable search
suggestions from your application, the user must open "Searchable items" (in Settings &gt; Search) and
enable your application as a searchable item.</p>
<p>Each application that is available to Quick Search Box has an entry in the Searchable items
settings page. The entry includes the name of the application and a short description of what
content can be searched from the application and made available for suggestions in Quick Search Box.
To define the description text for your searchable application, add the <code>android:searchSettingsDescription</code> attribute to your searchable configuration. For example:</p>
<p>WHATSON? 8cb1ac36-09c8-49a6-90fd-a79a1f9ae768</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    android:includeInGlobalSearch="true"
    <b>android:searchSettingsDescription="@string/search_description"</b> &gt;
&lt;/searchable&gt;
</pre>
<p>The string for <code>android:searchSettingsDescription</code> should be as concise as possible and
state the content that is searchable. For example, "Artists, albums, and tracks" for a music
application, or "Saved notes" for a notepad application. Providing this description is important so
the user knows what kind of suggestions are provided. You should always include this attribute
when <code>android:includeInGlobalSearch</code> is "true".</p>
<p>Remember that the user must visit the settings menu to enable search suggestions for your
application before your search suggestions appear in Quick Search Box. As such, if search is an
important aspect of your application, then you might want to consider a way to convey that to
your users — you might provide a note the first time they launch the app that instructs
them how to enable search suggestions for Quick Search Box.</p>
<h3>Managing Quick Search Box suggestion shortcuts</h3>
<p>Suggestions that the user selects from Quick Search Box can be automatically made into shortcuts.
These are suggestions that the system has copied from your content provider  so it can
quickly access the suggestion without the need to re-query your content provider. </p>
<p>By default, this is enabled for all suggestions retrieved by Quick Search Box, but if your
suggestion data changes over time, then you can request that the shortcuts be refreshed. For
instance, if your suggestions refer to dynamic data, such as a contact's presence status, then you
should request that the suggestion shortcuts be refreshed when shown to the user. To do so,
include the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> in your suggestions table.
Using this column, you can
configure the shortcut behavior for each suggestion in one of the following ways:</p>
<ol>
  <li>Have Quick Search Box re-query your content provider for a fresh version of the suggestion
shortcut.
    <p>Provide a value in the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> column
and the suggestion is
re-queried for a fresh version each time the shortcut is displayed. The shortcut
is quickly displayed with whatever data was most recently available until the refresh query
returns, at which point the suggestion is refreshed with the new information. The
refresh query is sent to your content provider with a URI path of <code>SUGGEST_URI_PATH_SHORTCUT</code>
(instead of <code>SUGGEST_URI_PATH_QUERY</code>).</p>
    <p>The <code>Cursor</code> you return should contain one suggestion using the
same columns as the original suggestion, or be empty, indicating that the shortcut is no
longer valid (in which case, the suggestion disappears and the shortcut is removed).</p>
    <p>If a suggestion refers to data that could take longer to refresh, such as a network-based
refresh, you can also add the <code>SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING</code> column to your suggestions
table with a value
of "true" in order to show a progress spinner for the right hand icon until the refresh is complete.
Any value other than "true" does not show the progress spinner.</p>
  </li>

  <li>Prevent the suggestion from being copied into a shortcut at all.
    <p>Provide a value of <code>SUGGEST_NEVER_MAKE_SHORTCUT</code> in the
<code>SUGGEST_COLUMN_SHORTCUT_ID</code> column. In
this case, the suggestion is never copied into a shortcut. This should only be necessary if you
absolutely do not want the previously copied suggestion to appear. (Recall that if you
provide a normal value for the column, then the suggestion shortcut appears only until the
refresh query returns.)</p></li>
  <li>Allow the default shortcut behavior to apply.
    <p>Leave the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> empty for each
suggestion that will not change and can be saved as a shortcut.</p></li>
</ol>
<p>Provide a value in the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> column
and the suggestion is
re-queried for a fresh version each time the shortcut is displayed. The shortcut
is quickly displayed with whatever data was most recently available until the refresh query
returns, at which point the suggestion is refreshed with the new information. The
refresh query is sent to your content provider with a URI path of <code>SUGGEST_URI_PATH_SHORTCUT</code>
(instead of <code>SUGGEST_URI_PATH_QUERY</code>).</p>
<p>The <code>Cursor</code> you return should contain one suggestion using the
same columns as the original suggestion, or be empty, indicating that the shortcut is no
longer valid (in which case, the suggestion disappears and the shortcut is removed).</p>
<p>If a suggestion refers to data that could take longer to refresh, such as a network-based
refresh, you can also add the <code>SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING</code> column to your suggestions
table with a value
of "true" in order to show a progress spinner for the right hand icon until the refresh is complete.
Any value other than "true" does not show the progress spinner.</p>
<p>Provide a value of <code>SUGGEST_NEVER_MAKE_SHORTCUT</code> in the
<code>SUGGEST_COLUMN_SHORTCUT_ID</code> column. In
this case, the suggestion is never copied into a shortcut. This should only be necessary if you
absolutely do not want the previously copied suggestion to appear. (Recall that if you
provide a normal value for the column, then the suggestion shortcut appears only until the
refresh query returns.)</p>
<p>Leave the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> empty for each
suggestion that will not change and can be saved as a shortcut.</p>
<p>If none of your suggestions ever change, then you do not need the
<code>SUGGEST_COLUMN_SHORTCUT_ID</code> column at all.</p>
<p><strong>Note</strong>: Quick Search Box ultimately decides whether or not to create
a shortcut for a suggestion, considering these values as a strong request from your
application—there is no guarantee that the behavior you have requested for your suggestion
shortcuts will be honored.</p>
<h3>About Quick Search Box suggestion ranking</h3>
<p>Once you make your application's search suggestions available to Quick Search Box, the Quick
Search Box ranking determines how the suggestions are surfaced to the user for a particular query.
This might depend on how many other apps have results for that query, and how often the user has
selected your results compared to those from other apps. There is no guarantee about how your
suggestions are ranked, or whether your app's suggestions show at all for a given query. In
general, you can expect that providing quality results increases the likelihood that your app's
suggestions are provided in a prominent position and apps that provide low quality suggestions
are more likely to be ranked lower or not displayed.</p>
<p>See the Searchable
Dictionary sample app for a complete demonstration of custom search suggestions.</p>
<h1>Adding Custom Suggestions</h1>
<h2>In this document</h2>
<ol>
<li>The Basics</li>
<li>Modifying the Searchable Configuration</li>
<li>Creating a Content Provider
  <ol>
    <li>Handling a suggestion query</li>
    <li>Building a suggestion table</li>
  </ol>
</li>
<li>Declaring an Intent for Suggestions
  <ol>
    <li>Declaring the intent action</li>
    <li>Declaring the intent data</li>
  </ol>
</li>
<li>Handling the Intent</li>
<li>Rewriting the Query Text</li>
<li>Exposing Search Suggestions to Quick Search Box</li>
</ol>
<ol>
    <li>Handling a suggestion query</li>
    <li>Building a suggestion table</li>
  </ol>
<ol>
    <li>Declaring the intent action</li>
    <li>Declaring the intent data</li>
  </ol>
<h2>Key classes</h2>
<ol>
<li><code>SearchManager</code></li>
<li><code>SearchRecentSuggestionsProvider</code></li>
<li><code>ContentProvider</code></li>
</ol>
<h2>Related samples</h2>
<ol>
<li>Searchable
Dictionary</li>
</ol>
<h2>See also</h2>
<ol>
<li>Searchable Configuration</li>
<li>Content Providers</li>
</ol>
<p>When using the Android search dialog or search widget, you can provide custom search suggestions
that are created from data in your application. For example, if your application is a word
dictionary, you can suggest words from the
dictionary that match the text entered so far. These are the most valuable suggestions, because you
can effectively predict what the user wants and provide instant access to it. Figure 1 shows
an example of a search dialog with custom suggestions.</p>
<p>Once you provide custom suggestions, you can also make them available to the system-wide Quick
Search Box, providing access to your content from outside your application.</p>
<p>Before you begin with this guide to add custom suggestions, you need to have implemented the
Android search dialog or a search widget for searches in your
application. If you haven't, see Creating a Search Interface.</p>
<h2>The Basics</h2>
<p><strong>Figure 1.</strong> Screenshot of a search dialog with custom
search suggestions.</p>
<p>When the user selects a custom suggestion, the Android system sends an <code>Intent</code> to
your searchable activity. Whereas a normal search query sends an intent with the <code>ACTION_SEARCH</code> action, you can instead define your custom suggestions to use
<code>ACTION_VIEW</code> (or any other intent action), and also include data
that's relevant to the selected suggestion. Continuing
the dictionary example, when the user selects a suggestion, your application can immediately
open the definition for that word, instead of searching the dictionary for matches.</p>
<p>To provide custom suggestions, do the following:</p>
<ul>
  <li>Implement a basic searchable activity, as described in Creating a Search Interface.</li>
  <li>Modify the searchable configuration with information about the content provider that
provides custom suggestions.</li>
  <li>Build a table (such as in an <code>SQLiteDatabase</code>) for your
suggestions and format the table with required columns.</li>
  <li>Create a Content
Provider that has access to your suggestions table and declare the provider
in your manifest.</li>
  <li>Declare the type of <code>Intent</code> to be sent when the user selects a
suggestion (including a custom action and custom data). </li>
</ul>
<p>Just as the Android system displays the search dialog, it also displays your search
suggestions. All you need is a content provider from which the system can retrieve your
suggestions. If you're not familiar with creating content
providers, read the Content
Providers developer guide before you continue.</p>
<p>When the system identifies that your activity is searchable and provides search
suggestions, the following procedure takes place when the user types a query:</p>
<ol>
  <li>The system takes the search query text (whatever has been typed so far) and performs a
query to your content provider that manages your suggestions.</li>
  <li>Your content provider returns a <code>Cursor</code> that points to all
suggestions that are relevant to the search query text.</li>
  <li>The system displays the list of suggestions provided by the Cursor.</li>
</ol>
<p>Once the custom suggestions are displayed, the following might happen:</p>
<ul>
  <li>If the user types another key, or changes the query in any way, the above steps are repeated
and the suggestion list is updated as appropriate. </li>
  <li>If the user executes the search, the suggestions are ignored and the search is delivered
to your searchable activity using the normal <code>ACTION_SEARCH</code>
intent.</li>
  <li>If the user selects a suggestion, an intent is sent to your searchable activity, carrying a
custom action and custom data so that your application can open the suggested content.</li>
</ul>
<h2>Modifying the searchable configuration</h2>
<p>To add support for custom suggestions, add the <code>android:searchSuggestAuthority</code> attribute
to the <code>&lt;searchable&gt;</code> element in your searchable configuration file. For example:</p>
<p>WHATSON? 113c7cd3-bc57-443b-a6ad-309fa4cb9ba4</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    <b>android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"</b>&gt;
&lt;/searchable&gt;
</pre>
<p>You might need some additional attributes, depending on the type of intent you attach
to each suggestion and how you want to format queries to your content provider. The other optional
attributes are discussed in the following sections.</p>
<h2>Creating a Content Provider</h2>
<p>Creating a content provider for custom suggestions requires previous knowledge about content
providers that's covered in the Content Provider developer
guide. For the most part, a content provider for custom suggestions is the
same as any other content provider. However, for each suggestion you provide, the respective row in
the <code>Cursor</code> must include specific columns that the system
understands and uses to format the suggestions.</p>
<p>When the user starts typing into the search dialog or search widget, the system queries
your content provider for suggestions by calling <code>query()</code> each time
a letter is typed. In your implementation of <code>query()</code>, your
content provider must search your suggestion data and return a <code>Cursor</code> that points to the rows you have determined to be good suggestions.</p>
<p>Details about creating a content provider for custom suggestions are discussed in the following
two sections:</p>
<h3>Handling the suggestion query</h3>
<p>When the system requests suggestions from your content provider, it calls your content
provider's <code>query()</code> method. You must
implement this method to search your suggestion data and return a
<code>Cursor</code> pointing to the suggestions you deem relevant.</p>
<p>Here's a summary of the parameters that the system passes to your <code>query()</code> method
(listed in order):</p>
<p>WHATSON? 418c37bc-5fd5-433c-96f1-e02555f98fca</p>
<pre>
content://<em>your.authority</em>/<em>optional.suggest.path</em>/<em><code>SUGGEST_URI_PATH_QUERY</code></em>
</pre>
<p>The default behavior is for system to pass this URI and append it with the query text.
For example:</p>
<p>WHATSON? 40d6d5da-0d53-47c5-9893-e0b1aa4a5ae0</p>
<pre>
content://<em>your.authority</em>/<em>optional.suggest.path</em>/<em><code>SUGGEST_URI_PATH_QUERY</code></em>/puppies
</pre>
<p>The query text on the end is encoded using URI encoding rules, so you might need to decode
it before performing a search.</p>
<p>The <em><code>optional.suggest.path</code></em> portion is only included in the URI if you have set
such a path in your searchable configuration file with the <code>android:searchSuggestPath</code>
attribute. This is only needed if you use the same content provider for multiple searchable
activities, in which case, you need to disambiguate the source of the suggestion query.</p>
<p><strong>Note:</strong> <code>SUGGEST_URI_PATH_QUERY</code> is not the literal
string provided in the URI, but a constant that you should use if you need to refer to this
path.</p>
<p>The system can send you the search query text in two ways. The
default manner is for the query text to be included as the last path of the content
URI passed in the <code>uri</code> parameter. However, if you include a selection value in your
searchable configuration's <code>android:searchSuggestSelection</code> attribute, then the query text is instead passed as the first
element of the <code>selectionArgs</code> string array. Both options are summarized next.</p>
<h4>Get the query in the Uri</h4>
<p>By default, the query is appended as the last segment of the <code>uri</code>
parameter (a <code>Uri</code> object). To retrieve the query text in this case, simply use
<code>getLastPathSegment()</code>. For example:</p>
<p>WHATSON? 0e6698a4-2a64-4108-bf02-7149920b9087</p>
<pre>
String query = uri.getLastPathSegment().toLowerCase();
</pre>
<p>This returns the last segment of the <code>Uri</code>, which is the query text entered
by the user.</p>
<h4>Get the query in the selection arguments</h4>
<p>Instead of using the URI, you might decide it makes more sense for your <code>query()</code> method to
receive everything it needs to perform the look-up and you want the
<code>selection</code> and <code>selectionArgs</code> parameters to carry the appropriate values. In such a
case, add the <code>android:searchSuggestSelection</code> attribute to your searchable configuration with
your SQLite selection string. In the selection string, include a question mark ("?") as
a placeholder for the actual search query. The system calls <code>query()</code> with the
selection string as the <code>selection</code> parameter and the search query as the first
element in the <code>selectionArgs</code> array.</p>
<p>For example, here's how you might form the <code>android:searchSuggestSelection</code> attribute to
create a full-text search statement:</p>
<p>WHATSON? 1268043b-d2df-40d0-a4e8-c97c49fb7aed</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    <b>android:searchSuggestSelection="word MATCH ?"</b>&gt;
&lt;/searchable&gt;
</pre>
<p>With this configuration, your <code>query()</code> method
delivers the <code>selection</code> parameter as <code>"word MATCH ?"</code> and the <code>selectionArgs</code>
parameter as the search query. When you pass these to an SQLite
<code>query()</code> method, as their respective arguments, they are synthesized together (the
question mark is replaced with the query
text). If you chose to receive suggestion queries this way and need to add wildcards to
the query text, append (and/or prefix) them to the <code>selectionArgs</code>
parameter, because this value is wrapped in quotes and inserted in place of the
question mark.</p>
<p>Another new attribute in the example above is <code>android:searchSuggestIntentAction</code>, which
defines the intent action sent with each intent when the user selects a suggestion. It is
discussed further in the section about Declaring an Intent for
Suggestions.</p>
<p><strong>Tip:</strong> If you don't want to define a selection clause in
the <code>android:searchSuggestSelection</code> attribute, but would still like to receive the query
text in the <code>selectionArgs</code> parameter, simply provide a non-null value for the <code>android:searchSuggestSelection</code> attribute. This triggers the query to be passed in <code>selectionArgs</code> and you can ignore the <code>selection</code> parameter. In this way, you can instead
define the actual selection clause at a lower level so that your content provider doesn't have to
handle it.</p>
<h3>Building a suggestion table</h3>
<h2>Creating a Cursor without a table</h2>
<p>If your search suggestions are not stored in a table format (such as an SQLite table) using the
columns required by the
system, then you can search your suggestion data for matches and then format them
into the necessary table on each request. To do so, create a <code>MatrixCursor</code>
using the required column names and then add a row for each suggestion using <code>addRow(Object[])</code>. Return the final product from your Content
Provider's <code>query()</code> method.</p>
<p>When you return suggestions to the system with a <code>Cursor</code>, the
system expects specific columns in each row. So, regardless of whether you
decide to store
your suggestion data in an SQLite database on the device, a database on a web server, or another
format on the device or web, you must format the suggestions as rows in a table and
present them with a <code>Cursor</code>. The system understands several columns, but
only two are required:</p>
<p>The following columns are all optional (and most are discussed further in the following
sections):</p>
<p>Some of these columns are discussed more in the following sections.</p>
<h2>Declaring an Intent for Suggestions</h2>
<p>When the user selects a suggestion from the list that appears below the search dialog or widget,
the system sends a custom <code>Intent</code> to your searchable activity. You
must define the action and data for the intent.</p>
<h3>Declaring the intent action</h3>
<p>The most common intent action for a custom suggestion is <code>ACTION_VIEW</code>, which is appropriate when
you want to open something, like the definition for a word, a person's contact information, or a web
page. However, the intent action can be any other action and can even be different for each
suggestion.</p>
<p>Depending on whether you want all suggestions to use the same intent action, you
can define the action in two ways:</p>
<ol>
  <li>Use the <code>android:searchSuggestIntentAction</code> attribute of your searchable configuration
file to define the action for all suggestions. <p>For example:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    <b>android:searchSuggestIntentAction="android.Intent.action.VIEW"</b> &gt;
&lt;/searchable&gt;
</pre>

  </li>
  <li>Use the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column to define the
action for individual suggestions.
  <p>Add the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column to
your suggestions table and, for each suggestion, place in it the action to use (such as
<code>"android.Intent.action.VIEW"</code>).</p>

  </li>
</ol>
<p>For example:</p>
<p>WHATSON? 2fd63420-006e-4830-97fa-37cae2f72984</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    <b>android:searchSuggestIntentAction="android.Intent.action.VIEW"</b> &gt;
&lt;/searchable&gt;
</pre>
<p>Add the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column to
your suggestions table and, for each suggestion, place in it the action to use (such as
<code>"android.Intent.action.VIEW"</code>).</p>
<p>You can also combine these two techniques. For instance, you can include the <code>android:searchSuggestIntentAction</code> attribute with an action to be used with all suggestions by
default, then override this action for some suggestions by declaring a different action in the
<code>SUGGEST_COLUMN_INTENT_ACTION</code> column. If you do not include
a value in the <code>SUGGEST_COLUMN_INTENT_ACTION</code> column, then the
intent provided in the <code>android:searchSuggestIntentAction</code> attribute is used.</p>
<p><strong>Note</strong>: If you do not include the
<code>android:searchSuggestIntentAction</code> attribute in your searchable configuration, then you
<em>must</em> include a value in the <code>SUGGEST_COLUMN_INTENT_ACTION</code>
column for every suggestion, or the intent will fail.</p>
<h3>Declaring intent data</h3>
<p>When the user selects a suggestion, your searchable activity receives the intent with the
action you've defined (as discussed in the previous section), but the intent must also carry
data in order for your activity to identify which suggestion was selected. Specifically,
the data should be something unique for each suggestion, such as the row ID for the suggestion in
your SQLite table. When the intent is received,
you can retrieve the attached data with <code>getData()</code> or <code>getDataString()</code>.</p>
<p>You can define the data included with the intent in two ways:</p>
<ol>
  <li>Define the data for each suggestion inside the <code>SUGGEST_COLUMN_INTENT_DATA</code> column of your suggestions table.

<p>Provide all necessary data information for each intent in the suggestions table by including the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column and then populating it with
unique data for each row. The data from this column is attached to the intent exactly as you
define it in this column. You can then retrieve it with with <code>getData()</code> or <code>getDataString()</code>.</p>

<p><strong>Tip</strong>: It's usually easiest to use the table's row ID as the
Intent data, because it's always unique. And the easiest way to do that is by using the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column name as an alias for the row ID
column. See the Searchable Dictionary sample
app for an example in which <code>SQLiteQueryBuilder</code> creates a
projection map of column names to aliases.</p>
  </li>

  <li>Fragment a data URI into two pieces: the portion common to all suggestions and the portion
unique to each suggestion. Place these parts into the <code>android:searchSuggestintentData</code>
attribute of the searchable configuration and the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column of your
suggestions table, respectively.

<p>Declare the piece of the URI that is common to all suggestions in the <code>android:searchSuggestIntentData</code> attribute of your searchable configuration. For example:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    <b>android:searchSuggestIntentData="content://com.example/datatable"</b> &gt;
&lt;/searchable&gt;
</pre>

<p>Then include the final path for each suggestion (the unique part) in the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code>
column of your suggestions table. When the user selects a suggestion, the system takes
the string from <code>android:searchSuggestIntentData</code>, appends a slash ("/") and then adds the
respective value from the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column to
form a complete content URI. You can then retrieve the <code>Uri</code> with with <code>getData()</code>.</p>

  </li>
</ol>
<p>Provide all necessary data information for each intent in the suggestions table by including the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column and then populating it with
unique data for each row. The data from this column is attached to the intent exactly as you
define it in this column. You can then retrieve it with with <code>getData()</code> or <code>getDataString()</code>.</p>
<p><strong>Tip</strong>: It's usually easiest to use the table's row ID as the
Intent data, because it's always unique. And the easiest way to do that is by using the
<code>SUGGEST_COLUMN_INTENT_DATA</code> column name as an alias for the row ID
column. See the Searchable Dictionary sample
app for an example in which <code>SQLiteQueryBuilder</code> creates a
projection map of column names to aliases.</p>
<p>Declare the piece of the URI that is common to all suggestions in the <code>android:searchSuggestIntentData</code> attribute of your searchable configuration. For example:</p>
<p>WHATSON? 20463949-9e6a-4bb4-b219-207671514436</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    <b>android:searchSuggestIntentData="content://com.example/datatable"</b> &gt;
&lt;/searchable&gt;
</pre>
<p>Then include the final path for each suggestion (the unique part) in the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code>
column of your suggestions table. When the user selects a suggestion, the system takes
the string from <code>android:searchSuggestIntentData</code>, appends a slash ("/") and then adds the
respective value from the <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column to
form a complete content URI. You can then retrieve the <code>Uri</code> with with <code>getData()</code>.</p>
<h4>Add more data</h4>
<p>If you need to express even more information with your intent, you can add another table column,
<code>SUGGEST_COLUMN_INTENT_EXTRA_DATA</code>, which can store additional
information about the suggestion. The data saved in this column is placed in <code>EXTRA_DATA_KEY</code> of the intent's extra Bundle.</p>
<h2>Handling the Intent</h2>
<p>Now that you provide custom search suggestions with custom intents, you
need your searchable activity to handle these intents when the user selects a
suggestion. This is in addition to handling the <code>ACTION_SEARCH</code> intent, which your searchable activity already does.
Here's an example of how you can handle the intents during your activity <code>onCreate()</code> callback:</p>
<p>WHATSON? 124b0b6b-ae19-488e-9ae6-2d20e96690bb</p>
<pre>
Intent intent = getIntent();
if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
    // Handle the normal search query case
    String query = intent.getStringExtra(SearchManager.QUERY);
    doSearch(query);
} else if (Intent.ACTION_VIEW.equals(intent.getAction())) {
    // Handle a suggestions click (because the suggestions all use ACTION_VIEW)
    Uri data = intent.getData();
    showResult(data);
}
</pre>
<p>In this example, the intent action is <code>ACTION_VIEW</code> and the data carries a complete URI pointing to the suggested
item, as synthesized by the <code>android:searchSuggestIntentData</code> string and <code>SUGGEST_COLUMN_INTENT_DATA_ID</code> column. The URI is then passed to the local
<code>showResult()</code> method that queries the content provider for the item specified by the URI.</p>
<p><strong>Note:</strong> You do <em>not</em> need to add an intent filter to your
Android manifest file for the intent action you defined with the <code>android:searchSuggestIntentAction</code> attribute or <code>SUGGEST_COLUMN_INTENT_ACTION</code> column. The system opens your
searchable activity by name to deliver the suggestion's intent, so the activity does not need to
declare the accepted action.</p>
<h2>Rewriting the query text</h2>
<p>If the user navigates through the suggestions list using the directional controls (such
as with a trackball or d-pad), the query text does not update, by default. However, you
can temporarily rewrite the user's query text as it appears in the text box with
a query that matches the suggestion currently in focus. This enables the user to see what query is
being suggested (if appropriate) and then select the search box and edit the query before
dispatching it as a search.</p>
<p>You can rewrite the query text in the following ways:</p>
<ol>
  <li>Add the <code>android:searchMode</code> attribute to your searchable configuration with the
"queryRewriteFromText" value. In this case, the content from the suggestion's <code>SUGGEST_COLUMN_TEXT_1</code>
column is used to rewrite the query text.</li>
  <li>Add the <code>android:searchMode</code> attribute to your searchable configuration with the
"queryRewriteFromData" value. In this case, the content from the suggestion's
<code>SUGGEST_COLUMN_INTENT_DATA</code> column is used to rewrite the
query text. This should only
be used with URI's or other data formats that are intended to be user-visible, such as HTTP URLs.
Internal URI schemes should not be used to rewrite the query in this way.</li>
  <li>Provide a unique query text string in the <code>SUGGEST_COLUMN_QUERY</code> column of your suggestions table. If this column is
present and contains a value for the current suggestion, it is used to rewrite the query text
(and override either of the previous implementations).</li>
</ol>
<h2>Exposing search suggestions to Quick Search Box</h2>
<p>Once you configure your application to provide custom search suggestions, making them available
to the globally accessible Quick Search Box is as easy as modifying your searchable configuration to
include <code>android:includeInGlobalSearch</code> as "true".</p>
<p>The only scenario in which additional work is necessary is when your content provider demands a
read permission. In which case, you need to add a special
<code>&lt;path-permission&gt;</code> element for the provider to grant Quick Search Box read access to
your content provider. For example:</p>
<p>WHATSON? dbe2f9f2-7203-47a8-8f96-4ac68cc5fbfd</p>
<pre>
&lt;provider android:name="MySuggestionProvider"
          android:authorities="com.example.MyCustomSuggestionProvider"
          android:readPermission="com.example.provider.READ_MY_DATA"
          android:writePermission="com.example.provider.WRITE_MY_DATA"&gt;
  &lt;path-permission android:pathPrefix="/search_suggest_query"
                   android:readPermission="android.permission.GLOBAL_SEARCH" /&gt;
&lt;/provider&gt;
</pre>
<p>In this example, the provider restricts read and write access to the content. The
<code>&lt;path-permission&gt;</code> element amends the restriction by granting read access to content
inside the <code>"/search_suggest_query"</code> path prefix when the <code>"android.permission.GLOBAL_SEARCH"</code> permission exists. This grants access to Quick Search Box
so that it may query your content provider for suggestions.</p>
<p>If your content provider does not enforce read permissions, then Quick Search Box can read
it by default.</p>
<h3>Enabling suggestions on a device</h3>
<p>When your application is configured to provide suggestions in Quick Search Box, it is not
actually enabled to provide suggestions in Quick Search Box, by default. It is the user's choice
whether to include suggestions from your application in the Quick Search Box. To enable search
suggestions from your application, the user must open "Searchable items" (in Settings &gt; Search) and
enable your application as a searchable item.</p>
<p>Each application that is available to Quick Search Box has an entry in the Searchable items
settings page. The entry includes the name of the application and a short description of what
content can be searched from the application and made available for suggestions in Quick Search Box.
To define the description text for your searchable application, add the <code>android:searchSettingsDescription</code> attribute to your searchable configuration. For example:</p>
<p>WHATSON? e8c0e7a2-f31e-41a1-b52f-5848d1bbab4e</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint"
    android:searchSuggestAuthority="com.example.MyCustomSuggestionProvider"
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    android:includeInGlobalSearch="true"
    <b>android:searchSettingsDescription="@string/search_description"</b> &gt;
&lt;/searchable&gt;
</pre>
<p>The string for <code>android:searchSettingsDescription</code> should be as concise as possible and
state the content that is searchable. For example, "Artists, albums, and tracks" for a music
application, or "Saved notes" for a notepad application. Providing this description is important so
the user knows what kind of suggestions are provided. You should always include this attribute
when <code>android:includeInGlobalSearch</code> is "true".</p>
<p>Remember that the user must visit the settings menu to enable search suggestions for your
application before your search suggestions appear in Quick Search Box. As such, if search is an
important aspect of your application, then you might want to consider a way to convey that to
your users — you might provide a note the first time they launch the app that instructs
them how to enable search suggestions for Quick Search Box.</p>
<h3>Managing Quick Search Box suggestion shortcuts</h3>
<p>Suggestions that the user selects from Quick Search Box can be automatically made into shortcuts.
These are suggestions that the system has copied from your content provider  so it can
quickly access the suggestion without the need to re-query your content provider. </p>
<p>By default, this is enabled for all suggestions retrieved by Quick Search Box, but if your
suggestion data changes over time, then you can request that the shortcuts be refreshed. For
instance, if your suggestions refer to dynamic data, such as a contact's presence status, then you
should request that the suggestion shortcuts be refreshed when shown to the user. To do so,
include the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> in your suggestions table.
Using this column, you can
configure the shortcut behavior for each suggestion in one of the following ways:</p>
<ol>
  <li>Have Quick Search Box re-query your content provider for a fresh version of the suggestion
shortcut.
    <p>Provide a value in the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> column
and the suggestion is
re-queried for a fresh version each time the shortcut is displayed. The shortcut
is quickly displayed with whatever data was most recently available until the refresh query
returns, at which point the suggestion is refreshed with the new information. The
refresh query is sent to your content provider with a URI path of <code>SUGGEST_URI_PATH_SHORTCUT</code>
(instead of <code>SUGGEST_URI_PATH_QUERY</code>).</p>
    <p>The <code>Cursor</code> you return should contain one suggestion using the
same columns as the original suggestion, or be empty, indicating that the shortcut is no
longer valid (in which case, the suggestion disappears and the shortcut is removed).</p>
    <p>If a suggestion refers to data that could take longer to refresh, such as a network-based
refresh, you can also add the <code>SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING</code> column to your suggestions
table with a value
of "true" in order to show a progress spinner for the right hand icon until the refresh is complete.
Any value other than "true" does not show the progress spinner.</p>
  </li>

  <li>Prevent the suggestion from being copied into a shortcut at all.
    <p>Provide a value of <code>SUGGEST_NEVER_MAKE_SHORTCUT</code> in the
<code>SUGGEST_COLUMN_SHORTCUT_ID</code> column. In
this case, the suggestion is never copied into a shortcut. This should only be necessary if you
absolutely do not want the previously copied suggestion to appear. (Recall that if you
provide a normal value for the column, then the suggestion shortcut appears only until the
refresh query returns.)</p></li>
  <li>Allow the default shortcut behavior to apply.
    <p>Leave the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> empty for each
suggestion that will not change and can be saved as a shortcut.</p></li>
</ol>
<p>Provide a value in the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> column
and the suggestion is
re-queried for a fresh version each time the shortcut is displayed. The shortcut
is quickly displayed with whatever data was most recently available until the refresh query
returns, at which point the suggestion is refreshed with the new information. The
refresh query is sent to your content provider with a URI path of <code>SUGGEST_URI_PATH_SHORTCUT</code>
(instead of <code>SUGGEST_URI_PATH_QUERY</code>).</p>
<p>The <code>Cursor</code> you return should contain one suggestion using the
same columns as the original suggestion, or be empty, indicating that the shortcut is no
longer valid (in which case, the suggestion disappears and the shortcut is removed).</p>
<p>If a suggestion refers to data that could take longer to refresh, such as a network-based
refresh, you can also add the <code>SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING</code> column to your suggestions
table with a value
of "true" in order to show a progress spinner for the right hand icon until the refresh is complete.
Any value other than "true" does not show the progress spinner.</p>
<p>Provide a value of <code>SUGGEST_NEVER_MAKE_SHORTCUT</code> in the
<code>SUGGEST_COLUMN_SHORTCUT_ID</code> column. In
this case, the suggestion is never copied into a shortcut. This should only be necessary if you
absolutely do not want the previously copied suggestion to appear. (Recall that if you
provide a normal value for the column, then the suggestion shortcut appears only until the
refresh query returns.)</p>
<p>Leave the <code>SUGGEST_COLUMN_SHORTCUT_ID</code> empty for each
suggestion that will not change and can be saved as a shortcut.</p>
<p>If none of your suggestions ever change, then you do not need the
<code>SUGGEST_COLUMN_SHORTCUT_ID</code> column at all.</p>
<p><strong>Note</strong>: Quick Search Box ultimately decides whether or not to create
a shortcut for a suggestion, considering these values as a strong request from your
application—there is no guarantee that the behavior you have requested for your suggestion
shortcuts will be honored.</p>
<h3>About Quick Search Box suggestion ranking</h3>
<p>Once you make your application's search suggestions available to Quick Search Box, the Quick
Search Box ranking determines how the suggestions are surfaced to the user for a particular query.
This might depend on how many other apps have results for that query, and how often the user has
selected your results compared to those from other apps. There is no guarantee about how your
suggestions are ranked, or whether your app's suggestions show at all for a given query. In
general, you can expect that providing quality results increases the likelihood that your app's
suggestions are provided in a prominent position and apps that provide low quality suggestions
are more likely to be ranked lower or not displayed.</p>
<p>See the Searchable
Dictionary sample app for a complete demonstration of custom search suggestions.</p>
</body>
</html>