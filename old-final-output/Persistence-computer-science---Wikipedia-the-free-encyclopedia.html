<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Persistence-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Persistence (computer science)</h1>
<p>In computer science, <b>persistence</b> refers to the characteristic of state that outlives the process that created it. Without this capability, state would only exist in RAM, and would be lost when this RAM loses power, such as a computer shutdown.</p>
<p>This is achieved in practice by storing the state as data in non-volatile storage such as a hard drive or flash memory, most basically via serialization of the data to a storable format, and then saving the data to a file.</p>
<p>Picture editing programs or word processors, for example, achieve state persistence by saving their documents to files.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Orthogonal or transparent persistence
<ul>
<li>1.1 Adoption</li>
</ul>
</li>
<li>2 Persistence techniques
<ul>
<li>2.1 System images</li>
<li>2.2 Journals</li>
<li>2.3 Dirty writes</li>
</ul>
</li>
<li>3 Persistence layers</li>
<li>4 System prevalence</li>
<li>5 Database management systems (DBMSs)</li>
<li>6 Persistent operating systems</li>
<li>7 References</li>
<li>8 See also</li>
</ul>
<ul>
<li>1.1 Adoption</li>
</ul>
<ul>
<li>2.1 System images</li>
<li>2.2 Journals</li>
<li>2.3 Dirty writes</li>
</ul>
<p></p>
<h2>Orthogonal or transparent persistence</h2>
<p>Persistence is said to be "orthogonal" or "transparent" when it is implemented as an intrinsic property of the execution environment of a program. An orthogonal persistence environment does not require any specific actions by programs running in it to retrieve or save their state.</p>
<p>Non-orthogonal persistence requires data to be written and read to and from storage using specific instructions in a program, resulting in the use of <i>persist</i> as a transitive verb: <i>On completion, the program persists the data</i>.</p>
<p>The advantage of orthogonal persistence environments is simpler and less error-prone programs.</p>
<h3>Adoption</h3>
<p>Orthogonal persistence is widely adopted in operating systems for hibernation and in platform virtualization systems such as VMware and VirtualBox for state saving.</p>
<p>Research prototype languages such as PS-algol, Napier88, Fibonacci and pJama, successfully demonstrated the concepts along with the advantages to programmers. As Java developed, the more traditional mechanism of serialization and, later, JAXB bindings, gave similar functionality to programmers. Perl has two well-defined interfaces for providing alternate semantics to fetches and stores on its basic data types, "tie" and "overload," both of which are often used to provide orthogonal interfaces to persistent storage methods.</p>
<h2>Persistence techniques</h2>
<h3>System images</h3>
<p>Using system images is the simplest persistence strategy. Notebook hibernation is an example of orthogonal persistence using a system image because it does not require any actions by the programs running on the machine. An example of non-orthogonal persistence using a system image is a simple text editing program executing specific instructions to save an entire document to a file.</p>
<p><b>Shortcomings</b>: State changes made to a system after its last image was saved are lost in the case of a system failure or shutdown. Saving an image for every single change would be too time-consuming for most systems, so images are not used as the single persistence technique for critical systems.</p>
<h3>Journals</h3>
<p>Using journals is the second simplest persistence technique. Journaling is the process of storing events in a log before each one is applied to a system. Such logs are called journals.</p>
<p>On startup, the journal is read and each event is reapplied to the system, avoiding data loss in the case of system failure or shutdown.</p>
<p>The entire "Undo/Redo" history of user commands in a picture editing program, for example, when written to a file, constitutes a journal capable of recovering the state of an edited pictures at any point in time.</p>
<p>Journals are used by journaling file systems, prevalent systems and database management systems where they are also called "transaction logs" or "redo logs".</p>
<p><b>Shortcomings</b>: Journals are often combined with other persistence techniques so that the entire (potentially large) history of all system events does not have to be reapplied on system startup.</p>
<h3>Dirty writes</h3>
<p>This technique is the writing to storage of only those portions of system state that have been modified (are dirty) since their last write. Sophisticated document editing applications, for example, will use dirty writes to save only those portions of a document that were actually changed since the last save.</p>
<p><b>Shortcomings:</b> This technique requires state changes to be intercepted within a program. This is achieved in a non-transparent way by requiring specific storage-API calls or in a transparent way with automatic program transformation. This results in code that is slower than native code and more complicated to debug.</p>
<h2>Persistence layers</h2>
<p>Any software layer that makes it easier for a program to persist its state is generically called a persistence layer. Most persistence layers will not achieve persistence directly but will use an underlying database management system.</p>
<h2>System prevalence</h2>
<p>System prevalence is a technique that combines system images and transaction journals, mentioned above, to overcome their limitations.</p>
<p><b>Shortcomings:</b> A prevalent system must have enough RAM to hold the entire system state.</p>
<h2>Database management systems (DBMSs)</h2>
<p>DBMSs use a combination of the dirty writes and transaction journaling techniques mentioned above. They provide not only persistence but also other services such as queries, auditing and access control.</p>
<h2>Persistent operating systems</h2>
<p>Persistent operating systems are operating systems that remain persistent even after a crash or unexpected shutdown. Operating systems that employ this ability include</p>
<ul>
<li>CapROS, revisions of EROS</li>
<li>Coyotos, successor to EROS</li>
<li>EROS, the successor to KeyKOS</li>
<li>KeyKOS</li>
<li>Multics with its single-level store</li>
<li>Phantom</li>
<li>IBM System/38</li>
<li>Grasshopper OS [1]</li>
<li>Lua OS</li>
</ul>
</body>
</html>