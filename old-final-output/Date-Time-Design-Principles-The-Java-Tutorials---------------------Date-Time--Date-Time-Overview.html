<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Date-Time-Design-Principles-The-Java-Tutorials---------------------Date-Time--Date-Time-Overview.html</title></head>
<body>
<h1>Date-Time Design Principles</h1>
<p>
The Date-Time API was developed using several design principles.</p>
<h2>Clear</h2>
<p>
The methods in the API are well defined and their behavior is clear and expected. For example, invoking a Date-Time method with a <tt>null</tt> parameter value typically triggers a <tt>NullPointerException</tt>.</p>
<h2>Fluent</h2>
<p>
The Date-Time API provides a fluent interface, making the code easy to read. Because most methods do not allow parameters with a <tt>null</tt> value and do not return a <tt>null</tt> value, method calls can be chained together and the resulting code can be quickly understood. For example:</p>
<p>WHATSON? 62c15a98-7b23-40a7-a4da-7c1007755736</p>
<pre>
LocalDate today = LocalDate.now();
LocalDate payday = today.with(TemporalAdjusters.lastDayOfMonth()).minusDays(2);
</pre>
<h2>Immutable</h2>
<p>
Most of the classes in the Date-Time API create objects that are
immutable, meaning that, after the object is created, it cannot be modified. To alter the value of an immutable object, a new object must be constructed as a modified copy of the original. This also means that the Date-Time API is, by definition, thread-safe. This affects the API in that most of the methods used to create date or time objects are prefixed with <code>of</code>, <code>from</code>, or <code>with</code>, rather than constructors, and there are no <code>set</code> methods. For example:</p>
<p>WHATSON? 550d9be8-9f53-4785-82a4-1310c25abc7f</p>
<pre>
LocalDate dateOfBirth = LocalDate.of(2012, Month.MAY, 14);
LocalDate firstBirthday = dateOfBirth.plusYears(1);
</pre>
<h2>Extensible</h2>
<p>
The Date-Time API is extensible wherever possible. For example, you can define your own time adjusters and queries, or build your own calendar system.</p>
</body>
</html>