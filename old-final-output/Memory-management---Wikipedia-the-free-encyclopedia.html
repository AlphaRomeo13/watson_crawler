<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Memory-management---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Memory management</h1>
<p><b>Memory management</b> is the act of managing computer memory. The essential requirement of memory management is to provide ways to dynamically allocate portions of memory to programs at their request, and free it for reuse when no longer needed. This is critical to any advanced computer system where more than a single process might be underway at any time.</p>
<p>Several methods have been devised that increase the effectiveness of memory management. Virtual memory systems separate the memory addresses used by a process from actual physical addresses, allowing separation of processes and increasing the effectively available amount of RAM using paging or swapping to secondary storage. The quality of the virtual memory manager can have an extensive effect on overall system performance.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Dynamic memory allocation
<ul>
<li>1.1 Details</li>
<li>1.2 Efficiency</li>
<li>1.3 Implementations
<ul>
<li>1.3.1 Fixed-size blocks allocation</li>
<li>1.3.2 Buddy blocks</li>
</ul>
</li>
</ul>
</li>
<li>2 Systems with virtual memory
<ul>
<li>2.1 Protection</li>
<li>2.2 Sharing</li>
<li>2.3 Physical organization</li>
</ul>
</li>
<li>3 See also</li>
<li>4 Notes</li>
<li>5 References</li>
<li>6 Further reading</li>
<li>7 External links</li>
</ul>
<ul>
<li>1.1 Details</li>
<li>1.2 Efficiency</li>
<li>1.3 Implementations
<ul>
<li>1.3.1 Fixed-size blocks allocation</li>
<li>1.3.2 Buddy blocks</li>
</ul>
</li>
</ul>
<ul>
<li>1.3.1 Fixed-size blocks allocation</li>
<li>1.3.2 Buddy blocks</li>
</ul>
<ul>
<li>2.1 Protection</li>
<li>2.2 Sharing</li>
<li>2.3 Physical organization</li>
</ul>
<p></p>
<h2>Dynamic memory allocation</h2>
<h3>Details</h3>
<p>The task of fulfilling an allocation request consists of locating a block of unused memory of sufficient size. Memory requests are satisfied by allocating portions from a large pool of memory called the <b>heap</b> or <b>free store</b>. At any given time, some parts of the heap are in use, while some are "free" (unused) and thus available for future allocations.</p>
<p>Several issues complicate the implementation, such as external fragmentation, which arises when there are many small gaps between allocated memory blocks, which invalidates their use for an allocation request. The allocator's metadata can also inflate the size of (individually) small allocations. This is managed often by chunking. The memory management system must track outstanding allocations to ensure that they do not overlap and that no memory is ever "lost" as a memory leak.</p>
<h3>Efficiency</h3>
<p>The specific dynamic memory allocation algorithm implemented can impact performance significantly. A study conducted in 1994 by Digital Equipment Corporation illustrates the overheads involved for a variety of allocators. The lowest average instruction path length required to allocate a single memory slot was 52 (as measured with an instruction level profiler on a variety of software).</p>
<h3>Implementations</h3>
<p>Since the precise location of the allocation is not known in advance, the memory is accessed indirectly, usually through a pointer reference. The specific algorithm used to organize the memory area and allocate and deallocate chunks is interlinked with the kernel, and may use any of the following methods:</p>
<h4>Fixed-size blocks allocation</h4>
<p>Fixed-size blocks allocation, also called memory pool allocation, uses a free list of fixed-size blocks of memory (often all of the same size). This works well for simple embedded systems where no large objects need to be allocated, but suffers from fragmentation, especially with long memory addresses. However, due to the significantly reduced overhead this method can substantially improve performance for objects that need frequent allocation / de-allocation and is often used in video games.</p>
<h4>Buddy blocks</h4>
<p>In this system, memory is allocated into several pools of memory instead of just one, where each pool represents blocks of memory of a certain power of two in size. All blocks of a particular size are kept in a sorted linked list or tree and all new blocks that are formed during allocation are added to their respective memory pools for later use. If a smaller size is requested than is available, the smallest available size is selected and halved. One of the resulting halves is selected, and the process repeats until the request is complete. When a block is allocated, the allocator will start with the smallest sufficiently large block to avoid needlessly breaking blocks. When a block is freed, it is compared to its buddy. If they are both free, they are combined and placed in the next-largest size buddy-block list.</p>
<h2>Systems with virtual memory</h2>
<p>Virtual memory is a method of decoupling the memory organization from the physical hardware. The applications operate memory via <i>virtual addresses</i>. Each time an attempt to access stored data is made, virtual memory data orders translate the virtual address to a <i>physical address</i>. In this way addition of virtual memory enables granular control over memory systems and methods of access.</p>
<h3>Protection</h3>
<p>In virtual memory systems the operating system limits how a process can access the memory. This feature can be used to disallow a process to read or write to memory that is not allocated to it, preventing malicious or malfunctioning code in one program from interfering with the operation of another.</p>
<h3>Sharing</h3>
<p>Even though the memory allocated for specific processes is normally isolated, processes sometimes need to be able to share information. Shared memory is one of the fastest techniques for inter-process communication.</p>
<h3>Physical organization</h3>
<p>Memory is usually classed by access rate as with primary storage and secondary storage. Memory management systems handle moving information between these two levels of memory.</p>
<h2>See also</h2>
<ul>
<li>Automatic memory allocation</li>
<li>Demand paging</li>
<li>Dynamic array</li>
<li>Garbage collection</li>
<li>Memory management (operating systems)</li>
<li>Memory management unit (MMU)</li>
<li>Memory pool</li>
<li>Region-based memory management</li>
<li>Resource management</li>
<li>Slab allocation</li>
<li>Stack-based memory allocation</li>
<li>Page table</li>
<li>Paging</li>
<li>Pointer</li>
<li>Virtual memory</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Gibson, Steve (August 15, 1988). "Tech Talk: Placing the IBM/Microsoft XMS Spec Into Perspective". <i>InfoWorld</i>. </li>
<li><b>^</b> Detlefs, D.; Dosser, A.; Zorn, B. (June 1994). "Memory allocation costs in large C and C++ programs". <i>Software: Practice and Experience</i> <b>24</b> (6): 527–542. doi:10.1002/spe.4380240602. CiteSeerX: 10.1.1.30.3073.  edit</li>
</ol>
</body>
</html>