<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Function composition (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>function composition</b> (not to be confused with <a href="/wiki/Object_composition" title="Object composition">object composition</a>) is an act or mechanism to combine simple <a href="/wiki/Subroutine" title="Subroutine">functions</a> to build more complicated ones. Like the usual <a href="/wiki/Function_composition" title="Function composition">composition of functions</a> in <a href="/wiki/Mathematics" title="Mathematics">mathematics</a>, the result of each function is passed as the argument of the next, and the result of the last one is the result of the whole.</p>
<p>Programmers frequently apply functions to results of other functions, and almost all programming languages allow it. In some cases, the composition of functions is interesting as a function in its own right, to be used later. Such a function can always be defined but languages with <a href="/wiki/First-class_functions" title="First-class functions" class="mw-redirect">first-class functions</a> make it easier.</p>
<p>The ability to easily compose functions encourages <a href="/wiki/Code_refactoring" title="Code refactoring">factoring</a> (breaking apart) <a href="/wiki/Subroutine" title="Subroutine">functions</a> for maintainability and <a href="/wiki/Code_reuse" title="Code reuse">code reuse</a>. More generally, big systems might be built by composing whole programs.</p>
<p>Narrowly speaking, function composition applies to functions that operate on a finite amount of data, each step sequentially processing it before handing it to the next. Functions that operate on potentially infinite data (a <a href="/wiki/Stream_(computing)" title="Stream (computing)">stream</a> or other <a href="/wiki/Codata" title="Codata" class="mw-redirect">codata</a>), known as <a href="/wiki/Filter_(software)" title="Filter (software)">filters</a>, and are instead connected in a <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">pipeline</a>, which is analogous to function composition and can execute <a href="/wiki/Concurrent_computing" title="Concurrent computing">concurrently</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Composing_function_calls"><span class="tocnumber">1</span> <span class="toctext">Composing function calls</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Naming_the_composition_of_functions"><span class="tocnumber">2</span> <span class="toctext">Naming the composition of functions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#First-class_composition"><span class="tocnumber">3</span> <span class="toctext">First-class composition</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Research_survey"><span class="tocnumber">4</span> <span class="toctext">Research survey</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Large-scale_composition"><span class="tocnumber">5</span> <span class="toctext">Large-scale composition</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Notes"><span class="tocnumber">7</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Composing_function_calls">Composing function calls</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Composing function calls">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For example, suppose we have two <a href="/wiki/Function_(mathematics)" title="Function (mathematics)">functions</a> <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png"> and <img class="mwe-math-fallback-image-inline tex" alt="g" src="//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png">, as in <img class="mwe-math-fallback-image-inline tex" alt="z=f(y)" src="//upload.wikimedia.org/math/3/e/f/3ef3cadf29d48026f675ae9b1c31cc7b.png"> and <img class="mwe-math-fallback-image-inline tex" alt="y=g(x)" src="//upload.wikimedia.org/math/d/1/3/d13f453d5a25ba83fd2f3ecc74880538.png">. Composing them means we first compute <img class="mwe-math-fallback-image-inline tex" alt="y=g(x)" src="//upload.wikimedia.org/math/d/1/3/d13f453d5a25ba83fd2f3ecc74880538.png">, and then use <img class="mwe-math-fallback-image-inline tex" alt="y" src="//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png"> to compute <img class="mwe-math-fallback-image-inline tex" alt="z=f(y)" src="//upload.wikimedia.org/math/3/e/f/3ef3cadf29d48026f675ae9b1c31cc7b.png">. Here is the example in the <a href="/wiki/C_(programming_language)" title="C (programming language)">C language</a>:</p>
<p>WHATSON? 6a493a11-6dea-4d14-a3f8-956a84fcbc27</p>
<pre class="de1">
<span class="kw4">float</span> x<span class="sy0">,</span> y<span class="sy0">,</span> z<span class="sy0">;</span>
<span class="co1">// ...</span>
y <span class="sy0">=</span> g<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
z <span class="sy0">=</span> f<span class="br0">(</span>y<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The steps can be combined if we don't give a name to the intermediate result:</p>
<p>WHATSON? 58d161d2-8ea8-4558-9b12-153791ebb3bd</p>
<pre class="de1">
z <span class="sy0">=</span> f<span class="br0">(</span>g<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>Despite differences in length, these two implementations compute the same result. The second implementation requires only one line of code and is colloquially referred to as a "highly composed" form. Readability and hence maintainability is one advantage of highly composed forms, since they require fewer lines of code, minimizing a program's "surface area".<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> DeMarco and Lister empirically verify an inverse relationship between surface area and maintainability.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> On the other hand, it may be possible to overuse highly composed forms. A nesting of too many functions may have the opposite effect, making the code less maintainable.</p>
<p>In a <a href="/wiki/Stack-based_language" title="Stack-based language" class="mw-redirect">stack-based language</a>, functional composition is even more natural: it is performed by <a href="/wiki/Concatenation" title="Concatenation">concatenation</a>, and is usually the primary method of program design. The above example in <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>:</p>
<p>WHATSON? 04c5d71f-7afd-4110-b5fc-5b8583328bdc</p>
<pre>
g f
</pre>
<p>Which will take whatever was on the stack before, apply g, then f, and leave the result on the stack. See <a href="/wiki/Function_composition#Alternative_notations" title="Function composition">postfix composition notation</a> for the corresponding mathematical notation.</p>
<h2><span class="mw-headline" id="Naming_the_composition_of_functions">Naming the composition of functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Naming the composition of functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Now suppose that the combination of calling f() on the result of g() is frequently useful and we want to name foo() and use it as a function in its own right.</p>
<p>In all languages, we can define a new function implemented by composition. Example in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>:</p>
<p>WHATSON? ef558171-cfd7-4f30-8b22-09f63992003e</p>
<pre class="de1">
<span class="kw4">float</span> foo<span class="br0">(</span><span class="kw4">float</span> x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> f<span class="br0">(</span>g<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>(the long form with intermediates would work as well.) Example in <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>:</p>
<p>WHATSON? 3bd53273-d06e-41cf-a1db-f67afd4021b6</p>
<pre>
   : foo g f ;
</pre>
<p>In languages such as <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>, the only way to create a new function is to define it in the program source, which means that functions can't be composed at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run time</a>.</p>
<h2><span class="mw-headline" id="First-class_composition">First-class composition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: First-class composition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In functional programming languages, function composition can be naturally expressed as a <a href="/wiki/Higher-order_function" title="Higher-order function">higher-order function</a> or operator. In <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, the example given above becomes:</p>
<p>WHATSON? 445bf59b-25d1-4272-8012-71c7e3bc5938</p>
<pre>
foo = f . g
</pre>
<p>using the built-in composition operator (.), which can be read as <i>f after g</i> or <i>g composed with f</i>.</p>
<p>The composition operator itself can be defined in Haskell using a <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda expression</a>:</p>
<p>WHATSON? 597d845f-cba8-46d5-88bd-ca90ab3cfdb9</p>
<pre class="de1">
<span class="br0">(</span><span class="sy0">.</span><span class="br0">)</span> <span class="sy0">::</span> <span class="br0">(</span>b <span class="sy0">-&gt;</span> c<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> c
f <span class="sy0">.</span> g <span class="sy0">=</span> \x <span class="sy0">-&gt;</span> f <span class="br0">(</span>g x<span class="br0">)</span>
</pre>
<p>The first lines describes the type of (.) - it takes a pair of functions and returns a function. Note that Haskell doesn't require specification of the exact input and output types of f and g, only the relations between them (f must accept what g returns). This makes (.) a <a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">polymorphic</a> operator.</p>
<p>Variants of <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>, especially <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>, the <a href="/wiki/Homoiconic" title="Homoiconic" class="mw-redirect">interchangeability of code and data</a> together with the treatment of functions lend themselves extremely well for a recursive definition of a <a href="/wiki/Variadic" title="Variadic">variadic</a> compositional operator.</p>
<p>WHATSON? b9bab28c-cc13-47f7-b7c8-4ddf30039ff1</p>
<pre class="de1">
<span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>compose . fs<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">null?</span> fs<span class="br0">)</span> <span class="br0">(</span><span class="kw1">lambda</span> <span class="br0">(</span>x<span class="br0">)</span> x<span class="br0">)</span> <span class="co1">; if no argument is given, evaluates to the identity function</span>
      <span class="br0">(</span><span class="kw1">lambda</span> <span class="br0">(</span>x<span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span><span class="kw1">car</span> fs<span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span>apply compose <span class="br0">(</span><span class="kw1">cdr</span> fs<span class="br0">)</span><span class="br0">)</span> x<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 
<span class="co1">; examples</span>
<span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>add<span class="sy0">-</span>a<span class="sy0">-</span>bang str<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">string-append</span> str <span class="st0">"!"</span><span class="br0">)</span><span class="br0">)</span>
 
<span class="br0">(</span><span class="kw1">define</span> givebang
  <span class="br0">(</span>compose string<span class="sy0">-&gt;</span>symbol add<span class="sy0">-</span>a<span class="sy0">-</span>bang symbol<span class="sy0">-&gt;</span><span class="kw1">string</span><span class="br0">)</span><span class="br0">)</span>
 
<span class="br0">(</span>givebang 'set<span class="br0">)</span> <span class="co1">; ===&gt; set!</span>
 
<span class="co1">; anonymous composition</span>
<span class="br0">(</span><span class="br0">(</span>compose <span class="kw1">sqrt</span> negate square<span class="br0">)</span> <span class="nu0">5</span><span class="br0">)</span> <span class="co1">; ===&gt; 0+5i</span>
</pre>
<p>In <a href="/wiki/JavaScript" title="JavaScript">JavaScript</a> we can define it as a function which takes two functions f and g, and produces a function:</p>
<p>WHATSON? 7ae51f8d-74f3-4922-9152-bd2237d344b9</p>
<pre class="de1">
<span class="kw1">function</span> o<span class="br0">(</span>f<span class="sy0">,</span> g<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="kw1">function</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> f<span class="br0">(</span>g<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
</pre>
<p>In <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, a way to define the composition for any group of functions, is using <a href="/wiki/Fold_(higher-order_function)" title="Fold (higher-order function)">reduce</a> function (use functools.reduce in Python 3):</p>
<p>WHATSON? 9c18967e-12bb-468c-9762-ece5f7a61275</p>
<pre class="de1">
<span class="kw1">def</span> compose<span class="br0">(</span>*funcs<span class="br0">)</span>:
    <span class="st0">"""Compose a group of functions (f(g(h(..)))) into a single composite func"""</span>
    <span class="kw1">return</span> <span class="kw2">reduce</span><span class="br0">(</span><span class="kw1">lambda</span> f<span class="sy0">,</span> g: <span class="kw1">lambda</span> *args<span class="sy0">,</span> **kwargs: f<span class="br0">(</span>g<span class="br0">(</span>*args<span class="sy0">,</span> **kwargs<span class="br0">)</span><span class="br0">)</span><span class="sy0">,</span> funcs<span class="br0">)</span>
 
<span class="co1"># Example</span>
f <span class="sy0">=</span> <span class="kw1">lambda</span> x: x+<span class="nu0">1</span>
g <span class="sy0">=</span> <span class="kw1">lambda</span> x: x*<span class="nu0">2</span>
h <span class="sy0">=</span> <span class="kw1">lambda</span> x: x-<span class="nu0">3</span>
 
<span class="co1"># Call the function x=10 : ((x-3)*2)+1 = 15</span>
<span class="kw1">print</span> <span class="br0">(</span>compose<span class="br0">(</span>f<span class="sy0">,</span> g<span class="sy0">,</span> h<span class="br0">)</span><span class="br0">)</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span>
</pre>
<h2><span class="mw-headline" id="Research_survey">Research survey</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Research survey">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Notions of composition, including the <a href="/wiki/Principle_of_compositionality" title="Principle of compositionality">principle of compositionality</a> and <a href="/wiki/Composability" title="Composability">composability</a>, are so ubiquitous that numerous strands of research have separately evolved. The following is a sampling of the kind of research in which the notion of composition is central.</p>
<ul>
<li><a href="#CITEREFSteele1994">Steele (1994</a>) directly applied function composition to the assemblage of building blocks known as '<a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">monads</a>' in the <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell programming language</a>.</li>
<li><a href="#CITEREFMeyer1988">Meyer (1988</a>) addressed the <a href="/wiki/Code_reuse" title="Code reuse">software reuse</a> problem in terms of composability.</li>
<li><a href="#CITEREFAbadiLamport1993">Abadi &amp; Lamport (1993</a>) formally defined a proof rule for functional composition that assures a program's safety and liveness.</li>
<li><a href="#CITEREFKracht2001">Kracht (2001</a>) identified a strengthened form of compositionality by placing it into a <a href="/wiki/Computational_semiotics" title="Computational semiotics">semiotic</a> system and applying it to the problem of structural <a href="/wiki/Ambiguity" title="Ambiguity" class="mw-disambig">ambiguity</a> frequently encountered in <a href="/wiki/Computational_linguistics" title="Computational linguistics">computational linguistics</a>.</li>
<li><a href="#CITEREFvan_GelderPort1993">van Gelder &amp; Port (1993</a>) examined the role of compositionality in analog aspects of natural language processing.</li>
<li>According to a review by <a href="#CITEREFGibbons2002">Gibbons (2002</a>), formal treatment of composition underlies validation of component assembly in visual programming languages like IBM's Visual Age for the <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> language.</li>
</ul>
<h2><span class="mw-headline" id="Large-scale_composition">Large-scale composition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Large-scale composition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Whole programs or systems can be treated as functions, which can be readily composed if their inputs and outputs are well-defined<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">pipelines</a> allowing easy composition of <a href="/wiki/Filter_(software)" title="Filter (software)">filters</a> were so successful that it become a <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">design pattern</a> of operating systems.</p>
<p><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative procedures</a> with side effects violate <a href="/wiki/Referential_transparency_(computer_science)" title="Referential transparency (computer science)">referential transparency</a> and therefore are not cleanly composable. However if you consider the "state of the world" before and after running the code as its input and output, you get a clean function. Composition of such functions corresponds to running the procedures one after the other. The <a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">Monads</a> formalism uses this idea to incorporate side effects and I/O into functional languages.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Functional_decomposition" title="Functional decomposition">Functional decomposition</a></li>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Inheritance_semantics" title="Inheritance semantics" class="mw-redirect">Inheritance semantics</a></li>
<li><a href="/wiki/Pipeline_(Unix)" title="Pipeline (Unix)">Pipeline (Unix)</a></li>
<li><a href="/wiki/Iteratee" title="Iteratee">Iteratee</a></li>
<li><a href="/wiki/Principle_of_compositionality" title="Principle of compositionality">Principle of compositionality</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><a href="#CITEREFCox1986">Cox (1986</a>), pp. 15–17</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a href="#CITEREFDeMarcoLister1995">DeMarco &amp; Lister (1995</a>), pp. 133–135.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a href="#CITEREFRaymond2003">Raymond (2003</a>)</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span id="CITEREFAbadiLamport1993" class="citation"><a href="/wiki/Mart%C3%ADn_Abadi" title="Martín Abadi">Abadi, Martín</a>; <a href="/wiki/Leslie_Lamport" title="Leslie Lamport">Lamport, Leslie</a> (1993), <a rel="nofollow" class="external text" href="http://research.microsoft.com/users/lamPort/pubs/abadi-composing.pdf"><i>Composing specifications</i></a>, <i>ACM Transactions on Programming Languages and Systems</i> <b>15</b> (1): 73–132, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F151646.151649">10.1145/151646.151649</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Composing+specifications&amp;rft.au=Abadi%2C+Mart%C3%ADn&amp;rft.aufirst=Mart%C3%ADn&amp;rft.au=Lamport%2C+Leslie&amp;rft.aulast=Abadi&amp;rft.date=1993&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fresearch.microsoft.com%2Fusers%2FlamPort%2Fpubs%2Fabadi-composing.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F151646.151649&amp;rft.issue=1&amp;rft.jtitle=ACM+Transactions+on+Programming+Languages+and+Systems&amp;rft.pages=73-132&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=15" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFCox1986" class="citation"><a href="/wiki/Brad_Cox" title="Brad Cox">Cox, Brad</a> (1986), <i>Object-oriented Programming, an Evolutionary Approach</i>, Reading, MA: Addison-Wesley, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-201-54834-1" title="Special:BookSources/978-0-201-54834-1">978-0-201-54834-1</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.au=Cox%2C+Brad&amp;rft.aufirst=Brad&amp;rft.aulast=Cox&amp;rft.btitle=Object-oriented+Programming%2C+an+Evolutionary+Approach&amp;rft.date=1986&amp;rft.genre=book&amp;rft.isbn=978-0-201-54834-1&amp;rft.place=Reading%2C+MA&amp;rft.pub=Addison-Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFDaume" class="citation">Daume, Hal, III, <a class="external text" href="http://en.wikibooks.org/wiki/Haskell/YAHT"><i>Yet Another Haskell Tutorial</i></a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.au=Daume%2C+Hal%2C+III&amp;rft.aufirst=Hal%2C+III&amp;rft.aulast=Daume&amp;rft.btitle=Yet+Another+Haskell+Tutorial&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fen.wikibooks.org%2Fwiki%2FHaskell%2FYAHT&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFDeMarcoLister1995" class="citation"><a href="/wiki/Tom_DeMarco" title="Tom DeMarco">DeMarco, Tom</a>; Lister, Tim (1995), "Software development: state of the art vs. state of the practice", in <a href="/wiki/Tom_DeMarco" title="Tom DeMarco">DeMarco, Tom</a>, <i>Why Does Software Cost So Much, and other puzzles of the Information Age</i>, New York, NY: Dorset House, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-932633-34-X" title="Special:BookSources/0-932633-34-X">0-932633-34-X</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Why+Does+Software+Cost+So+Much%2C+and+other+puzzles+of+the+Information+Age&amp;rft.au=DeMarco%2C+Tom&amp;rft.aufirst=Tom&amp;rft.aulast=DeMarco&amp;rft.au=Lister%2C+Tim&amp;rft.btitle=Software+development%3A+state+of+the+art+vs.+state+of+the+practice&amp;rft.date=1995&amp;rft.genre=bookitem&amp;rft.isbn=0-932633-34-X&amp;rft.place=New+York%2C+NY&amp;rft.pub=Dorset+House&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFvan_GelderPort1993" class="citation"><a href="/wiki/Tim_van_Gelder" title="Tim van Gelder">van Gelder, Timothy</a>; Port, Robert (1993), "Beyond symbolic: prolegomena to a Kama-Sutra of compositionality", in <a href="/wiki/Vasant_Honavar" title="Vasant Honavar">Honavar, Vasant</a>; <a href="/wiki/Leonard_Uhr" title="Leonard Uhr">Uhr, Leonard</a>, <i>Symbol Processing and Connectionist Models in Artificial Intelligence and Cognition: Steps Toward Integration</i>, Academic Press</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Symbol+Processing+and+Connectionist+Models+in+Artificial+Intelligence+and+Cognition%3A+Steps+Toward+Integration&amp;rft.aufirst=Timothy&amp;rft.aulast=van+Gelder&amp;rft.au=Port%2C+Robert&amp;rft.au=van+Gelder%2C+Timothy&amp;rft.btitle=Beyond+symbolic%3A+prolegomena+to+a+Kama-Sutra+of+compositionality&amp;rft.date=1993&amp;rft.genre=bookitem&amp;rft.pub=Academic+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFGibbons2002" class="citation"><a href="/wiki/Jeremy_Gibbons" title="Jeremy Gibbons">Gibbons, Jeremy</a> (2002), Arbab, Farhad; Talcott, Carolyn, eds., <a rel="nofollow" class="external text" href="http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/superposition-extended.pdf"><i>Proc. 5th International Conference on Coordination Models and Languages</i></a>, Lecture Notes in Computer Science <b>2315</b>, Springer-Verlag, pp. 339–350, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-46000-4%5C_18">10.1007/3-540-46000-4\_18</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.aufirst=Jeremy&amp;rft.au=Gibbons%2C+Jeremy&amp;rft.aulast=Gibbons&amp;rft.btitle=Proc.+5th+International+Conference+on+Coordination+Models+and+Languages&amp;rft.date=2002&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.comlab.ox.ac.uk%2Foucl%2Fwork%2Fjeremy.gibbons%2Fpublications%2Fsuperposition-extended.pdf&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-46000-4%5C_18&amp;rft.pages=339-350&amp;rft.pub=Springer-Verlag&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=2315" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFKornLiberi1974" class="citation">Korn, Henry; Liberi, Albert (1974), <i>An Elementary Approach to Functions</i>, New York, NY: McGraw-Hill, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-07-035339-5" title="Special:BookSources/0-07-035339-5">0-07-035339-5</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.aufirst=Henry&amp;rft.au=Korn%2C+Henry&amp;rft.aulast=Korn&amp;rft.au=Liberi%2C+Albert&amp;rft.btitle=An+Elementary+Approach+to+Functions&amp;rft.date=1974&amp;rft.genre=book&amp;rft.isbn=0-07-035339-5&amp;rft.place=New+York%2C+NY&amp;rft.pub=McGraw-Hill&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFKracht2001" class="citation">Kracht, Marcus (2001), "Strict compositionality and literal movement grammars", <i>Proc. 3rd International Conference on Logical Aspects of Computational Linguistics</i>, Lecture Notes in Computer Science <b>2014</b>, Springer-Verlag, pp. 126–143, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-45738-0_8">10.1007/3-540-45738-0_8</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Proc.+3rd+International+Conference+on+Logical+Aspects+of+Computational+Linguistics&amp;rft.aufirst=Marcus&amp;rft.au=Kracht%2C+Marcus&amp;rft.aulast=Kracht&amp;rft.btitle=Strict+compositionality+and+literal+movement+grammars&amp;rft.date=2001&amp;rft.genre=bookitem&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-45738-0_8&amp;rft.pages=126-143&amp;rft.pub=Springer-Verlag&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=2014" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFMeyer1988" class="citation"><a href="/wiki/Bertrand_Meyer" title="Bertrand Meyer">Meyer, Bertrand</a> (1988), <i>Object-oriented Software Construction</i>, New York, NY: Prentice Hall, pp. 13–15, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-13-629049-3" title="Special:BookSources/0-13-629049-3">0-13-629049-3</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.aufirst=Bertrand&amp;rft.aulast=Meyer&amp;rft.au=Meyer%2C+Bertrand&amp;rft.btitle=Object-oriented+Software+Construction&amp;rft.date=1988&amp;rft.genre=book&amp;rft.isbn=0-13-629049-3&amp;rft.pages=13-15&amp;rft.place=New+York%2C+NY&amp;rft.pub=Prentice+Hall&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFMiller1956" class="citation"><a href="/wiki/George_Armitage_Miller" title="George Armitage Miller">Miller, George A.</a> (1956), <a rel="nofollow" class="external text" href="http://psychclassics.asu.edu/Miller/"><i>The magical number seven, plus or minus two: some limits on our capacity for processing information</i></a>, <i>Psychological Review</i> <b>63</b> (2): 81–97, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1037%2Fh0043158">10.1037/h0043158</a>, <a href="/wiki/PubMed_Identifier" title="PubMed Identifier" class="mw-redirect">PMID</a> <a rel="nofollow" class="external text" href="//www.ncbi.nlm.nih.gov/pubmed/13310704">13310704</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=The+magical+number+seven%2C+plus+or+minus+two%3A+some+limits+on+our+capacity+for+processing+information&amp;rft.aufirst=George+A.&amp;rft.aulast=Miller&amp;rft.au=Miller%2C+George+A.&amp;rft.date=1956&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fpsychclassics.asu.edu%2FMiller%2F&amp;rft_id=info%3Adoi%2F10.1037%2Fh0043158&amp;rft_id=info%3Apmid%2F13310704&amp;rft.issue=2&amp;rft.jtitle=Psychological+Review&amp;rft.pages=81-97&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=63" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFPierceTurner2000" class="citation">Pierce, Benjamin C.; Turner, David N. (2000), <a rel="nofollow" class="external text" href="http://www.cis.upenn.edu/~bcpierce/papers/pict-design.ps">"Pict: A programming language based on the pi-calculus"</a>, <i>Proof, Language, and Interaction: Essays in Honour of Robin Milner</i>, Foundations Of Computing Series, Cambridge, MA: MIT Press, pp. 455–494, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-262-16188-5" title="Special:BookSources/0-262-16188-5">0-262-16188-5</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Proof%2C+Language%2C+and+Interaction%3A+Essays+in+Honour+of+Robin+Milner&amp;rft.aufirst=Benjamin+C.&amp;rft.aulast=Pierce&amp;rft.au=Pierce%2C+Benjamin+C.&amp;rft.au=Turner%2C+David+N.&amp;rft.btitle=Pict%3A+A+programming+language+based+on+the+pi-calculus&amp;rft.date=2000&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cis.upenn.edu%2F~bcpierce%2Fpapers%2Fpict-design.ps&amp;rft.isbn=0-262-16188-5&amp;rft.pages=455-494&amp;rft.place=Cambridge%2C+MA&amp;rft.pub=MIT+Press&amp;rft.series=Foundations+Of+Computing+Series&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFRaymond2003" class="citation"><a href="/wiki/Eric_S._Raymond" title="Eric S. Raymond">Raymond, Eric S.</a> (2003), <a rel="nofollow" class="external text" href="http://catb.org/esr/writings/taoup/html/ch01s06.html#id2877684">"1.6.3 Rule of Composition: Design programs to be connected with other programs"</a>, <i><a href="/wiki/The_Art_of_Unix_Programming" title="The Art of Unix Programming">The Art of Unix Programming</a></i>, Addison-Wesley, pp. 15–16, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-13-142901-7" title="Special:BookSources/978-0-13-142901-7">978-0-13-142901-7</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=The+Art+of+Unix+Programming&amp;rft.aufirst=Eric+S.&amp;rft.aulast=Raymond&amp;rft.au=Raymond%2C+Eric+S.&amp;rft.btitle=1.6.3+Rule+of+Composition%3A+Design+programs+to+be+connected+with+other+programs&amp;rft.date=2003&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fcatb.org%2Fesr%2Fwritings%2Ftaoup%2Fhtml%2Fch01s06.html%23id2877684&amp;rft.isbn=978-0-13-142901-7&amp;rft.pages=15-16&amp;rft.pub=Addison-Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFSteele1994" class="citation"><a href="/wiki/Guy_L._Steele,_Jr." title="Guy L. Steele, Jr.">Steele, Guy L., Jr.</a> (1994), <a rel="nofollow" class="external text" href="http://groups.csail.mit.edu/mac/~dae/related-papers/steele.ps.Z">"Building interpreters by composing monads"</a>, <i><a href="/wiki/Symposium_on_Principles_of_Programming_Languages" title="Symposium on Principles of Programming Languages">Proc. 21st ACM Symposium on Principles of Programming Languages</a></i>, pp. 472–492, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F174675.178068">10.1145/174675.178068</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Proc.+21st+ACM+Symposium+on+Principles+of+Programming+Languages&amp;rft.aufirst=Guy+L.%2C+Jr.&amp;rft.aulast=Steele&amp;rft.au=Steele%2C+Guy+L.%2C+Jr.&amp;rft.btitle=Building+interpreters+by+composing+monads&amp;rft.date=1994&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fgroups.csail.mit.edu%2Fmac%2F~dae%2Frelated-papers%2Fsteele.ps.Z&amp;rft_id=info%3Adoi%2F10.1145%2F174675.178068&amp;rft.pages=472-492&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Function composition (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>function composition</b> (not to be confused with <a href="/wiki/Object_composition" title="Object composition">object composition</a>) is an act or mechanism to combine simple <a href="/wiki/Subroutine" title="Subroutine">functions</a> to build more complicated ones. Like the usual <a href="/wiki/Function_composition" title="Function composition">composition of functions</a> in <a href="/wiki/Mathematics" title="Mathematics">mathematics</a>, the result of each function is passed as the argument of the next, and the result of the last one is the result of the whole.</p>
<p>Programmers frequently apply functions to results of other functions, and almost all programming languages allow it. In some cases, the composition of functions is interesting as a function in its own right, to be used later. Such a function can always be defined but languages with <a href="/wiki/First-class_functions" title="First-class functions" class="mw-redirect">first-class functions</a> make it easier.</p>
<p>The ability to easily compose functions encourages <a href="/wiki/Code_refactoring" title="Code refactoring">factoring</a> (breaking apart) <a href="/wiki/Subroutine" title="Subroutine">functions</a> for maintainability and <a href="/wiki/Code_reuse" title="Code reuse">code reuse</a>. More generally, big systems might be built by composing whole programs.</p>
<p>Narrowly speaking, function composition applies to functions that operate on a finite amount of data, each step sequentially processing it before handing it to the next. Functions that operate on potentially infinite data (a <a href="/wiki/Stream_(computing)" title="Stream (computing)">stream</a> or other <a href="/wiki/Codata" title="Codata" class="mw-redirect">codata</a>), known as <a href="/wiki/Filter_(software)" title="Filter (software)">filters</a>, and are instead connected in a <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">pipeline</a>, which is analogous to function composition and can execute <a href="/wiki/Concurrent_computing" title="Concurrent computing">concurrently</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Composing_function_calls"><span class="tocnumber">1</span> <span class="toctext">Composing function calls</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Naming_the_composition_of_functions"><span class="tocnumber">2</span> <span class="toctext">Naming the composition of functions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#First-class_composition"><span class="tocnumber">3</span> <span class="toctext">First-class composition</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Research_survey"><span class="tocnumber">4</span> <span class="toctext">Research survey</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Large-scale_composition"><span class="tocnumber">5</span> <span class="toctext">Large-scale composition</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Notes"><span class="tocnumber">7</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Composing_function_calls">Composing function calls</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Composing function calls">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For example, suppose we have two <a href="/wiki/Function_(mathematics)" title="Function (mathematics)">functions</a> <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png"> and <img class="mwe-math-fallback-image-inline tex" alt="g" src="//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png">, as in <img class="mwe-math-fallback-image-inline tex" alt="z=f(y)" src="//upload.wikimedia.org/math/3/e/f/3ef3cadf29d48026f675ae9b1c31cc7b.png"> and <img class="mwe-math-fallback-image-inline tex" alt="y=g(x)" src="//upload.wikimedia.org/math/d/1/3/d13f453d5a25ba83fd2f3ecc74880538.png">. Composing them means we first compute <img class="mwe-math-fallback-image-inline tex" alt="y=g(x)" src="//upload.wikimedia.org/math/d/1/3/d13f453d5a25ba83fd2f3ecc74880538.png">, and then use <img class="mwe-math-fallback-image-inline tex" alt="y" src="//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png"> to compute <img class="mwe-math-fallback-image-inline tex" alt="z=f(y)" src="//upload.wikimedia.org/math/3/e/f/3ef3cadf29d48026f675ae9b1c31cc7b.png">. Here is the example in the <a href="/wiki/C_(programming_language)" title="C (programming language)">C language</a>:</p>
<p>WHATSON? 8b877abd-0704-4da0-8c93-7a20a2249b8e</p>
<pre class="de1">
<span class="kw4">float</span> x<span class="sy0">,</span> y<span class="sy0">,</span> z<span class="sy0">;</span>
<span class="co1">// ...</span>
y <span class="sy0">=</span> g<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
z <span class="sy0">=</span> f<span class="br0">(</span>y<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The steps can be combined if we don't give a name to the intermediate result:</p>
<p>WHATSON? 348d07f2-87ad-492b-8aae-0301896bde84</p>
<pre class="de1">
z <span class="sy0">=</span> f<span class="br0">(</span>g<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>Despite differences in length, these two implementations compute the same result. The second implementation requires only one line of code and is colloquially referred to as a "highly composed" form. Readability and hence maintainability is one advantage of highly composed forms, since they require fewer lines of code, minimizing a program's "surface area".<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> DeMarco and Lister empirically verify an inverse relationship between surface area and maintainability.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> On the other hand, it may be possible to overuse highly composed forms. A nesting of too many functions may have the opposite effect, making the code less maintainable.</p>
<p>In a <a href="/wiki/Stack-based_language" title="Stack-based language" class="mw-redirect">stack-based language</a>, functional composition is even more natural: it is performed by <a href="/wiki/Concatenation" title="Concatenation">concatenation</a>, and is usually the primary method of program design. The above example in <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>:</p>
<p>WHATSON? ae6ebefe-2008-418e-887f-714bf737f86e</p>
<pre>
g f
</pre>
<p>Which will take whatever was on the stack before, apply g, then f, and leave the result on the stack. See <a href="/wiki/Function_composition#Alternative_notations" title="Function composition">postfix composition notation</a> for the corresponding mathematical notation.</p>
<h2><span class="mw-headline" id="Naming_the_composition_of_functions">Naming the composition of functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Naming the composition of functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Now suppose that the combination of calling f() on the result of g() is frequently useful and we want to name foo() and use it as a function in its own right.</p>
<p>In all languages, we can define a new function implemented by composition. Example in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>:</p>
<p>WHATSON? 03700f3b-e47a-49c7-a855-db2cb56b39af</p>
<pre class="de1">
<span class="kw4">float</span> foo<span class="br0">(</span><span class="kw4">float</span> x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> f<span class="br0">(</span>g<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>(the long form with intermediates would work as well.) Example in <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>:</p>
<p>WHATSON? dff30fdc-f0df-48dd-ad34-7e25a792e994</p>
<pre>
   : foo g f ;
</pre>
<p>In languages such as <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>, the only way to create a new function is to define it in the program source, which means that functions can't be composed at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run time</a>.</p>
<h2><span class="mw-headline" id="First-class_composition">First-class composition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: First-class composition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In functional programming languages, function composition can be naturally expressed as a <a href="/wiki/Higher-order_function" title="Higher-order function">higher-order function</a> or operator. In <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, the example given above becomes:</p>
<p>WHATSON? e4e4c171-2a6b-4da5-ae4b-4a04cb8a74e6</p>
<pre>
foo = f . g
</pre>
<p>using the built-in composition operator (.), which can be read as <i>f after g</i> or <i>g composed with f</i>.</p>
<p>The composition operator itself can be defined in Haskell using a <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda expression</a>:</p>
<p>WHATSON? cff6a350-9d07-4a03-8b4f-187a692a2bcd</p>
<pre class="de1">
<span class="br0">(</span><span class="sy0">.</span><span class="br0">)</span> <span class="sy0">::</span> <span class="br0">(</span>b <span class="sy0">-&gt;</span> c<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> c
f <span class="sy0">.</span> g <span class="sy0">=</span> \x <span class="sy0">-&gt;</span> f <span class="br0">(</span>g x<span class="br0">)</span>
</pre>
<p>The first lines describes the type of (.) - it takes a pair of functions and returns a function. Note that Haskell doesn't require specification of the exact input and output types of f and g, only the relations between them (f must accept what g returns). This makes (.) a <a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">polymorphic</a> operator.</p>
<p>Variants of <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>, especially <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>, the <a href="/wiki/Homoiconic" title="Homoiconic" class="mw-redirect">interchangeability of code and data</a> together with the treatment of functions lend themselves extremely well for a recursive definition of a <a href="/wiki/Variadic" title="Variadic">variadic</a> compositional operator.</p>
<p>WHATSON? 5d351827-86bd-41e3-93a5-6aa34a30f886</p>
<pre class="de1">
<span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>compose . fs<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">null?</span> fs<span class="br0">)</span> <span class="br0">(</span><span class="kw1">lambda</span> <span class="br0">(</span>x<span class="br0">)</span> x<span class="br0">)</span> <span class="co1">; if no argument is given, evaluates to the identity function</span>
      <span class="br0">(</span><span class="kw1">lambda</span> <span class="br0">(</span>x<span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span><span class="kw1">car</span> fs<span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span>apply compose <span class="br0">(</span><span class="kw1">cdr</span> fs<span class="br0">)</span><span class="br0">)</span> x<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 
<span class="co1">; examples</span>
<span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>add<span class="sy0">-</span>a<span class="sy0">-</span>bang str<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">string-append</span> str <span class="st0">"!"</span><span class="br0">)</span><span class="br0">)</span>
 
<span class="br0">(</span><span class="kw1">define</span> givebang
  <span class="br0">(</span>compose string<span class="sy0">-&gt;</span>symbol add<span class="sy0">-</span>a<span class="sy0">-</span>bang symbol<span class="sy0">-&gt;</span><span class="kw1">string</span><span class="br0">)</span><span class="br0">)</span>
 
<span class="br0">(</span>givebang 'set<span class="br0">)</span> <span class="co1">; ===&gt; set!</span>
 
<span class="co1">; anonymous composition</span>
<span class="br0">(</span><span class="br0">(</span>compose <span class="kw1">sqrt</span> negate square<span class="br0">)</span> <span class="nu0">5</span><span class="br0">)</span> <span class="co1">; ===&gt; 0+5i</span>
</pre>
<p>In <a href="/wiki/JavaScript" title="JavaScript">JavaScript</a> we can define it as a function which takes two functions f and g, and produces a function:</p>
<p>WHATSON? acecea9e-e944-4445-9051-dde85111043b</p>
<pre class="de1">
<span class="kw1">function</span> o<span class="br0">(</span>f<span class="sy0">,</span> g<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="kw1">function</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> f<span class="br0">(</span>g<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
</pre>
<p>In <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, a way to define the composition for any group of functions, is using <a href="/wiki/Fold_(higher-order_function)" title="Fold (higher-order function)">reduce</a> function (use functools.reduce in Python 3):</p>
<p>WHATSON? 8167148b-4279-4b86-964a-3d9a11f9488b</p>
<pre class="de1">
<span class="kw1">def</span> compose<span class="br0">(</span>*funcs<span class="br0">)</span>:
    <span class="st0">"""Compose a group of functions (f(g(h(..)))) into a single composite func"""</span>
    <span class="kw1">return</span> <span class="kw2">reduce</span><span class="br0">(</span><span class="kw1">lambda</span> f<span class="sy0">,</span> g: <span class="kw1">lambda</span> *args<span class="sy0">,</span> **kwargs: f<span class="br0">(</span>g<span class="br0">(</span>*args<span class="sy0">,</span> **kwargs<span class="br0">)</span><span class="br0">)</span><span class="sy0">,</span> funcs<span class="br0">)</span>
 
<span class="co1"># Example</span>
f <span class="sy0">=</span> <span class="kw1">lambda</span> x: x+<span class="nu0">1</span>
g <span class="sy0">=</span> <span class="kw1">lambda</span> x: x*<span class="nu0">2</span>
h <span class="sy0">=</span> <span class="kw1">lambda</span> x: x-<span class="nu0">3</span>
 
<span class="co1"># Call the function x=10 : ((x-3)*2)+1 = 15</span>
<span class="kw1">print</span> <span class="br0">(</span>compose<span class="br0">(</span>f<span class="sy0">,</span> g<span class="sy0">,</span> h<span class="br0">)</span><span class="br0">)</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span>
</pre>
<h2><span class="mw-headline" id="Research_survey">Research survey</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Research survey">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Notions of composition, including the <a href="/wiki/Principle_of_compositionality" title="Principle of compositionality">principle of compositionality</a> and <a href="/wiki/Composability" title="Composability">composability</a>, are so ubiquitous that numerous strands of research have separately evolved. The following is a sampling of the kind of research in which the notion of composition is central.</p>
<ul>
<li><a href="#CITEREFSteele1994">Steele (1994</a>) directly applied function composition to the assemblage of building blocks known as '<a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">monads</a>' in the <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell programming language</a>.</li>
<li><a href="#CITEREFMeyer1988">Meyer (1988</a>) addressed the <a href="/wiki/Code_reuse" title="Code reuse">software reuse</a> problem in terms of composability.</li>
<li><a href="#CITEREFAbadiLamport1993">Abadi &amp; Lamport (1993</a>) formally defined a proof rule for functional composition that assures a program's safety and liveness.</li>
<li><a href="#CITEREFKracht2001">Kracht (2001</a>) identified a strengthened form of compositionality by placing it into a <a href="/wiki/Computational_semiotics" title="Computational semiotics">semiotic</a> system and applying it to the problem of structural <a href="/wiki/Ambiguity" title="Ambiguity" class="mw-disambig">ambiguity</a> frequently encountered in <a href="/wiki/Computational_linguistics" title="Computational linguistics">computational linguistics</a>.</li>
<li><a href="#CITEREFvan_GelderPort1993">van Gelder &amp; Port (1993</a>) examined the role of compositionality in analog aspects of natural language processing.</li>
<li>According to a review by <a href="#CITEREFGibbons2002">Gibbons (2002</a>), formal treatment of composition underlies validation of component assembly in visual programming languages like IBM's Visual Age for the <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> language.</li>
</ul>
<h2><span class="mw-headline" id="Large-scale_composition">Large-scale composition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Large-scale composition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Whole programs or systems can be treated as functions, which can be readily composed if their inputs and outputs are well-defined<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">pipelines</a> allowing easy composition of <a href="/wiki/Filter_(software)" title="Filter (software)">filters</a> were so successful that it become a <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">design pattern</a> of operating systems.</p>
<p><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative procedures</a> with side effects violate <a href="/wiki/Referential_transparency_(computer_science)" title="Referential transparency (computer science)">referential transparency</a> and therefore are not cleanly composable. However if you consider the "state of the world" before and after running the code as its input and output, you get a clean function. Composition of such functions corresponds to running the procedures one after the other. The <a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">Monads</a> formalism uses this idea to incorporate side effects and I/O into functional languages.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Functional_decomposition" title="Functional decomposition">Functional decomposition</a></li>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Inheritance_semantics" title="Inheritance semantics" class="mw-redirect">Inheritance semantics</a></li>
<li><a href="/wiki/Pipeline_(Unix)" title="Pipeline (Unix)">Pipeline (Unix)</a></li>
<li><a href="/wiki/Iteratee" title="Iteratee">Iteratee</a></li>
<li><a href="/wiki/Principle_of_compositionality" title="Principle of compositionality">Principle of compositionality</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><a href="#CITEREFCox1986">Cox (1986</a>), pp. 15–17</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a href="#CITEREFDeMarcoLister1995">DeMarco &amp; Lister (1995</a>), pp. 133–135.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a href="#CITEREFRaymond2003">Raymond (2003</a>)</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Function_composition_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span id="CITEREFAbadiLamport1993" class="citation"><a href="/wiki/Mart%C3%ADn_Abadi" title="Martín Abadi">Abadi, Martín</a>; <a href="/wiki/Leslie_Lamport" title="Leslie Lamport">Lamport, Leslie</a> (1993), <a rel="nofollow" class="external text" href="http://research.microsoft.com/users/lamPort/pubs/abadi-composing.pdf"><i>Composing specifications</i></a>, <i>ACM Transactions on Programming Languages and Systems</i> <b>15</b> (1): 73–132, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F151646.151649">10.1145/151646.151649</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Composing+specifications&amp;rft.au=Abadi%2C+Mart%C3%ADn&amp;rft.aufirst=Mart%C3%ADn&amp;rft.au=Lamport%2C+Leslie&amp;rft.aulast=Abadi&amp;rft.date=1993&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fresearch.microsoft.com%2Fusers%2FlamPort%2Fpubs%2Fabadi-composing.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F151646.151649&amp;rft.issue=1&amp;rft.jtitle=ACM+Transactions+on+Programming+Languages+and+Systems&amp;rft.pages=73-132&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=15" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFCox1986" class="citation"><a href="/wiki/Brad_Cox" title="Brad Cox">Cox, Brad</a> (1986), <i>Object-oriented Programming, an Evolutionary Approach</i>, Reading, MA: Addison-Wesley, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-201-54834-1" title="Special:BookSources/978-0-201-54834-1">978-0-201-54834-1</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.au=Cox%2C+Brad&amp;rft.aufirst=Brad&amp;rft.aulast=Cox&amp;rft.btitle=Object-oriented+Programming%2C+an+Evolutionary+Approach&amp;rft.date=1986&amp;rft.genre=book&amp;rft.isbn=978-0-201-54834-1&amp;rft.place=Reading%2C+MA&amp;rft.pub=Addison-Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFDaume" class="citation">Daume, Hal, III, <a class="external text" href="http://en.wikibooks.org/wiki/Haskell/YAHT"><i>Yet Another Haskell Tutorial</i></a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.au=Daume%2C+Hal%2C+III&amp;rft.aufirst=Hal%2C+III&amp;rft.aulast=Daume&amp;rft.btitle=Yet+Another+Haskell+Tutorial&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fen.wikibooks.org%2Fwiki%2FHaskell%2FYAHT&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFDeMarcoLister1995" class="citation"><a href="/wiki/Tom_DeMarco" title="Tom DeMarco">DeMarco, Tom</a>; Lister, Tim (1995), "Software development: state of the art vs. state of the practice", in <a href="/wiki/Tom_DeMarco" title="Tom DeMarco">DeMarco, Tom</a>, <i>Why Does Software Cost So Much, and other puzzles of the Information Age</i>, New York, NY: Dorset House, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-932633-34-X" title="Special:BookSources/0-932633-34-X">0-932633-34-X</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Why+Does+Software+Cost+So+Much%2C+and+other+puzzles+of+the+Information+Age&amp;rft.au=DeMarco%2C+Tom&amp;rft.aufirst=Tom&amp;rft.aulast=DeMarco&amp;rft.au=Lister%2C+Tim&amp;rft.btitle=Software+development%3A+state+of+the+art+vs.+state+of+the+practice&amp;rft.date=1995&amp;rft.genre=bookitem&amp;rft.isbn=0-932633-34-X&amp;rft.place=New+York%2C+NY&amp;rft.pub=Dorset+House&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFvan_GelderPort1993" class="citation"><a href="/wiki/Tim_van_Gelder" title="Tim van Gelder">van Gelder, Timothy</a>; Port, Robert (1993), "Beyond symbolic: prolegomena to a Kama-Sutra of compositionality", in <a href="/wiki/Vasant_Honavar" title="Vasant Honavar">Honavar, Vasant</a>; <a href="/wiki/Leonard_Uhr" title="Leonard Uhr">Uhr, Leonard</a>, <i>Symbol Processing and Connectionist Models in Artificial Intelligence and Cognition: Steps Toward Integration</i>, Academic Press</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Symbol+Processing+and+Connectionist+Models+in+Artificial+Intelligence+and+Cognition%3A+Steps+Toward+Integration&amp;rft.aufirst=Timothy&amp;rft.aulast=van+Gelder&amp;rft.au=Port%2C+Robert&amp;rft.au=van+Gelder%2C+Timothy&amp;rft.btitle=Beyond+symbolic%3A+prolegomena+to+a+Kama-Sutra+of+compositionality&amp;rft.date=1993&amp;rft.genre=bookitem&amp;rft.pub=Academic+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFGibbons2002" class="citation"><a href="/wiki/Jeremy_Gibbons" title="Jeremy Gibbons">Gibbons, Jeremy</a> (2002), Arbab, Farhad; Talcott, Carolyn, eds., <a rel="nofollow" class="external text" href="http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/superposition-extended.pdf"><i>Proc. 5th International Conference on Coordination Models and Languages</i></a>, Lecture Notes in Computer Science <b>2315</b>, Springer-Verlag, pp. 339–350, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-46000-4%5C_18">10.1007/3-540-46000-4\_18</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.aufirst=Jeremy&amp;rft.au=Gibbons%2C+Jeremy&amp;rft.aulast=Gibbons&amp;rft.btitle=Proc.+5th+International+Conference+on+Coordination+Models+and+Languages&amp;rft.date=2002&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.comlab.ox.ac.uk%2Foucl%2Fwork%2Fjeremy.gibbons%2Fpublications%2Fsuperposition-extended.pdf&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-46000-4%5C_18&amp;rft.pages=339-350&amp;rft.pub=Springer-Verlag&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=2315" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFKornLiberi1974" class="citation">Korn, Henry; Liberi, Albert (1974), <i>An Elementary Approach to Functions</i>, New York, NY: McGraw-Hill, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-07-035339-5" title="Special:BookSources/0-07-035339-5">0-07-035339-5</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.aufirst=Henry&amp;rft.au=Korn%2C+Henry&amp;rft.aulast=Korn&amp;rft.au=Liberi%2C+Albert&amp;rft.btitle=An+Elementary+Approach+to+Functions&amp;rft.date=1974&amp;rft.genre=book&amp;rft.isbn=0-07-035339-5&amp;rft.place=New+York%2C+NY&amp;rft.pub=McGraw-Hill&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFKracht2001" class="citation">Kracht, Marcus (2001), "Strict compositionality and literal movement grammars", <i>Proc. 3rd International Conference on Logical Aspects of Computational Linguistics</i>, Lecture Notes in Computer Science <b>2014</b>, Springer-Verlag, pp. 126–143, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-45738-0_8">10.1007/3-540-45738-0_8</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Proc.+3rd+International+Conference+on+Logical+Aspects+of+Computational+Linguistics&amp;rft.aufirst=Marcus&amp;rft.au=Kracht%2C+Marcus&amp;rft.aulast=Kracht&amp;rft.btitle=Strict+compositionality+and+literal+movement+grammars&amp;rft.date=2001&amp;rft.genre=bookitem&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-45738-0_8&amp;rft.pages=126-143&amp;rft.pub=Springer-Verlag&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=2014" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFMeyer1988" class="citation"><a href="/wiki/Bertrand_Meyer" title="Bertrand Meyer">Meyer, Bertrand</a> (1988), <i>Object-oriented Software Construction</i>, New York, NY: Prentice Hall, pp. 13–15, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-13-629049-3" title="Special:BookSources/0-13-629049-3">0-13-629049-3</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.aufirst=Bertrand&amp;rft.aulast=Meyer&amp;rft.au=Meyer%2C+Bertrand&amp;rft.btitle=Object-oriented+Software+Construction&amp;rft.date=1988&amp;rft.genre=book&amp;rft.isbn=0-13-629049-3&amp;rft.pages=13-15&amp;rft.place=New+York%2C+NY&amp;rft.pub=Prentice+Hall&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFMiller1956" class="citation"><a href="/wiki/George_Armitage_Miller" title="George Armitage Miller">Miller, George A.</a> (1956), <a rel="nofollow" class="external text" href="http://psychclassics.asu.edu/Miller/"><i>The magical number seven, plus or minus two: some limits on our capacity for processing information</i></a>, <i>Psychological Review</i> <b>63</b> (2): 81–97, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1037%2Fh0043158">10.1037/h0043158</a>, <a href="/wiki/PubMed_Identifier" title="PubMed Identifier" class="mw-redirect">PMID</a> <a rel="nofollow" class="external text" href="//www.ncbi.nlm.nih.gov/pubmed/13310704">13310704</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=The+magical+number+seven%2C+plus+or+minus+two%3A+some+limits+on+our+capacity+for+processing+information&amp;rft.aufirst=George+A.&amp;rft.aulast=Miller&amp;rft.au=Miller%2C+George+A.&amp;rft.date=1956&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fpsychclassics.asu.edu%2FMiller%2F&amp;rft_id=info%3Adoi%2F10.1037%2Fh0043158&amp;rft_id=info%3Apmid%2F13310704&amp;rft.issue=2&amp;rft.jtitle=Psychological+Review&amp;rft.pages=81-97&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=63" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFPierceTurner2000" class="citation">Pierce, Benjamin C.; Turner, David N. (2000), <a rel="nofollow" class="external text" href="http://www.cis.upenn.edu/~bcpierce/papers/pict-design.ps">"Pict: A programming language based on the pi-calculus"</a>, <i>Proof, Language, and Interaction: Essays in Honour of Robin Milner</i>, Foundations Of Computing Series, Cambridge, MA: MIT Press, pp. 455–494, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-262-16188-5" title="Special:BookSources/0-262-16188-5">0-262-16188-5</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Proof%2C+Language%2C+and+Interaction%3A+Essays+in+Honour+of+Robin+Milner&amp;rft.aufirst=Benjamin+C.&amp;rft.aulast=Pierce&amp;rft.au=Pierce%2C+Benjamin+C.&amp;rft.au=Turner%2C+David+N.&amp;rft.btitle=Pict%3A+A+programming+language+based+on+the+pi-calculus&amp;rft.date=2000&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cis.upenn.edu%2F~bcpierce%2Fpapers%2Fpict-design.ps&amp;rft.isbn=0-262-16188-5&amp;rft.pages=455-494&amp;rft.place=Cambridge%2C+MA&amp;rft.pub=MIT+Press&amp;rft.series=Foundations+Of+Computing+Series&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFRaymond2003" class="citation"><a href="/wiki/Eric_S._Raymond" title="Eric S. Raymond">Raymond, Eric S.</a> (2003), <a rel="nofollow" class="external text" href="http://catb.org/esr/writings/taoup/html/ch01s06.html#id2877684">"1.6.3 Rule of Composition: Design programs to be connected with other programs"</a>, <i><a href="/wiki/The_Art_of_Unix_Programming" title="The Art of Unix Programming">The Art of Unix Programming</a></i>, Addison-Wesley, pp. 15–16, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-13-142901-7" title="Special:BookSources/978-0-13-142901-7">978-0-13-142901-7</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=The+Art+of+Unix+Programming&amp;rft.aufirst=Eric+S.&amp;rft.aulast=Raymond&amp;rft.au=Raymond%2C+Eric+S.&amp;rft.btitle=1.6.3+Rule+of+Composition%3A+Design+programs+to+be+connected+with+other+programs&amp;rft.date=2003&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fcatb.org%2Fesr%2Fwritings%2Ftaoup%2Fhtml%2Fch01s06.html%23id2877684&amp;rft.isbn=978-0-13-142901-7&amp;rft.pages=15-16&amp;rft.pub=Addison-Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
<li><span id="CITEREFSteele1994" class="citation"><a href="/wiki/Guy_L._Steele,_Jr." title="Guy L. Steele, Jr.">Steele, Guy L., Jr.</a> (1994), <a rel="nofollow" class="external text" href="http://groups.csail.mit.edu/mac/~dae/related-papers/steele.ps.Z">"Building interpreters by composing monads"</a>, <i><a href="/wiki/Symposium_on_Principles_of_Programming_Languages" title="Symposium on Principles of Programming Languages">Proc. 21st ACM Symposium on Principles of Programming Languages</a></i>, pp. 472–492, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F174675.178068">10.1145/174675.178068</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFunction+composition+%28computer+science%29&amp;rft.atitle=Proc.+21st+ACM+Symposium+on+Principles+of+Programming+Languages&amp;rft.aufirst=Guy+L.%2C+Jr.&amp;rft.aulast=Steele&amp;rft.au=Steele%2C+Guy+L.%2C+Jr.&amp;rft.btitle=Building+interpreters+by+composing+monads&amp;rft.date=1994&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fgroups.csail.mit.edu%2Fmac%2F~dae%2Frelated-papers%2Fsteele.ps.Z&amp;rft_id=info%3Adoi%2F10.1145%2F174675.178068&amp;rft.pages=472-492&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>.</li>
</ul>
