<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Side effect (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <a href="/wiki/Subroutine" title="Subroutine">function</a> or <a href="/wiki/Expression_(programming)" title="Expression (programming)" class="mw-redirect">expression</a> is said to have a <b>side effect</b> if, in addition to returning a value, it also modifies some <a href="/wiki/State_(computer_science)" title="State (computer science)">state</a> or has an <i>observable</i> interaction with calling functions or the outside world. For example, a function might modify a <a href="/wiki/Global_variable" title="Global variable">global variable</a> or <a href="/wiki/Static_variable" title="Static variable">static variable</a>, modify one of its arguments, raise an exception, write data to a display or file, read data, or call other side-effecting functions. In the presence of side effects, a program's behavior may depend on history; that is, the order of evaluation matters. Understanding and debugging a function with side effects requires knowledge about the context and its possible histories.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p>Side effects are the most common way that a program interacts with the outside world (people, filesystems, other computers on networks). But the degree to which side effects are used depends on the programming paradigm. <a href="/wiki/Imperative_programming" title="Imperative programming">Imperative programming</a> is known for its frequent utilization of side effects. In <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, side effects are rarely used. Functional languages such as <a href="/wiki/Standard_ML" title="Standard ML">Standard ML</a>, <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a> and <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> do not restrict side effects, but it is customary for programmers to avoid them.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> The functional language <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> expresses side effects such as <a href="/wiki/Input/output" title="Input/output">I/O</a> and other stateful computations using <a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">monadic</a> actions.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p><a href="/wiki/Assembly_language" title="Assembly language">Assembly language</a> programmers must be aware of <i>hidden</i> side effects — instructions that modify parts of the processor state which are not mentioned in the instruction's mnemonic. A classic example of a hidden side effect is an arithmetic instruction that implicitly modifies <a href="/wiki/Status_register" title="Status register">condition codes</a> (a hidden side effect) while it explicitly modifies a <a href="/wiki/Processor_register" title="Processor register">register</a> (the overt effect). One potential drawback of an <a href="/wiki/Instruction_set" title="Instruction set">instruction set</a> with hidden side effects is that, if many instructions have side effects on a single piece of state, like condition codes, then the logic required to update that state sequentially may become a performance bottleneck. The problem is particularly acute on some processors designed with <a href="/wiki/Instruction_pipeline" title="Instruction pipeline">pipelining</a> (since 1990) or with <a href="/wiki/Out-of-order_execution" title="Out-of-order execution">out-of-order execution</a>. Such a processor may require additional control circuitry to detect hidden side effects and stall the pipeline if the next instruction depends on the results of those effects.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Referential_transparency"><span class="tocnumber">1</span> <span class="toctext">Referential transparency</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Temporal_side_effects"><span class="tocnumber">2</span> <span class="toctext">Temporal side effects</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Idempotence"><span class="tocnumber">3</span> <span class="toctext">Idempotence</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Example"><span class="tocnumber">4</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Referential_transparency">Referential transparency</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Referential transparency">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Absence of side effects is a necessary, but not sufficient, condition for referential transparency. Referential transparency means that an expression (such as a function call) can be replaced with its value; this requires that the expression has no side effects and is <a href="/wiki/Pure_function" title="Pure function">pure</a> (always returns the same results on the same input).</p>
<h2><span class="mw-headline" id="Temporal_side_effects">Temporal side effects</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Temporal side effects">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Side effects caused by the time taken for an operation to execute are usually ignored when discussing side effects and referential transparency. There are some cases, such as with hardware timing or testing, where operations are inserted specifically for their temporal side effects e.g. <code>Sleep(5000)</code> or <code>for(int i=0; i &lt; 10000; i++){}</code>. These instructions do not change state other than taking an amount of time to complete.</p>
<h2><span class="mw-headline" id="Idempotence">Idempotence</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Idempotence">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A function with side effects is said to be idempotent under sequential composition (<code>f; f</code>) if, when called with the same argument twice, the second call returns the same value and has no side effects which can distinguish it from the first call. For instance, consider:</p>
<p>WHATSON? 08b0cc38-8f7b-4bde-8cda-c39a279b98ba</p>
<pre class="de1">
x <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw1">def</span> xSetter<span class="br0">(</span>n<span class="br0">)</span>:
  <span class="kw1">global</span> x
  x <span class="sy0">=</span> n
xSetter<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span>
xSetter<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span>
</pre>
<p>Here, <code>xSetter</code> is idempotent because the second call to <code>xSetter</code> (with the same argument) returns the same value and does not change the visible program state. Note that this is distinct from <a href="/wiki/Idempotence" title="Idempotence">idempotence</a> under function composition (<code>f ∘ f</code>): <code>xSetter</code> is not idempotent under function composition because <code>xSetter(5)</code> and <code>xSetter(xSetter(5))</code> set <code>x</code> to different values where return value of xSetter is x; in this example return value is always 5.</p>
<p>Functions which are side effect free are always idempotent under sequential composition.</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>One common demonstration of side effect behavior is that of the <a href="/wiki/Assignment_operator" title="Assignment operator" class="mw-redirect">assignment operator</a> in <a href="/wiki/C%2B%2B" title="C++">C++</a>. For example, assignment returns the right operand and has the side effect of assigning that value to a variable. This allows for syntactically clean multiple assignment:</p>
<p>WHATSON? e72ae2fd-0201-4ad3-93e8-d8a9af03a666</p>
<pre class="de1">
<span class="kw4">int</span> i, j<span class="sy4">;</span>
i <span class="sy1">=</span> j <span class="sy1">=</span> <span class="nu0">3</span><span class="sy4">;</span>
</pre>
<p>Because the operator <a href="/wiki/Operator_associativity#Right-associativity_of_assignment_operators" title="Operator associativity">right associates</a>, this equates to</p>
<p>WHATSON? 05f0a335-3b5b-4884-8a6b-2aa25dd43b7d</p>
<pre class="de1">
<span class="kw4">int</span> i, j<span class="sy4">;</span>
i <span class="sy1">=</span> <span class="br0">(</span>j <span class="sy1">=</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//j = 3 returns 3, which then gets assigned to i</span>
</pre>
<p>Where the result of assigning 3 into "j" then gets assigned into "i". This presents a potential hangup for novice programmers who may confuse</p>
<p>WHATSON? fab9e3d4-80b9-4318-bfaa-22d81fc32f5b</p>
<pre class="de1">
<span class="kw1">while</span> <span class="br0">(</span>b <span class="sy1">==</span> <span class="nu0">10</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">//Tests if b evaluates to 10</span>
</pre>
<p>with</p>
<p>WHATSON? 8e6e1c11-5c8f-4b94-ae03-95a2252aa42b</p>
<pre class="de1">
<span class="co1">// The assignment function returns 10</span>
<span class="co1">// which automatically casts to "true"</span>
<span class="co1">// so the loop conditional always evaluates to true</span>
<span class="kw1">while</span> <span class="br0">(</span>b <span class="sy1">=</span> <span class="nu0">10</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Sequence_point" title="Sequence point">Sequence point</a></li>
<li><a href="/wiki/Action_at_a_distance_(computer_science)" title="Action at a distance (computer science)" class="mw-redirect">Action at a distance (computer science)</a></li>
<li><a href="/wiki/Don%27t-care_term" title="Don't-care term">Don't-care term</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">“Research Topics in Functional Programming” ed. D. Turner, Addison-Wesley, 1990, pp 17–42. Retrieved from: <span id="CITEREFHughes" class="citation">Hughes, John, <a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf"><i>Why Functional Programming Matters</i></a> (PDF)</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ASide+effect+%28computer+science%29&amp;rft.aufirst=John&amp;rft.au=Hughes%2C+John&amp;rft.aulast=Hughes&amp;rft.btitle=Why+Functional+Programming+Matters&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.utexas.edu%2F~shmat%2Fcourses%2Fcs345%2Fwhyfp.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span id="CITEREFCollberg" class="citation">Collberg, <a rel="nofollow" class="external text" href="http://www.cs.arizona.edu/~collberg/Teaching/520/2005/Html/Html-24/index.html"><i>CSc 520 Principles of Programming Languages</i></a>, Department of Computer Science, University of Arizona</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ASide+effect+%28computer+science%29&amp;rft.au=Collberg&amp;rft.aulast=Collberg&amp;rft.btitle=CSc+520+Principles+of+Programming+Languages&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.arizona.edu%2F~collberg%2FTeaching%2F520%2F2005%2FHtml%2FHtml-24%2Findex.html&amp;rft.pub=Department+of+Computer+Science%2C+University+of+Arizona&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.htdp.org/">Matthias Felleisen et al., <i>How To Design Programs</i>, MIT Press</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Haskell 98 report, <a rel="nofollow" class="external free" href="http://www.haskell.org">http://www.haskell.org</a>.</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><i>Imperative Functional Programming</i>, Simon Peyton Jones and Phil Wadler, <em>Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages</em>, pages 71–84, 1993</span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Side effect (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <a href="/wiki/Subroutine" title="Subroutine">function</a> or <a href="/wiki/Expression_(programming)" title="Expression (programming)" class="mw-redirect">expression</a> is said to have a <b>side effect</b> if, in addition to returning a value, it also modifies some <a href="/wiki/State_(computer_science)" title="State (computer science)">state</a> or has an <i>observable</i> interaction with calling functions or the outside world. For example, a function might modify a <a href="/wiki/Global_variable" title="Global variable">global variable</a> or <a href="/wiki/Static_variable" title="Static variable">static variable</a>, modify one of its arguments, raise an exception, write data to a display or file, read data, or call other side-effecting functions. In the presence of side effects, a program's behavior may depend on history; that is, the order of evaluation matters. Understanding and debugging a function with side effects requires knowledge about the context and its possible histories.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p>Side effects are the most common way that a program interacts with the outside world (people, filesystems, other computers on networks). But the degree to which side effects are used depends on the programming paradigm. <a href="/wiki/Imperative_programming" title="Imperative programming">Imperative programming</a> is known for its frequent utilization of side effects. In <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, side effects are rarely used. Functional languages such as <a href="/wiki/Standard_ML" title="Standard ML">Standard ML</a>, <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a> and <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> do not restrict side effects, but it is customary for programmers to avoid them.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> The functional language <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> expresses side effects such as <a href="/wiki/Input/output" title="Input/output">I/O</a> and other stateful computations using <a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">monadic</a> actions.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p><a href="/wiki/Assembly_language" title="Assembly language">Assembly language</a> programmers must be aware of <i>hidden</i> side effects — instructions that modify parts of the processor state which are not mentioned in the instruction's mnemonic. A classic example of a hidden side effect is an arithmetic instruction that implicitly modifies <a href="/wiki/Status_register" title="Status register">condition codes</a> (a hidden side effect) while it explicitly modifies a <a href="/wiki/Processor_register" title="Processor register">register</a> (the overt effect). One potential drawback of an <a href="/wiki/Instruction_set" title="Instruction set">instruction set</a> with hidden side effects is that, if many instructions have side effects on a single piece of state, like condition codes, then the logic required to update that state sequentially may become a performance bottleneck. The problem is particularly acute on some processors designed with <a href="/wiki/Instruction_pipeline" title="Instruction pipeline">pipelining</a> (since 1990) or with <a href="/wiki/Out-of-order_execution" title="Out-of-order execution">out-of-order execution</a>. Such a processor may require additional control circuitry to detect hidden side effects and stall the pipeline if the next instruction depends on the results of those effects.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Referential_transparency"><span class="tocnumber">1</span> <span class="toctext">Referential transparency</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Temporal_side_effects"><span class="tocnumber">2</span> <span class="toctext">Temporal side effects</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Idempotence"><span class="tocnumber">3</span> <span class="toctext">Idempotence</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Example"><span class="tocnumber">4</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Referential_transparency">Referential transparency</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Referential transparency">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Absence of side effects is a necessary, but not sufficient, condition for referential transparency. Referential transparency means that an expression (such as a function call) can be replaced with its value; this requires that the expression has no side effects and is <a href="/wiki/Pure_function" title="Pure function">pure</a> (always returns the same results on the same input).</p>
<h2><span class="mw-headline" id="Temporal_side_effects">Temporal side effects</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Temporal side effects">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Side effects caused by the time taken for an operation to execute are usually ignored when discussing side effects and referential transparency. There are some cases, such as with hardware timing or testing, where operations are inserted specifically for their temporal side effects e.g. <code>Sleep(5000)</code> or <code>for(int i=0; i &lt; 10000; i++){}</code>. These instructions do not change state other than taking an amount of time to complete.</p>
<h2><span class="mw-headline" id="Idempotence">Idempotence</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Idempotence">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A function with side effects is said to be idempotent under sequential composition (<code>f; f</code>) if, when called with the same argument twice, the second call returns the same value and has no side effects which can distinguish it from the first call. For instance, consider:</p>
<p>WHATSON? f65545a7-2f6d-4a2d-94a4-daa11f9b70fb</p>
<pre class="de1">
x <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw1">def</span> xSetter<span class="br0">(</span>n<span class="br0">)</span>:
  <span class="kw1">global</span> x
  x <span class="sy0">=</span> n
xSetter<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span>
xSetter<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span>
</pre>
<p>Here, <code>xSetter</code> is idempotent because the second call to <code>xSetter</code> (with the same argument) returns the same value and does not change the visible program state. Note that this is distinct from <a href="/wiki/Idempotence" title="Idempotence">idempotence</a> under function composition (<code>f ∘ f</code>): <code>xSetter</code> is not idempotent under function composition because <code>xSetter(5)</code> and <code>xSetter(xSetter(5))</code> set <code>x</code> to different values where return value of xSetter is x; in this example return value is always 5.</p>
<p>Functions which are side effect free are always idempotent under sequential composition.</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>One common demonstration of side effect behavior is that of the <a href="/wiki/Assignment_operator" title="Assignment operator" class="mw-redirect">assignment operator</a> in <a href="/wiki/C%2B%2B" title="C++">C++</a>. For example, assignment returns the right operand and has the side effect of assigning that value to a variable. This allows for syntactically clean multiple assignment:</p>
<p>WHATSON? 7907beae-ae88-4ffe-b4ba-18d7d3ae0ce7</p>
<pre class="de1">
<span class="kw4">int</span> i, j<span class="sy4">;</span>
i <span class="sy1">=</span> j <span class="sy1">=</span> <span class="nu0">3</span><span class="sy4">;</span>
</pre>
<p>Because the operator <a href="/wiki/Operator_associativity#Right-associativity_of_assignment_operators" title="Operator associativity">right associates</a>, this equates to</p>
<p>WHATSON? ceb04dda-8d3a-418f-ae85-fe83a0894bd0</p>
<pre class="de1">
<span class="kw4">int</span> i, j<span class="sy4">;</span>
i <span class="sy1">=</span> <span class="br0">(</span>j <span class="sy1">=</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">//j = 3 returns 3, which then gets assigned to i</span>
</pre>
<p>Where the result of assigning 3 into "j" then gets assigned into "i". This presents a potential hangup for novice programmers who may confuse</p>
<p>WHATSON? e98e4e7a-e982-48a2-9465-29e2bec35501</p>
<pre class="de1">
<span class="kw1">while</span> <span class="br0">(</span>b <span class="sy1">==</span> <span class="nu0">10</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">//Tests if b evaluates to 10</span>
</pre>
<p>with</p>
<p>WHATSON? 1150344b-5627-4e04-a8b1-4a8422b2d7f1</p>
<pre class="de1">
<span class="co1">// The assignment function returns 10</span>
<span class="co1">// which automatically casts to "true"</span>
<span class="co1">// so the loop conditional always evaluates to true</span>
<span class="kw1">while</span> <span class="br0">(</span>b <span class="sy1">=</span> <span class="nu0">10</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Sequence_point" title="Sequence point">Sequence point</a></li>
<li><a href="/wiki/Action_at_a_distance_(computer_science)" title="Action at a distance (computer science)" class="mw-redirect">Action at a distance (computer science)</a></li>
<li><a href="/wiki/Don%27t-care_term" title="Don't-care term">Don't-care term</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Side_effect_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">“Research Topics in Functional Programming” ed. D. Turner, Addison-Wesley, 1990, pp 17–42. Retrieved from: <span id="CITEREFHughes" class="citation">Hughes, John, <a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf"><i>Why Functional Programming Matters</i></a> (PDF)</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ASide+effect+%28computer+science%29&amp;rft.aufirst=John&amp;rft.au=Hughes%2C+John&amp;rft.aulast=Hughes&amp;rft.btitle=Why+Functional+Programming+Matters&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.utexas.edu%2F~shmat%2Fcourses%2Fcs345%2Fwhyfp.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span id="CITEREFCollberg" class="citation">Collberg, <a rel="nofollow" class="external text" href="http://www.cs.arizona.edu/~collberg/Teaching/520/2005/Html/Html-24/index.html"><i>CSc 520 Principles of Programming Languages</i></a>, Department of Computer Science, University of Arizona</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ASide+effect+%28computer+science%29&amp;rft.au=Collberg&amp;rft.aulast=Collberg&amp;rft.btitle=CSc+520+Principles+of+Programming+Languages&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.arizona.edu%2F~collberg%2FTeaching%2F520%2F2005%2FHtml%2FHtml-24%2Findex.html&amp;rft.pub=Department+of+Computer+Science%2C+University+of+Arizona&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.htdp.org/">Matthias Felleisen et al., <i>How To Design Programs</i>, MIT Press</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Haskell 98 report, <a rel="nofollow" class="external free" href="http://www.haskell.org">http://www.haskell.org</a>.</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><i>Imperative Functional Programming</i>, Simon Peyton Jones and Phil Wadler, <em>Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages</em>, pages 71–84, 1993</span></li>
</ol>
