<h1>Using Objects</h1>
<p>Once you've created an object, you probably want to use it for something. You may need to use the value of one of its fields, change one of its fields, or call one of its methods to perform an action.</p>
<p><a name="fields" id="fields"></a></p>
<h2>Referencing an Object's Fields</h2>
<p>Object fields are accessed by their name. You must use a name that is unambiguous.</p>
<p>You may use a simple name for a field within its own class. For example, we can add a statement <i>within</i> the <code>Rectangle</code> class that prints the <code>width</code> and <code>height</code>:</p>
<p>WHATSON? bc6e7748-062c-4ac9-8f8e-3fd013c29e2c</p>
<pre>
System.out.println("Width and height are: " + width + ", " + height);
</pre>
<p>In this case, <code>width</code> and <code>height</code> are simple names.</p>
<p>Code that is outside the object's class must use an object reference or expression, followed by the dot (.) operator, followed by a simple field name, as in:</p>
<p>WHATSON? 52c7b468-b28a-4997-bcf8-3457e3798b5f</p>
<pre>
objectReference.fieldName
</pre>
<p>For example, the code in the <tt>CreateObjectDemo</tt> class is outside the code for the <tt>Rectangle</tt> class. So to refer to the <tt>origin</tt>, <tt>width</tt>, and <tt>height</tt> fields within the <tt>Rectangle</tt> object named <tt>rectOne</tt>, the <tt>CreateObjectDemo</tt> class must use the names <tt>rectOne.origin</tt>, <tt>rectOne.width</tt>, and <tt>rectOne.height</tt>, respectively. The program uses two of these names to display the <tt>width</tt> and the <tt>height</tt> of <tt>rectOne</tt>:</p>
<p>WHATSON? 43dce384-7dbb-4679-aa94-67a600780ed8</p>
<pre>
System.out.println("Width of rectOne: "  + rectOne.width);
System.out.println("Height of rectOne: " + rectOne.height);
</pre>
<p>Attempting to use the simple names <tt>width</tt> and <tt>height</tt> from the code in the <tt>CreateObjectDemo</tt> class doesn't make sense  those fields exist only within an object  and results in a compiler error.</p>
<p>Later, the program uses similar code to display information about <tt>rectTwo</tt>. Objects of the same type have their own copy of the same instance fields. Thus, each <tt>Rectangle</tt> object has fields named <tt>origin</tt>, <tt>width</tt>, and <tt>height</tt>. When you access an instance field through an object reference, you reference that particular object's field. The two objects <tt>rectOne</tt> and <tt>rectTwo</tt> in the <tt>CreateObjectDemo</tt> program have different <tt>origin</tt>, <tt>width</tt>, and <tt>height</tt> fields.</p>
<p>To access a field, you can use a named reference to an object, as in the previous examples, or you can use any expression that returns an object reference. Recall that the <tt>new</tt> operator returns a reference to an object. So you could use the value returned from new to access a new object's fields:</p>
<p>WHATSON? 65b06186-973e-4a29-9d53-940f362ee07c</p>
<pre>
int height = new Rectangle().height;
</pre>
<p>This statement creates a new <tt>Rectangle</tt> object and immediately gets its height. In essence, the statement calculates the default height of a <tt>Rectangle</tt>. Note that after this statement has been executed, the program no longer has a reference to the created <tt>Rectangle</tt>, because the program never stored the reference anywhere. The object is unreferenced, and its resources are free to be recycled by the Java Virtual Machine. <a name="methods" id="methods"></a></p>
<h2>Calling an Object's Methods</h2>
<p>You also use an object reference to invoke an object's method. You append the method's simple name to the object reference, with an intervening dot operator (.). Also, you provide, within enclosing parentheses, any arguments to the method. If the method does not require any arguments, use empty parentheses.</p>
<p>WHATSON? 875a79ad-e72e-4ddd-bb60-27cbf744eb41</p>
<pre>
objectReference.methodName(argumentList);
</pre>
<p>or:</p>
<p>WHATSON? de81e77f-3156-423c-ac5f-63f5a1741644</p>
<pre>
objectReference.methodName();
</pre>
<p>The <tt>Rectangle</tt> class has two methods: <tt>getArea()</tt> to compute the rectangle's area and <tt>move()</tt> to change the rectangle's origin. Here's the <tt>CreateObjectDemo</tt> code that invokes these two methods:</p>
<p>WHATSON? 11e08dcd-7196-4cd3-b4ac-720bdcf9516a</p>
<pre>
System.out.println("Area of rectOne: " + rectOne.getArea());
...
rectTwo.move(40, 72);
</pre>
<p>The first statement invokes <tt>rectOne</tt>'s <code>getArea()</code> method and displays the results. The second line moves <tt>rectTwo</tt> because the <tt>move()</tt> method assigns new values to the object's <tt>origin.x</tt> and <tt>origin.y</tt>.</p>
<p>As with instance fields, <em>objectReference</em> must be a reference to an object. You can use a variable name, but you also can use any expression that returns an object reference. The <tt>new</tt> operator returns an object reference, so you can use the value returned from new to invoke a new object's methods:</p>
<p>WHATSON? f04bbaf1-eb90-4046-8a3f-c09d04689ef9</p>
<pre>
new Rectangle(100, 50).getArea()
</pre>
<p>The expression <tt>new Rectangle(100, 50)</tt> returns an object reference that refers to a <tt>Rectangle</tt> object. As shown, you can use the dot notation to invoke the new <tt>Rectangle</tt>'s <tt>getArea()</tt> method to compute the area of the new rectangle.</p>
<p>Some methods, such as <tt>getArea()</tt>, return a value. For methods that return a value, you can use the method invocation in expressions. You can assign the return value to a variable, use it to make decisions, or control a loop. This code assigns the value returned by <tt>getArea()</tt> to the variable <code>areaOfRectangle</code>:</p>
<p>WHATSON? e44b1bfa-9db1-4126-a473-23760190a23b</p>
<pre>
int areaOfRectangle = new Rectangle(100, 50).getArea();
</pre>
<p>Remember, invoking a method on a particular object is the same as sending a message to that object. In this case, the object that <tt>getArea()</tt> is invoked on is the rectangle returned by the constructor.</p>
<h2>The Garbage Collector</h2>
<p>Some object-oriented languages require that you keep track of all the objects you create and that you explicitly destroy them when they are no longer needed. Managing memory explicitly is tedious and error-prone. The Java platform allows you to create as many objects as you want (limited, of course, by what your system can handle), and you don't have to worry about destroying them. The Java runtime environment deletes objects when it determines that they are no longer being used. This process is called <em>garbage collection</em>.</p>
<p>An object is eligible for garbage collection when there are no more references to that object. References that are held in a variable are usually dropped when the variable goes out of scope. Or, you can explicitly drop an object reference by setting the variable to the special value <tt>null</tt>. Remember that a program can have multiple references to the same object; all references to an object must be dropped before the object is eligible for garbage collection.</p>
<p>The Java runtime environment has a garbage collector that periodically frees the memory used by objects that are no longer referenced. The garbage collector does its job automatically when it determines that the time is right.</p>
