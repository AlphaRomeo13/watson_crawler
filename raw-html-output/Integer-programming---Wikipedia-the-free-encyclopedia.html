<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Integer programming</span></h1>
<p>An <b>integer programming</b> problem is a mathematical <a href="/wiki/Optimization_(mathematics)" title="Optimization (mathematics)" class="mw-redirect">optimization</a> or <a href="/wiki/Constraint_satisfaction_problem" title="Constraint satisfaction problem">feasibility</a> program in which some or all of the variables are restricted to be integers. In many settings the term refers to <b>integer <a href="/wiki/Linear_programming" title="Linear programming">linear programming</a></b> (ILP), in which the objective function and the constraints (other than the integer constraints) are <a href="/wiki/Linear_function_(calculus)" title="Linear function (calculus)">linear</a>.</p>
<p>Integer programming is <a href="/wiki/NP-hard" title="NP-hard">NP-hard</a>. A special case, 0-1 integer linear programming, in which unknowns are binary, is one of <a href="/wiki/Karp%27s_21_NP-complete_problems" title="Karp's 21 NP-complete problems">Karp's 21 NP-complete problems</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Canonical_and_standard_form_for_ILPs"><span class="tocnumber">1</span> <span class="toctext">Canonical and standard form for ILPs</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Example"><span class="tocnumber">2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Variants"><span class="tocnumber">3</span> <span class="toctext">Variants</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Example_problems_that_can_be_formulated_as_ILPs"><span class="tocnumber">4</span> <span class="toctext">Example problems that can be formulated as ILPs</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Applications"><span class="tocnumber">5</span> <span class="toctext">Applications</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Production_planning"><span class="tocnumber">5.1</span> <span class="toctext">Production planning</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Scheduling"><span class="tocnumber">5.2</span> <span class="toctext">Scheduling</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Telecommunications_networks"><span class="tocnumber">5.3</span> <span class="toctext">Telecommunications networks</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Cellular_networks"><span class="tocnumber">5.4</span> <span class="toctext">Cellular networks</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Algorithms"><span class="tocnumber">6</span> <span class="toctext">Algorithms</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Using_total_unimodularity"><span class="tocnumber">6.1</span> <span class="toctext">Using total unimodularity</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Exact_algorithms"><span class="tocnumber">6.2</span> <span class="toctext">Exact algorithms</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Heuristic_methods"><span class="tocnumber">6.3</span> <span class="toctext">Heuristic methods</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Further_reading"><span class="tocnumber">8</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Production_planning"><span class="tocnumber">5.1</span> <span class="toctext">Production planning</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Scheduling"><span class="tocnumber">5.2</span> <span class="toctext">Scheduling</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Telecommunications_networks"><span class="tocnumber">5.3</span> <span class="toctext">Telecommunications networks</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Cellular_networks"><span class="tocnumber">5.4</span> <span class="toctext">Cellular networks</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Using_total_unimodularity"><span class="tocnumber">6.1</span> <span class="toctext">Using total unimodularity</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Exact_algorithms"><span class="tocnumber">6.2</span> <span class="toctext">Exact algorithms</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Heuristic_methods"><span class="tocnumber">6.3</span> <span class="toctext">Heuristic methods</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Canonical_and_standard_form_for_ILPs">Canonical and standard form for ILPs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=1" title="Edit section: Canonical and standard form for ILPs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An integer linear program in canonical form is expressed as:<sup id="cite_ref-optBook_1-0" class="reference"><a href="#cite_note-optBook-1"><span>[</span>1<span>]</span></a></sup></p>
<p>and an ILP in standard form is expressed as</p>
<p>where the entries of <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{c}, \mathbf{b}" src="//upload.wikimedia.org/math/3/7/a/37a51ceabde30c5d039d595660037ccb.png"> are vectors and <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> is a matrix, having integer values. Note that similar to linear programs, ILPs not in standard form can be <a href="/wiki/Simplex_algorithm#Standard_form" title="Simplex algorithm">converted to standard form</a> by eliminating inequalities by introducing slack variables (<img class="mwe-math-fallback-image-inline tex" alt="\mathbf{s}" src="//upload.wikimedia.org/math/b/4/d/b4d8d570276e116700e0ce286fec6cc7.png">) and replacing variables that are not sign-constrained with the difference of two sign-constrained variables</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=2" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The graph on the right shows the following problem.</p>
<p>The feasible integer points are shown in red, and the red dashed lines indicate their convex hull, which is the smallest polyhedron that contains all of these points. The blue lines together with the coordinate axes define the polyhedron of the LP relaxation, which is given by the inequalities without the integrality constraint. The goal of the optimization is to move the black dotted line as far upward while still touching the polyhedron. The optimal solutions of the integer problem are the points <img class="mwe-math-fallback-image-inline tex" alt="(1,2)" src="//upload.wikimedia.org/math/3/6/9/369a154d5347e70114104fec91cf72fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="(2,2)" src="//upload.wikimedia.org/math/3/9/c/39c6a79fe45ebffea0c1a626d317ece5.png"> which both have an objective value of 2. The unique optimum of the relaxation is <img class="mwe-math-fallback-image-inline tex" alt="(1.8,2.8)" src="//upload.wikimedia.org/math/a/a/0/aa00a9c4977931c040fec3c5e14c5761.png"> with objective value of 2.8. Note that if the solution of the relaxation is rounded to the nearest integers, it is not feasible for the ILP.</p>
<h2><span class="mw-headline" id="Variants">Variants</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=3" title="Edit section: Variants">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><b>Mixed integer linear programming</b> (MILP) involves problems in which only some of the variables, <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png">, are constrained to be integers, while other variables are allowed to be non-integers.</p>
<p><b>Zero-one linear programming</b> involves problems in which the variables are restricted to be either 0 or 1. Note that any bounded integer variable can be expressed as a combination of binary variables.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> For example, given an integer variable, <img class="mwe-math-fallback-image-inline tex" alt="0\le x\le U" src="//upload.wikimedia.org/math/b/a/4/ba402b108931a3c976ab5dcc9532232d.png">, the variable can be expressed using <img class="mwe-math-fallback-image-inline tex" alt="\lfloor \log_2U\rfloor+1" src="//upload.wikimedia.org/math/8/5/7/85711c6d031725daf06dcde3cd3a67cc.png"> binary variables:</p>
<h2><span class="mw-headline" id="Example_problems_that_can_be_formulated_as_ILPs">Example problems that can be formulated as ILPs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=4" title="Edit section: Example problems that can be formulated as ILPs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A large number of problems can be formulated as ILPs. These include</p>
<ul>
<li><a href="/wiki/Travelling_salesman_problem#Integer_linear_programming_formulation" title="Travelling salesman problem">Travelling Salesman</a></li>
<li><a href="/wiki/Vertex_cover#ILP_formulation" title="Vertex cover">Vertex Cover</a> and other <a href="/wiki/Covering_problem" title="Covering problem" class="mw-redirect">Covering problems</a></li>
<li><a href="/wiki/Set_packing#Integer_linear_program_formulation" title="Set packing">Set packing</a> and other <a href="/wiki/Packing_problem" title="Packing problem" class="mw-redirect">Packing problems</a></li>
<li><a href="/wiki/Boolean_satisfiability_problem" title="Boolean satisfiability problem">Boolean satisfiability</a></li>
</ul>
<p>Since the decision version of integer linear programming is in <a href="/wiki/NP_(complexity)" title="NP (complexity)">NP</a> (solutions can be verified in polynomial time) and there are <a href="/wiki/NP-complete" title="NP-complete">NP-complete</a> problems that can be polynomially reduced to ILPs, the decision version of integer linear programming is NP-complete.</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=5" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are two main reasons for using integer variables when modeling problems as a linear program:</p>
<ol>
<li>The integer variables represent quantities that can only be integer. For example, it is not possible to build 3.7 cars.</li>
<li>The integer variables represent decisions and so should only take on the value 0 or 1 .</li>
</ol>
<p>These considerations occur frequently in practice and so integer linear programming can be used in many applications areas, some of which are briefly described below.</p>
<h3><span class="mw-headline" id="Production_planning">Production planning</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=6" title="Edit section: Production planning">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Mixed integer programming has many applications in industrial production, including job-shop modelling. One important example happens In agricultural production planning involves determining production yield for several crops that can share resources (e.g. Land, labor, capital seeds fertilizer, etc.). A possible objective is to maximize the total production, without exceeding the available resources. In some cases, this can be expressed in terms of a linear program, but variables must be constrained to be integer.</p>
<h3><span class="mw-headline" id="Scheduling">Scheduling</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=7" title="Edit section: Scheduling">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>These problems involve service and vehicle scheduling in transportation networks. For example, a problem may involve assigning buses or subways to individual routes so that a timetable can be met, and also to equip them with drivers. Here binary decision variables indicate whether a bus or subway is assigned to a route and whether a driver is assigned to a particular train or subway.</p>
<h3><span class="mw-headline" id="Telecommunications_networks">Telecommunications networks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=8" title="Edit section: Telecommunications networks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The goal of these problems is to design a network of lines to install so that a predefined set of communication requirements are met and the total cost of the network is minimal.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> This requires optimizing both the topology of the network along with the setting the capacities of the various lines. In many cases, the capacities are constrained to be integer quantities. Usually there are, depending on the technology used, additional restrictions that can modeled as a linear inequalities with integer or binary variables.</p>
<h3><span class="mw-headline" id="Cellular_networks">Cellular networks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=9" title="Edit section: Cellular networks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The task of frequency planning in <a href="/wiki/GSM" title="GSM">GSM</a> mobile networks involves distributing available frequencies across the antennas so that users can be served and interference is minimized between the antennas.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> This problem can be formulated as an integer linear program in which binary variables indicate whether a frequency is assigned to an antenna.</p>
<h2><span class="mw-headline" id="Algorithms">Algorithms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=10" title="Edit section: Algorithms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The naive way to solve an ILP is to simply remove the constraint that <b>x</b> is integral, solve the corresponding LP (called the <a href="/wiki/Linear_programming_relaxation" title="Linear programming relaxation">LP relaxation</a> of the ILP), and then round the entries of the solution to the LP relaxation. But, not only may this solution not be optimal, it may not even be feasible, that is it may violate some constraint.</p>
<h3><span class="mw-headline" id="Using_total_unimodularity">Using total unimodularity</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=11" title="Edit section: Using total unimodularity">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>While in general the solution to LP relaxation will not be guaranteed to be optimal, if the ILP has the form <img class="mwe-math-fallback-image-inline tex" alt="\max\mathbf{c}^\mathrm{T} \mathbf{x}" src="//upload.wikimedia.org/math/1/0/0/10041494c04f67a63d992ee17208fe71.png"> such that <img class="mwe-math-fallback-image-inline tex" alt="A\mathbf{x} = \mathbf{b}" src="//upload.wikimedia.org/math/2/9/9/299e5c6fa6afd1ff13210c9a5d905971.png"> where <img class="mwe-math-fallback-image-inline tex" alt="A, \mathbf{b}," src="//upload.wikimedia.org/math/4/9/1/491e730ffde5f21d0eeb6b466736922c.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{c}" src="//upload.wikimedia.org/math/8/9/1/891394a9962c76dc890bd4010f6b111e.png"> have all integer entries and <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> is <a href="/wiki/Unimodular_matrix#Total_unimodularity" title="Unimodular matrix">totally unimodular</a>, then every basic feasible solution is integral. Consequently, the solution returned by the <a href="/wiki/Simplex_algorithm" title="Simplex algorithm">simplex algorithm</a> is guaranteed to be integral. To show that every basic feasible solution is integral, let <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{x}" src="//upload.wikimedia.org/math/3/c/6/3c66d9170d4c3fb75456e1a9fc6ead37.png"> be an arbitrary basic feasible solution . Since <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{x}" src="//upload.wikimedia.org/math/3/c/6/3c66d9170d4c3fb75456e1a9fc6ead37.png"> is feasible, we know that <img class="mwe-math-fallback-image-inline tex" alt="A\mathbf{x}=\mathbf{b}" src="//upload.wikimedia.org/math/2/9/9/299e5c6fa6afd1ff13210c9a5d905971.png">. Let <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{x}_0=[x_{n_1},x_{n_2},\cdots,x_{n_j}]" src="//upload.wikimedia.org/math/6/8/c/68c3257bec9f75af87c86419940c1b2a.png"> be the elements corresponding to the basis columns for the basic solution <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{x}" src="//upload.wikimedia.org/math/3/c/6/3c66d9170d4c3fb75456e1a9fc6ead37.png">. By definition of a basis, there is some square submatrix <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> of <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> with linearly independent columns such that <img class="mwe-math-fallback-image-inline tex" alt="B\mathbf{x}_0=\mathbf{b}" src="//upload.wikimedia.org/math/8/8/f/88fdbc09dff39f05a50340a5daa8eeee.png">.</p>
<p>Since the columns of <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> are linearly independent and <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> is square, <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> is nonsingular, and therefore by assumption, <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> is <a href="/wiki/Unimodular_matrix" title="Unimodular matrix">unimodular</a> and so <img class="mwe-math-fallback-image-inline tex" alt="\det(B)=\pm1" src="//upload.wikimedia.org/math/9/f/a/9fa430020a43eb0dbc8b46753959a734.png">. Also, since <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> is nonsingular, it is invertible and therefore <img class="mwe-math-fallback-image-inline tex" alt="\mathbf{x}_0=B^{-1}\mathbf{b}" src="//upload.wikimedia.org/math/4/3/3/433b756f961160961f65e0c8fc407666.png">. By definition, <img class="mwe-math-fallback-image-inline tex" alt="B^{-1}=\frac{B^{adj}}{\det(B)}=\pm B^{adj}" src="//upload.wikimedia.org/math/f/0/e/f0e800e60ec1a3c190906f885efe546f.png">. Note that <img class="mwe-math-fallback-image-inline tex" alt="B^{adj}" src="//upload.wikimedia.org/math/8/9/4/8946356cb749b52838066df2dce7b4c3.png"> denotes the <a href="/wiki/Adjugate_matrix" title="Adjugate matrix">adjugate</a> of <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> and is integral because <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> is integer. Therefore,</p>
<p>Thus, if the matrix <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> of an ILP is totally unimodular, rather than use an ILP algorithm, the simplex method can be used to solve the LP relaxation and the solution will be integer.</p>
<h3><span class="mw-headline" id="Exact_algorithms">Exact algorithms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=12" title="Edit section: Exact algorithms">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When the matrix <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> is not totally unimodular, there are a variety of algorithms that can be used to solve integer linear programs exactly. One class of algorithms are <a href="/wiki/Cutting-plane_method" title="Cutting-plane method">cutting plane methods</a> which work by solving the LP relaxation and then adding linear constraints that drive the solution towards being integer without excluding any integer feasible points.</p>
<p>Another class of algorithms are variants of the <a href="/wiki/Branch_and_bound" title="Branch and bound">branch and bound</a> method. For example, the <a href="/wiki/Branch_and_cut" title="Branch and cut">branch and cut</a> method that combines both branch and bound and cutting plane methods. Branch and bound algorithms have a number of advantages over algorithms that only use cutting planes. One advantage is that the algorithms can be terminated early and as long as at least one integral solution has been found, a feasible, although not necessarily optimal, solution can be returned. Further, the solutions of the LP relaxations can be used to provide a worst-case estimate of how far from optimality the returned solution is. Finally, branch and bound methods can be used to return multiple optimal solutions.</p>
<p>Lenstra in 1983 showed,<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> that when number of variables is fixed, integer programming problem can be solved in a polynomial time.</p>
<h3><span class="mw-headline" id="Heuristic_methods">Heuristic methods</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=13" title="Edit section: Heuristic methods">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Since integer linear programming is <a href="/wiki/NP-complete" title="NP-complete">NP-complete</a>, many problem instances are intractable and so heuristic methods must be used instead. For example, <a href="/wiki/Tabu_search" title="Tabu search">tabu search</a> can be used to search for solutions to ILPs.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> To use tabu search to solve ILPs, moves can be defined as incrementing or decrementing an integer constrained variable of a feasible solution, while keeping all other integer-constrained variables constant. The unrestricted variables are then solved for. Short term memory can consist of previous tried solutions while medium term memory can consist of values for the integer constrained variables that have resulted in high objective values (assuming the ILP is a maximization problem). Finally, long term memory can guide the search towards integer values that have not previously been tried.</p>
<p>Other heuristic methods that can be applied to ILPs include</p>
<ul>
<li><a href="/wiki/Hill_climbing" title="Hill climbing">Hill climbing</a></li>
<li><a href="/wiki/Simulated_annealing" title="Simulated annealing">Simulated annealing</a></li>
<li><a href="/wiki/Reactive_search_optimization" title="Reactive search optimization">Reactive search optimization</a></li>
<li><a href="/wiki/Ant_colony_optimization_algorithms" title="Ant colony optimization algorithms">Ant colony optimization</a></li>
<li><a href="/wiki/Hopfield_network" title="Hopfield network">Hopfield neural networks</a></li>
</ul>
<p>There are also a variety of other problem-specific heuristics, such as the <a href="/wiki/Travelling_salesman_problem#Iterative_improvement" title="Travelling salesman problem">k-opt heuristic</a> for the travelling salesman problem. Note that a disadvantage of heuristic methods is that if they fail to find a solution, it cannot be determined whether it is because there is no feasible solution or whether the algorithm simply was unable to find one. Further, it is usually impossible to quantify how close to optimal a solution returned by these methods is.</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=14" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-optBook-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-optBook_1-0">^</a></b></span> <span class="reference-text"><span class="citation book">Papadimitriou, C.H.; Steiglitz, K. (1998). <i>Combinatorial optimization: algorithms and complexity</i>. Mineola, NY: Dover. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0486402584" title="Special:BookSources/0486402584">0486402584</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.aufirst=C.H.&amp;rft.aulast=Papadimitriou&amp;rft.au=Papadimitriou%2C+C.H.&amp;rft.au=Steiglitz%2C+K.&amp;rft.btitle=Combinatorial+optimization%3A+algorithms+and+complexity&amp;rft.date=1998&amp;rft.genre=book&amp;rft.isbn=0486402584&amp;rft.place=Mineola%2C+NY&amp;rft.pub=Dover&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation book">Williams, H.P. (2009). <i>Logic and integer programming</i>. International Series in Operations Research &amp; Management Science <b>130</b>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-387-92280-5" title="Special:BookSources/978-0-387-92280-5">978-0-387-92280-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.aufirst=H.P.&amp;rft.aulast=Williams&amp;rft.au=Williams%2C+H.P.&amp;rft.btitle=Logic+and+integer+programming&amp;rft.date=2009&amp;rft.genre=book&amp;rft.isbn=978-0-387-92280-5&amp;rft.series=International+Series+in+Operations+Research+%26+Management+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=130" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web">Borndörer, R.; M. (2012). <a rel="nofollow" class="external text" href="http://www.zib.de/groetschel/teaching/SS2012/120503Vorlesung-DesigningTelcomNetworks-reduced.pdf">"Designing telecommunication networks by integer programming"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=Bornd%C3%B6rer%2C+R.&amp;rft.aufirst=R.&amp;rft.aulast=Bornd%C3%B6rer&amp;rft.au=M.&amp;rft.btitle=Designing+telecommunication+networks+by+integer+programming&amp;rft.date=2012&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.zib.de%2Fgroetschel%2Fteaching%2FSS2012%2F120503Vorlesung-DesigningTelcomNetworks-reduced.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web">Sharma, Deepak (2010). <a rel="nofollow" class="external text" href="http://www.slideshare.net/deepakecrbs/gsm-frequency-planning">"Frequency Planning"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.aufirst=Deepak&amp;rft.aulast=Sharma&amp;rft.au=Sharma%2C+Deepak&amp;rft.btitle=Frequency+Planning&amp;rft.date=2010&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.slideshare.net%2Fdeepakecrbs%2Fgsm-frequency-planning&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">H.W.Lenstra, "Integer programming with a fixed number of variables", Mathematics of operations research, Vol 8, No 8, November 1983</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation journal">Glover, F. (1989). "Tabu search-Part II". <i>ORSA Journal on computing</i> <b>1</b> (3): 4–32. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1287%2Fijoc.2.1.4">10.1287/ijoc.2.1.4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.atitle=Tabu+search-Part+II&amp;rft.aufirst=F.&amp;rft.au=Glover%2C+F.&amp;rft.aulast=Glover&amp;rft.date=1989&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1287%2Fijoc.2.1.4&amp;rft.issue=3&amp;rft.jtitle=ORSA+Journal+on+computing&amp;rft.pages=4-32&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=1" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=15" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation book"><a href="/wiki/George_Nemhauser" title="George Nemhauser">George L. Nemhauser</a>; Laurence A. Wolsey (1988). <i>Integer and combinatorial optimization</i>. Wiley. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-471-82819-8" title="Special:BookSources/978-0-471-82819-8">978-0-471-82819-8</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=George+L.+Nemhauser&amp;rft.aulast=George+L.+Nemhauser&amp;rft.au=Laurence+A.+Wolsey&amp;rft.btitle=Integer+and+combinatorial+optimization&amp;rft.date=1988&amp;rft.genre=book&amp;rft.isbn=978-0-471-82819-8&amp;rft.pub=Wiley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book"><a href="/wiki/Alexander_Schrijver" title="Alexander Schrijver">Alexander Schrijver</a> (1998). <i>Theory of linear and integer programming</i>. John Wiley and Sons. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-471-98232-6" title="Special:BookSources/978-0-471-98232-6">978-0-471-98232-6</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=Alexander+Schrijver&amp;rft.aulast=Alexander+Schrijver&amp;rft.btitle=Theory+of+linear+and+integer+programming&amp;rft.date=1998&amp;rft.genre=book&amp;rft.isbn=978-0-471-98232-6&amp;rft.pub=John+Wiley+and+Sons&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Laurence A. Wolsey (1998). <i>Integer programming</i>. Wiley. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-471-28366-9" title="Special:BookSources/978-0-471-28366-9">978-0-471-28366-9</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.aulast=Laurence+A.+Wolsey&amp;rft.au=Laurence+A.+Wolsey&amp;rft.btitle=Integer+programming&amp;rft.date=1998&amp;rft.genre=book&amp;rft.isbn=978-0-471-28366-9&amp;rft.pub=Wiley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Dimitris Bertsimas; Robert Weismantel (2005). <i>Optimization over integers</i>. Dynamic Ideas. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-9759146-2-5" title="Special:BookSources/978-0-9759146-2-5">978-0-9759146-2-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=Dimitris+Bertsimas&amp;rft.aulast=Dimitris+Bertsimas&amp;rft.au=Robert+Weismantel&amp;rft.btitle=Optimization+over+integers&amp;rft.date=2005&amp;rft.genre=book&amp;rft.isbn=978-0-9759146-2-5&amp;rft.pub=Dynamic+Ideas&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">John K. Karlof (2006). <i>Integer programming: theory and practice</i>. CRC Press. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-8493-1914-3" title="Special:BookSources/978-0-8493-1914-3">978-0-8493-1914-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=John+K.+Karlof&amp;rft.aulast=John+K.+Karlof&amp;rft.btitle=Integer+programming%3A+theory+and+practice&amp;rft.date=2006&amp;rft.genre=book&amp;rft.isbn=978-0-8493-1914-3&amp;rft.pub=CRC+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">H. Paul Williams (2009). <i>Logic and Integer Programming</i>. Springer. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-387-92279-9" title="Special:BookSources/978-0-387-92279-9">978-0-387-92279-9</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=H.+Paul+Williams&amp;rft.aulast=H.+Paul+Williams&amp;rft.btitle=Logic+and+Integer+Programming&amp;rft.date=2009&amp;rft.genre=book&amp;rft.isbn=978-0-387-92279-9&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Michael Jünger, Thomas M. Liebling, Denis Naddef, <a href="/wiki/George_Nemhauser" title="George Nemhauser">George Nemhauser</a>, William R. Pulleyblank, Gerhard Reinelt, Giovanni Rinaldi and Laurence A. Wolsey, ed. (2009). <i>50 Years of Integer Programming 1958-2008: From the Early Years to the State-of-the-Art</i>. Springer. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-68274-5" title="Special:BookSources/978-3-540-68274-5">978-3-540-68274-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.btitle=50+Years+of+Integer+Programming+1958-2008%3A+From+the+Early+Years+to+the+State-of-the-Art&amp;rft.date=2009&amp;rft.genre=book&amp;rft.isbn=978-3-540-68274-5&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Der-San Chen; Robert G. Batson; Yu Dang (2010). <i>Applied Integer Programming: Modeling and Solution</i>. John Wiley and Sons. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-470-37306-4" title="Special:BookSources/978-0-470-37306-4">978-0-470-37306-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInteger+programming&amp;rft.au=Der-San+Chen&amp;rft.aulast=Der-San+Chen&amp;rft.au=Robert+G.+Batson&amp;rft.au=Yu+Dang&amp;rft.btitle=Applied+Integer+Programming%3A+Modeling+and+Solution&amp;rft.date=2010&amp;rft.genre=book&amp;rft.isbn=978-0-470-37306-4&amp;rft.pub=John+Wiley+and+Sons&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Integer_programming&amp;action=edit&amp;section=16" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://mat.gsia.cmu.edu/orclass/integer/integer.html">A Tutorial on Integer Programming</a></li>
<li>Conference <a rel="nofollow" class="external text" href="http://www.mathopt.org/?nav=ipco">Integer Programming and Combinatorial Optimization, IPCO</a></li>
<li><a rel="nofollow" class="external text" href="http://www.iasi.cnr.it/aussois">The Aussois Combinatorial Optimization Workshop</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Optimization_algorithms" title="Template:Optimization algorithms"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Optimization_algorithms" title="Template talk:Optimization algorithms"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Optimization_algorithms&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Golden_section_search" title="Golden section search">Golden section search</a></li>
<li><a href="/wiki/Powell%27s_method" title="Powell's method">Interpolation methods</a></li>
<li><a href="/wiki/Line_search" title="Line search">Line search</a></li>
<li><a href="/wiki/Nelder%E2%80%93Mead_method" title="Nelder–Mead method">Nelder–Mead method</a></li>
<li><a href="/wiki/Successive_parabolic_interpolation" title="Successive parabolic interpolation">Successive parabolic interpolation</a></li>
</ul>
<ul>
<li><a href="/wiki/Trust_region" title="Trust region">Trust region</a></li>
<li><a href="/wiki/Wolfe_conditions" title="Wolfe conditions">Wolfe conditions</a></li>
</ul>
<ul>
<li><a href="/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm" title="Broyden–Fletcher–Goldfarb–Shanno algorithm">BFGS</a> and <a href="/wiki/Limited-memory_BFGS" title="Limited-memory BFGS">L-BFGS</a></li>
<li><a href="/wiki/Davidon%E2%80%93Fletcher%E2%80%93Powell_formula" title="Davidon–Fletcher–Powell formula">DFP</a></li>
<li><a href="/wiki/SR1_formula" title="SR1 formula" class="mw-redirect">Symmetric rank-one (SR1)</a></li>
</ul>
<ul>
<li><a href="/wiki/Gauss%E2%80%93Newton_algorithm" title="Gauss–Newton algorithm">Gauss–Newton</a></li>
<li><a href="/wiki/Gradient_descent" title="Gradient descent">Gradient</a></li>
<li><a href="/wiki/Levenberg%E2%80%93Marquardt_algorithm" title="Levenberg–Marquardt algorithm">Levenberg–Marquardt</a></li>
<li><a href="/wiki/Nonlinear_conjugate_gradient_method" title="Nonlinear conjugate gradient method">Conjugate gradient</a></li>
</ul>
<ul>
<li><a href="/wiki/Newton%27s_method_in_optimization" title="Newton's method in optimization">Newton's method</a></li>
</ul>
<ul>
<li><a href="/wiki/Barrier_function" title="Barrier function">Barrier methods</a></li>
<li><a href="/wiki/Penalty_method" title="Penalty method">Penalty methods</a></li>
</ul>
<ul>
<li><a href="/wiki/Augmented_Lagrangian_method" title="Augmented Lagrangian method">Augmented Lagrangian methods</a></li>
<li><a href="/wiki/Sequential_quadratic_programming" title="Sequential quadratic programming">Sequential quadratic programming</a></li>
<li><a href="/wiki/Successive_linear_programming" title="Successive linear programming">Successive linear programming</a></li>
</ul>
<ul>
<li><a href="/wiki/Cutting-plane_method" title="Cutting-plane method">Cutting-plane method</a></li>
<li><a href="/wiki/Frank%E2%80%93Wolfe_algorithm" title="Frank–Wolfe algorithm">Reduced gradient (Frank–Wolfe)</a></li>
<li><a href="/wiki/Subgradient_method" title="Subgradient method">Subgradient method</a></li>
</ul>
<ul>
<li><a href="/wiki/Ellipsoid_method" title="Ellipsoid method">Ellipsoid algorithm of Khachiyan</a></li>
<li><a href="/wiki/Karmarkar%27s_algorithm" title="Karmarkar's algorithm">Projective algorithm of Karmarkar</a></li>
</ul>
<ul>
<li><a href="/wiki/Simplex_algorithm" title="Simplex algorithm">Simplex algorithm of Dantzig</a></li>
<li><a href="/wiki/Revised_simplex_algorithm" title="Revised simplex algorithm" class="mw-redirect">Revised simplex algorithm</a></li>
<li><a href="/wiki/Criss-cross_algorithm" title="Criss-cross algorithm">Criss-cross algorithm</a></li>
<li><a href="/wiki/Lemke%27s_algorithm" title="Lemke's algorithm">Principal pivoting algorithm of Lemke</a></li>
</ul>
<ul>
<li><a href="/wiki/Approximation_algorithm" title="Approximation algorithm">Approximation algorithm</a></li>
<li><a href="/wiki/Dynamic_programming" title="Dynamic programming">Dynamic programming</a></li>
<li><a href="/wiki/Greedy_algorithm" title="Greedy algorithm">Greedy algorithm</a></li>
<li><strong class="selflink">Integer programming</strong>
<ul>
<li><a href="/wiki/Branch_and_bound" title="Branch and bound">Branch &amp; bound</a> or <a href="/wiki/Branch_and_cut" title="Branch and cut">cut</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Branch_and_bound" title="Branch and bound">Branch &amp; bound</a> or <a href="/wiki/Branch_and_cut" title="Branch and cut">cut</a></li>
</ul>
<ul>
<li><a href="/wiki/Bellman%E2%80%93Ford_algorithm" title="Bellman–Ford algorithm">Bellman–Ford</a></li>
<li><a href="/wiki/Bor%C5%AFvka%27s_algorithm" title="Borůvka's algorithm">Borůvka</a></li>
<li><a href="/wiki/Dijkstra%27s_algorithm" title="Dijkstra's algorithm">Dijkstra</a></li>
<li><a href="/wiki/Floyd%E2%80%93Warshall_algorithm" title="Floyd–Warshall algorithm">Floyd–Warshall</a></li>
<li><a href="/wiki/Johnson%27s_algorithm" title="Johnson's algorithm">Johnson</a></li>
<li><a href="/wiki/Kruskal%27s_algorithm" title="Kruskal's algorithm">Kruskal</a></li>
</ul>
<ul>
<li><a href="/wiki/Dinic%27s_algorithm" title="Dinic's algorithm">Dinic</a></li>
<li><a href="/wiki/Edmonds%E2%80%93Karp_algorithm" title="Edmonds–Karp algorithm">Edmonds–Karp</a></li>
<li><a href="/wiki/Ford%E2%80%93Fulkerson_algorithm" title="Ford–Fulkerson algorithm">Ford–Fulkerson</a></li>
<li><a href="/wiki/Push-relabel_maximum_flow_algorithm" title="Push-relabel maximum flow algorithm" class="mw-redirect">Push-relabel maximum flow</a></li>
</ul>
<ul>
<li><a href="/wiki/Evolutionary_algorithm" title="Evolutionary algorithm">Evolutionary algorithm</a></li>
<li><a href="/wiki/Hill_climbing" title="Hill climbing">Hill climbing</a></li>
<li><a href="/wiki/Local_search_(optimization)" title="Local search (optimization)">Local search</a></li>
<li><a href="/wiki/Simulated_annealing" title="Simulated annealing">Simulated annealing</a></li>
<li><a href="/wiki/Tabu_search" title="Tabu search">Tabu search</a></li>
</ul>
<ul>
<li><b>Categories</b>
<ul>
<li><a href="/wiki/Category:Optimization_algorithms_and_methods" title="Category:Optimization algorithms and methods">Algorithms and methods</a></li>
<li><a href="/wiki/Category:Heuristic_algorithms" title="Category:Heuristic algorithms">Heuristics</a></li>
</ul>
</li>
<li><b><a href="/wiki/Comparison_of_optimization_software" title="Comparison of optimization software">Software</a></b></li>
</ul>
<ul>
<li><a href="/wiki/Category:Optimization_algorithms_and_methods" title="Category:Optimization algorithms and methods">Algorithms and methods</a></li>
<li><a href="/wiki/Category:Heuristic_algorithms" title="Category:Heuristic algorithms">Heuristics</a></li>
</ul>
