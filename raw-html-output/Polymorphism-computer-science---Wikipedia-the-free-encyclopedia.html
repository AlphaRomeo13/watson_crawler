<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Polymorphism (computer science)</span></h1>
<ul>
<li><a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism">Ad hoc polymorphism</a></li>
<li><a href="/wiki/Function_overloading" title="Function overloading">Function overloading</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Double_dispatch" title="Double dispatch">Double dispatch</a></li>
<li><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">Multiple dispatch</a></li>
<li><a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">Single &amp; dynamic dispatch</a></li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Virtual_function" title="Virtual function">Virtual function</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Polymorphism" title="Template:Polymorphism"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Polymorphism" title="Template talk:Polymorphism"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Polymorphism&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p>In <a href="/wiki/Programming_language" title="Programming language">programming languages</a> and <a href="/wiki/Type_theory" title="Type theory">type theory</a>, <b>polymorphism</b> (from Greek <a href="//en.wiktionary.org/wiki/%CF%80%CE%BF%CE%BB%CF%8D%CF%82#Ancient_Greek" class="extiw" title="wikt:πολύς">πολύς</a>, polys, "many, much" and <a href="//en.wiktionary.org/wiki/%CE%BC%CE%BF%CF%81%CF%86%CE%AE#Ancient_Greek" class="extiw" title="wikt:μορφή">μορφή</a>, morphē, "form, shape") is the providing of a single <a href="/wiki/Interface_(computing)" title="Interface (computing)">interface</a> to entities of different <a href="/wiki/Data_type" title="Data type">types</a>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> A <b>polymorphic type</b> is a type whose operations can also be applied to values of some other type, or types.<sup id="cite_ref-Luca_2-0" class="reference"><a href="#cite_note-Luca-2"><span>[</span>2<span>]</span></a></sup> There are several fundamentally different kinds of polymorphism:</p>
<ul>
<li>If a function denotes different and potentially heterogeneous implementations depending on a limited range of individually specified types and combinations, it is called <a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism"><i>ad hoc</i> polymorphism</a>. <i>Ad hoc</i> polymorphism is supported in many languages using <a href="/wiki/Function_overloading" title="Function overloading">function overloading</a>.</li>
<li>If the code is written without mention of any specific type and thus can be used transparently with any number of new types, it is called <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>. In the object-oriented programming community, this is often known as <i>generics</i> or <i><a href="/wiki/Generic_programming" title="Generic programming">generic programming</a></i>. In the functional programming community, this is often simply called <i>polymorphism</i>.</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a> (or <i>inclusion polymorphism</i>) is a concept wherein a name may denote instances of many different classes as long as they are related by some common superclass.<sup id="cite_ref-gbooch_3-0" class="reference"><a href="#cite_note-gbooch-3"><span>[</span>3<span>]</span></a></sup> In object-oriented programming, this is often referred to simply as <i>polymorphism</i>.</li>
</ul>
<p>The interaction between parametric polymorphism and subtyping leads to the concepts of <a href="/wiki/Covariance_and_contravariance_(computer_science)" title="Covariance and contravariance (computer science)">variance</a> and <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded quantification</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Types_of_polymorphism"><span class="tocnumber">2</span> <span class="toctext">Types of polymorphism</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Ad_hoc_polymorphism"><span class="tocnumber">2.1</span> <span class="toctext">Ad hoc polymorphism</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Parametric_polymorphism"><span class="tocnumber">2.2</span> <span class="toctext">Parametric polymorphism</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Subtyping"><span class="tocnumber">2.3</span> <span class="toctext"> Subtyping</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Polytypism"><span class="tocnumber">2.4</span> <span class="toctext">Polytypism</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">5</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Ad_hoc_polymorphism"><span class="tocnumber">2.1</span> <span class="toctext">Ad hoc polymorphism</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Parametric_polymorphism"><span class="tocnumber">2.2</span> <span class="toctext">Parametric polymorphism</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Subtyping"><span class="tocnumber">2.3</span> <span class="toctext"> Subtyping</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Polytypism"><span class="tocnumber">2.4</span> <span class="toctext">Polytypism</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><i>Ad hoc</i> polymorphism and parametric polymorphism were originally described in <i><a href="/wiki/Fundamental_Concepts_in_Programming_Languages" title="Fundamental Concepts in Programming Languages">Fundamental Concepts in Programming Languages</a></i>, a set of lecture notes written in 1967 by British computer scientist <a href="/wiki/Christopher_Strachey" title="Christopher Strachey">Christopher Strachey</a>.<sup id="cite_ref-Strachey_4-0" class="reference"><a href="#cite_note-Strachey-4"><span>[</span>4<span>]</span></a></sup> In a 1985 paper, <a href="/wiki/Peter_Wegner" title="Peter Wegner">Peter Wegner</a> and <a href="/wiki/Luca_Cardelli" title="Luca Cardelli">Luca Cardelli</a> introduced the term <i>inclusion polymorphism</i> to model subtypes and <a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">inheritance</a>.<sup id="cite_ref-Luca_2-1" class="reference"><a href="#cite_note-Luca-2"><span>[</span>2<span>]</span></a></sup> However, implementations of subtyping and inheritance predate the term 'inclusion polymorphism', having appeared with <a href="/wiki/Simula" title="Simula">Simula</a> in 1967.</p>
<h2><span class="mw-headline" id="Types_of_polymorphism">Types of polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Types of polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Ad_hoc_polymorphism">Ad hoc polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Ad hoc polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="/wiki/Chris_Strachey" title="Chris Strachey" class="mw-redirect">Chris Strachey</a><sup id="cite_ref-Strachey_4-1" class="reference"><a href="#cite_note-Strachey-4"><span>[</span>4<span>]</span></a></sup> chose the term ad hoc polymorphism to refer to polymorphic functions which can be applied to arguments of different types, but which behave differently depending on the type of the argument to which they are applied (also known as <a href="/wiki/Function_overloading" title="Function overloading">function overloading</a> or <a href="/wiki/Operator_overloading" title="Operator overloading">operator overloading</a>). The term "<a href="/wiki/Ad_hoc" title="Ad hoc">ad hoc</a>" in this context is not intended to be pejorative; it refers simply to the fact that this type of polymorphism is not a fundamental feature of the type system. In the example below, the <code>Add</code> functions seem to work generically over various types when looking at the invocations, but are considered to be two entirely distinct functions by the compiler for all intents and purposes:</p>
<p>WHATSON? 6211e42a-da4a-437d-9832-8232ba6ce19c</p>
<pre class="de1">
<span class="kw1">program</span> Adhoc<span class="sy1">;</span>
 
<span class="kw1">function</span> Add<span class="br0">(</span> x<span class="sy1">,</span> y <span class="sy1">:</span> <span class="kw4">Integer</span> <span class="br0">)</span> <span class="sy1">:</span> <span class="kw4">Integer</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    Add <span class="sy1">:</span><span class="sy3">=</span> x <span class="sy3">+</span> y
<span class="kw1">end</span><span class="sy1">;</span>
 
<span class="kw1">function</span> Add<span class="br0">(</span> s<span class="sy1">,</span> t <span class="sy1">:</span> <span class="kw4">String</span> <span class="br0">)</span> <span class="sy1">:</span> <span class="kw4">String</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    Add <span class="sy1">:</span><span class="sy3">=</span> Concat<span class="br0">(</span> s<span class="sy1">,</span> t <span class="br0">)</span>
<span class="kw1">end</span><span class="sy1">;</span>
 
<span class="kw1">begin</span>
    <span class="kw3">Writeln</span><span class="br0">(</span>Add<span class="br0">(</span><span class="nu0">1</span><span class="sy1">,</span> <span class="nu0">2</span><span class="br0">)</span><span class="br0">)</span><span class="sy1">;</span>
    <span class="kw3">Writeln</span><span class="br0">(</span>Add<span class="br0">(</span><span class="st0">'Hello, '</span><span class="sy1">,</span> <span class="st0">'World!'</span><span class="br0">)</span><span class="br0">)</span><span class="sy1">;</span>
<span class="kw1">end</span><span class="sy1">.</span>
</pre>
<p>In <a href="/wiki/Dynamically_typed" title="Dynamically typed" class="mw-redirect">dynamically typed</a> languages the situation can be more complex as the correct function that needs to be invoked might only be determinable at run time.</p>
<p>Implicit type conversion has also been defined as a form of polymorphism, referred to as "coercion polymorphism".<sup id="cite_ref-Tucker2004_5-0" class="reference"><a href="#cite_note-Tucker2004-5"><span>[</span>5<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Parametric_polymorphism">Parametric polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Parametric polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Parametric polymorphism allows a function or a data type to be written generically, so that it can handle values <i>identically</i> without depending on their type.<sup id="cite_ref-bjpierce_6-0" class="reference"><a href="#cite_note-bjpierce-6"><span>[</span>6<span>]</span></a></sup> Parametric polymorphism is a way to make a language more expressive, while still maintaining full static <a href="/wiki/Type-safety" title="Type-safety" class="mw-redirect">type-safety</a>.</p>
<p>The concept of parametric polymorphism applies to both <a href="/wiki/Data_type" title="Data type">data types</a> and <a href="/wiki/Function_(programming)" title="Function (programming)" class="mw-redirect">functions</a>. A function that can evaluate to or be applied to values of different types is known as a <i>polymorphic function.</i> A data type that can appear to be of a generalized type (e.g., a <a href="/wiki/List_(computing)" title="List (computing)" class="mw-redirect">list</a> with elements of arbitrary type) is designated <i>polymorphic data type</i> like the generalized type from which such specializations are made.</p>
<p>Parametric polymorphism is ubiquitous in functional programming, where it is often simply referred to as "polymorphism". The following example shows a parametrized list data type and two parametrically polymorphic functions on them:</p>
<p>WHATSON? 52494611-2f36-4732-9339-74617085676b</p>
<pre class="de1">
<span class="kw1">data</span> List a <span class="sy0">=</span> Nil <span class="sy0">|</span> Cons a <span class="br0">(</span>List a<span class="br0">)</span>
 
<span class="kw3">length</span> <span class="sy0">::</span> List a <span class="sy0">-&gt;</span> <span class="kw4">Integer</span>
<span class="kw3">length</span> Nil         <span class="sy0">=</span> <span class="nu0">0</span>
<span class="kw3">length</span> <span class="br0">(</span>Cons x xs<span class="br0">)</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> <span class="kw3">length</span> xs
 
<span class="kw3">map</span> <span class="sy0">::</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> List a <span class="sy0">-&gt;</span> List b
<span class="kw3">map</span> f Nil         <span class="sy0">=</span> Nil
<span class="kw3">map</span> f <span class="br0">(</span>Cons x xs<span class="br0">)</span> <span class="sy0">=</span> Cons <span class="br0">(</span>f x<span class="br0">)</span> <span class="br0">(</span><span class="kw3">map</span> f xs<span class="br0">)</span>
</pre>
<p>Parametric polymorphism is also available in several object-oriented languages, where it often goes under the name "generics" (for example, Java) or "<a href="/wiki/Template_(C%2B%2B)" title="Template (C++)">templates</a>" (C++ and D):</p>
<p>WHATSON? eb83e0b3-50ad-405a-ad27-f35b05e04e51</p>
<pre class="de1">
<span class="kw4">class</span> List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
    <span class="kw4">class</span> Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
        T elem<span class="sy0">;</span>
        Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> next<span class="sy0">;</span>
    <span class="br0">}</span>
    Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> head<span class="sy0">;</span>
    <span class="kw4">int</span> length<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="sy0">...</span> <span class="br0">}</span>
<span class="br0">}</span>
 
List<span class="sy0">&lt;</span>B<span class="sy0">&gt;</span> map<span class="br0">(</span>Func<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> f, List<span class="sy0">&lt;</span>A<span class="sy0">&gt;</span> xs<span class="br0">)</span> <span class="br0">{</span>
    <span class="sy0">...</span>
<span class="br0">}</span>
</pre>
<p><a href="/wiki/John_C._Reynolds" title="John C. Reynolds">John C. Reynolds</a> (and later <a href="/wiki/Jean-Yves_Girard" title="Jean-Yves Girard">Jean-Yves Girard</a>) formally developed this notion of polymorphism as an extension to lambda calculus (called the <a href="/wiki/Polymorphic_Lambda_Calculus" title="Polymorphic Lambda Calculus" class="mw-redirect">polymorphic lambda calculus</a>, or <a href="/wiki/System_F" title="System F">System F</a>). Any parametrically polymorphic function is necessarily restricted in what it can do, working on the shape of the data instead of its value, leading to the concept of <a href="/wiki/Parametricity" title="Parametricity">parametricity</a>.</p>
<h3><span class="mw-headline" id="Subtyping"><span id="Subtyping"></span><span id="Subtype_polymorphism"></span> Subtyping</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Subtyping">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages employ the idea of <b>subtyping</b> to restrict the range of types that can be used in a particular case of polymorphism. In these languages, <b>subtype polymorphism</b> (sometimes referred to as <b>inclusion polymorphism</b> or <b>dynamic polymorphism</b><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2013)">citation needed</span></a></i>]</sup>) allows a function to be written to take an object of a certain type <i>T</i>, but also work correctly if passed an object that belongs to a type <i>S</i> that is a subtype of <i>T</i> (according to the <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>). This type relation is sometimes written <i>S</i> &lt;: <i>T</i>. Conversely, <i>T</i> is said to be a <i>supertype</i> of <i>S</i>—written <i>T</i> :&gt; <i>S</i>.</p>
<p>In the following example we make cats and dogs subtypes of animals. The procedure letsHear() accepts an animal, but will also work correctly if a subtype is passed to it:</p>
<p>WHATSON? ebc40540-007c-4a03-a090-16902966a2f9</p>
<pre class="de1">
<span class="kw1">abstract</span> <span class="kw1">class</span> Animal <span class="br0">{</span>
    <span class="kw1">abstract</span> <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw1">class</span> Cat <span class="kw1">extends</span> Animal <span class="br0">{</span>
    <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> <span class="st0">"Meow!"</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw1">class</span> Dog <span class="kw1">extends</span> Animal <span class="br0">{</span>
    <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> <span class="st0">"Woof!"</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> letsHear<span class="br0">(</span>Animal a<span class="br0">)</span> <span class="br0">{</span>
    println<span class="br0">(</span>a.<span class="me1">talk</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    letsHear<span class="br0">(</span><span class="kw1">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    letsHear<span class="br0">(</span><span class="kw1">new</span> Dog<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>In another example, if <code>Number</code>, <code>Rational</code>, and <code>Integer</code> are types such that <code>Number</code> :&gt; <code>Rational</code> and <code>Number</code> :&gt; <code>Integer</code>, a function written to take a <code>Number</code> will work equally well when passed an <code>Integer</code> or <code>Rational</code> as when passed a <code>Number</code>. The actual type of the object can be hidden from clients into a <a href="/wiki/Black_box_(systems)" title="Black box (systems)" class="mw-redirect">black box</a>, and accessed via object <a href="/wiki/Identity_(object-oriented_programming)" title="Identity (object-oriented programming)">identity</a>. In fact, if the <code>Number</code> type is <i>abstract</i>, it may not even be possible to get your hands on an object whose <i>most-derived</i> type is <code>Number</code> (see <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data type</a>, <a href="/wiki/Abstract_class" title="Abstract class" class="mw-redirect">abstract class</a>). This particular kind of type hierarchy is known—especially in the context of the <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme programming language</a>—as a <i><a href="/wiki/Numerical_tower" title="Numerical tower">numerical tower</a></i>, and usually contains many more types.</p>
<p><a href="/wiki/Object-oriented_programming_language" title="Object-oriented programming language" class="mw-redirect">Object-oriented programming languages</a> offer subtyping polymorphism using <i><a href="/wiki/Subclass_(computer_science)" title="Subclass (computer science)" class="mw-redirect">subclassing</a></i> (also known as <i><a href="/wiki/Inheritance_in_object-oriented_programming" title="Inheritance in object-oriented programming" class="mw-redirect">inheritance</a></i>). In typical implementations, each class contains what is called a <i><a href="/wiki/Virtual_table" title="Virtual table" class="mw-redirect">virtual table</a></i>—a table of functions that implement the polymorphic part of the class interface—and each object contains a pointer to the "vtable" of its class, which is then consulted whenever a polymorphic method is called. This mechanism is an example of:</p>
<ul>
<li><i><a href="/wiki/Late_binding" title="Late binding">late binding</a></i>, because virtual function calls are not bound until the time of invocation, and</li>
<li><i><a href="/wiki/Single_dispatch" title="Single dispatch" class="mw-redirect">single dispatch</a></i> (i.e., single-argument polymorphism), because virtual function calls are bound simply by looking through the vtable provided by the first argument (the <code>this</code> object), so the runtime types of the other arguments are completely irrelevant.</li>
</ul>
<p>The same goes for most other popular object systems. Some, however, such as <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a>, provide <i><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">multiple dispatch</a></i>, under which method calls are polymorphic in <i>all</i> arguments.</p>
<h3><span class="mw-headline" id="Polytypism">Polytypism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Polytypism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A related concept is <b>polytypism</b> or <b>data type genericity</b>. A polytypic function is more general than polymorphic, and in such a function, "though one can provide fixed <i>ad hoc</i> cases for specific data types, an <i>ad hoc</i> combinator is absent".<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Type_theory" title="Type theory">Type theory</a></li>
<li><a href="/wiki/Duck_typing" title="Duck typing">Duck typing</a> for polymorphism without (static) types</li>
<li><a href="/wiki/Polymorphic_code" title="Polymorphic code">Polymorphic code</a> (Computer virus terminology)</li>
<li><a href="/wiki/System_F" title="System F">System F</a> for a <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a> with parametric polymorphism.</li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web">Bjarne Stroustrup (February 19, 2007). <a rel="nofollow" class="external text" href="http://www.stroustrup.com/glossary.html#Gpolymorphism">"Bjarne Stroustrup's C++ Glossary"</a>. "polymorphism - providing a single interface to entities of different types."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.au=Bjarne+Stroustrup&amp;rft.aulast=Bjarne+Stroustrup&amp;rft.btitle=Bjarne+Stroustrup%27s+C%2B%2B+Glossary&amp;rft.date=February+19%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.stroustrup.com%2Fglossary.html%23Gpolymorphism&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Luca-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-Luca_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Luca_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span id="CITEREFCardelliWegner1985" class="citation journal"><a href="/wiki/Luca_Cardelli" title="Luca Cardelli">Cardelli, Luca</a>; <a href="/wiki/Peter_Wegner" title="Peter Wegner">Wegner, Peter</a> (December 1985). <a rel="nofollow" class="external text" href="http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf">"On understanding types, data abstraction, and polymorphism"</a>. <i><a href="/wiki/ACM_Computing_Surveys" title="ACM Computing Surveys">ACM Computing Surveys</a></i> (New York, NY, USA: <a href="/wiki/Association_for_Computing_Machinery" title="Association for Computing Machinery">ACM</a>) <b>17</b> (4): 471–523. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F6041.6042">10.1145/6041.6042</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0360-0300">0360-0300</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.atitle=On+understanding+types%2C+data+abstraction%2C+and+polymorphism&amp;rft.au=Cardelli%2C+Luca&amp;rft.aufirst=Luca&amp;rft.aulast=Cardelli&amp;rft.au=Wegner%2C+Peter&amp;rft.date=December+1985&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flucacardelli.name%2FPapers%2FOnUnderstanding.A4.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F6041.6042&amp;rft.issn=0360-0300&amp;rft.issue=4&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.pages=471-523&amp;rft.place=New+York%2C+NY%2C+USA&amp;rft.pub=ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=17" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1145.2F6041.6042&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span>: "Polymorphic types are types whose operations are applicable to values of more than one type."</span></li>
<li id="cite_note-gbooch-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-gbooch_3-0">^</a></b></span> <span class="reference-text">Booch, et all 2007 <i>Object-Oriented Analysis and Design with Applications.</i> Addison-Wesley.</span></li>
<li id="cite_note-Strachey-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-Strachey_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Strachey_4-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">C. Strachey - <i>Fundamental Concepts in Programming Languages</i> <a rel="nofollow" class="external free" href="http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf">http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf</a></span></li>
<li id="cite_note-Tucker2004-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-Tucker2004_5-0">^</a></b></span> <span class="reference-text"><span class="citation book">Allen B. Tucker (28 June 2004). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=9IFMCsQJyscC&amp;pg=SA91-PA5"><i>Computer Science Handbook, Second Edition</i></a>. Taylor &amp; Francis. pp. 91–. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-1-58488-360-9" title="Special:BookSources/978-1-58488-360-9">978-1-58488-360-9</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.au=Allen+B.+Tucker&amp;rft.aulast=Allen+B.+Tucker&amp;rft.btitle=Computer+Science+Handbook%2C+Second+Edition&amp;rft.date=28+June+2004&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3D9IFMCsQJyscC%26pg%3DSA91-PA5&amp;rft.isbn=978-1-58488-360-9&amp;rft.pages=91-&amp;rft.pub=Taylor+%26+Francis&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-bjpierce-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-bjpierce_6-0">^</a></b></span> <span class="reference-text">Pierce, B. C. 2002 <i>Types and Programming Languages.</i> MIT Press.</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Ralf Lammel and Joost Visser, "Typed Combinators for Generic Traversal", in <i>Practical Aspects of Declarative Languages: 4th International Symposium</i> (2002), p. 153.</span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.cplusplus.com/doc/tutorial/polymorphism/">C++ examples of polymorphism</a></li>
<li><a rel="nofollow" class="external text" href="http://wiki.visual-prolog.com/index.php?title=Objects_and_Polymorphism">Objects and Polymorphism (Visual Prolog)</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_types" title="Template:Data types"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_types" title="Template talk:Data types"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_types&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Bit" title="Bit">Bit</a></li>
<li><a href="/wiki/Byte" title="Byte">Byte</a></li>
<li><a href="/wiki/Ternary_numeral_system" title="Ternary numeral system">Trit</a></li>
<li><a href="/wiki/Ternary_numeral_system#Tryte" title="Ternary numeral system">Tryte</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
<ul>
<li><a href="/wiki/Arbitrary-precision_arithmetic" title="Arbitrary-precision arithmetic">Bignum</a></li>
<li><a href="/wiki/Complex_data_type" title="Complex data type">Complex</a></li>
<li><a href="/wiki/Decimal_data_type" title="Decimal data type">Decimal</a></li>
<li><a href="/wiki/Fixed-point_arithmetic" title="Fixed-point arithmetic">Fixed-point</a></li>
<li><a href="/wiki/Floating_point" title="Floating point">Floating-point</a></li>
<li><a href="/wiki/Integer_(computer_science)" title="Integer (computer science)">Integer</a>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
</li>
<li><a href="/wiki/Interval_arithmetic" title="Interval arithmetic">Interval</a></li>
<li><a href="/wiki/Rational_data_type" title="Rational data type">Rational</a></li>
</ul>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
<ul>
<li><a href="/wiki/Character_(computing)" title="Character (computing)">Character</a></li>
<li><a href="/wiki/String_(computer_science)" title="String (computer science)">String</a>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_address" title="Memory address">Address</a>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
</li>
<li><a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">Reference</a></li>
</ul>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
<ul>
<li><a href="/wiki/Algebraic_data_type" title="Algebraic data type">Algebraic data type</a>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
</li>
<li><a href="/wiki/Array_data_type" title="Array data type">Array</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">Class</a></li>
<li><a href="/wiki/Dependent_type" title="Dependent type">Dependent</a></li>
<li><a href="/wiki/Intuitionistic_type_theory#Equality_type" title="Intuitionistic type theory">Equality</a></li>
<li><a href="/wiki/Inductive_type" title="Inductive type">Inductive</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Object_(computer_science)" title="Object (computer science)">Object</a>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
</li>
<li><a href="/wiki/Option_type" title="Option type">Option type</a></li>
<li><a href="/wiki/Product_type" title="Product type">Product</a></li>
<li><a href="/wiki/Record_(computer_science)" title="Record (computer science)">Record</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a></li>
<li><a href="/wiki/Union_type" title="Union type">Union</a>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
<ul>
<li><a href="/wiki/Boolean_data_type" title="Boolean data type">Boolean</a></li>
<li><a href="/wiki/Bottom_type" title="Bottom type">Bottom type</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Collection</a></li>
<li><a href="/wiki/Enumerated_type" title="Enumerated type">Enumerated type</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception</a></li>
<li><a href="/wiki/Function_type" title="Function type">Function type</a></li>
<li><a href="/wiki/Opaque_data_type" title="Opaque data type">Opaque data type</a></li>
<li><a href="/wiki/Recursive_data_type" title="Recursive data type">Recursive data type</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Stream_(computing)" title="Stream (computing)">Stream</a></li>
<li><a href="/wiki/Top_type" title="Top type">Top type</a></li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Unit_type" title="Unit type">Unit type</a></li>
<li><a href="/wiki/Void_type" title="Void type">Void</a></li>
</ul>
<ul>
<li><a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract data type</a></li>
<li><a href="/wiki/Data_structure" title="Data structure">Data structure</a></li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Kind_(type_theory)" title="Kind (type theory)">Kind</a>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
</li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Primitive_data_type" title="Primitive data type">Primitive data type</a></li>
<li><a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">Protocol</a>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Type_constructor" title="Type constructor">Type constructor</a></li>
<li><a href="/wiki/Type_conversion" title="Type conversion">Type conversion</a></li>
<li><a href="/wiki/Type_system" title="Type system">Type system</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Polymorphism (computer science)</span></h1>
<ul>
<li><a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism">Ad hoc polymorphism</a></li>
<li><a href="/wiki/Function_overloading" title="Function overloading">Function overloading</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Double_dispatch" title="Double dispatch">Double dispatch</a></li>
<li><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">Multiple dispatch</a></li>
<li><a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">Single &amp; dynamic dispatch</a></li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Virtual_function" title="Virtual function">Virtual function</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Polymorphism" title="Template:Polymorphism"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Polymorphism" title="Template talk:Polymorphism"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Polymorphism&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p>In <a href="/wiki/Programming_language" title="Programming language">programming languages</a> and <a href="/wiki/Type_theory" title="Type theory">type theory</a>, <b>polymorphism</b> (from Greek <a href="//en.wiktionary.org/wiki/%CF%80%CE%BF%CE%BB%CF%8D%CF%82#Ancient_Greek" class="extiw" title="wikt:πολύς">πολύς</a>, polys, "many, much" and <a href="//en.wiktionary.org/wiki/%CE%BC%CE%BF%CF%81%CF%86%CE%AE#Ancient_Greek" class="extiw" title="wikt:μορφή">μορφή</a>, morphē, "form, shape") is the providing of a single <a href="/wiki/Interface_(computing)" title="Interface (computing)">interface</a> to entities of different <a href="/wiki/Data_type" title="Data type">types</a>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> A <b>polymorphic type</b> is a type whose operations can also be applied to values of some other type, or types.<sup id="cite_ref-Luca_2-0" class="reference"><a href="#cite_note-Luca-2"><span>[</span>2<span>]</span></a></sup> There are several fundamentally different kinds of polymorphism:</p>
<ul>
<li>If a function denotes different and potentially heterogeneous implementations depending on a limited range of individually specified types and combinations, it is called <a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism"><i>ad hoc</i> polymorphism</a>. <i>Ad hoc</i> polymorphism is supported in many languages using <a href="/wiki/Function_overloading" title="Function overloading">function overloading</a>.</li>
<li>If the code is written without mention of any specific type and thus can be used transparently with any number of new types, it is called <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>. In the object-oriented programming community, this is often known as <i>generics</i> or <i><a href="/wiki/Generic_programming" title="Generic programming">generic programming</a></i>. In the functional programming community, this is often simply called <i>polymorphism</i>.</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a> (or <i>inclusion polymorphism</i>) is a concept wherein a name may denote instances of many different classes as long as they are related by some common superclass.<sup id="cite_ref-gbooch_3-0" class="reference"><a href="#cite_note-gbooch-3"><span>[</span>3<span>]</span></a></sup> In object-oriented programming, this is often referred to simply as <i>polymorphism</i>.</li>
</ul>
<p>The interaction between parametric polymorphism and subtyping leads to the concepts of <a href="/wiki/Covariance_and_contravariance_(computer_science)" title="Covariance and contravariance (computer science)">variance</a> and <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded quantification</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Types_of_polymorphism"><span class="tocnumber">2</span> <span class="toctext">Types of polymorphism</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Ad_hoc_polymorphism"><span class="tocnumber">2.1</span> <span class="toctext">Ad hoc polymorphism</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Parametric_polymorphism"><span class="tocnumber">2.2</span> <span class="toctext">Parametric polymorphism</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Subtyping"><span class="tocnumber">2.3</span> <span class="toctext"> Subtyping</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Polytypism"><span class="tocnumber">2.4</span> <span class="toctext">Polytypism</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">5</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Ad_hoc_polymorphism"><span class="tocnumber">2.1</span> <span class="toctext">Ad hoc polymorphism</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Parametric_polymorphism"><span class="tocnumber">2.2</span> <span class="toctext">Parametric polymorphism</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Subtyping"><span class="tocnumber">2.3</span> <span class="toctext"> Subtyping</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Polytypism"><span class="tocnumber">2.4</span> <span class="toctext">Polytypism</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><i>Ad hoc</i> polymorphism and parametric polymorphism were originally described in <i><a href="/wiki/Fundamental_Concepts_in_Programming_Languages" title="Fundamental Concepts in Programming Languages">Fundamental Concepts in Programming Languages</a></i>, a set of lecture notes written in 1967 by British computer scientist <a href="/wiki/Christopher_Strachey" title="Christopher Strachey">Christopher Strachey</a>.<sup id="cite_ref-Strachey_4-0" class="reference"><a href="#cite_note-Strachey-4"><span>[</span>4<span>]</span></a></sup> In a 1985 paper, <a href="/wiki/Peter_Wegner" title="Peter Wegner">Peter Wegner</a> and <a href="/wiki/Luca_Cardelli" title="Luca Cardelli">Luca Cardelli</a> introduced the term <i>inclusion polymorphism</i> to model subtypes and <a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">inheritance</a>.<sup id="cite_ref-Luca_2-1" class="reference"><a href="#cite_note-Luca-2"><span>[</span>2<span>]</span></a></sup> However, implementations of subtyping and inheritance predate the term 'inclusion polymorphism', having appeared with <a href="/wiki/Simula" title="Simula">Simula</a> in 1967.</p>
<h2><span class="mw-headline" id="Types_of_polymorphism">Types of polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Types of polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Ad_hoc_polymorphism">Ad hoc polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Ad hoc polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="/wiki/Chris_Strachey" title="Chris Strachey" class="mw-redirect">Chris Strachey</a><sup id="cite_ref-Strachey_4-1" class="reference"><a href="#cite_note-Strachey-4"><span>[</span>4<span>]</span></a></sup> chose the term ad hoc polymorphism to refer to polymorphic functions which can be applied to arguments of different types, but which behave differently depending on the type of the argument to which they are applied (also known as <a href="/wiki/Function_overloading" title="Function overloading">function overloading</a> or <a href="/wiki/Operator_overloading" title="Operator overloading">operator overloading</a>). The term "<a href="/wiki/Ad_hoc" title="Ad hoc">ad hoc</a>" in this context is not intended to be pejorative; it refers simply to the fact that this type of polymorphism is not a fundamental feature of the type system. In the example below, the <code>Add</code> functions seem to work generically over various types when looking at the invocations, but are considered to be two entirely distinct functions by the compiler for all intents and purposes:</p>
<p>WHATSON? bdb752bf-26fb-476b-acbd-64d42cbf1be1</p>
<pre class="de1">
<span class="kw1">program</span> Adhoc<span class="sy1">;</span>
 
<span class="kw1">function</span> Add<span class="br0">(</span> x<span class="sy1">,</span> y <span class="sy1">:</span> <span class="kw4">Integer</span> <span class="br0">)</span> <span class="sy1">:</span> <span class="kw4">Integer</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    Add <span class="sy1">:</span><span class="sy3">=</span> x <span class="sy3">+</span> y
<span class="kw1">end</span><span class="sy1">;</span>
 
<span class="kw1">function</span> Add<span class="br0">(</span> s<span class="sy1">,</span> t <span class="sy1">:</span> <span class="kw4">String</span> <span class="br0">)</span> <span class="sy1">:</span> <span class="kw4">String</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    Add <span class="sy1">:</span><span class="sy3">=</span> Concat<span class="br0">(</span> s<span class="sy1">,</span> t <span class="br0">)</span>
<span class="kw1">end</span><span class="sy1">;</span>
 
<span class="kw1">begin</span>
    <span class="kw3">Writeln</span><span class="br0">(</span>Add<span class="br0">(</span><span class="nu0">1</span><span class="sy1">,</span> <span class="nu0">2</span><span class="br0">)</span><span class="br0">)</span><span class="sy1">;</span>
    <span class="kw3">Writeln</span><span class="br0">(</span>Add<span class="br0">(</span><span class="st0">'Hello, '</span><span class="sy1">,</span> <span class="st0">'World!'</span><span class="br0">)</span><span class="br0">)</span><span class="sy1">;</span>
<span class="kw1">end</span><span class="sy1">.</span>
</pre>
<p>In <a href="/wiki/Dynamically_typed" title="Dynamically typed" class="mw-redirect">dynamically typed</a> languages the situation can be more complex as the correct function that needs to be invoked might only be determinable at run time.</p>
<p>Implicit type conversion has also been defined as a form of polymorphism, referred to as "coercion polymorphism".<sup id="cite_ref-Tucker2004_5-0" class="reference"><a href="#cite_note-Tucker2004-5"><span>[</span>5<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Parametric_polymorphism">Parametric polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Parametric polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Parametric polymorphism allows a function or a data type to be written generically, so that it can handle values <i>identically</i> without depending on their type.<sup id="cite_ref-bjpierce_6-0" class="reference"><a href="#cite_note-bjpierce-6"><span>[</span>6<span>]</span></a></sup> Parametric polymorphism is a way to make a language more expressive, while still maintaining full static <a href="/wiki/Type-safety" title="Type-safety" class="mw-redirect">type-safety</a>.</p>
<p>The concept of parametric polymorphism applies to both <a href="/wiki/Data_type" title="Data type">data types</a> and <a href="/wiki/Function_(programming)" title="Function (programming)" class="mw-redirect">functions</a>. A function that can evaluate to or be applied to values of different types is known as a <i>polymorphic function.</i> A data type that can appear to be of a generalized type (e.g., a <a href="/wiki/List_(computing)" title="List (computing)" class="mw-redirect">list</a> with elements of arbitrary type) is designated <i>polymorphic data type</i> like the generalized type from which such specializations are made.</p>
<p>Parametric polymorphism is ubiquitous in functional programming, where it is often simply referred to as "polymorphism". The following example shows a parametrized list data type and two parametrically polymorphic functions on them:</p>
<p>WHATSON? eab263c8-bffa-4e75-aaca-e182f63c0b91</p>
<pre class="de1">
<span class="kw1">data</span> List a <span class="sy0">=</span> Nil <span class="sy0">|</span> Cons a <span class="br0">(</span>List a<span class="br0">)</span>
 
<span class="kw3">length</span> <span class="sy0">::</span> List a <span class="sy0">-&gt;</span> <span class="kw4">Integer</span>
<span class="kw3">length</span> Nil         <span class="sy0">=</span> <span class="nu0">0</span>
<span class="kw3">length</span> <span class="br0">(</span>Cons x xs<span class="br0">)</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> <span class="kw3">length</span> xs
 
<span class="kw3">map</span> <span class="sy0">::</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> List a <span class="sy0">-&gt;</span> List b
<span class="kw3">map</span> f Nil         <span class="sy0">=</span> Nil
<span class="kw3">map</span> f <span class="br0">(</span>Cons x xs<span class="br0">)</span> <span class="sy0">=</span> Cons <span class="br0">(</span>f x<span class="br0">)</span> <span class="br0">(</span><span class="kw3">map</span> f xs<span class="br0">)</span>
</pre>
<p>Parametric polymorphism is also available in several object-oriented languages, where it often goes under the name "generics" (for example, Java) or "<a href="/wiki/Template_(C%2B%2B)" title="Template (C++)">templates</a>" (C++ and D):</p>
<p>WHATSON? c2568f8e-6214-459d-95f3-13e942f48892</p>
<pre class="de1">
<span class="kw4">class</span> List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
    <span class="kw4">class</span> Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
        T elem<span class="sy0">;</span>
        Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> next<span class="sy0">;</span>
    <span class="br0">}</span>
    Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> head<span class="sy0">;</span>
    <span class="kw4">int</span> length<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="sy0">...</span> <span class="br0">}</span>
<span class="br0">}</span>
 
List<span class="sy0">&lt;</span>B<span class="sy0">&gt;</span> map<span class="br0">(</span>Func<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> f, List<span class="sy0">&lt;</span>A<span class="sy0">&gt;</span> xs<span class="br0">)</span> <span class="br0">{</span>
    <span class="sy0">...</span>
<span class="br0">}</span>
</pre>
<p><a href="/wiki/John_C._Reynolds" title="John C. Reynolds">John C. Reynolds</a> (and later <a href="/wiki/Jean-Yves_Girard" title="Jean-Yves Girard">Jean-Yves Girard</a>) formally developed this notion of polymorphism as an extension to lambda calculus (called the <a href="/wiki/Polymorphic_Lambda_Calculus" title="Polymorphic Lambda Calculus" class="mw-redirect">polymorphic lambda calculus</a>, or <a href="/wiki/System_F" title="System F">System F</a>). Any parametrically polymorphic function is necessarily restricted in what it can do, working on the shape of the data instead of its value, leading to the concept of <a href="/wiki/Parametricity" title="Parametricity">parametricity</a>.</p>
<h3><span class="mw-headline" id="Subtyping"><span id="Subtyping"></span><span id="Subtype_polymorphism"></span> Subtyping</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Subtyping">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages employ the idea of <b>subtyping</b> to restrict the range of types that can be used in a particular case of polymorphism. In these languages, <b>subtype polymorphism</b> (sometimes referred to as <b>inclusion polymorphism</b> or <b>dynamic polymorphism</b><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2013)">citation needed</span></a></i>]</sup>) allows a function to be written to take an object of a certain type <i>T</i>, but also work correctly if passed an object that belongs to a type <i>S</i> that is a subtype of <i>T</i> (according to the <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>). This type relation is sometimes written <i>S</i> &lt;: <i>T</i>. Conversely, <i>T</i> is said to be a <i>supertype</i> of <i>S</i>—written <i>T</i> :&gt; <i>S</i>.</p>
<p>In the following example we make cats and dogs subtypes of animals. The procedure letsHear() accepts an animal, but will also work correctly if a subtype is passed to it:</p>
<p>WHATSON? 82265966-4933-4fda-bed7-55f623104c6d</p>
<pre class="de1">
<span class="kw1">abstract</span> <span class="kw1">class</span> Animal <span class="br0">{</span>
    <span class="kw1">abstract</span> <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw1">class</span> Cat <span class="kw1">extends</span> Animal <span class="br0">{</span>
    <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> <span class="st0">"Meow!"</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw1">class</span> Dog <span class="kw1">extends</span> Animal <span class="br0">{</span>
    <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> <span class="st0">"Woof!"</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> letsHear<span class="br0">(</span>Animal a<span class="br0">)</span> <span class="br0">{</span>
    println<span class="br0">(</span>a.<span class="me1">talk</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    letsHear<span class="br0">(</span><span class="kw1">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    letsHear<span class="br0">(</span><span class="kw1">new</span> Dog<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>In another example, if <code>Number</code>, <code>Rational</code>, and <code>Integer</code> are types such that <code>Number</code> :&gt; <code>Rational</code> and <code>Number</code> :&gt; <code>Integer</code>, a function written to take a <code>Number</code> will work equally well when passed an <code>Integer</code> or <code>Rational</code> as when passed a <code>Number</code>. The actual type of the object can be hidden from clients into a <a href="/wiki/Black_box_(systems)" title="Black box (systems)" class="mw-redirect">black box</a>, and accessed via object <a href="/wiki/Identity_(object-oriented_programming)" title="Identity (object-oriented programming)">identity</a>. In fact, if the <code>Number</code> type is <i>abstract</i>, it may not even be possible to get your hands on an object whose <i>most-derived</i> type is <code>Number</code> (see <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data type</a>, <a href="/wiki/Abstract_class" title="Abstract class" class="mw-redirect">abstract class</a>). This particular kind of type hierarchy is known—especially in the context of the <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme programming language</a>—as a <i><a href="/wiki/Numerical_tower" title="Numerical tower">numerical tower</a></i>, and usually contains many more types.</p>
<p><a href="/wiki/Object-oriented_programming_language" title="Object-oriented programming language" class="mw-redirect">Object-oriented programming languages</a> offer subtyping polymorphism using <i><a href="/wiki/Subclass_(computer_science)" title="Subclass (computer science)" class="mw-redirect">subclassing</a></i> (also known as <i><a href="/wiki/Inheritance_in_object-oriented_programming" title="Inheritance in object-oriented programming" class="mw-redirect">inheritance</a></i>). In typical implementations, each class contains what is called a <i><a href="/wiki/Virtual_table" title="Virtual table" class="mw-redirect">virtual table</a></i>—a table of functions that implement the polymorphic part of the class interface—and each object contains a pointer to the "vtable" of its class, which is then consulted whenever a polymorphic method is called. This mechanism is an example of:</p>
<ul>
<li><i><a href="/wiki/Late_binding" title="Late binding">late binding</a></i>, because virtual function calls are not bound until the time of invocation, and</li>
<li><i><a href="/wiki/Single_dispatch" title="Single dispatch" class="mw-redirect">single dispatch</a></i> (i.e., single-argument polymorphism), because virtual function calls are bound simply by looking through the vtable provided by the first argument (the <code>this</code> object), so the runtime types of the other arguments are completely irrelevant.</li>
</ul>
<p>The same goes for most other popular object systems. Some, however, such as <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a>, provide <i><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">multiple dispatch</a></i>, under which method calls are polymorphic in <i>all</i> arguments.</p>
<h3><span class="mw-headline" id="Polytypism">Polytypism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Polytypism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A related concept is <b>polytypism</b> or <b>data type genericity</b>. A polytypic function is more general than polymorphic, and in such a function, "though one can provide fixed <i>ad hoc</i> cases for specific data types, an <i>ad hoc</i> combinator is absent".<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Type_theory" title="Type theory">Type theory</a></li>
<li><a href="/wiki/Duck_typing" title="Duck typing">Duck typing</a> for polymorphism without (static) types</li>
<li><a href="/wiki/Polymorphic_code" title="Polymorphic code">Polymorphic code</a> (Computer virus terminology)</li>
<li><a href="/wiki/System_F" title="System F">System F</a> for a <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a> with parametric polymorphism.</li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web">Bjarne Stroustrup (February 19, 2007). <a rel="nofollow" class="external text" href="http://www.stroustrup.com/glossary.html#Gpolymorphism">"Bjarne Stroustrup's C++ Glossary"</a>. "polymorphism - providing a single interface to entities of different types."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.au=Bjarne+Stroustrup&amp;rft.aulast=Bjarne+Stroustrup&amp;rft.btitle=Bjarne+Stroustrup%27s+C%2B%2B+Glossary&amp;rft.date=February+19%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.stroustrup.com%2Fglossary.html%23Gpolymorphism&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Luca-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-Luca_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Luca_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span id="CITEREFCardelliWegner1985" class="citation journal"><a href="/wiki/Luca_Cardelli" title="Luca Cardelli">Cardelli, Luca</a>; <a href="/wiki/Peter_Wegner" title="Peter Wegner">Wegner, Peter</a> (December 1985). <a rel="nofollow" class="external text" href="http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf">"On understanding types, data abstraction, and polymorphism"</a>. <i><a href="/wiki/ACM_Computing_Surveys" title="ACM Computing Surveys">ACM Computing Surveys</a></i> (New York, NY, USA: <a href="/wiki/Association_for_Computing_Machinery" title="Association for Computing Machinery">ACM</a>) <b>17</b> (4): 471–523. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F6041.6042">10.1145/6041.6042</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0360-0300">0360-0300</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.atitle=On+understanding+types%2C+data+abstraction%2C+and+polymorphism&amp;rft.au=Cardelli%2C+Luca&amp;rft.aufirst=Luca&amp;rft.aulast=Cardelli&amp;rft.au=Wegner%2C+Peter&amp;rft.date=December+1985&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flucacardelli.name%2FPapers%2FOnUnderstanding.A4.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F6041.6042&amp;rft.issn=0360-0300&amp;rft.issue=4&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.pages=471-523&amp;rft.place=New+York%2C+NY%2C+USA&amp;rft.pub=ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=17" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1145.2F6041.6042&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span>: "Polymorphic types are types whose operations are applicable to values of more than one type."</span></li>
<li id="cite_note-gbooch-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-gbooch_3-0">^</a></b></span> <span class="reference-text">Booch, et all 2007 <i>Object-Oriented Analysis and Design with Applications.</i> Addison-Wesley.</span></li>
<li id="cite_note-Strachey-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-Strachey_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Strachey_4-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">C. Strachey - <i>Fundamental Concepts in Programming Languages</i> <a rel="nofollow" class="external free" href="http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf">http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf</a></span></li>
<li id="cite_note-Tucker2004-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-Tucker2004_5-0">^</a></b></span> <span class="reference-text"><span class="citation book">Allen B. Tucker (28 June 2004). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=9IFMCsQJyscC&amp;pg=SA91-PA5"><i>Computer Science Handbook, Second Edition</i></a>. Taylor &amp; Francis. pp. 91–. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-1-58488-360-9" title="Special:BookSources/978-1-58488-360-9">978-1-58488-360-9</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.au=Allen+B.+Tucker&amp;rft.aulast=Allen+B.+Tucker&amp;rft.btitle=Computer+Science+Handbook%2C+Second+Edition&amp;rft.date=28+June+2004&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3D9IFMCsQJyscC%26pg%3DSA91-PA5&amp;rft.isbn=978-1-58488-360-9&amp;rft.pages=91-&amp;rft.pub=Taylor+%26+Francis&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-bjpierce-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-bjpierce_6-0">^</a></b></span> <span class="reference-text">Pierce, B. C. 2002 <i>Types and Programming Languages.</i> MIT Press.</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Ralf Lammel and Joost Visser, "Typed Combinators for Generic Traversal", in <i>Practical Aspects of Declarative Languages: 4th International Symposium</i> (2002), p. 153.</span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.cplusplus.com/doc/tutorial/polymorphism/">C++ examples of polymorphism</a></li>
<li><a rel="nofollow" class="external text" href="http://wiki.visual-prolog.com/index.php?title=Objects_and_Polymorphism">Objects and Polymorphism (Visual Prolog)</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_types" title="Template:Data types"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_types" title="Template talk:Data types"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_types&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Bit" title="Bit">Bit</a></li>
<li><a href="/wiki/Byte" title="Byte">Byte</a></li>
<li><a href="/wiki/Ternary_numeral_system" title="Ternary numeral system">Trit</a></li>
<li><a href="/wiki/Ternary_numeral_system#Tryte" title="Ternary numeral system">Tryte</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
<ul>
<li><a href="/wiki/Arbitrary-precision_arithmetic" title="Arbitrary-precision arithmetic">Bignum</a></li>
<li><a href="/wiki/Complex_data_type" title="Complex data type">Complex</a></li>
<li><a href="/wiki/Decimal_data_type" title="Decimal data type">Decimal</a></li>
<li><a href="/wiki/Fixed-point_arithmetic" title="Fixed-point arithmetic">Fixed-point</a></li>
<li><a href="/wiki/Floating_point" title="Floating point">Floating-point</a></li>
<li><a href="/wiki/Integer_(computer_science)" title="Integer (computer science)">Integer</a>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
</li>
<li><a href="/wiki/Interval_arithmetic" title="Interval arithmetic">Interval</a></li>
<li><a href="/wiki/Rational_data_type" title="Rational data type">Rational</a></li>
</ul>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
<ul>
<li><a href="/wiki/Character_(computing)" title="Character (computing)">Character</a></li>
<li><a href="/wiki/String_(computer_science)" title="String (computer science)">String</a>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_address" title="Memory address">Address</a>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
</li>
<li><a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">Reference</a></li>
</ul>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
<ul>
<li><a href="/wiki/Algebraic_data_type" title="Algebraic data type">Algebraic data type</a>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
</li>
<li><a href="/wiki/Array_data_type" title="Array data type">Array</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">Class</a></li>
<li><a href="/wiki/Dependent_type" title="Dependent type">Dependent</a></li>
<li><a href="/wiki/Intuitionistic_type_theory#Equality_type" title="Intuitionistic type theory">Equality</a></li>
<li><a href="/wiki/Inductive_type" title="Inductive type">Inductive</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Object_(computer_science)" title="Object (computer science)">Object</a>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
</li>
<li><a href="/wiki/Option_type" title="Option type">Option type</a></li>
<li><a href="/wiki/Product_type" title="Product type">Product</a></li>
<li><a href="/wiki/Record_(computer_science)" title="Record (computer science)">Record</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a></li>
<li><a href="/wiki/Union_type" title="Union type">Union</a>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
<ul>
<li><a href="/wiki/Boolean_data_type" title="Boolean data type">Boolean</a></li>
<li><a href="/wiki/Bottom_type" title="Bottom type">Bottom type</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Collection</a></li>
<li><a href="/wiki/Enumerated_type" title="Enumerated type">Enumerated type</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception</a></li>
<li><a href="/wiki/Function_type" title="Function type">Function type</a></li>
<li><a href="/wiki/Opaque_data_type" title="Opaque data type">Opaque data type</a></li>
<li><a href="/wiki/Recursive_data_type" title="Recursive data type">Recursive data type</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Stream_(computing)" title="Stream (computing)">Stream</a></li>
<li><a href="/wiki/Top_type" title="Top type">Top type</a></li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Unit_type" title="Unit type">Unit type</a></li>
<li><a href="/wiki/Void_type" title="Void type">Void</a></li>
</ul>
<ul>
<li><a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract data type</a></li>
<li><a href="/wiki/Data_structure" title="Data structure">Data structure</a></li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Kind_(type_theory)" title="Kind (type theory)">Kind</a>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
</li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Primitive_data_type" title="Primitive data type">Primitive data type</a></li>
<li><a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">Protocol</a>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Type_constructor" title="Type constructor">Type constructor</a></li>
<li><a href="/wiki/Type_conversion" title="Type conversion">Type conversion</a></li>
<li><a href="/wiki/Type_system" title="Type system">Type system</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Polymorphism (computer science)</span></h1>
<ul>
<li><a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism">Ad hoc polymorphism</a></li>
<li><a href="/wiki/Function_overloading" title="Function overloading">Function overloading</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Double_dispatch" title="Double dispatch">Double dispatch</a></li>
<li><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">Multiple dispatch</a></li>
<li><a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">Single &amp; dynamic dispatch</a></li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Virtual_function" title="Virtual function">Virtual function</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Polymorphism" title="Template:Polymorphism"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Polymorphism" title="Template talk:Polymorphism"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Polymorphism&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p>In <a href="/wiki/Programming_language" title="Programming language">programming languages</a> and <a href="/wiki/Type_theory" title="Type theory">type theory</a>, <b>polymorphism</b> (from Greek <a href="//en.wiktionary.org/wiki/%CF%80%CE%BF%CE%BB%CF%8D%CF%82#Ancient_Greek" class="extiw" title="wikt:πολύς">πολύς</a>, polys, "many, much" and <a href="//en.wiktionary.org/wiki/%CE%BC%CE%BF%CF%81%CF%86%CE%AE#Ancient_Greek" class="extiw" title="wikt:μορφή">μορφή</a>, morphē, "form, shape") is the providing of a single <a href="/wiki/Interface_(computing)" title="Interface (computing)">interface</a> to entities of different <a href="/wiki/Data_type" title="Data type">types</a>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> A <b>polymorphic type</b> is a type whose operations can also be applied to values of some other type, or types.<sup id="cite_ref-Luca_2-0" class="reference"><a href="#cite_note-Luca-2"><span>[</span>2<span>]</span></a></sup> There are several fundamentally different kinds of polymorphism:</p>
<ul>
<li>If a function denotes different and potentially heterogeneous implementations depending on a limited range of individually specified types and combinations, it is called <a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism"><i>ad hoc</i> polymorphism</a>. <i>Ad hoc</i> polymorphism is supported in many languages using <a href="/wiki/Function_overloading" title="Function overloading">function overloading</a>.</li>
<li>If the code is written without mention of any specific type and thus can be used transparently with any number of new types, it is called <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>. In the object-oriented programming community, this is often known as <i>generics</i> or <i><a href="/wiki/Generic_programming" title="Generic programming">generic programming</a></i>. In the functional programming community, this is often simply called <i>polymorphism</i>.</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a> (or <i>inclusion polymorphism</i>) is a concept wherein a name may denote instances of many different classes as long as they are related by some common superclass.<sup id="cite_ref-gbooch_3-0" class="reference"><a href="#cite_note-gbooch-3"><span>[</span>3<span>]</span></a></sup> In object-oriented programming, this is often referred to simply as <i>polymorphism</i>.</li>
</ul>
<p>The interaction between parametric polymorphism and subtyping leads to the concepts of <a href="/wiki/Covariance_and_contravariance_(computer_science)" title="Covariance and contravariance (computer science)">variance</a> and <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded quantification</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Types_of_polymorphism"><span class="tocnumber">2</span> <span class="toctext">Types of polymorphism</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Ad_hoc_polymorphism"><span class="tocnumber">2.1</span> <span class="toctext">Ad hoc polymorphism</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Parametric_polymorphism"><span class="tocnumber">2.2</span> <span class="toctext">Parametric polymorphism</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Subtyping"><span class="tocnumber">2.3</span> <span class="toctext"> Subtyping</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Polytypism"><span class="tocnumber">2.4</span> <span class="toctext">Polytypism</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">5</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Ad_hoc_polymorphism"><span class="tocnumber">2.1</span> <span class="toctext">Ad hoc polymorphism</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Parametric_polymorphism"><span class="tocnumber">2.2</span> <span class="toctext">Parametric polymorphism</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Subtyping"><span class="tocnumber">2.3</span> <span class="toctext"> Subtyping</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Polytypism"><span class="tocnumber">2.4</span> <span class="toctext">Polytypism</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><i>Ad hoc</i> polymorphism and parametric polymorphism were originally described in <i><a href="/wiki/Fundamental_Concepts_in_Programming_Languages" title="Fundamental Concepts in Programming Languages">Fundamental Concepts in Programming Languages</a></i>, a set of lecture notes written in 1967 by British computer scientist <a href="/wiki/Christopher_Strachey" title="Christopher Strachey">Christopher Strachey</a>.<sup id="cite_ref-Strachey_4-0" class="reference"><a href="#cite_note-Strachey-4"><span>[</span>4<span>]</span></a></sup> In a 1985 paper, <a href="/wiki/Peter_Wegner" title="Peter Wegner">Peter Wegner</a> and <a href="/wiki/Luca_Cardelli" title="Luca Cardelli">Luca Cardelli</a> introduced the term <i>inclusion polymorphism</i> to model subtypes and <a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">inheritance</a>.<sup id="cite_ref-Luca_2-1" class="reference"><a href="#cite_note-Luca-2"><span>[</span>2<span>]</span></a></sup> However, implementations of subtyping and inheritance predate the term 'inclusion polymorphism', having appeared with <a href="/wiki/Simula" title="Simula">Simula</a> in 1967.</p>
<h2><span class="mw-headline" id="Types_of_polymorphism">Types of polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Types of polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Ad_hoc_polymorphism">Ad hoc polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Ad hoc polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="/wiki/Chris_Strachey" title="Chris Strachey" class="mw-redirect">Chris Strachey</a><sup id="cite_ref-Strachey_4-1" class="reference"><a href="#cite_note-Strachey-4"><span>[</span>4<span>]</span></a></sup> chose the term ad hoc polymorphism to refer to polymorphic functions which can be applied to arguments of different types, but which behave differently depending on the type of the argument to which they are applied (also known as <a href="/wiki/Function_overloading" title="Function overloading">function overloading</a> or <a href="/wiki/Operator_overloading" title="Operator overloading">operator overloading</a>). The term "<a href="/wiki/Ad_hoc" title="Ad hoc">ad hoc</a>" in this context is not intended to be pejorative; it refers simply to the fact that this type of polymorphism is not a fundamental feature of the type system. In the example below, the <code>Add</code> functions seem to work generically over various types when looking at the invocations, but are considered to be two entirely distinct functions by the compiler for all intents and purposes:</p>
<p>WHATSON? 9863f7f3-45a6-40ad-acf5-9a581bf546ec</p>
<pre class="de1">
<span class="kw1">program</span> Adhoc<span class="sy1">;</span>
 
<span class="kw1">function</span> Add<span class="br0">(</span> x<span class="sy1">,</span> y <span class="sy1">:</span> <span class="kw4">Integer</span> <span class="br0">)</span> <span class="sy1">:</span> <span class="kw4">Integer</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    Add <span class="sy1">:</span><span class="sy3">=</span> x <span class="sy3">+</span> y
<span class="kw1">end</span><span class="sy1">;</span>
 
<span class="kw1">function</span> Add<span class="br0">(</span> s<span class="sy1">,</span> t <span class="sy1">:</span> <span class="kw4">String</span> <span class="br0">)</span> <span class="sy1">:</span> <span class="kw4">String</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    Add <span class="sy1">:</span><span class="sy3">=</span> Concat<span class="br0">(</span> s<span class="sy1">,</span> t <span class="br0">)</span>
<span class="kw1">end</span><span class="sy1">;</span>
 
<span class="kw1">begin</span>
    <span class="kw3">Writeln</span><span class="br0">(</span>Add<span class="br0">(</span><span class="nu0">1</span><span class="sy1">,</span> <span class="nu0">2</span><span class="br0">)</span><span class="br0">)</span><span class="sy1">;</span>
    <span class="kw3">Writeln</span><span class="br0">(</span>Add<span class="br0">(</span><span class="st0">'Hello, '</span><span class="sy1">,</span> <span class="st0">'World!'</span><span class="br0">)</span><span class="br0">)</span><span class="sy1">;</span>
<span class="kw1">end</span><span class="sy1">.</span>
</pre>
<p>In <a href="/wiki/Dynamically_typed" title="Dynamically typed" class="mw-redirect">dynamically typed</a> languages the situation can be more complex as the correct function that needs to be invoked might only be determinable at run time.</p>
<p>Implicit type conversion has also been defined as a form of polymorphism, referred to as "coercion polymorphism".<sup id="cite_ref-Tucker2004_5-0" class="reference"><a href="#cite_note-Tucker2004-5"><span>[</span>5<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Parametric_polymorphism">Parametric polymorphism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Parametric polymorphism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Parametric polymorphism allows a function or a data type to be written generically, so that it can handle values <i>identically</i> without depending on their type.<sup id="cite_ref-bjpierce_6-0" class="reference"><a href="#cite_note-bjpierce-6"><span>[</span>6<span>]</span></a></sup> Parametric polymorphism is a way to make a language more expressive, while still maintaining full static <a href="/wiki/Type-safety" title="Type-safety" class="mw-redirect">type-safety</a>.</p>
<p>The concept of parametric polymorphism applies to both <a href="/wiki/Data_type" title="Data type">data types</a> and <a href="/wiki/Function_(programming)" title="Function (programming)" class="mw-redirect">functions</a>. A function that can evaluate to or be applied to values of different types is known as a <i>polymorphic function.</i> A data type that can appear to be of a generalized type (e.g., a <a href="/wiki/List_(computing)" title="List (computing)" class="mw-redirect">list</a> with elements of arbitrary type) is designated <i>polymorphic data type</i> like the generalized type from which such specializations are made.</p>
<p>Parametric polymorphism is ubiquitous in functional programming, where it is often simply referred to as "polymorphism". The following example shows a parametrized list data type and two parametrically polymorphic functions on them:</p>
<p>WHATSON? ed3bbf2d-d34c-41ce-9a9e-23e4189b3d42</p>
<pre class="de1">
<span class="kw1">data</span> List a <span class="sy0">=</span> Nil <span class="sy0">|</span> Cons a <span class="br0">(</span>List a<span class="br0">)</span>
 
<span class="kw3">length</span> <span class="sy0">::</span> List a <span class="sy0">-&gt;</span> <span class="kw4">Integer</span>
<span class="kw3">length</span> Nil         <span class="sy0">=</span> <span class="nu0">0</span>
<span class="kw3">length</span> <span class="br0">(</span>Cons x xs<span class="br0">)</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> <span class="kw3">length</span> xs
 
<span class="kw3">map</span> <span class="sy0">::</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> List a <span class="sy0">-&gt;</span> List b
<span class="kw3">map</span> f Nil         <span class="sy0">=</span> Nil
<span class="kw3">map</span> f <span class="br0">(</span>Cons x xs<span class="br0">)</span> <span class="sy0">=</span> Cons <span class="br0">(</span>f x<span class="br0">)</span> <span class="br0">(</span><span class="kw3">map</span> f xs<span class="br0">)</span>
</pre>
<p>Parametric polymorphism is also available in several object-oriented languages, where it often goes under the name "generics" (for example, Java) or "<a href="/wiki/Template_(C%2B%2B)" title="Template (C++)">templates</a>" (C++ and D):</p>
<p>WHATSON? 6fbf7765-83d7-4ec6-9dd9-1a9b61164fb6</p>
<pre class="de1">
<span class="kw4">class</span> List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
    <span class="kw4">class</span> Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
        T elem<span class="sy0">;</span>
        Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> next<span class="sy0">;</span>
    <span class="br0">}</span>
    Node<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> head<span class="sy0">;</span>
    <span class="kw4">int</span> length<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="sy0">...</span> <span class="br0">}</span>
<span class="br0">}</span>
 
List<span class="sy0">&lt;</span>B<span class="sy0">&gt;</span> map<span class="br0">(</span>Func<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> f, List<span class="sy0">&lt;</span>A<span class="sy0">&gt;</span> xs<span class="br0">)</span> <span class="br0">{</span>
    <span class="sy0">...</span>
<span class="br0">}</span>
</pre>
<p><a href="/wiki/John_C._Reynolds" title="John C. Reynolds">John C. Reynolds</a> (and later <a href="/wiki/Jean-Yves_Girard" title="Jean-Yves Girard">Jean-Yves Girard</a>) formally developed this notion of polymorphism as an extension to lambda calculus (called the <a href="/wiki/Polymorphic_Lambda_Calculus" title="Polymorphic Lambda Calculus" class="mw-redirect">polymorphic lambda calculus</a>, or <a href="/wiki/System_F" title="System F">System F</a>). Any parametrically polymorphic function is necessarily restricted in what it can do, working on the shape of the data instead of its value, leading to the concept of <a href="/wiki/Parametricity" title="Parametricity">parametricity</a>.</p>
<h3><span class="mw-headline" id="Subtyping"><span id="Subtyping"></span><span id="Subtype_polymorphism"></span> Subtyping</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Subtyping">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages employ the idea of <b>subtyping</b> to restrict the range of types that can be used in a particular case of polymorphism. In these languages, <b>subtype polymorphism</b> (sometimes referred to as <b>inclusion polymorphism</b> or <b>dynamic polymorphism</b><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2013)">citation needed</span></a></i>]</sup>) allows a function to be written to take an object of a certain type <i>T</i>, but also work correctly if passed an object that belongs to a type <i>S</i> that is a subtype of <i>T</i> (according to the <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>). This type relation is sometimes written <i>S</i> &lt;: <i>T</i>. Conversely, <i>T</i> is said to be a <i>supertype</i> of <i>S</i>—written <i>T</i> :&gt; <i>S</i>.</p>
<p>In the following example we make cats and dogs subtypes of animals. The procedure letsHear() accepts an animal, but will also work correctly if a subtype is passed to it:</p>
<p>WHATSON? 8bdee250-84a7-4e68-aa79-50890674c7d0</p>
<pre class="de1">
<span class="kw1">abstract</span> <span class="kw1">class</span> Animal <span class="br0">{</span>
    <span class="kw1">abstract</span> <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw1">class</span> Cat <span class="kw1">extends</span> Animal <span class="br0">{</span>
    <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> <span class="st0">"Meow!"</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw1">class</span> Dog <span class="kw1">extends</span> Animal <span class="br0">{</span>
    <span class="kw3">String</span> talk<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">return</span> <span class="st0">"Woof!"</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> letsHear<span class="br0">(</span>Animal a<span class="br0">)</span> <span class="br0">{</span>
    println<span class="br0">(</span>a.<span class="me1">talk</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    letsHear<span class="br0">(</span><span class="kw1">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    letsHear<span class="br0">(</span><span class="kw1">new</span> Dog<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>In another example, if <code>Number</code>, <code>Rational</code>, and <code>Integer</code> are types such that <code>Number</code> :&gt; <code>Rational</code> and <code>Number</code> :&gt; <code>Integer</code>, a function written to take a <code>Number</code> will work equally well when passed an <code>Integer</code> or <code>Rational</code> as when passed a <code>Number</code>. The actual type of the object can be hidden from clients into a <a href="/wiki/Black_box_(systems)" title="Black box (systems)" class="mw-redirect">black box</a>, and accessed via object <a href="/wiki/Identity_(object-oriented_programming)" title="Identity (object-oriented programming)">identity</a>. In fact, if the <code>Number</code> type is <i>abstract</i>, it may not even be possible to get your hands on an object whose <i>most-derived</i> type is <code>Number</code> (see <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data type</a>, <a href="/wiki/Abstract_class" title="Abstract class" class="mw-redirect">abstract class</a>). This particular kind of type hierarchy is known—especially in the context of the <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme programming language</a>—as a <i><a href="/wiki/Numerical_tower" title="Numerical tower">numerical tower</a></i>, and usually contains many more types.</p>
<p><a href="/wiki/Object-oriented_programming_language" title="Object-oriented programming language" class="mw-redirect">Object-oriented programming languages</a> offer subtyping polymorphism using <i><a href="/wiki/Subclass_(computer_science)" title="Subclass (computer science)" class="mw-redirect">subclassing</a></i> (also known as <i><a href="/wiki/Inheritance_in_object-oriented_programming" title="Inheritance in object-oriented programming" class="mw-redirect">inheritance</a></i>). In typical implementations, each class contains what is called a <i><a href="/wiki/Virtual_table" title="Virtual table" class="mw-redirect">virtual table</a></i>—a table of functions that implement the polymorphic part of the class interface—and each object contains a pointer to the "vtable" of its class, which is then consulted whenever a polymorphic method is called. This mechanism is an example of:</p>
<ul>
<li><i><a href="/wiki/Late_binding" title="Late binding">late binding</a></i>, because virtual function calls are not bound until the time of invocation, and</li>
<li><i><a href="/wiki/Single_dispatch" title="Single dispatch" class="mw-redirect">single dispatch</a></i> (i.e., single-argument polymorphism), because virtual function calls are bound simply by looking through the vtable provided by the first argument (the <code>this</code> object), so the runtime types of the other arguments are completely irrelevant.</li>
</ul>
<p>The same goes for most other popular object systems. Some, however, such as <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a>, provide <i><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">multiple dispatch</a></i>, under which method calls are polymorphic in <i>all</i> arguments.</p>
<h3><span class="mw-headline" id="Polytypism">Polytypism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Polytypism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A related concept is <b>polytypism</b> or <b>data type genericity</b>. A polytypic function is more general than polymorphic, and in such a function, "though one can provide fixed <i>ad hoc</i> cases for specific data types, an <i>ad hoc</i> combinator is absent".<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Type_theory" title="Type theory">Type theory</a></li>
<li><a href="/wiki/Duck_typing" title="Duck typing">Duck typing</a> for polymorphism without (static) types</li>
<li><a href="/wiki/Polymorphic_code" title="Polymorphic code">Polymorphic code</a> (Computer virus terminology)</li>
<li><a href="/wiki/System_F" title="System F">System F</a> for a <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a> with parametric polymorphism.</li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web">Bjarne Stroustrup (February 19, 2007). <a rel="nofollow" class="external text" href="http://www.stroustrup.com/glossary.html#Gpolymorphism">"Bjarne Stroustrup's C++ Glossary"</a>. "polymorphism - providing a single interface to entities of different types."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.au=Bjarne+Stroustrup&amp;rft.aulast=Bjarne+Stroustrup&amp;rft.btitle=Bjarne+Stroustrup%27s+C%2B%2B+Glossary&amp;rft.date=February+19%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.stroustrup.com%2Fglossary.html%23Gpolymorphism&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Luca-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-Luca_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Luca_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span id="CITEREFCardelliWegner1985" class="citation journal"><a href="/wiki/Luca_Cardelli" title="Luca Cardelli">Cardelli, Luca</a>; <a href="/wiki/Peter_Wegner" title="Peter Wegner">Wegner, Peter</a> (December 1985). <a rel="nofollow" class="external text" href="http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf">"On understanding types, data abstraction, and polymorphism"</a>. <i><a href="/wiki/ACM_Computing_Surveys" title="ACM Computing Surveys">ACM Computing Surveys</a></i> (New York, NY, USA: <a href="/wiki/Association_for_Computing_Machinery" title="Association for Computing Machinery">ACM</a>) <b>17</b> (4): 471–523. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F6041.6042">10.1145/6041.6042</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0360-0300">0360-0300</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.atitle=On+understanding+types%2C+data+abstraction%2C+and+polymorphism&amp;rft.au=Cardelli%2C+Luca&amp;rft.aufirst=Luca&amp;rft.aulast=Cardelli&amp;rft.au=Wegner%2C+Peter&amp;rft.date=December+1985&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flucacardelli.name%2FPapers%2FOnUnderstanding.A4.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F6041.6042&amp;rft.issn=0360-0300&amp;rft.issue=4&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.pages=471-523&amp;rft.place=New+York%2C+NY%2C+USA&amp;rft.pub=ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=17" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1145.2F6041.6042&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span>: "Polymorphic types are types whose operations are applicable to values of more than one type."</span></li>
<li id="cite_note-gbooch-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-gbooch_3-0">^</a></b></span> <span class="reference-text">Booch, et all 2007 <i>Object-Oriented Analysis and Design with Applications.</i> Addison-Wesley.</span></li>
<li id="cite_note-Strachey-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-Strachey_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Strachey_4-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">C. Strachey - <i>Fundamental Concepts in Programming Languages</i> <a rel="nofollow" class="external free" href="http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf">http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf</a></span></li>
<li id="cite_note-Tucker2004-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-Tucker2004_5-0">^</a></b></span> <span class="reference-text"><span class="citation book">Allen B. Tucker (28 June 2004). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=9IFMCsQJyscC&amp;pg=SA91-PA5"><i>Computer Science Handbook, Second Edition</i></a>. Taylor &amp; Francis. pp. 91–. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-1-58488-360-9" title="Special:BookSources/978-1-58488-360-9">978-1-58488-360-9</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APolymorphism+%28computer+science%29&amp;rft.au=Allen+B.+Tucker&amp;rft.aulast=Allen+B.+Tucker&amp;rft.btitle=Computer+Science+Handbook%2C+Second+Edition&amp;rft.date=28+June+2004&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3D9IFMCsQJyscC%26pg%3DSA91-PA5&amp;rft.isbn=978-1-58488-360-9&amp;rft.pages=91-&amp;rft.pub=Taylor+%26+Francis&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-bjpierce-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-bjpierce_6-0">^</a></b></span> <span class="reference-text">Pierce, B. C. 2002 <i>Types and Programming Languages.</i> MIT Press.</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Ralf Lammel and Joost Visser, "Typed Combinators for Generic Traversal", in <i>Practical Aspects of Declarative Languages: 4th International Symposium</i> (2002), p. 153.</span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Polymorphism_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.cplusplus.com/doc/tutorial/polymorphism/">C++ examples of polymorphism</a></li>
<li><a rel="nofollow" class="external text" href="http://wiki.visual-prolog.com/index.php?title=Objects_and_Polymorphism">Objects and Polymorphism (Visual Prolog)</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_types" title="Template:Data types"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_types" title="Template talk:Data types"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_types&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Bit" title="Bit">Bit</a></li>
<li><a href="/wiki/Byte" title="Byte">Byte</a></li>
<li><a href="/wiki/Ternary_numeral_system" title="Ternary numeral system">Trit</a></li>
<li><a href="/wiki/Ternary_numeral_system#Tryte" title="Ternary numeral system">Tryte</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
<ul>
<li><a href="/wiki/Arbitrary-precision_arithmetic" title="Arbitrary-precision arithmetic">Bignum</a></li>
<li><a href="/wiki/Complex_data_type" title="Complex data type">Complex</a></li>
<li><a href="/wiki/Decimal_data_type" title="Decimal data type">Decimal</a></li>
<li><a href="/wiki/Fixed-point_arithmetic" title="Fixed-point arithmetic">Fixed-point</a></li>
<li><a href="/wiki/Floating_point" title="Floating point">Floating-point</a></li>
<li><a href="/wiki/Integer_(computer_science)" title="Integer (computer science)">Integer</a>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
</li>
<li><a href="/wiki/Interval_arithmetic" title="Interval arithmetic">Interval</a></li>
<li><a href="/wiki/Rational_data_type" title="Rational data type">Rational</a></li>
</ul>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
<ul>
<li><a href="/wiki/Character_(computing)" title="Character (computing)">Character</a></li>
<li><a href="/wiki/String_(computer_science)" title="String (computer science)">String</a>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_address" title="Memory address">Address</a>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
</li>
<li><a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">Reference</a></li>
</ul>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
<ul>
<li><a href="/wiki/Algebraic_data_type" title="Algebraic data type">Algebraic data type</a>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
</li>
<li><a href="/wiki/Array_data_type" title="Array data type">Array</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">Class</a></li>
<li><a href="/wiki/Dependent_type" title="Dependent type">Dependent</a></li>
<li><a href="/wiki/Intuitionistic_type_theory#Equality_type" title="Intuitionistic type theory">Equality</a></li>
<li><a href="/wiki/Inductive_type" title="Inductive type">Inductive</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Object_(computer_science)" title="Object (computer science)">Object</a>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
</li>
<li><a href="/wiki/Option_type" title="Option type">Option type</a></li>
<li><a href="/wiki/Product_type" title="Product type">Product</a></li>
<li><a href="/wiki/Record_(computer_science)" title="Record (computer science)">Record</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a></li>
<li><a href="/wiki/Union_type" title="Union type">Union</a>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
<ul>
<li><a href="/wiki/Boolean_data_type" title="Boolean data type">Boolean</a></li>
<li><a href="/wiki/Bottom_type" title="Bottom type">Bottom type</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Collection</a></li>
<li><a href="/wiki/Enumerated_type" title="Enumerated type">Enumerated type</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception</a></li>
<li><a href="/wiki/Function_type" title="Function type">Function type</a></li>
<li><a href="/wiki/Opaque_data_type" title="Opaque data type">Opaque data type</a></li>
<li><a href="/wiki/Recursive_data_type" title="Recursive data type">Recursive data type</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Stream_(computing)" title="Stream (computing)">Stream</a></li>
<li><a href="/wiki/Top_type" title="Top type">Top type</a></li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Unit_type" title="Unit type">Unit type</a></li>
<li><a href="/wiki/Void_type" title="Void type">Void</a></li>
</ul>
<ul>
<li><a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract data type</a></li>
<li><a href="/wiki/Data_structure" title="Data structure">Data structure</a></li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Kind_(type_theory)" title="Kind (type theory)">Kind</a>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
</li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Primitive_data_type" title="Primitive data type">Primitive data type</a></li>
<li><a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">Protocol</a>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Type_constructor" title="Type constructor">Type constructor</a></li>
<li><a href="/wiki/Type_conversion" title="Type conversion">Type conversion</a></li>
<li><a href="/wiki/Type_system" title="Type system">Type system</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
