<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Inductive programming</span></h1>
<p><b>Inductive Programming</b> (IP) is a special area of <a href="/wiki/Automatic_programming" title="Automatic programming">automatic programming</a>, covering research from <a href="/wiki/Artificial_intelligence" title="Artificial intelligence">artificial intelligence</a> and <a href="/wiki/Computer_programming" title="Computer programming">programming</a>, which addresses <a href="/wiki/Machine_learning" title="Machine learning">learning</a> of typically <a href="/wiki/Declarative_programming" title="Declarative programming">declarative</a> (<a href="/wiki/Logic_programming" title="Logic programming">logic</a> or <a href="/wiki/Functional_programming" title="Functional programming">functional</a>) and often <a href="/wiki/Recursion" title="Recursion">recursive</a> programs from incomplete specifications, such as input/output examples or constraints.</p>
<p>Depending on the programming language used, there are several kinds of inductive programming. <a href="/wiki/Inductive_functional_programming" title="Inductive functional programming">Inductive functional programming</a>, which uses functional programming languages such as <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a> or <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, and most especially <a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic programming</a>, which uses logic programming languages such as <a href="/wiki/Prolog" title="Prolog">Prolog</a> and other logical representations such as <a href="/wiki/Description_logics" title="Description logics" class="mw-redirect">Description logics</a>, have been more prominent, but other (programming) language paradigms have also been used, such as <a href="/wiki/Constraint_programming" title="Constraint programming">constraint programming</a> or <a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">probabilistic programming</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Definition"><span class="tocnumber">1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#History"><span class="tocnumber">2</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Application_areas"><span class="tocnumber">3</span> <span class="toctext">Application areas</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#External_links"><span class="tocnumber">5</span> <span class="toctext">External links</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Further_reading"><span class="tocnumber">6</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=1" title="Edit section: Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Inductive programming incorporates all approaches which are concerned with learning programs or algorithms from incomplete (<a href="/wiki/Formal_specification" title="Formal specification">formal</a>) specifications. Possible inputs in an IP system are a set of training inputs and corresponding outputs or an output evaluation function, describing the desired behavior of the intended program, <a href="/wiki/Tracing_(software)" title="Tracing (software)">traces</a> or action sequences which describe the process of calculating specific outputs, <a href="/wiki/Constraint_(mathematics)" title="Constraint (mathematics)">constraints</a> for the program to be induced concerning its time efficiency or its complexity, various kinds of background knowledge such as standard <a href="/wiki/Data_type" title="Data type">data types</a>, predefined functions to be used, program schemes or templates describing the data flow of the intended program, heuristics for guiding the search for a solution or other biases.</p>
<p>Output of an IP system is a program in some arbitrary programming language containing conditionals and loop or recursive control structures, or any other kind of <a href="/wiki/Turing_completeness" title="Turing completeness">Turing-complete</a> <a href="/wiki/Knowledge_representation_and_reasoning" title="Knowledge representation and reasoning">representation</a> language.</p>
<p>In many applications the output program must be correct with respect to the examples and partial specification, and this leads to the consideration of inductive programming as a special area inside automatic programming or <a href="/wiki/Program_synthesis" title="Program synthesis">program synthesis</a>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> usually opposed to 'deductive' program synthesis,<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup><sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> where the specification is usually complete.</p>
<p>In other cases, inductive programming is seen as a more general area where any declarative programming or representation language can be used and we may even have some degree of error in the examples, as in general <a href="/wiki/Machine_learning" title="Machine learning">machine learning</a>, the more specific area of <a href="/wiki/Structure_mining" title="Structure mining">structure mining</a> or the area of symbolic artificial intelligence. A distinctive feature is the number of examples or partial specification needed. Typically, inductive programming techniques can learn from just a few examples.</p>
<p>The diversity of inductive programming usually comes from the applications and the languages that are used: apart from logic programming and functional programming, other programming paradigms and representation languages have been used or suggested in inductive programming, such as <a href="/wiki/Functional_logic_programming" title="Functional logic programming">functional logic programming</a>, <a href="/wiki/Constraint_programming" title="Constraint programming">constraint programming</a>, <a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">probabilistic programming</a>, <a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">abductive logic programming</a>, <a href="/wiki/Modal_logic" title="Modal logic">modal logic</a>, <a href="/wiki/Action_language" title="Action language">action languages</a>, agent languages and many types of <a href="/wiki/Imperative_languages" title="Imperative languages" class="mw-redirect">imperative languages</a>.</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=2" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Research on the inductive synthesis of recursive functional programs started in the early 1970s and was brought onto firm theoretical foundations with the seminal THESIS system of Summers<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> and work of Biermann.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> These approaches were split into two phases: first, input-output examples are transformed into non-recursive programs (traces) using a small set of basic operators; second, regularities in the traces are searched for and used to fold them into a recursive program. The main results until the mid 1980s are surveyed by Smith.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup> Due to limited progress with respect to the range of programs that could be synthesized, research activities decreased significantly in the next decade.</p>
<p>The advent of logic programming brought a new elan but also a new direction in the early 1980s, especially due to the MIS system of Shapiro<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup> eventually spawning the new field of inductive logic programming (ILP).<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup> The early works of Plotkin,<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup><sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup> and his "<i>relative least general generalization (rlgg)</i>", had an enormous impact in inductive logic programming. Most of ILP work addresses a wider class of problems, as the focus is not only on recursive logic programs but on machine learning of symbolic hypotheses from logical representations. However, there were some encouraging results on learning recursive Prolog programs such as quicksort from examples together with suitable background knowledge, for example with GOLEM.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>13<span>]</span></a></sup> But again, after initial success, the community got disappointed by limited progress about the induction of recursive programs<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>14<span>]</span></a></sup><sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>15<span>]</span></a></sup><sup id="cite_ref-16" class="reference"><a href="#cite_note-16"><span>[</span>16<span>]</span></a></sup> with ILP less and less focusing on recursive programs and leaning more and more towards a machine learning setting with applications in <a href="/wiki/Relational_data_mining" title="Relational data mining">relational data mining</a> and knowledge discovery.<sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>17<span>]</span></a></sup></p>
<p>In parallel to work in ILP, Koza<sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>18<span>]</span></a></sup> proposed genetic programming in the early 1990s as a generate-and-test based approach to learning programs. The idea of genetic programming was further developed into the inductive programming system ADATE<sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span>[</span>19<span>]</span></a></sup> and the systematic-search-based system MagicHaskeller.<sup id="cite_ref-20" class="reference"><a href="#cite_note-20"><span>[</span>20<span>]</span></a></sup> Here again, functional programs are learned from sets of positive examples together with an output evaluation (fitness) function which specifies the desired input/output behavior of the program to be learned.</p>
<p>The early work in <a href="/wiki/Grammar_induction" title="Grammar induction">grammar induction</a> (also known as grammatical inference) is related to inductive programming, as rewriting systems or logic programs can be used to represent production rules. In fact, early works in inductive inference considered grammar induction and Lisp program inference as basically the same problem.<sup id="cite_ref-21" class="reference"><a href="#cite_note-21"><span>[</span>21<span>]</span></a></sup> The results in terms of learnability were related to classical concepts, such as identification-in-the-limit, as introduced in the seminal work of Gold.<sup id="cite_ref-22" class="reference"><a href="#cite_note-22"><span>[</span>22<span>]</span></a></sup> More recently, the language learning problem was addressed by the inductive programming community.<sup id="cite_ref-23" class="reference"><a href="#cite_note-23"><span>[</span>23<span>]</span></a></sup><sup id="cite_ref-24" class="reference"><a href="#cite_note-24"><span>[</span>24<span>]</span></a></sup></p>
<p>In the recent years, the classical approaches have been resumed and advanced with great success. Therefore the synthesis problem has been reformulated on the background of constructor-based term rewriting systems taking into account modern techniques of functional programming, as well as moderate use of search-based strategies and usage of background knowledge as well as automatic invention of subprograms. Many new and successful applications have recently appeared beyond program synthesis, most especially in the area of data manipulation, programming by example and cognitive modelling (see below).</p>
<p>Other ideas have also been explored with the common characteristic of using declarative languages for the representation of hypotheses. For instance, the use of higher-order features, schemes or structured distances have been advocated for a better handling of recursive data types and structures;<sup id="cite_ref-25" class="reference"><a href="#cite_note-25"><span>[</span>25<span>]</span></a></sup><sup id="cite_ref-26" class="reference"><a href="#cite_note-26"><span>[</span>26<span>]</span></a></sup><sup id="cite_ref-27" class="reference"><a href="#cite_note-27"><span>[</span>27<span>]</span></a></sup> abstraction has also been explored as a more powerful approach to cumulative learning and function invention.<sup id="cite_ref-28" class="reference"><a href="#cite_note-28"><span>[</span>28<span>]</span></a></sup><sup id="cite_ref-29" class="reference"><a href="#cite_note-29"><span>[</span>29<span>]</span></a></sup></p>
<p>One powerful paradigm that has been recently used for the representation of hypotheses in inductive programming (generally in the form of <a href="/wiki/Generative_model" title="Generative model">generative models</a>) is <a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">probabilistic programming</a> (and related paradigms, such as stochastic logic programs and Bayesian logic programming).<sup id="cite_ref-30" class="reference"><a href="#cite_note-30"><span>[</span>30<span>]</span></a></sup><sup id="cite_ref-31" class="reference"><a href="#cite_note-31"><span>[</span>31<span>]</span></a></sup><sup id="cite_ref-32" class="reference"><a href="#cite_note-32"><span>[</span>32<span>]</span></a></sup><sup id="cite_ref-33" class="reference"><a href="#cite_note-33"><span>[</span>33<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Application_areas">Application areas</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=3" title="Edit section: Application areas">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a rel="nofollow" class="external text" href="http://www.cogsys.wiai.uni-bamberg.de/aaip05/objectives.html">first workshop on Approaches and Applications of Inductive Programming (AAIP)</a> held in conjunction with <a href="/wiki/ICML" title="ICML" class="mw-redirect">ICML</a> 2005 identified all applications where "learning of programs or recursive rules are called for, [...] first in the domain of software engineering where structural learning, software assistants and software agents can help to relieve programmers from routine tasks, give programming support for end users, or support of novice programmers and programming tutor systems. Further areas of application are language learning, learning recursive control rules for AI-planning, learning recursive concepts in web-mining or for data-format transformations".</p>
<p>Since then, these and many other areas have shown to be successful application niches for inductive programming, such as <a href="/wiki/End-user_development" title="End-user development">end-user programming</a>,<sup id="cite_ref-34" class="reference"><a href="#cite_note-34"><span>[</span>34<span>]</span></a></sup> the related areas of <a href="/wiki/Programming_by_example" title="Programming by example">programming by example</a><sup id="cite_ref-35" class="reference"><a href="#cite_note-35"><span>[</span>35<span>]</span></a></sup> and <a href="/wiki/Programming_by_demonstration" title="Programming by demonstration">programming by demonstration</a>,<sup id="cite_ref-36" class="reference"><a href="#cite_note-36"><span>[</span>36<span>]</span></a></sup> and <a href="/wiki/Intelligent_tutoring_system" title="Intelligent tutoring system">intelligent tutoring systems</a>. Automatic data manipulation has also been subject of some 'killer applications' for inductive programming, such as the 'Flash Fill' tool<sup id="cite_ref-37" class="reference"><a href="#cite_note-37"><span>[</span>37<span>]</span></a></sup><sup id="cite_ref-38" class="reference"><a href="#cite_note-38"><span>[</span>38<span>]</span></a></sup> in <a href="/wiki/Microsoft_Excel" title="Microsoft Excel">Microsoft Excel</a>.</p>
<p>Other areas where inductive inference has been recently applied are <a href="/wiki/Knowledge_acquisition" title="Knowledge acquisition">knowledge acquisition</a>,<sup id="cite_ref-39" class="reference"><a href="#cite_note-39"><span>[</span>39<span>]</span></a></sup> <a href="/wiki/Artificial_general_intelligence" title="Artificial general intelligence">artificial general intelligence</a>,<sup id="cite_ref-40" class="reference"><a href="#cite_note-40"><span>[</span>40<span>]</span></a></sup> <a href="/wiki/Reinforcement_learning" title="Reinforcement learning">reinforcement learning</a> and theory evaluation,<sup id="cite_ref-41" class="reference"><a href="#cite_note-41"><span>[</span>41<span>]</span></a></sup><sup id="cite_ref-42" class="reference"><a href="#cite_note-42"><span>[</span>42<span>]</span></a></sup> and <a href="/wiki/Cognitive_science" title="Cognitive science">cognitive science</a> in general.<sup id="cite_ref-43" class="reference"><a href="#cite_note-43"><span>[</span>43<span>]</span></a></sup><sup id="cite_ref-44" class="reference"><a href="#cite_note-44"><span>[</span>44<span>]</span></a></sup> There may also be prospective applications in intelligent agents, games, robotics, personalisation, ambient intelligence and human interfaces.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=4" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Inductive_reasoning" title="Inductive reasoning">Inductive reasoning</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic programming</a></li>
<li><a href="/wiki/Inductive_functional_programming" title="Inductive functional programming">Inductive functional programming</a></li>
<li><a href="/wiki/Programming_by_example" title="Programming by example">Programming by example</a></li>
<li><a href="/wiki/Programming_by_demonstration" title="Programming by demonstration">Programming by demonstration</a></li>
<li><a href="/wiki/Genetic_programming" title="Genetic programming">Genetic programming</a></li>
<li><a href="/wiki/Evolutionary_programming" title="Evolutionary programming">Evolutionary programming</a></li>
<li><a href="/wiki/Grammar_induction" title="Grammar induction">Grammar induction</a></li>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic programming</a></li>
<li><a href="/wiki/Machine_learning" title="Machine learning">Machine learning</a></li>
<li><a href="/wiki/Declarative_programming" title="Declarative programming">Declarative programming</a></li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional programming</a></li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic programming</a></li>
<li><a href="/wiki/Program_synthesis" title="Program synthesis">Program synthesis</a></li>
<li><a href="/wiki/Structure_mining" title="Structure mining">Structure mining</a></li>
<li><a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">Probabilistic programming language</a></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=5" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.inductive-programming.org/">Inductive Programming community page</a>, hosted by the University of Bamberg.</li>
</ul>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=6" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation journal">Flener, P.; Schmid, U. (2008). "An introduction to inductive programming". <i>Artificial Intelligence Review</i> (Springer). 29(1): 45–62.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=An+introduction+to+inductive+programming&amp;rft.aufirst=P.&amp;rft.au=Flener%2C+P.&amp;rft.aulast=Flener&amp;rft.au=Schmid%2C+U.&amp;rft.date=2008&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence+Review&amp;rft.pages=45-62&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=29%281%29" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation journal">Kitzelmann, E. (2010). "Inductive programming: A survey of program synthesis techniques". <i>Approaches and Applications of Inductive Programming</i> (Springer): 50–73.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+programming%3A+A+survey+of+program+synthesis+techniques&amp;rft.aufirst=E.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.aulast=Kitzelmann&amp;rft.date=2010&amp;rft.genre=article&amp;rft.jtitle=Approaches+and+Applications+of+Inductive+Programming&amp;rft.pages=50-73&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation journal">Partridge, D. (1997). "The case for inductive programming". <i>Computer</i> (IEEE). 30(1): 36–41.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=The+case+for+inductive+programming&amp;rft.aufirst=D.&amp;rft.aulast=Partridge&amp;rft.au=Partridge%2C+D.&amp;rft.date=1997&amp;rft.genre=article&amp;rft.jtitle=Computer&amp;rft.pages=36-41&amp;rft.pub=IEEE&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=30%281%29" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation journal">Flener, P.; Partridge, D. (2001). "Inductive Programming". <i>Automated Software Engineering</i> (Springer) <b>8(2)</b>: 131–137.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+Programming&amp;rft.aufirst=P.&amp;rft.au=Flener%2C+P.&amp;rft.aulast=Flener&amp;rft.au=Partridge%2C+D.&amp;rft.date=2001&amp;rft.genre=article&amp;rft.jtitle=Automated+Software+Engineering&amp;rft.pages=131-137&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=8%282%29" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation journal">Hofmann, M.; Kitzelmann, E. (2009). "A unifying framework for analysis and evaluation of inductive programming systems". <i>Proceedings of the Second Conference on Artificial General Intelligence</i>: 55–60.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=A+unifying+framework+for+analysis+and+evaluation+of+inductive+programming+systems&amp;rft.aufirst=M.&amp;rft.au=Hofmann%2C+M.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.aulast=Hofmann&amp;rft.date=2009&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Second+Conference+on+Artificial+General+Intelligence&amp;rft.pages=55-60&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation journal">Muggleton, S.; De Raedt, L. (1994). "Inductive Logic Programming: Theory and methods". <i>The Journal of Logic Programming</i>. 19-20: 629–679. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0743-1066%2894%2990035-3">10.1016/0743-1066(94)90035-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+Logic+Programming%3A+Theory+and+methods&amp;rft.au=De+Raedt%2C+L.&amp;rft.aufirst=S.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.&amp;rft.date=1994&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2F0743-1066%2894%2990035-3&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.pages=629-679&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=19-20" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1016.2F0743-1066.2894.2990035-3&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span></li>
</ul>
<ul>
<li><span class="citation book">Lavrac, N.; Dzeroski, S. (1994). <a rel="nofollow" class="external text" href="http://www-ai.ijs.si/SasoDzeroski/ILPBook/"><i>Inductive Logic Programming: Techniques and Applications</i></a>. New York: Ellis Horwood. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-13-457870-8" title="Special:BookSources/0-13-457870-8">0-13-457870-8</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.au=Dzeroski%2C+S.&amp;rft.aufirst=N.&amp;rft.aulast=Lavrac&amp;rft.au=Lavrac%2C+N.&amp;rft.btitle=Inductive+Logic+Programming%3A+Techniques+and+Applications&amp;rft.date=1994&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww-ai.ijs.si%2FSasoDzeroski%2FILPBook%2F&amp;rft.isbn=0-13-457870-8&amp;rft.place=New+York&amp;rft.pub=Ellis+Horwood&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation journal">Muggleton, S.; De Raedt, Luc.; Poole, D.; Bratko, I.; Flach, P.; Inoue, K.; Srinivasan, A. (2012). "ILP turns 20". <i>Machine Learning</i> (Springer). 86(1): 3–23.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=ILP+turns+20&amp;rft.au=Bratko%2C+I.&amp;rft.au=De+Raedt%2C+Luc.&amp;rft.aufirst=S.&amp;rft.au=Flach%2C+P.&amp;rft.au=Inoue%2C+K.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.&amp;rft.au=Poole%2C+D.&amp;rft.au=Srinivasan%2C+A.&amp;rft.date=2012&amp;rft.genre=article&amp;rft.jtitle=Machine+Learning&amp;rft.pages=3-23&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=86%281%29" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation journal">Biermann, A.W. (1992). Shapiro, S.C., ed. "Automatic programming". <i>Encyclopedia of artificial intelligence</i> (Wiley): 18–35.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Automatic+programming&amp;rft.au=Biermann%2C+A.W.&amp;rft.aufirst=A.W.&amp;rft.aulast=Biermann&amp;rft.date=1992&amp;rft.genre=article&amp;rft.jtitle=Encyclopedia+of+artificial+intelligence&amp;rft.pages=18-35&amp;rft.pub=Wiley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation journal">Rich, C.; Waters, R.C. (1993). Yovits, M.C., ed. "Approaches to automatic programming". <i>Advances in computers</i> (Academic Press) <b>37</b>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Approaches+to+automatic+programming&amp;rft.aufirst=C.&amp;rft.aulast=Rich&amp;rft.au=Rich%2C+C.&amp;rft.au=Waters%2C+R.C.&amp;rft.date=1993&amp;rft.genre=article&amp;rft.jtitle=Advances+in+computers&amp;rft.pub=Academic+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=37" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation book">Lowry, R.D.; McCarthy, eds. (1991). <i>Automatic software design</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.btitle=Automatic+software+design&amp;rft.date=1991&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation journal">Manna, Z.; Waldinger, R. (1992). "Fundamentals of deductive program synthesis". <i>IEEE Trans Softw Eng</i>. 18(8): 674–704.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Fundamentals+of+deductive+program+synthesis&amp;rft.aufirst=Z.&amp;rft.aulast=Manna&amp;rft.au=Manna%2C+Z.&amp;rft.au=Waldinger%2C+R.&amp;rft.date=1992&amp;rft.genre=article&amp;rft.jtitle=IEEE+Trans+Softw+Eng&amp;rft.pages=674-704&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=18%288%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation journal">Flener, P. (2002). Kakas, A.; Sadri, F., eds. "Achievements and prospects of program synthesis". <i>Computational logic: logic programming and beyond; essays in honour of Robert A. Kowalski</i> (Springer). LNAI 2407: 310–346. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-45628-7_13">10.1007/3-540-45628-7_13</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Achievements+and+prospects+of+program+synthesis&amp;rft.aufirst=P.&amp;rft.au=Flener%2C+P.&amp;rft.aulast=Flener&amp;rft.date=2002&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-45628-7_13&amp;rft.jtitle=Computational+logic%3A+logic+programming+and+beyond%3B+essays+in+honour+of+Robert+A.+Kowalski&amp;rft.pages=310-346&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=LNAI+2407" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation journal">Summers, P.D. (1977). "A methodology for LISP program construction from examples". <i>J ACM</i>. 24(1): 161–175.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=A+methodology+for+LISP+program+construction+from+examples&amp;rft.aufirst=P.D.&amp;rft.aulast=Summers&amp;rft.au=Summers%2C+P.D.&amp;rft.date=1977&amp;rft.genre=article&amp;rft.jtitle=J+ACM&amp;rft.pages=161-175&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=24%281%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation journal">Biermann, A.W. (1978). "The inference of regular LISP programs from examples". <i>IEEE Trans Syst Man Cybern</i> <b>8(8)</b>: 585–600. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1109%2Ftsmc.1978.4310035">10.1109/tsmc.1978.4310035</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=The+inference+of+regular+LISP+programs+from+examples&amp;rft.au=Biermann%2C+A.W.&amp;rft.aufirst=A.W.&amp;rft.aulast=Biermann&amp;rft.date=1978&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1109%2Ftsmc.1978.4310035&amp;rft.jtitle=IEEE+Trans+Syst+Man+Cybern&amp;rft.pages=585-600&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=8%288%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation journal">Smith, D.R. (1984). Biermann, A.W.; Guiho, G., eds. "The synthesis of LISP programs from examples: a survey". <i>Automatic program construction techniques</i> (Macmillan): 307–324.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=The+synthesis+of+LISP+programs+from+examples%3A+a+survey&amp;rft.aufirst=D.R.&amp;rft.aulast=Smith&amp;rft.au=Smith%2C+D.R.&amp;rft.date=1984&amp;rft.genre=article&amp;rft.jtitle=Automatic+program+construction+techniques&amp;rft.pages=307-324&amp;rft.pub=Macmillan&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><span class="citation book">Shapiro, E.Y. (1983). <i>Algorithmic program debugging</i>. The MIT Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.aufirst=E.Y.&amp;rft.aulast=Shapiro&amp;rft.au=Shapiro%2C+E.Y.&amp;rft.btitle=Algorithmic+program+debugging&amp;rft.date=1983&amp;rft.genre=book&amp;rft.pub=The+MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation journal">Muggleton, S. (1991). "Inductive logic programming". <i>New Generation Computing</i> <b>8</b> (4): 295–318. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2FBF03037089">10.1007/BF03037089</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+logic+programming&amp;rft.aufirst=S.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.&amp;rft.date=1991&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1007%2FBF03037089&amp;rft.issue=4&amp;rft.jtitle=New+Generation+Computing&amp;rft.pages=295-318&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=8" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1007.2FBF03037089&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation journal">Plotkin, Gordon D. (1970). Meltzer, B.; Michie, D., eds. "A Note on Inductive Generalization". <i>Machine Intelligence</i> (Edinburgh University Press) <b>5</b>: 153–163.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=A+Note+on+Inductive+Generalization&amp;rft.aufirst=Gordon+D.&amp;rft.aulast=Plotkin&amp;rft.au=Plotkin%2C+Gordon+D.&amp;rft.date=1970&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=153-163&amp;rft.pub=Edinburgh+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=5" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation journal">Plotkin, Gordon D. (1971). Meltzer, B.; Michie, D., eds. "A Further Note on Inductive Generalization". <i>Machine Intelligence</i> (Edinburgh University Press) <b>6</b>: 101–124.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=A+Further+Note+on+Inductive+Generalization&amp;rft.aufirst=Gordon+D.&amp;rft.aulast=Plotkin&amp;rft.au=Plotkin%2C+Gordon+D.&amp;rft.date=1971&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=101-124&amp;rft.pub=Edinburgh+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation journal">Muggleton, S.H.; Feng, C. (1990). "Efficient induction of logic programs". <i>Proceedings of the Workshop on Algorithmic Learning Theory</i> (the Japanese Society for AI) <b>6</b>: 368–381.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Efficient+induction+of+logic+programs&amp;rft.au=Feng%2C+C.&amp;rft.aufirst=S.H.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.H.&amp;rft.date=1990&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Workshop+on+Algorithmic+Learning+Theory&amp;rft.pages=368-381&amp;rft.pub=the+Japanese+Society+for+AI&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation journal">Quinlan, J.R.; Cameron-Jones, R.M. (1993). "Avoiding Pitfalls When Learning Recursive Theories". <i>IJCAI</i>: 1050–1057.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Avoiding+Pitfalls+When+Learning+Recursive+Theories&amp;rft.au=Cameron-Jones%2C+R.M.&amp;rft.aufirst=J.R.&amp;rft.aulast=Quinlan&amp;rft.au=Quinlan%2C+J.R.&amp;rft.date=1993&amp;rft.genre=article&amp;rft.jtitle=IJCAI&amp;rft.pages=1050-1057&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><span class="citation journal">Quinlan, J.R.; Cameron-Jones, R.M. (1995). "Induction of logic programs: FOIL and related systems". 13(3-4). Springer. pp. 287–312.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.au=Cameron-Jones%2C+R.M.&amp;rft.aufirst=J.R.&amp;rft.aulast=Quinlan&amp;rft.au=Quinlan%2C+J.R.&amp;rft.btitle=Induction+of+logic+programs%3A+FOIL+and+related+systems&amp;rft.date=1995&amp;rft.genre=book&amp;rft.pages=287-312&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=13%283-4%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-16"><span class="mw-cite-backlink"><b><a href="#cite_ref-16">^</a></b></span> <span class="reference-text"><span class="citation journal">Flener, P.; Yilmaz, S. (1999). "Inductive synthesis of recursive logic programs: Achievements and prospects". <i>The Journal of Logic Programming</i>. 41(2): 141–195.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+synthesis+of+recursive+logic+programs%3A+Achievements+and+prospects&amp;rft.aufirst=P.&amp;rft.au=Flener%2C+P.&amp;rft.aulast=Flener&amp;rft.au=Yilmaz%2C+S.&amp;rft.date=1999&amp;rft.genre=article&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.pages=141-195&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=41%282%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><span id="CITEREFD.C5.BEeroski1996" class="citation">Džeroski, Sašo (1996), "Inductive Logic Programming and Knowledge Discovery in Databases", in Fayyad, U.M.; Piatetsky-Shapiro, G.; Smith, P. et al., <i>Advances in Knowledge Discovery and Data Mining</i>, MIT Press, pp. 117–152</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Advances+in+Knowledge+Discovery+and+Data+Mining&amp;rft.au=D%C5%BEeroski%2C+Sa%C5%A1o&amp;rft.aufirst=Sa%C5%A1o&amp;rft.aulast=D%C5%BEeroski&amp;rft.btitle=Inductive+Logic+Programming+and+Knowledge+Discovery+in+Databases&amp;rft.date=1996&amp;rft.genre=bookitem&amp;rft.pages=117-152&amp;rft.pub=MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> <span style="display:none;font-size:100%" class="error citation-comment"><code style="color:inherit; border:inherit; padding:inherit;">|displayeditors=</code> suggested (<a href="/wiki/Help:CS1_errors#displayeditors" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text"><span class="citation book">Koza, J.R. (1992). <i>Genetic Programming: vol. 1, On the programming of computers by means of natural selection</i>. MIT Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.aufirst=J.R.&amp;rft.au=Koza%2C+J.R.&amp;rft.aulast=Koza&amp;rft.btitle=Genetic+Programming%3A+vol.+1%2C+On+the+programming+of+computers+by+means+of+natural+selection&amp;rft.date=1992&amp;rft.genre=book&amp;rft.pub=MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text"><span class="citation journal">Olsson, J.R. (1995). "Inductive functional programming using incremental program transformation". <i>Artificial Intelligence</i> (Elsevier). 74(1): 55–83.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+functional+programming+using+incremental+program+transformation&amp;rft.aufirst=J.R.&amp;rft.aulast=Olsson&amp;rft.au=Olsson%2C+J.R.&amp;rft.date=1995&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.pages=55-83&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=74%281%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-20"><span class="mw-cite-backlink"><b><a href="#cite_ref-20">^</a></b></span> <span class="reference-text"><span class="citation journal">Katayama, Susumu (2008). "Efficient exhaustive generation of functional programs using Monte-Carlo search with iterative deepening". <i>PRICAI 2008: Trends in Artificial Intelligence</i>: 199–210.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Efficient+exhaustive+generation+of+functional+programs+using+Monte-Carlo+search+with+iterative+deepening&amp;rft.aufirst=Susumu&amp;rft.au=Katayama%2C+Susumu&amp;rft.aulast=Katayama&amp;rft.date=2008&amp;rft.genre=article&amp;rft.jtitle=PRICAI+2008%3A+Trends+in+Artificial+Intelligence&amp;rft.pages=199-210&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-21"><span class="mw-cite-backlink"><b><a href="#cite_ref-21">^</a></b></span> <span class="reference-text"><span class="citation journal">Angluin, D.; C.H., Smith (1983). "Inductive inference: Theory and methods". <i>ACM Computing Surveys</i> (ACM) <b>15</b>: 237–269. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F356914.356918">10.1145/356914.356918</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+inference%3A+Theory+and+methods&amp;rft.au=Angluin%2C+D.&amp;rft.au=C.H.%2C+Smith&amp;rft.aufirst=D.&amp;rft.aulast=Angluin&amp;rft.date=1983&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1145%2F356914.356918&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.pages=237-269&amp;rft.pub=ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=15" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-22"><span class="mw-cite-backlink"><b><a href="#cite_ref-22">^</a></b></span> <span class="reference-text"><span class="citation journal">Gold, E.M. (1967). <a rel="nofollow" class="external text" href="http://web.mit.edu/~6.863/www/spring2009/readings/gold67limit.pdf">"Language identification in the limit"</a>. <i>Information and Control</i> (Elsevier). 10(5): 447–474.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Language+identification+in+the+limit&amp;rft.aufirst=E.M.&amp;rft.au=Gold%2C+E.M.&amp;rft.aulast=Gold&amp;rft.date=1967&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fweb.mit.edu%2F~6.863%2Fwww%2Fspring2009%2Freadings%2Fgold67limit.pdf&amp;rft.jtitle=Information+and+Control&amp;rft.pages=447-474&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=10%285%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-23"><span class="mw-cite-backlink"><b><a href="#cite_ref-23">^</a></b></span> <span class="reference-text"><span class="citation journal">Muggleton, Stephen (1999). "Inductive Logic Programming: Issues, Results and the Challenge of Learning Language in Logic". <i>Artificial Intelligence</i> <b>114</b>: 283–296. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fs0004-3702%2899%2900067-3">10.1016/s0004-3702(99)00067-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+Logic+Programming%3A+Issues%2C+Results+and+the+Challenge+of+Learning+Language+in+Logic&amp;rft.aufirst=Stephen&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+Stephen&amp;rft.date=1999&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2Fs0004-3702%2899%2900067-3&amp;rft.jtitle=Artificial+Intelligence&amp;rft.pages=283-296&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=114" class="Z3988"><span style="display:none;"> </span></span>; here: Sect.2.1</span></li>
<li id="cite_note-24"><span class="mw-cite-backlink"><b><a href="#cite_ref-24">^</a></b></span> <span class="reference-text"><span class="citation journal">Olsson, J.R.; Powers, D.M.W. (2003). "Machine learning of human language through automatic programming". <i>Proceedings of the International Conference on Cognitive Science</i> (University of New South Wales): 507–512.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Machine+learning+of+human+language+through+automatic+programming&amp;rft.aufirst=J.R.&amp;rft.aulast=Olsson&amp;rft.au=Olsson%2C+J.R.&amp;rft.au=Powers%2C+D.M.W.&amp;rft.date=2003&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+International+Conference+on+Cognitive+Science&amp;rft.pages=507-512&amp;rft.pub=University+of+New+South+Wales&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-25"><span class="mw-cite-backlink"><b><a href="#cite_ref-25">^</a></b></span> <span class="reference-text"><span class="citation journal">Lloyd, J.W. (2001). "Knowledge Representation, Computation, and Learning in Higher-order Logic".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.aufirst=J.W.&amp;rft.aulast=Lloyd&amp;rft.au=Lloyd%2C+J.W.&amp;rft.btitle=Knowledge+Representation%2C+Computation%2C+and+Learning+in+Higher-order+Logic&amp;rft.date=2001&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-26"><span class="mw-cite-backlink"><b><a href="#cite_ref-26">^</a></b></span> <span class="reference-text"><span class="citation book">Lloyd, J.W. (2003). <i>Logic for learning: learning comprehensible theories from structured data</i>. Springer.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.aufirst=J.W.&amp;rft.aulast=Lloyd&amp;rft.au=Lloyd%2C+J.W.&amp;rft.btitle=Logic+for+learning%3A+learning+comprehensible+theories+from+structured+data&amp;rft.date=2003&amp;rft.genre=book&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-27"><span class="mw-cite-backlink"><b><a href="#cite_ref-27">^</a></b></span> <span class="reference-text"><span class="citation journal">Estruch, V.; Ferri, C.; Hernandez-Orallo, J.; Ramirez-Quintana, M.J. (2014). "Bridging the gap between distance and generalization". <i>Computational Intelligence</i> (Wiley).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Bridging+the+gap+between+distance+and+generalization&amp;rft.au=Estruch%2C+V.&amp;rft.au=Ferri%2C+C.&amp;rft.aufirst=V.&amp;rft.au=Hernandez-Orallo%2C+J.&amp;rft.aulast=Estruch&amp;rft.au=Ramirez-Quintana%2C+M.J.&amp;rft.date=2014&amp;rft.genre=article&amp;rft.jtitle=Computational+Intelligence&amp;rft.pub=Wiley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-28"><span class="mw-cite-backlink"><b><a href="#cite_ref-28">^</a></b></span> <span class="reference-text"><span class="citation journal">Henderson, R.J.; Muggleton, S.H. (2012). "Automatic invention of functional abstractions". <i>Advances in Inductive Logic Programming</i> (Imperial College Press).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Automatic+invention+of+functional+abstractions&amp;rft.aufirst=R.J.&amp;rft.au=Henderson%2C+R.J.&amp;rft.aulast=Henderson&amp;rft.au=Muggleton%2C+S.H.&amp;rft.date=2012&amp;rft.genre=article&amp;rft.jtitle=Advances+in+Inductive+Logic+Programming&amp;rft.pub=Imperial+College+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-29"><span class="mw-cite-backlink"><b><a href="#cite_ref-29">^</a></b></span> <span class="reference-text"><span class="citation journal">Irvin, H.; Stuhlmuller, A.; Goodman, N.D. (2011). "Inducing probabilistic programs by Bayesian program merging". <i>arXiv preprint arXiv:1110.5667</i> (Elsevier).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inducing+probabilistic+programs+by+Bayesian+program+merging&amp;rft.aufirst=H.&amp;rft.au=Goodman%2C+N.D.&amp;rft.au=Irvin%2C+H.&amp;rft.aulast=Irvin&amp;rft.au=Stuhlmuller%2C+A.&amp;rft.date=2011&amp;rft.genre=article&amp;rft.jtitle=arXiv+preprint+arXiv%3A1110.5667&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-30"><span class="mw-cite-backlink"><b><a href="#cite_ref-30">^</a></b></span> <span class="reference-text"><span class="citation journal">Muggleton, S. (2000). "Learning stochastic logic programs". <i>Electron. Trans. Artif. Intell</i>. 4(B), pages=141-153.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Learning+stochastic+logic+programs&amp;rft.aufirst=S.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.&amp;rft.date=2000&amp;rft.genre=article&amp;rft.jtitle=Electron.+Trans.+Artif.+Intell.&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=4%28B%29%2C%0Apages%3D141-153" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-31"><span class="mw-cite-backlink"><b><a href="#cite_ref-31">^</a></b></span> <span class="reference-text"><span class="citation book">De Raedt, L.; Kersting, K. (2008). <i>Probabilistic inductive logic programming</i>. Springer.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.au=De+Raedt%2C+L.&amp;rft.aufirst=L.&amp;rft.au=Kersting%2C+K.&amp;rft.aulast=De+Raedt&amp;rft.btitle=Probabilistic+inductive+logic+programming&amp;rft.date=2008&amp;rft.genre=book&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-32"><span class="mw-cite-backlink"><b><a href="#cite_ref-32">^</a></b></span> <span class="reference-text"><span class="citation journal">Irvin, H.; Stuhlmuller, A.; Goodman, N.D. (2011). "Inducing probabilistic programs by Bayesian program merging". <i>arXiv preprint arXiv:1110.5667</i> (Elsevier).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inducing+probabilistic+programs+by+Bayesian+program+merging&amp;rft.aufirst=H.&amp;rft.au=Goodman%2C+N.D.&amp;rft.au=Irvin%2C+H.&amp;rft.aulast=Irvin&amp;rft.au=Stuhlmuller%2C+A.&amp;rft.date=2011&amp;rft.genre=article&amp;rft.jtitle=arXiv+preprint+arXiv%3A1110.5667&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-33"><span class="mw-cite-backlink"><b><a href="#cite_ref-33">^</a></b></span> <span class="reference-text"><span class="citation journal">Stuhlmuller, A.; Goodman, N.D. (2012). "Reasoning about reasoning by nested conditioning: Modeling theory of mind with probabilistic programs". <i>Cognitive Systems Research</i> (Elsevier).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Reasoning+about+reasoning+by+nested+conditioning%3A+Modeling+theory+of+mind+with+probabilistic+programs&amp;rft.aufirst=A.&amp;rft.au=Goodman%2C+N.D.&amp;rft.aulast=Stuhlmuller&amp;rft.au=Stuhlmuller%2C+A.&amp;rft.date=2012&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Systems+Research&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-34"><span class="mw-cite-backlink"><b><a href="#cite_ref-34">^</a></b></span> <span class="reference-text"><span class="citation book">Lieberman, H.; Paternò, F.; Wulf, V. (2006). <i>End user development</i>. Springer.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.aufirst=H.&amp;rft.aulast=Lieberman&amp;rft.au=Lieberman%2C+H.&amp;rft.au=Patern%C3%B2%2C+F.&amp;rft.au=Wulf%2C+V.&amp;rft.btitle=End+user+development&amp;rft.date=2006&amp;rft.genre=book&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-35"><span class="mw-cite-backlink"><b><a href="#cite_ref-35">^</a></b></span> <span class="reference-text"><span class="citation book">Lieberman, H. (2001). <i>Your wish is my command: Programming by example</i>. Morgan Kaufmann.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.aufirst=H.&amp;rft.aulast=Lieberman&amp;rft.au=Lieberman%2C+H.&amp;rft.btitle=Your+wish+is+my+command%3A+Programming+by+example&amp;rft.date=2001&amp;rft.genre=book&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-36"><span class="mw-cite-backlink"><b><a href="#cite_ref-36">^</a></b></span> <span class="reference-text"><span class="citation journal">Cypher, E.; Halbert, D.C. "Watch what I do: programming by demonstration publisher=".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.au=Cypher%2C+E.&amp;rft.aufirst=E.&amp;rft.au=Halbert%2C+D.C.&amp;rft.aulast=Cypher&amp;rft.btitle=Watch+what+I+do%3A+programming+by+demonstration%0Apublisher%3D&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-37"><span class="mw-cite-backlink"><b><a href="#cite_ref-37">^</a></b></span> <span class="reference-text"><span class="citation journal">Gulwani, S.; Harris, W.R.; Singh, R. (2012). "Spreadsheet data manipulation using examples". <i>Communications of the ACM</i> (ACM). 55(8): 97–105.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Spreadsheet+data+manipulation+using+examples&amp;rft.aufirst=S.&amp;rft.au=Gulwani%2C+S.&amp;rft.au=Harris%2C+W.R.&amp;rft.aulast=Gulwani&amp;rft.au=Singh%2C+R.&amp;rft.date=2012&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.pages=97-105&amp;rft.pub=ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=55%288%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-38"><span class="mw-cite-backlink"><b><a href="#cite_ref-38">^</a></b></span> <span class="reference-text"><span class="citation web">Harris, Steven (1 October 2013). <a rel="nofollow" class="external text" href="http://www.experts-exchange.com/Software/Office_Productivity/Office_Suites/MS_Office/Excel/A_12314-Excel-2013-Flash-Fill.html">"Excel 2013 - Flash Fill"</a>. <i>Experts-Exchange.com</i>. Experts Exchange<span class="reference-accessdate">. Retrieved 23 November 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Excel+2013+-+Flash+Fill&amp;rft.aufirst=Steven&amp;rft.au=Harris%2C+Steven&amp;rft.aulast=Harris&amp;rft.date=1+October+2013&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.experts-exchange.com%2FSoftware%2FOffice_Productivity%2FOffice_Suites%2FMS_Office%2FExcel%2FA_12314-Excel-2013-Flash-Fill.html&amp;rft.jtitle=Experts-Exchange.com&amp;rft.pub=Experts+Exchange&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-39"><span class="mw-cite-backlink"><b><a href="#cite_ref-39">^</a></b></span> <span class="reference-text"><span class="citation journal">Schmid, U.; Hofmann, M.; Kitzelmann, E. (2009). "Analytical inductive programming as a cognitive rule acquisition devise". <i>Proceedings of the Second Conference on Artificial General Intelligence</i>: 162–167.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Analytical+inductive+programming+as+a+cognitive+rule+acquisition+devise&amp;rft.aufirst=U.&amp;rft.au=Hofmann%2C+M.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.aulast=Schmid&amp;rft.au=Schmid%2C+U.&amp;rft.date=2009&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Second+Conference+on+Artificial+General+Intelligence&amp;rft.pages=162-167&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-40"><span class="mw-cite-backlink"><b><a href="#cite_ref-40">^</a></b></span> <span class="reference-text"><span class="citation journal">Crossley, N.; Kitzelmann, E.; Hofmann, M.; Schmid, U. (2009). "Combining analytical and evolutionary inductive programming". <i>Proceedings of the Second Conference on Artificial General Intelligence</i>: 19–24.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Combining+analytical+and+evolutionary+inductive+programming&amp;rft.au=Crossley%2C+N.&amp;rft.aufirst=N.&amp;rft.au=Hofmann%2C+M.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.aulast=Crossley&amp;rft.au=Schmid%2C+U.&amp;rft.date=2009&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Second+Conference+on+Artificial+General+Intelligence&amp;rft.pages=19-24&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-41"><span class="mw-cite-backlink"><b><a href="#cite_ref-41">^</a></b></span> <span class="reference-text"><span class="citation journal">Hernandez-Orallo, J. (2000). "Constructive reinforcement learning". <i>International Journal of Intelligent Systems</i>. 15(3): 241–264. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1002%2F%28sici%291098-111x%28200003%2915%3A3%3C241%3A%3Aaid-int6%3E3.0.co%3B2-z">10.1002/(sici)1098-111x(200003)15:3&lt;241::aid-int6&gt;3.0.co;2-z</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Constructive+reinforcement+learning&amp;rft.aufirst=J.&amp;rft.au=Hernandez-Orallo%2C+J.&amp;rft.aulast=Hernandez-Orallo&amp;rft.date=2000&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1002%2F%28sici%291098-111x%28200003%2915%3A3%3C241%3A%3Aaid-int6%3E3.0.co%3B2-z&amp;rft.jtitle=International+Journal+of+Intelligent+Systems&amp;rft.pages=241-264&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=15%283%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-42"><span class="mw-cite-backlink"><b><a href="#cite_ref-42">^</a></b></span> <span class="reference-text"><span class="citation journal">Kemp, C.; Goodman, N.; Tenenbaum, J.B. (2007). "Learning and using relational theories". <i>Advances in neural information processing systems</i>: 753–760.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Learning+and+using+relational+theories&amp;rft.aufirst=C.&amp;rft.au=Goodman%2C+N.&amp;rft.au=Kemp%2C+C.&amp;rft.aulast=Kemp&amp;rft.au=Tenenbaum%2C+J.B.&amp;rft.date=2007&amp;rft.genre=article&amp;rft.jtitle=Advances+in+neural+information+processing+systems&amp;rft.pages=753-760&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-43"><span class="mw-cite-backlink"><b><a href="#cite_ref-43">^</a></b></span> <span class="reference-text"><span class="citation journal">Schmid, U.; Kitzelmann, E. (2011). "Inductive rule learning on the knowledge level". <i>Cognitive Systems Research</i>. 12(3): 237–248.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Inductive+rule+learning+on+the+knowledge+level&amp;rft.aufirst=U.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.aulast=Schmid&amp;rft.au=Schmid%2C+U.&amp;rft.date=2011&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Systems+Research&amp;rft.pages=237-248&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=12%283%29" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-44"><span class="mw-cite-backlink"><b><a href="#cite_ref-44">^</a></b></span> <span class="reference-text"><span class="citation journal">Stuhlmuller, A.; Goodman, N.D. (2012). "Reasoning about reasoning by nested conditioning: Modeling theory of mind with probabilistic programs". <i>Cognitive Systems Research</i> (Elsevier).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming&amp;rft.atitle=Reasoning+about+reasoning+by+nested+conditioning%3A+Modeling+theory+of+mind+with+probabilistic+programs&amp;rft.aufirst=A.&amp;rft.au=Goodman%2C+N.D.&amp;rft.aulast=Stuhlmuller&amp;rft.au=Stuhlmuller%2C+A.&amp;rft.date=2012&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Systems+Research&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
