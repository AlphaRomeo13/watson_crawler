<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Stack-based memory allocation</span></h1>
<p><a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">Stacks</a> in computing architectures are regions of <a href="/wiki/Memory_(computers)" title="Memory (computers)" class="mw-redirect">memory</a> where data is added or removed in a <a href="/wiki/LIFO_(computing)" title="LIFO (computing)">last-in-first-out</a> manner.</p>
<p>In most modern computer systems, each <a href="/wiki/Thread_(computer_science)" title="Thread (computer science)" class="mw-redirect">thread</a> has a reserved region of memory referred to as its stack. When a function executes, it may add some of its state data to the top of the stack; when the function exits it is responsible for removing that data from the stack. At a minimum, a thread's stack is used to store the location of function calls in order to allow return statements to return to the correct location, but programmers may further choose to explicitly use the stack. If a region of memory lies on the thread's stack, that memory is said to have been allocated on the stack.</p>
<p>Because the data is added and removed in a last-in-first-out manner, <b>stack-based memory allocation</b> is very simple and typically faster than heap-based memory allocation (also known as <a href="/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation" class="mw-redirect">dynamic memory allocation</a>). Another feature is that memory on the stack is automatically, and very efficiently, reclaimed when the function exits, which can be convenient for the programmer if the data is no longer required. If however, the data needs to be kept in some form, then it must be copied from the stack before the function exits. Therefore, stack based allocation is suitable for temporary data or data which is no longer required after the creating function exits.</p>
<p>A thread's assigned stack size can be as small as a few dozen <a href="/wiki/Kilobytes" title="Kilobytes" class="mw-redirect">kilobytes</a>. Allocating more memory on the stack than is available can result in a <a href="/wiki/Crash_(computing)" title="Crash (computing)">crash</a> due to <a href="/wiki/Stack_overflow" title="Stack overflow">stack overflow</a>.</p>
<p>Some processors families, such as the <a href="/wiki/X86" title="X86">x86</a>, have special instructions for manipulating the stack of the currently executing thread. Other processor families, including <a href="/wiki/PowerPC" title="PowerPC">PowerPC</a> and <a href="/wiki/MIPS_architecture" title="MIPS architecture" class="mw-redirect">MIPS</a>, do not have explicit stack support, but instead rely on convention and delegate stack management to the operating system's <a href="/wiki/Application_binary_interface" title="Application binary interface">application binary interface</a> (ABI).</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack-based_memory_allocation&amp;action=edit&amp;section=1" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Automatic_variable" title="Automatic variable">Automatic variable</a></li>
<li><a href="/wiki/Call_stack" title="Call stack">Call stack</a></li>
<li><a href="/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation" class="mw-redirect">Dynamic memory allocation</a></li>
<li><a href="/wiki/Stack_buffer_overflow" title="Stack buffer overflow">Stack buffer overflow</a></li>
<li><a href="/wiki/Stack_machine" title="Stack machine">Stack machine</a></li>
<li><a href="/wiki/Stack_overflow" title="Stack overflow">Stack overflow</a></li>
</ul>
