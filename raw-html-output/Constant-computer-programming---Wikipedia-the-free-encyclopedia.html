<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Constant (computer programming)</span></h1>
<p>In <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>, a <b>constant</b> is an <a href="/wiki/Identifier_(computer_programming)" title="Identifier (computer programming)" class="mw-redirect">identifier</a> with an associated <a href="/wiki/Value_(computer_science)" title="Value (computer science)">value</a> which cannot be altered by the <a href="/wiki/Computer_program" title="Computer program">program</a> during normal execution – the value is <i>constant</i>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>a<span>]</span></a></sup> This is contrasted with a <i><a href="/wiki/Variable_(computer_science)" title="Variable (computer science)">variable</a>,</i> which is an identifier with a value that can be changed during normal execution – the value is <i>variable.</i> Constants are useful for both programmers and compilers: for programmers they are a form of <a href="/wiki/Self-documenting" title="Self-documenting">self-documenting</a> code and allow reasoning about <a href="/wiki/Correctness_(computer_science)" title="Correctness (computer science)">correctness</a>; while for compilers they allow <a href="/wiki/Compile-time" title="Compile-time" class="mw-redirect">compile-time</a> and <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run-time</a> checks that constancy assumptions are not violated, and allow or simplify some <a href="/wiki/Compiler_optimization" title="Compiler optimization" class="mw-redirect">compiler optimizations</a>.</p>
<p>There are various specific realizations of the general notion of a constant, with subtle distinctions that are often overlooked. The most significant are: compile-time (statically-valued) constants, run-time (dynamically-valued) constants, <a href="/wiki/Immutable_object" title="Immutable object">immutable objects</a>, and constant types (<a href="/wiki/Const" title="Const" class="mw-redirect">const</a>).</p>
<p>Typical examples of compile-time constants include mathematical constants, values from standards (here <a href="/wiki/Maximum_transmission_unit" title="Maximum transmission unit">maximum transmission unit</a>), or internal configuration values (here <a href="/wiki/Characters_per_line" title="Characters per line">characters per line</a>), such as these C examples:</p>
<p>WHATSON? e1b2d734-52ec-46de-b377-8920d234e0e5</p>
<pre class="de1">
<span class="kw4">const</span> <span class="kw4">float</span> PI <span class="sy0">=</span> <span class="nu16">3.1415927</span><span class="sy0">;</span>  <span class="co1">// maximal single float precision</span>
<span class="kw4">const</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> MTU <span class="sy0">=</span> <span class="nu0">1500</span><span class="sy0">;</span>  <span class="co1">// Ethernet v2, RFC 894</span>
<span class="kw4">const</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> COLUMNS <span class="sy0">=</span> <span class="nu0">80</span><span class="sy0">;</span>
</pre>
<p>Typical examples of run-time constants are values calculated based on inputs to a function, such as this C++ example:</p>
<p>WHATSON? d2fc4bbb-bf4e-4326-bfba-c17eb9a08a44</p>
<pre class="de1">
<span class="kw4">void</span> f<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">string</span> s<span class="br0">)</span> <span class="br0">{</span>
  <span class="kw4">const</span> <span class="kw4">size_t</span> l <span class="sy1">=</span> s.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="co1">// ...</span>
<span class="br0">}</span>
</pre>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Use"><span class="tocnumber">1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Comparison_with_literals_and_macros"><span class="tocnumber">2</span> <span class="toctext">Comparison with literals and macros</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Dynamically-valued_constants"><span class="tocnumber">3</span> <span class="toctext">Dynamically-valued constants</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Constant_function_parameters"><span class="tocnumber">4</span> <span class="toctext">Constant function parameters</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Object-oriented_constants"><span class="tocnumber">5</span> <span class="toctext">Object-oriented constants</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Java"><span class="tocnumber">5.1</span> <span class="toctext">Java</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#C.23"><span class="tocnumber">5.2</span> <span class="toctext">C#</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#By_paradigm"><span class="tocnumber">6</span> <span class="toctext">By paradigm</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Naming_conventions"><span class="tocnumber">7</span> <span class="toctext">Naming conventions</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Notest"><span class="tocnumber">9</span> <span class="toctext">Notest</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#References"><span class="tocnumber">10</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Java"><span class="tocnumber">5.1</span> <span class="toctext">Java</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#C.23"><span class="tocnumber">5.2</span> <span class="toctext">C#</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Use">Use</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Use">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some <a href="/wiki/Programming_language" title="Programming language">programming languages</a> make an explicit syntactic distinction between constant and variable symbols, for example considering <a href="/wiki/Assignment_(computer_science)" title="Assignment (computer science)">assignment</a> to a constant to be a syntax error, while in other languages they are considered syntactically the same (both simply an identifier), and the difference in treatment is semantic (assignment to an identifier is syntactically valid, but if the identifier is a constant it is semantically invalid).</p>
<p>Although a constant's value is defined only once, a constant may be referenced many times in a program. Using a constant instead of specifying a value multiple times in the program does not only simplify code maintenance (as in <a href="/wiki/Don%27t_repeat_yourself" title="Don't repeat yourself">don't repeat yourself</a>), but it can also supply a meaningful name for it and can consolidate such constant bindings to a standard code location (for example, at the beginning or in a separate file).</p>
<h2><span class="mw-headline" id="Comparison_with_literals_and_macros">Comparison with literals and macros</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: Comparison with literals and macros">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are several main ways to express a data value that doesn't change during program execution that are consistent across a wide variety of programming languages. One very basic way is by simply writing a <a href="/wiki/Literal_(computer_science)" title="Literal (computer science)" class="mw-redirect">literal</a> number, character, or string into the program code, which is straightforward in C, C++, and similar languages.</p>
<p>In assembly language, literal numbers and characters are done using the "immediate mode" instructions available on most microprocessors. The name "immediate" comes from the values being available immediately from the <a href="/wiki/Instruction_(computer_science)" title="Instruction (computer science)" class="mw-redirect">instruction stream</a>, as opposed to loading them indirectly by looking up a memory address.<sup id="cite_ref-ibmpowerpc_2-0" class="reference"><a href="#cite_note-ibmpowerpc-2"><span>[</span>1<span>]</span></a></sup> On the other hand, values longer than the microprocessor's word length, such as strings and arrays, are handled indirectly and assemblers generally provide a "data" pseudo-op to embed such data tables in a program.</p>
<p>Another way is by defining a symbolic <a href="/wiki/Macro_(computer_science)" title="Macro (computer science)">macro</a>. Many high-level programming languages, and many assemblers, offer a macro facility where the programmer can define, generally at the beginning of a source file or in a separate definition file, names for different values. A preprocessor then replaces these names with the appropriate values before compiling, resulting in something functionally identical to using literals, with the speed advantages of immediate mode. Because it can be difficult to maintain code where all values are written literally, if a value is used in any repetitive or non-obvious way, it is often done as a macro.</p>
<p>A third way is by declaring and defining a variable as being "constant". A global or static variable can be declared (or a symbol defined in assembly) with a keyword qualifier such as <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>, <code>constant</code>, or <span class="mw-geshi java source-java"><span class="kw1">final</span></span> meaning that its value will be set at compile time and should not be changeable at runtime. Compilers generally put static constants in the text section of an object file along with the code itself, as opposed to the data section where non-const initialized data is kept, though some have an option to produce a section specifically dedicated to constants, if so desired. Memory protection can be applied to this area to prevent overwriting of constant variables by errant pointers.</p>
<p>These "constant variables" differ from literals in a number of ways. Compilers generally place a constant in a single memory location identified by symbol, rather than spread throughout the executable as with a macro. While this precludes the speed advantages of immediate mode, there are advantages in memory efficiency, and debuggers can work with these constants at runtime. Also while macros may be redefined accidentally by conflicting header files in C and C++, conflicting constants are detected at compile time.</p>
<p>Depending upon the language, constants can be untyped or typed. In C and C++, macros provide the former, while <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span> provides the latter:</p>
<p>WHATSON? fc323240-282e-4738-848a-ce7a89d84596</p>
<pre class="de1">
<span class="co2">#define PI 3.1415926535</span>
 
<span class="kw4">const</span> <span class="kw4">float</span> pi2 <span class="sy0">=</span> <span class="nu16">3.1415926535</span><span class="sy0">;</span>
</pre>
<p>while in Ada, there are universal numeric types that can be used, if desired:</p>
<p>WHATSON? 0d4ce475-7297-473f-bd6b-2ed7314edb39</p>
<pre class="de1">
pi : <span class="kw3">constant</span> := <span class="nu0">3.1415926535</span>;
 
pi2 : <span class="kw3">constant</span> float := <span class="nu0">3.1415926535</span>;
</pre>
<p>with the untyped variant being implicitly converted to the appropriate type upon each use.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>2<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Dynamically-valued_constants">Dynamically-valued constants</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Dynamically-valued constants">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Besides the <i>static constants</i> described above, many procedural languages such as Ada and C++ extend the concept of constantness toward global variables that are created at initialization time, local variables that are automatically created at runtime on the stack or in registers, to dynamically allocated memory that is accessed by pointer, and to parameter lists in function headers.</p>
<p>Dynamically-valued constants do not designate a variable as residing in a specific region of memory, nor are the values set at compile time. In C++ code such as</p>
<p>WHATSON? 8850d31a-51ad-4997-af38-8ba76bd02c22</p>
<pre class="de1">
<span class="kw4">float</span> func<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">float</span> ANYTHING<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">const</span> <span class="kw4">float</span> XYZ <span class="sy1">=</span> someGlobalVariable<span class="sy2">*</span>someOtherFunction<span class="br0">(</span>ANYTHING<span class="br0">)</span><span class="sy4">;</span>
    ...
<span class="br0">}</span>
</pre>
<p>the expression that the constant is initialized to are not themselves constant. Use of constantness is not necessary here for program legality or semantic correctness, but has three advantages:</p>
<ol>
<li>It is clear to the reader that the object will not be modified further, once set</li>
<li>Attempts to change the value of the object (by later programmers who do not fully understand the program logic) will be rejected by the compiler</li>
<li>The compiler may be able to perform code optimizations knowing that the value of the object will not change once created.<sup id="cite_ref-dvc_4-0" class="reference"><a href="#cite_note-dvc-4"><span>[</span>3<span>]</span></a></sup></li>
</ol>
<p>Dynamically-valued constants originated as a language feature with <a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a>.<sup id="cite_ref-dvc_4-1" class="reference"><a href="#cite_note-dvc-4"><span>[</span>3<span>]</span></a></sup> Studies of Ada and C++ code have shown that dynamically-valued constants are used infrequently, typically for 1% or less of objects, when they could be used much more, as some 40–50% of local, non-class objects are actually invariant once created.<sup id="cite_ref-dvc_4-2" class="reference"><a href="#cite_note-dvc-4"><span>[</span>3<span>]</span></a></sup><sup id="cite_ref-ada_5-0" class="reference"><a href="#cite_note-ada-5"><span>[</span>4<span>]</span></a></sup> On the other hand, such "immutable variables" tend to be the default in <a href="/wiki/Functional_programming" title="Functional programming">functional languages</a> since they favour programming styles with no side-effect (e.g., recursion) or make <a href="/wiki/ML_programming_language" title="ML programming language" class="mw-redirect">most declarations immutable</a> by default. Some functional languages even <a href="/wiki/Purely_functional" title="Purely functional">forbid side-effects</a> entirely.</p>
<p>Constantness is often used in function declarations, as a promise that when an object is passed by reference, the called function will not change it. Depending on the syntax, either a pointer or the object being pointed to may be constant, however normally the latter is desired. Especially in C++ and C, the discipline of ensuring that the proper data structures are constant throughout the program is called <a href="/wiki/Const-correctness" title="Const-correctness" class="mw-redirect">const-correctness</a>.</p>
<h2><span class="mw-headline" id="Constant_function_parameters">Constant function parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: Constant function parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In C/C++, it is possible to declare the parameter of a function or method as constant. This is a guarantee that this parameter cannot be modified after the first assignment (inadvertently). If the parameter is a pre-defined (built-in) type, it is <a href="/wiki/Called_by_value" title="Called by value" class="mw-redirect">called by value</a> and cannot be modified. If it is a user-defined type, the variable is the pointer address, which cannot be modified either. However, the content of the object can be modified without limits. Declaring parameters as constants may be a way to signalise that this value <i>should</i> not be changed, but the programmer must keep in mind that checks about modification of an object cannot be done by the compiler.</p>
<p>Besides this feature, it is in C/C++ also possible to declare a function or method as <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>. This prevents such functions or methods from modifying anything but local variables.</p>
<p>In C#, the keyword <span class="mw-geshi csharp source-csharp"><span class="kw1">const</span></span> exists, but does not have the same effect for function parameters, as it is the case in C/C++. There is, however, a way to "stir" the compiler to do make the check, albeit it is a bit tricky.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>5<span>]</span></a></sup></p>
<p>To get the same effect, first, two interfaces are defined</p>
<p>WHATSON? 5526d2c1-2e62-4134-a1a5-368d13f8eb82</p>
<pre class="de1">
<span class="kw1">public</span> <span class="kw4">interface</span> IReadable
<span class="br0">{</span>
    IValueInterface aValue <span class="br0">{</span> <span class="kw1">get</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw1">public</span> <span class="kw4">interface</span> IWritable <span class="sy0">:</span> IReadable
<span class="br0">{</span>
    IValueInterface aValue <span class="br0">{</span> <span class="kw1">set</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw1">public</span> <span class="kw4">class</span> AnObject <span class="sy0">:</span> IWritable
<span class="br0">{</span>
    <span class="kw1">private</span> ConcreteValue _aValue<span class="sy0">;</span>
 
    <span class="kw1">public</span> IValueInterface aValue
    <span class="br0">{</span>
        <span class="kw1">get</span> <span class="br0">{</span> <span class="kw1">return</span> _aValue<span class="sy0">;</span> <span class="br0">}</span>
        <span class="kw1">set</span> <span class="br0">{</span> _aValue <span class="sy0">=</span> <span class="kw1">value</span> <span class="kw1">as</span> ConcreteValue<span class="sy0">;</span> <span class="br0">}</span>
    <span class="br0">}</span>
<span class="br0">}</span>
</pre>
<p>Then, the defined methods select the right interface with read-only or read/write capabilities:</p>
<p>WHATSON? 6e6730d6-ab9f-4f2d-911d-4b7189a0ba19</p>
<pre class="de1">
<span class="kw1">public</span> <span class="kw4">void</span> doSomething<span class="br0">(</span>IReadable aVariable<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Cannot modify aVariable!</span>
<span class="br0">}</span>
 
<span class="kw1">public</span> <span class="kw4">void</span> doSomethingElse<span class="br0">(</span>IWritable aVariable<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Can modify aVariable, so be careful!</span>
<span class="br0">}</span>
</pre>
<h2><span class="mw-headline" id="Object-oriented_constants">Object-oriented constants</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: Object-oriented constants">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A constant data structure or object is referred to as "<a href="/wiki/Immutable_object" title="Immutable object">immutable</a>" in object-oriented parlance. An object being immutable confers some advantages in program design. For instance, it may be "copied" simply by copying its pointer or reference, avoiding a time-consuming copy operation and conserving memory.</p>
<p>Object-oriented languages such as C++ extend constantness even further. Individual members of a struct or class may be made const even if the class is not. Conversely, the <span class="mw-geshi cpp source-cpp">mutable</span> keyword allows a class member to be changed even if an object was instantiated as <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>.</p>
<p>Even functions can be const in C++. The meaning here is that only a const function may be called for an object instantiated as const; a const function doesn't change any non-mutable data.</p>
<p>C# has both a <span class="mw-geshi csharp source-csharp"><span class="kw1">const</span></span> and a <span class="mw-geshi csharp source-csharp"><span class="kw1">readonly</span></span> qualifier; its const is only for compile-time constants, while readonly can be used in constructors and other runtime applications.</p>
<h3><span class="mw-headline" id="Java">Java</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: Java">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Java has a qualifier called <span class="mw-geshi java source-java"><span class="kw1">final</span></span> that prevents changing a reference and makes sure it will never point to a different object. This does not prevent changes to the referred object itself. Java's <span class="mw-geshi java source-java"><span class="kw1">final</span></span> is basically equivalent to a <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span> <i>pointer</i> in C++. It does not provide the other features of <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span></span>.</p>
<p>In <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, the qualifier <code>final</code> states that the affected data member or variable is not assignable, as below:</p>
<p>WHATSON? 9663efe9-b8fd-413e-8f06-70c7e792c7eb</p>
<pre class="de1">
<span class="kw1">final</span> <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
i <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span> <span class="co1">// Error! Cannot modify a "final" object</span>
</pre>
<p>It must be decidable by the compilers where the variable with the <code>final</code> marker is initialized, and it must be performed only once, or the class will not compile. Java's <code>final</code> and C++'s <code>const</code> keywords have the same meaning when applied with primitive variables.</p>
<p>WHATSON? 8c4261fd-15c2-4003-8e1a-22e75b83118d</p>
<pre class="de1">
<span class="kw4">const</span> <span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">3</span><span class="sy4">;</span> <span class="co1">// C++ declaration</span>
i <span class="sy1">=</span> <span class="nu0">4</span><span class="sy4">;</span> <span class="co1">// Error!</span>
</pre>
<p>Considering pointers, a <code>final</code> reference in Java means something similar to <code>const</code> pointer in C++. In C++, one can declare a "<code>const</code> pointer type".</p>
<p>WHATSON? 5a246c42-eebd-4b12-8f96-0bfedfce4faf</p>
<pre class="de1">
Foo <span class="sy2">*</span><span class="kw4">const</span> bar <span class="sy1">=</span> mem_location<span class="sy4">;</span> <span class="co1">// const pointer type</span>
</pre>
<p>Here, <code>bar</code> must be initialised at the time of declaration and cannot be changed again, but what it points <i>is</i> modifiable. I.e. <code>*bar = <i>value</i></code> is valid. It just can't point to another location. Final reference in Java work the same way except it can be declared uninitialized.</p>
<p>WHATSON? ffdec423-7f70-4e79-864d-d822258df160</p>
<pre class="de1">
<span class="kw1">final</span> Foo i<span class="sy0">;</span> <span class="co1">// a Java declaration</span>
</pre>
<p>Note: Java does not support pointers.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>6<span>]</span></a></sup> It is because <a href="/wiki/Pointer_(computer_programming)#Java" title="Pointer (computer programming)">pointers</a> (with restrictions) are the default way of accessing objects in Java, and Java does not use stars to indicate them. For example <tt>i</tt> in the last example is a pointer and can be used to access the instance.</p>
<p>One can also declare a pointer to "read-only" data in C++.</p>
<p>WHATSON? e3812998-d03f-40f6-9e67-f212981194ca</p>
<pre class="de1">
<span class="kw4">const</span> Foo <span class="sy2">*</span>bar<span class="sy4">;</span>
</pre>
<p>Here <code>bar</code> can be modified to point anything, anytime; just that pointed value cannot be modified <i>through</i> <code>bar</code> pointer. There is no equivalent mechanism in Java. Thus there are also no <code>const</code> methods. Const-correctness cannot be enforced in Java, although by use of interfaces and defining a read-only interface to the class and passing this around, one can ensure that objects can be passed around the system in a way that they cannot be modified. <a href="/wiki/Java_collections_framework" title="Java collections framework">Java collections framework</a> provides a way to create unmodifiable wrapper of a <code>Collection</code> via <code>Collections.unmodifiableCollection()</code> and similar methods.</p>
<p>Methods in Java can be declared "<code>final</code>", but that has a completely unrelated meaning - it means that the method cannot be overridden in subclasses.</p>
<h3><span class="mw-headline" id="C.23">C#</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: C#">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, the qualifier <code>readonly</code> has the same effect on data members that <code>final</code> does in Java and the <code>const</code> does in C++; the <code>const</code> modifier in <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> has an effect similar (yet typed and class-scoped) to that of <code>#define</code> in C++. (The other, inheritance-inhibiting effect of Java's <code>final</code> when applied to methods and classes is induced in C# with the aid of a third keyword, <code>sealed</code>.)</p>
<p>Unlike C++, C# does not permit methods and parameters to be marked as <code>const</code>. However one may also pass around read-only subclasses, and the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a> provides some support for converting mutable collections to immutable ones which may be passed as read-only wrappers.</p>
<h2><span class="mw-headline" id="By_paradigm">By paradigm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=8" title="Edit section: By paradigm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Treatment of constants varies significantly by <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming paradigm</a>. Const-correctness is an issue in imperative languages like C++ because by default <a href="/wiki/Name_binding" title="Name binding">name bindings</a> typically create <a href="/wiki/Variable_(computer_science)" title="Variable (computer science)">variables</a>, which can vary, as the name suggests, and thus if one wishes to mark a binding as constant this requires some additional indication.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>b<span>]</span></a></sup> In other programming language paradigms related issues arise, with some analogs to const-correctness found.</p>
<p>In <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, data are typically constant by default, rather than variable by default. Instead of assigning a value to a variable (a storage space with a name and potentially variable value), one creates a binding of a name to a value, such as by the <code>let</code> construct in many dialects of <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>. In some functional languages, particularly multiparadigm ones such as <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>, modifying data is commonplace, while in others it is avoided or considered exceptional; this is the case for <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a> (another Lisp dialect), which uses the <code>set!</code> construct to modify data, with the <code>!</code> exclamation point drawing attention to this. Such languages achieve the goals of const-correctness by default, drawing attention to modification rather than constantness.</p>
<p>In a number of <a href="/wiki/Object-oriented_language" title="Object-oriented language" class="mw-redirect">object-oriented languages</a> (OOLs) there is the concept of an <a href="/wiki/Immutable_object" title="Immutable object">immutable object</a>, which is particularly used for basic types like strings; notable examples include Java, JavaScript, Python, and C#. These languages vary in whether user-defined types can be marked as immutable, and may allow particular fields (attributes) of an object or type to be marked as immutable.</p>
<p>In some multiparadigm languages that allow both object-oriented and functional styles, both of these features may be combined. For example, in <a href="/wiki/OCaml" title="OCaml">OCaml</a> object fields are immutable by default and must be explicitly marked with the <code>mutable</code> keyword to be mutable, while in Scala bindings are explicitly immutable, defined with <code>val</code> for "value" or explicitly mutable, defined with <code>var</code> for "variable".</p>
<h2><span class="mw-headline" id="Naming_conventions">Naming conventions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=9" title="Edit section: Naming conventions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Naming_conventions_(programming)" title="Naming conventions (programming)" class="mw-redirect">Naming conventions</a> for constant variables vary. Some simply name them as they would any other variable. Others use capitals and underscores for constants in a way similar to their traditional use for symbolic macros, such as <code>SOME_CONSTANT</code>.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>7<span>]</span></a></sup> In <a href="/wiki/Hungarian_notation" title="Hungarian notation">Hungarian notation</a>, a "k" <a href="/wiki/Prefix" title="Prefix">prefix</a> signifies constants as well as <a href="/wiki/Macro_(computer_science)" title="Macro (computer science)">macros</a> and <a href="/wiki/Enumerated_type" title="Enumerated type">enumerated types</a>.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Address_constant" title="Address constant">Address constants</a> for the <a href="/wiki/IBM/360" title="IBM/360" class="mw-redirect">IBM/360</a> and <a href="/wiki/Z/Architecture" title="Z/Architecture">Z/Architecture</a> platform</li>
</ul>
<h2><span class="mw-headline" id="Notest">Notest</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=11" title="Edit section: Notest">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">In some cases the expectation of constancy can be circumvented, e.g. using <a href="/wiki/Self-modifying_code" title="Self-modifying code">self-modifying code</a> or by overwriting the <a href="/wiki/Memory_location" title="Memory location" class="mw-redirect">memory location</a> where the value is stored.</span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text">This is not universal: in Ada input parameters and loop parameters are implicitly constant, for instance.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Constant_(computer_programming)&amp;action=edit&amp;section=12" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-ibmpowerpc-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-ibmpowerpc_2-0">^</a></b></span> <span class="reference-text">Ex. <a rel="nofollow" class="external text" href="http://publib.boulder.ibm.com/infocenter/systems/index.jsp?topic=/com.ibm.aix.aixassem/doc/alangref/addic.htm">IBM Systems Information</a>. Instruction Set - Assembler Language Reference for PowerPC.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation book"><a href="/wiki/Grady_Booch" title="Grady Booch">Booch, Grady</a> (1983). <i>Software Engineering with Ada</i>. <a href="/wiki/Benjamin_Cummings" title="Benjamin Cummings">Benjamin Cummings</a>. pp. 116–117. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-8053-0600-5" title="Special:BookSources/0-8053-0600-5">0-8053-0600-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstant+%28computer+programming%29&amp;rft.au=Booch%2C+Grady&amp;rft.aufirst=Grady&amp;rft.aulast=Booch&amp;rft.btitle=Software+Engineering+with+Ada&amp;rft.date=1983&amp;rft.genre=book&amp;rft.isbn=0-8053-0600-5&amp;rft.pages=116-117&amp;rft.pub=Benjamin+Cummings&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-dvc-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-dvc_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-dvc_4-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-dvc_4-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Schilling, Jonathan L. (April 1995). "Dynamically-Valued Constants: An Underused Language Feature". <i><a href="/wiki/SIGPLAN_Notices" title="SIGPLAN Notices" class="mw-redirect">SIGPLAN Notices</a></i> <b>30</b> (4): 13–20. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F202176.202177">10.1145/202176.202177</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstant+%28computer+programming%29&amp;rft.atitle=Dynamically-Valued+Constants%3A+An+Underused+Language+Feature&amp;rft.aufirst=Jonathan+L.&amp;rft.aulast=Schilling&amp;rft.au=Schilling%2C+Jonathan+L.&amp;rft.date=April+1995&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1145%2F202176.202177&amp;rft.issue=4&amp;rft.jtitle=SIGPLAN+Notices&amp;rft.pages=13-20&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=30" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-ada-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-ada_5-0">^</a></b></span> <span class="reference-text"><span class="citation conference">Perkins, J. A. "Programming Practices: Analysis of Ada Source Developed for the Air Force, Army, and Navy". Proceedings TRI-Ada '89. pp. 342–354. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F74261.74287">10.1145/74261.74287</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstant+%28computer+programming%29&amp;rft.aufirst=J.+A.&amp;rft.aulast=Perkins&amp;rft.au=Perkins%2C+J.+A.&amp;rft.btitle=Programming+Practices%3A+Analysis+of+Ada+Source+Developed+for+the+Air+Force%2C+Army%2C+and+Navy&amp;rft.genre=book&amp;rft_id=info%3Adoi%2F10.1145%2F74261.74287&amp;rft.pages=342-354&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web">Timwi (2010-09-09). <a rel="nofollow" class="external text" href="http://stackoverflow.com/a/3826657/">"Read-only ("const"-like) function parameters of C#"</a>. <a rel="nofollow" class="external free" href="http://stackoverflow.com/">http://stackoverflow.com/</a>: Stack Overflow<span class="reference-accessdate">. Retrieved 2012-05-06</span>. "[...] Then you can declare methods whose parameter type “tells” whether it plans on changing the variable or not:. [...] This mimics compile-time checks similar to constness in C++. As Eric Lippert correctly pointed out, this is not the same as immutability. But as a C++ programmer I think you know that."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstant+%28computer+programming%29&amp;rft.aulast=Timwi&amp;rft.au=Timwi&amp;rft.btitle=Read-only+%28%22const%22-like%29+function+parameters+of+C%23&amp;rft.date=2010-09-09&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fstackoverflow.com%2Fa%2F3826657%2F&amp;rft.place=http%3A%2F%2Fstackoverflow.com%2F&amp;rft.pub=Stack+Overflow&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://java.sun.com/docs/white/langenv/Simple.doc2.html#4107">"Oracle Technology Network for Java Developers | Oracle Technology Network | Oracle"</a>. Java.sun.com. 2013-08-14<span class="reference-accessdate">. Retrieved 2013-08-18</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstant+%28computer+programming%29&amp;rft.btitle=Oracle+Technology+Network+for+Java+Developers+%26%23124%3B+Oracle+Technology+Network+%26%23124%3B+Oracle&amp;rft.date=2013-08-14&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fjava.sun.com%2Fdocs%2Fwhite%2Flangenv%2FSimple.doc2.html%234107&amp;rft.pub=Java.sun.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/aa188468(office.10).aspx">Microsoft Office XP Developer: Constant Names</a></span></li>
</ol>
