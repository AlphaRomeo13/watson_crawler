<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Queue (abstract data type)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <b>queue</b> (<span class="nowrap"><span title="Representation in the International Phonetic Alphabet (IPA)" class="IPA"><a href="/wiki/Help:IPA_for_English" title="Help:IPA for English">/</a></span><span class="IPA nopopups"><a href="/wiki/Help:IPA_for_English#Key" title="Help:IPA for English"><span title="/ˈ/ primary stress follows" style="border-bottom:1px dotted">ˈ</span></a></span><span class="IPA nopopups"><a href="/wiki/Help:IPA_for_English#Key" title="Help:IPA for English"><span title="'k' in 'kind'" style="border-bottom:1px dotted">k</span></a></span><span class="IPA nopopups"><a href="/wiki/Help:IPA_for_English#Key" title="Help:IPA for English"><span title="/juː/ long 'u' in 'cute'" style="border-bottom:1px dotted">juː</span></a></span><span title="Representation in the International Phonetic Alphabet (IPA)" class="IPA"><a href="/wiki/Help:IPA_for_English" title="Help:IPA for English">/</a></span></span> <span title="English pronunciation respelling" class="Unicode"><a href="/wiki/Wikipedia:Pronunciation_respelling_key" title="Wikipedia:Pronunciation respelling key"><i><b><span class="smallcaps"><span class="SMALLCAPS" style="FONT-VARIANT:SMALL-CAPS;"><span class="NOCAPS" style="TEXT-TRANSFORM:LOWERCASE;">KEW</span></span></span></b></i></a></span>) is a particular kind of <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data type</a> or <a href="/wiki/Collection_(computing)" title="Collection (computing)" class="mw-redirect">collection</a> in which the entities in the collection are kept in order and the principal (or only) operations on the collection are the addition of entities to the rear terminal position, known as <i>enqueue,</i> and removal of entities from the front terminal position, known as <i>dequeue</i>. This makes the queue a <a href="/wiki/FIFO_(computing)" title="FIFO (computing)" class="mw-redirect">First-In-First-Out (FIFO) data structure</a>. In a FIFO data structure, the first element added to the queue will be the first one to be removed. This is equivalent to the requirement that once a new element is added, all elements that were added before have to be removed before the new element can be removed. Often a <i><a href="/wiki/Peek_(data_type_operation)" title="Peek (data type operation)">peek</a></i> or <i>front</i> operation is also entered, returning the value of the front element without dequeuing it. A queue is an example of a <a href="/wiki/Linear_data_structure" title="Linear data structure" class="mw-redirect">linear data structure</a>, or more abstractly a sequential collection.</p>
<p>Queues provide services in <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <a href="/wiki/Transport" title="Transport">transport</a>, and <a href="/wiki/Operations_research" title="Operations research">operations research</a> where various entities such as data, objects, persons, or events are stored and held to be processed later. In these contexts, the queue performs the function of a <a href="/wiki/Buffer_(computer_science)" title="Buffer (computer science)" class="mw-redirect">buffer</a>.</p>
<p>Queues are common in computer programs, where they are implemented as data structures coupled with access routines, as an <a href="/wiki/Abstract_data_structure" title="Abstract data structure" class="mw-redirect">abstract data structure</a> or in object-oriented languages as classes. Common implementations are <a href="/wiki/Circular_buffer" title="Circular buffer">circular buffers</a> and <a href="/wiki/Linked_list" title="Linked list">linked lists</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Queue_implementation"><span class="tocnumber">1</span> <span class="toctext">Queue implementation</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Queues_and_programming_languages"><span class="tocnumber">1.1</span> <span class="toctext">Queues and programming languages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#See_also"><span class="tocnumber">2</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#References"><span class="tocnumber">3</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#External_links"><span class="tocnumber">4</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Queues_and_programming_languages"><span class="tocnumber">1.1</span> <span class="toctext">Queues and programming languages</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Queue_implementation"><span id="BOUNDED"></span>Queue implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Queue_(abstract_data_type)&amp;action=edit&amp;section=1" title="Edit section: Queue implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Theoretically, one characteristic of a queue is that it does not have a specific capacity. Regardless of how many elements are already contained, a new element can always be added. It can also be empty, at which point removing an element will be impossible until a new element has been added again.</p>
<p>Fixed length arrays are limited in capacity, but it is not true that items need to be copied towards the head of the queue. The simple trick of turning the array into a closed circle and letting the head and tail drift around endlessly in that circle makes it unnecessary to ever move items stored in the array. If n is the size of the array, then computing indices modulo n will turn the array into a circle. This is still the conceptually simplest way to construct a queue in a high level language, but it does admittedly slow things down a little, because the array indices must be compared to zero and the array size, which is comparable to the time taken to check whether an array index is out of bounds, which some languages do, but this will certainly be the method of choice for a quick and dirty implementation, or for any high level language that does not have pointer syntax. The array size must be declared ahead of time, but some implementations simply double the declared array size when overflow occurs. Most modern languages with objects or <a href="/wiki/Pointer_(computer_programming)" title="Pointer (computer programming)">pointers</a> can implement or come with libraries for dynamic lists. Such <a href="/wiki/Data_structures" title="Data structures" class="mw-redirect">data structures</a> may have not specified fixed capacity limit besides memory constraints. Queue <i>overflow</i> results from trying to add an element onto a full queue and queue <i>underflow</i> happens when trying to remove an element from an empty queue.</p>
<p>A <i>bounded queue</i> is a queue limited to a fixed number of items.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>There are several efficient implementations of FIFO queues. An efficient implementation is one that can perform the operations—enqueuing and dequeuing—in <a href="/wiki/O(1)_scheduler#Meaning_of_O.281.29" title="O(1) scheduler">O(1) time</a>.</p>
<ul>
<li><a href="/wiki/Linked_list" title="Linked list">Linked list</a>
<ul>
<li>A <a href="/wiki/Doubly_linked_list" title="Doubly linked list">doubly linked list</a> has O(1) insertion and deletion at both ends, so is a natural choice for queues.</li>
<li>A regular singly linked list only has efficient insertion and deletion at one end. However, a small modification—keeping a pointer to the <i>last</i> node in addition to the first one—will enable it to implement an efficient queue.</li>
</ul>
</li>
<li>A <a href="/wiki/Double-ended_queue" title="Double-ended queue">deque</a> implemented using a modified dynamic array</li>
</ul>
<ul>
<li>A <a href="/wiki/Doubly_linked_list" title="Doubly linked list">doubly linked list</a> has O(1) insertion and deletion at both ends, so is a natural choice for queues.</li>
<li>A regular singly linked list only has efficient insertion and deletion at one end. However, a small modification—keeping a pointer to the <i>last</i> node in addition to the first one—will enable it to implement an efficient queue.</li>
</ul>
<h3><span class="mw-headline" id="Queues_and_programming_languages">Queues and programming languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Queue_(abstract_data_type)&amp;action=edit&amp;section=2" title="Edit section: Queues and programming languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Queues may be implemented as a separate data type, or may be considered a special case of a <a href="/wiki/Double-ended_queue" title="Double-ended queue">double-ended queue</a> (deque) and not implemented separately. For example, <a href="/wiki/Perl" title="Perl">Perl</a> and <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a> allow pushing and popping an array from both ends, so one can use <b>push</b> and <b>shift</b> functions to enqueue and dequeue a list (or, in reverse, one can use <b>unshift</b> and <b>pop</b>), although in some cases these operations are not efficient.</p>
<p>C++'s <a href="/wiki/Standard_Template_Library" title="Standard Template Library">Standard Template Library</a> provides a "<code>queue</code>" templated class which is restricted to only push/pop operations. Since J2SE5.0, Java's library contains a <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/Queue.html">Queue</a></code> interface that specifies queue operations; implementing classes include <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a></code> and (since J2SE 1.6) <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html">ArrayDeque</a></code>. PHP has an <a rel="nofollow" class="external text" href="http://www.php.net/manual/en/class.splqueue.php">SplQueue</a> class and third party libraries like <a href="/w/index.php?title=Beanstalk%27d&amp;action=edit&amp;redlink=1" class="new" title="Beanstalk'd (page does not exist)">beanstalk'd</a> and <a href="/wiki/Gearman" title="Gearman">Gearman</a>.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Queue_(abstract_data_type)&amp;action=edit&amp;section=3" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Circular_buffer" title="Circular buffer">Circular buffer</a></li>
<li><a href="/wiki/Deque" title="Deque" class="mw-redirect">Deque</a></li>
<li><a href="/wiki/Priority_queue" title="Priority queue">Priority queue</a></li>
<li><a href="/wiki/Queueing_theory" title="Queueing theory">Queueing theory</a></li>
<li><a href="/wiki/Stack_(data_structure)" title="Stack (data structure)" class="mw-redirect">Stack</a> – the "opposite" of a queue: <a href="/wiki/LIFO_(computing)" title="LIFO (computing)">LIFO</a> (Last In First Out)</li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Queue_(abstract_data_type)&amp;action=edit&amp;section=4" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">"Queue (Java Platform SE 7)"</a>. Docs.oracle.com. 2014-03-26<span class="reference-accessdate">. Retrieved 2014-05-22</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AQueue+%28abstract+data+type%29&amp;rft.btitle=Queue+%28Java+Platform+SE+7%29&amp;rft.date=2014-03-26&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F7%2Fdocs%2Fapi%2Fjava%2Futil%2FQueue.html&amp;rft.pub=Docs.oracle.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<ul>
<li><a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>. <i>The Art of Computer Programming</i>, Volume 1: <i>Fundamental Algorithms</i>, Third Edition. Addison-Wesley, 1997. <a href="/wiki/Special:BookSources/0201896834" class="internal mw-magiclink-isbn">ISBN 0-201-89683-4</a>. Section 2.2.1: Stacks, Queues, and Deques, pp. 238–243.</li>
<li><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw-Hill, 2001. <a href="/wiki/Special:BookSources/0262032937" class="internal mw-magiclink-isbn">ISBN 0-262-03293-7</a>. Section 10.1: Stacks and queues, pp. 200–204.</li>
<li><a href="/wiki/William_Ford" title="William Ford" class="mw-disambig">William Ford</a>, <a href="/w/index.php?title=William_Topp&amp;action=edit&amp;redlink=1" class="new" title="William Topp (page does not exist)">William Topp</a>. <i>Data Structures with C++ and STL</i>, Second Edition. Prentice Hall, 2002. <a href="/wiki/Special:BookSources/0130858501" class="internal mw-magiclink-isbn">ISBN 0-13-085850-1</a>. Chapter 8: Queues and Priority Queues, pp. 386–390.</li>
<li><a href="/w/index.php?title=Adam_Drozdek&amp;action=edit&amp;redlink=1" class="new" title="Adam Drozdek (page does not exist)">Adam Drozdek</a>. <i>Data Structures and Algorithms in C++</i>, Third Edition. Thomson Course Technology, 2005. <a href="/wiki/Special:BookSources/0534491820" class="internal mw-magiclink-isbn">ISBN 0-534-49182-0</a>. Chapter 4: Stacks and Queues, pp. 137–169.</li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Queue_(abstract_data_type)&amp;action=edit&amp;section=5" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.studytonight.com/data-structures/queue-data-structure">Queue Data Structure and Algorithm</a></li>
<li><a rel="nofollow" class="external text" href="http://scanftree.com/Data_Structure/Queues">Queues with algo and 'c' programme</a></li>
<li><a rel="nofollow" class="external text" href="http://www.halpernwightsoftware.com/stdlib-scratch/quickref.html#containers14">STL Quick Reference</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ludvikjerabek.com/downloads.html">VBScript implementation of stack, queue, deque, and Red-Black Tree</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_structures" title="Template:Data structures"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_structures" title="Template talk:Data structures"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_structures&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Collection_(abstract_data_type)" title="Collection (abstract data type)">Collection</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Container</a></li>
</ul>
<ul>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Double-ended_priority_queue" title="Double-ended priority queue">Double-ended priority queue</a></li>
<li><a href="/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queue</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Map</a></li>
<li><a href="/wiki/Multimap" title="Multimap">Multimap</a></li>
<li><a href="/wiki/Priority_queue" title="Priority queue">Priority queue</a></li>
<li><strong class="selflink">Queue</strong></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a>
<ul>
<li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">multiset</a></li>
</ul>
</li>
<li><a href="/wiki/Disjoint-set_data_structure" title="Disjoint-set data structure">Disjoint Sets</a></li>
<li><a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">Stack</a></li>
</ul>
<ul>
<li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">multiset</a></li>
</ul>
<ul>
<li><a href="/wiki/Bit_array" title="Bit array">Bit array</a></li>
<li><a href="/wiki/Circular_buffer" title="Circular buffer">Circular buffer</a></li>
<li><a href="/wiki/Dynamic_array" title="Dynamic array">Dynamic array</a></li>
<li><a href="/wiki/Hash_table" title="Hash table">Hash table</a></li>
<li><a href="/wiki/Hashed_array_tree" title="Hashed array tree">Hashed array tree</a></li>
<li><a href="/wiki/Sparse_array" title="Sparse array">Sparse array</a></li>
</ul>
<ul>
<li><a href="/wiki/Association_list" title="Association list">Association list</a></li>
<li><a href="/wiki/Linked_list" title="Linked list">Linked list</a></li>
<li><a href="/wiki/Skip_list" title="Skip list">Skip list</a></li>
<li><a href="/wiki/Unrolled_linked_list" title="Unrolled linked list">Unrolled linked list</a></li>
<li><a href="/wiki/XOR_linked_list" title="XOR linked list">XOR linked list</a></li>
</ul>
<ul>
<li><a href="/wiki/B-tree" title="B-tree">B-tree</a></li>
<li><a href="/wiki/Binary_search_tree" title="Binary search tree">Binary search tree</a>
<ul>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">red-black</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">splay</a></li>
</ul>
</li>
<li><a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">Heap</a>
<ul>
<li><a href="/wiki/Binary_heap" title="Binary heap">binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">binomial</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
</ul>
</li>
<li><a href="/wiki/R-tree" title="R-tree">R-tree</a>
<ul>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert</a></li>
</ul>
</li>
<li><a href="/wiki/Trie" title="Trie">Trie</a>
<ul>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">red-black</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">splay</a></li>
</ul>
<ul>
<li><a href="/wiki/Binary_heap" title="Binary heap">binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">binomial</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
</ul>
<ul>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert</a></li>
</ul>
<ul>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li>
</ul>
<ul>
<li><a href="/wiki/Binary_decision_diagram" title="Binary decision diagram">Binary decision diagram</a></li>
<li><a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">Directed acyclic graph</a></li>
<li><a href="/wiki/Directed_acyclic_word_graph" title="Directed acyclic word graph">Directed acyclic word graph</a></li>
</ul>
<ul>
<li><a href="/wiki/List_of_data_structures" title="List of data structures">List of data structures</a></li>
</ul>
<p>Paul E. Black, <a rel="nofollow" class="external text" href="http://www.nist.gov/dads/HTML/boundedqueue.html">Bounded queue</a> at the <a href="/wiki/National_Institute_of_Standards_and_Technology" title="National Institute of Standards and Technology">NIST</a> <a href="/wiki/Dictionary_of_Algorithms_and_Data_Structures" title="Dictionary of Algorithms and Data Structures">Dictionary of Algorithms and Data Structures</a>.</p>
