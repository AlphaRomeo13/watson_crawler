<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Instruction set</span></h1>
<p>An <b>instruction set</b>, or <b>instruction set architecture</b> (<b>ISA</b>), is the part of the <a href="/wiki/Computer_architecture" title="Computer architecture">computer architecture</a> related to <a href="/wiki/Computer_programming" title="Computer programming">programming</a>, including the native <a href="/wiki/Data_type" title="Data type">data types</a>, instructions, <a href="/wiki/Processor_register" title="Processor register">registers</a>, <a href="/wiki/Addressing_mode" title="Addressing mode">addressing modes</a>, <a href="/wiki/Memory_model_(computing)" title="Memory model (computing)" class="mw-redirect">memory architecture</a>, <a href="/wiki/Interrupt" title="Interrupt">interrupt</a> and <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a>, and external <a href="/wiki/Input/output" title="Input/output">I/O</a>. An ISA includes a specification of the set of <a href="/wiki/Opcode" title="Opcode">opcodes</a> (<a href="/wiki/Machine_language" title="Machine language" class="mw-redirect">machine language</a>), and the native commands implemented by a particular processor.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2012)">citation needed</span></a></i>]</sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Classification_of_instruction_sets"><span class="tocnumber">2</span> <span class="toctext">Classification of instruction sets</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Machine_language"><span class="tocnumber">3</span> <span class="toctext">Machine language</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Instruction_types"><span class="tocnumber">3.1</span> <span class="toctext">Instruction types</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Data_handling_and_memory_operations"><span class="tocnumber">3.1.1</span> <span class="toctext">Data handling and memory operations</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Arithmetic_and_logic_operations"><span class="tocnumber">3.1.2</span> <span class="toctext">Arithmetic and logic operations</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Control_flow_operations"><span class="tocnumber">3.1.3</span> <span class="toctext">Control flow operations</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Complex_instructions"><span class="tocnumber">3.2</span> <span class="toctext">Complex instructions</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Parts_of_an_instruction"><span class="tocnumber">3.3</span> <span class="toctext">Parts of an instruction</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Instruction_length"><span class="tocnumber">3.4</span> <span class="toctext">Instruction length</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Representation"><span class="tocnumber">3.5</span> <span class="toctext">Representation</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Design"><span class="tocnumber">3.6</span> <span class="toctext">Design</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Instruction_set_implementation"><span class="tocnumber">4</span> <span class="toctext">Instruction set implementation</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Code_density"><span class="tocnumber">4.1</span> <span class="toctext">Code density</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Number_of_operands"><span class="tocnumber">4.2</span> <span class="toctext">Number of operands</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Register_pressure"><span class="tocnumber">4.3</span> <span class="toctext">Register pressure</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Categories_of_ISA"><span class="tocnumber">5.1</span> <span class="toctext">Categories of ISA</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#Further_reading"><span class="tocnumber">7</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#External_links"><span class="tocnumber">8</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Instruction_types"><span class="tocnumber">3.1</span> <span class="toctext">Instruction types</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Data_handling_and_memory_operations"><span class="tocnumber">3.1.1</span> <span class="toctext">Data handling and memory operations</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Arithmetic_and_logic_operations"><span class="tocnumber">3.1.2</span> <span class="toctext">Arithmetic and logic operations</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Control_flow_operations"><span class="tocnumber">3.1.3</span> <span class="toctext">Control flow operations</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Complex_instructions"><span class="tocnumber">3.2</span> <span class="toctext">Complex instructions</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Parts_of_an_instruction"><span class="tocnumber">3.3</span> <span class="toctext">Parts of an instruction</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Instruction_length"><span class="tocnumber">3.4</span> <span class="toctext">Instruction length</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Representation"><span class="tocnumber">3.5</span> <span class="toctext">Representation</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Design"><span class="tocnumber">3.6</span> <span class="toctext">Design</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Data_handling_and_memory_operations"><span class="tocnumber">3.1.1</span> <span class="toctext">Data handling and memory operations</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Arithmetic_and_logic_operations"><span class="tocnumber">3.1.2</span> <span class="toctext">Arithmetic and logic operations</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Control_flow_operations"><span class="tocnumber">3.1.3</span> <span class="toctext">Control flow operations</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Code_density"><span class="tocnumber">4.1</span> <span class="toctext">Code density</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Number_of_operands"><span class="tocnumber">4.2</span> <span class="toctext">Number of operands</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Register_pressure"><span class="tocnumber">4.3</span> <span class="toctext">Register pressure</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Categories_of_ISA"><span class="tocnumber">5.1</span> <span class="toctext">Categories of ISA</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Instruction set architecture is distinguished from the <a href="/wiki/Microarchitecture" title="Microarchitecture">microarchitecture</a>, which is the set of processor design techniques used to implement the instruction set. Computers with different microarchitectures can share a common instruction set. For example, the <a href="/wiki/Intel" title="Intel">Intel</a> <a href="/wiki/Intel_P5_(microarchitecture)" title="Intel P5 (microarchitecture)" class="mw-redirect">Pentium</a> and the <a href="/wiki/Advanced_Micro_Devices" title="Advanced Micro Devices">AMD</a> <a href="/wiki/Athlon" title="Athlon">Athlon</a> implement nearly identical versions of the <a href="/wiki/X86" title="X86">x86</a> instruction set, but have radically different internal designs.</p>
<p>The concept of an <i>architecture</i>, distinct from the design of a specific machine, was developed by <a href="/wiki/Fred_Brooks" title="Fred Brooks">Fred Brooks</a> at IBM during the design phase of <a href="/wiki/System/360" title="System/360" class="mw-redirect">System/360</a>.</p>
<p>Prior to NPL [System/360], the company's computer designers had been free to honor cost objectives not only by selecting technologies but also by fashioning functional and architectural refinements. The SPREAD compatibility objective, in contrast, postulated a single architecture for a series of five processors spanning a wide range of cost and performance. None of the five engineering design teams could count on being able to bring about adjustments in architectural specifications as a way of easing difficulties in achieving cost and performance objectives.<sup id="cite_ref-Pugh_1-0" class="reference"><a href="#cite_note-Pugh-1"><span>[</span>1<span>]</span></a></sup><sup class="reference" style="white-space:nowrap;">:p.137</sup></p>
<p>Some virtual machines that support <a href="/wiki/Bytecode" title="Bytecode">bytecode</a> as their ISA such as <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>, the <a href="/wiki/Java_virtual_machine" title="Java virtual machine">Java virtual machine</a>, and Microsoft's <a href="/wiki/Common_Language_Runtime" title="Common Language Runtime">Common Language Runtime</a>, implement this by translating the bytecode for commonly used code paths into native machine code. In addition, these virtual machines execute less frequently used code paths by interpretation (see: <a href="/wiki/Just-in-time_compilation" title="Just-in-time compilation">Just-in-time compilation</a>). <a href="/wiki/Transmeta" title="Transmeta">Transmeta</a> implemented the x86 instruction set atop <a href="/wiki/VLIW" title="VLIW" class="mw-redirect">VLIW</a> processors in this fashion.</p>
<h2><span class="mw-headline" id="Classification_of_instruction_sets">Classification of instruction sets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=2" title="Edit section: Classification of instruction sets">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A <a href="/wiki/Complex_instruction_set_computer" title="Complex instruction set computer" class="mw-redirect">complex instruction set computer</a> (CISC) has many specialized instructions, some of which may only be rarely used in practical programs. A <a href="/wiki/Reduced_instruction_set_computer" title="Reduced instruction set computer" class="mw-redirect">reduced instruction set computer</a> (RISC) simplifies the processor by only implementing instructions that are frequently used in programs; unusual operations are implemented as subroutines, where the extra processor execution time is offset by their rare use. Theoretically important types are the <a href="/wiki/Minimal_instruction_set_computer" title="Minimal instruction set computer">minimal instruction set computer</a> and the <a href="/wiki/One_instruction_set_computer" title="One instruction set computer">one instruction set computer</a>, but these are not implemented in commercial processors. Another variation is the <a href="/wiki/Very_long_instruction_word" title="Very long instruction word">very long instruction word</a> (VLIW) where the processor receives many instructions encoded and retrieved in one instruction word.</p>
<h2><span class="mw-headline" id="Machine_language"><span id="NATIVE"></span>Machine language</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=3" title="Edit section: Machine language">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Machine language is built up from discrete <i>statements</i> or <i>instructions</i>. On the processing architecture, a given instruction may specify:</p>
<ul>
<li>Particular <a href="/wiki/Processor_register" title="Processor register">registers</a> for arithmetic, addressing, or control functions</li>
<li>Particular memory locations or offsets</li>
<li>Particular <a href="/wiki/Addressing_mode" title="Addressing mode">addressing modes</a> used to interpret the operands</li>
</ul>
<p>More complex operations are built up by combining these simple instructions, which are executed sequentially, or as otherwise directed by <a href="/wiki/Control_flow" title="Control flow">control flow</a> instructions.</p>
<h3><span class="mw-headline" id="Instruction_types">Instruction types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=4" title="Edit section: Instruction types">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Examples of operations common to many instruction sets include:</p>
<h4><span class="mw-headline" id="Data_handling_and_memory_operations">Data handling and memory operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=5" title="Edit section: Data handling and memory operations">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><i>Set</i> a <a href="/wiki/Processor_register" title="Processor register">register</a> to a fixed constant value.</li>
<li><i>Move</i> data from a memory location to a register, or vice versa. Used to store the contents of a register, result of a computation, or to retrieve stored data to perform a computation on it later.</li>
<li><i>Read</i> and <i>write</i> data from hardware devices.</li>
</ul>
<h4><span class="mw-headline" id="Arithmetic_and_logic_operations"><a href="/wiki/Arithmetic_and_logic_unit" title="Arithmetic and logic unit" class="mw-redirect">Arithmetic and logic</a> operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=6" title="Edit section: Arithmetic and logic operations">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><i>Add</i>, <i>subtract</i>, <i>multiply</i>, or <i>divide</i> the values of two registers, placing the result in a register, possibly setting one or more <a href="/wiki/Flag_(computing)" title="Flag (computing)" class="mw-redirect">condition codes</a> in a <a href="/wiki/Status_register" title="Status register">status register</a>.</li>
<li>Perform <a href="/wiki/Bitwise_operation" title="Bitwise operation">bitwise operations</a>, e.g., taking the <i><a href="/wiki/Logical_conjunction" title="Logical conjunction">conjunction</a></i> and <i><a href="/wiki/Logical_disjunction" title="Logical disjunction">disjunction</a></i> of corresponding bits in a pair of registers, taking the <i><a href="/wiki/Logical_negation" title="Logical negation" class="mw-redirect">negation</a></i> of each bit in a register.</li>
<li><i>Compare</i> two values in registers (for example, to see if one is less, or if they are equal).</li>
</ul>
<h4><span class="mw-headline" id="Control_flow_operations"><a href="/wiki/Control_flow" title="Control flow">Control flow</a> operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=7" title="Edit section: Control flow operations">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><i><a href="/wiki/Branch_(computer_science)" title="Branch (computer science)">Branch</a></i> to another location in the program and execute instructions there.</li>
<li><i><a href="/wiki/Branch_predication" title="Branch predication">Conditionally branch</a></i> to another location if a certain condition holds.</li>
<li><i><a href="/wiki/Indirect_branch" title="Indirect branch">Indirectly branch</a></i> to another location, while saving the location of the next instruction as a point to return to (a <i><a href="/wiki/Subroutine" title="Subroutine">call</a></i>).</li>
</ul>
<h3><span class="mw-headline" id="Complex_instructions">Complex instructions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=8" title="Edit section: Complex instructions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>CISC processors include "complex" instructions in their instruction set. A single "complex" instruction does something that may take many instructions on other computers.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2012)">citation needed</span></a></i>]</sup> Such instructions are typified by instructions that take multiple steps, control multiple functional units, or otherwise appear on a larger scale than the bulk of simple instructions implemented by the given processor. Some examples of "complex" instructions include:</p>
<ul>
<li>Saving many registers on the stack at once.</li>
<li>Moving large blocks of memory.</li>
<li>complicated integer and floating-point arithmetic (<a href="/wiki/Sine" title="Sine">sine</a>, <a href="/wiki/Cosine" title="Cosine" class="mw-redirect">cosine</a>, <a href="/wiki/Square_root" title="Square root">square root</a>, etc.).</li>
<li><a href="/wiki/SIMD" title="SIMD">SIMD</a> instructions, a single instruction performing an operation on many values in parallel.</li>
<li>Performing an atomic <a href="/wiki/Test-and-set" title="Test-and-set">test-and-set</a> instruction or other <a href="/wiki/Read-modify-write" title="Read-modify-write">read-modify-write</a> <a href="/wiki/Atomic_instruction" title="Atomic instruction" class="mw-redirect">atomic instruction</a>.</li>
<li>Instructions that perform <a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">ALU</a> operations with an operand from memory rather than a register.</li>
</ul>
<p>A complex instruction type that has become particularly popular recently<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2012)">citation needed</span></a></i>]</sup> is the <a href="/wiki/SIMD" title="SIMD">SIMD</a> or Single-Instruction Stream Multiple-Data Stream operation or <a href="/wiki/Vector_processing" title="Vector processing" class="mw-redirect">vector instruction</a>, that is an operation that performs the same arithmetic operation on multiple pieces of data at the same time. SIMD have the ability of manipulating large vectors and matrices in minimal time. SIMD instructions allow easy <a href="/wiki/Parallelization" title="Parallelization" class="mw-redirect">parallelization</a> of algorithms commonly involved in sound, image, and video processing. Various SIMD implementations have been brought to market under trade names such as <a href="/wiki/MMX_(instruction_set)" title="MMX (instruction set)">MMX</a>, <a href="/wiki/3DNow!" title="3DNow!">3DNow!</a> and <a href="/wiki/AltiVec" title="AltiVec">AltiVec</a>.</p>
<p>Specialised processor types like <a href="/wiki/GPUs" title="GPUs" class="mw-redirect">GPUs</a> for example also provide complex instruction sets. Nonetheless many of these specialised processor complex instruction sets do not have a publicly available native instruction set and native <a href="/wiki/Assembly_language" title="Assembly language">assembly language</a> for <a href="/wiki/Proprietary_hardware" title="Proprietary hardware">proprietary hardware</a> related reasons and are usually only accessible to software developers through standardized higher level languages and APIs. The <a href="/wiki/OpenGL" title="OpenGL">OpenGL</a> virtual instruction set and virtual assembly language <a href="/wiki/ARB_assembly_language" title="ARB assembly language">ARB assembly language</a> and <a href="/wiki/CUDA" title="CUDA">CUDA</a> are examples of such <a href="/wiki/Hardware_abstraction" title="Hardware abstraction">hardware abstraction</a> layers on top of the specialised processor native instruction set.</p>
<h3><span class="mw-headline" id="Parts_of_an_instruction">Parts of an instruction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=9" title="Edit section: Parts of an instruction">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>On traditional architectures, an instruction includes an <a href="/wiki/Opcode" title="Opcode">opcode</a> that specifies the operation to perform, such as <i>add contents of memory to register</i>—and zero or more <a href="/wiki/Operand" title="Operand">operand</a> specifiers, which may specify <a href="/wiki/Processor_register" title="Processor register">registers</a>, memory locations, or literal data. The operand specifiers may have <a href="/wiki/Addressing_mode" title="Addressing mode">addressing modes</a> determining their meaning or may be in fixed fields. In <a href="/wiki/Very_long_instruction_word" title="Very long instruction word">very long instruction word</a> (VLIW) architectures, which include many <a href="/wiki/Microcode" title="Microcode">microcode</a> architectures, multiple simultaneous opcodes and operands are specified in a single instruction.</p>
<p>Some exotic instruction sets do not have an opcode field (such as <a href="/wiki/Transport_triggered_architecture" title="Transport triggered architecture">Transport Triggered Architectures</a> (TTA) or the <a href="/wiki/Forth_virtual_machine" title="Forth virtual machine" class="mw-redirect">Forth virtual machine</a>), only operand(s). Other unusual "<a href="/wiki/0-operand_instruction_set" title="0-operand instruction set" class="mw-redirect">0-operand</a>" instruction sets lack any operand specifier fields, such as some <a href="/wiki/Stack_machine" title="Stack machine">stack machines</a> including NOSC.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup><sup class="noprint Inline-Template noprint Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:NOTRS" title="Wikipedia:NOTRS" class="mw-redirect"><span title="Not reliable. Just some random mailing list. (July 2014)">better source needed</span></a></i>]</sup></p>
<h3><span class="mw-headline" id="Instruction_length">Instruction length</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=10" title="Edit section: Instruction length">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The size or length of an instruction varies widely, from as little as four bits in some <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a> to many hundreds of bits in some VLIW systems. Processors used in <a href="/wiki/Personal_computer" title="Personal computer">personal computers</a>, <a href="/wiki/Mainframe_computer" title="Mainframe computer">mainframes</a>, and <a href="/wiki/Supercomputer" title="Supercomputer">supercomputers</a> have instruction sizes between 8 and 64 bits. The longest possible instruction on x86 is 15 bytes (120 bits).<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> Within an instruction set, different instructions may have different lengths. In some architectures, notably most <a href="/wiki/Reduced_instruction_set_computer" title="Reduced instruction set computer" class="mw-redirect">reduced instruction set computers</a> (RISC), instructions are a fixed length, typically corresponding with that architecture's <a href="/wiki/Word_(data_type)" title="Word (data type)" class="mw-redirect">word size</a>. In other architectures, instructions have variable length, typically integral multiples of a <a href="/wiki/Byte" title="Byte">byte</a> or a <a href="/wiki/Halfword" title="Halfword" class="mw-redirect">halfword</a>. Some such as the <a href="/wiki/ARMv7" title="ARMv7" class="mw-redirect">ARM</a> with <i>Thumb-extension</i> have <i>mixed</i> variable encoding, that is two fixed, usually 32-bit and 16-bit encodings, where instructions can not be mixed freely but must be switched between on a branch (or exception boundary in ARMv8).</p>
<p>A RISC instruction set normally has a fixed instruction width (often 4 bytes = 32 bits), whereas a typical CISC instruction set may have instructions of widely varying length (1 to 15 bytes for x86). Fixed-width instructions are less complicated to handle than variable-width instructions for several reasons (not having to check whether an instruction straddles a cache line or virtual memory page boundary<sup id="cite_ref-Cocke_4-0" class="reference"><a href="#cite_note-Cocke-4"><span>[</span>4<span>]</span></a></sup> for instance), and are therefore somewhat easier to optimize for speed.</p>
<h3><span class="mw-headline" id="Representation">Representation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=11" title="Edit section: Representation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The instructions constituting a program are rarely specified using their internal, numeric form (<a href="/wiki/Machine_code" title="Machine code">machine code</a>); they may be specified by programmers using an <a href="/wiki/Assembly_language" title="Assembly language">assembly language</a> or, more commonly, may be generated from <a href="/wiki/Programming_language" title="Programming language">programming languages</a> by <a href="/wiki/Compiler" title="Compiler">compilers</a>.</p>
<h3><span class="mw-headline" id="Design">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=12" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The design of instruction sets is a complex issue. There were two stages in history for the microprocessor. The first was the CISC (Complex Instruction Set Computer), which had many different instructions. In the 1970s, however, places like IBM did research and found that many instructions in the set could be eliminated. The result was the RISC (Reduced Instruction Set Computer), an architecture that uses a smaller set of instructions. A simpler instruction set may offer the potential for higher speeds, reduced processor size, and reduced power consumption. However, a more complex set may optimize common operations, improve memory/<a href="/wiki/CPU_cache" title="CPU cache">cache</a> efficiency, or simplify programming.</p>
<p>Some instruction set designers reserve one or more opcodes for some kind of <a href="/wiki/System_call" title="System call">system call</a> or <a href="/wiki/Software_interrupt" title="Software interrupt" class="mw-redirect">software interrupt</a>. For example, <a href="/wiki/MOS_Technology_6502" title="MOS Technology 6502">MOS Technology 6502</a> uses 00<sub>H</sub>, <a href="/wiki/Zilog_Z80" title="Zilog Z80">Zilog Z80</a> uses the eight codes C7,CF,D7,DF,E7,EF,F7,FF<sub>H</sub><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> while <a href="/wiki/Motorola_68000" title="Motorola 68000">Motorola 68000</a> use codes in the range A000..AFFF<sub>H</sub>.</p>
<p>Fast virtual machines are much easier to implement if an instruction set meets the <a href="/wiki/Popek_and_Goldberg_virtualization_requirements" title="Popek and Goldberg virtualization requirements">Popek and Goldberg virtualization requirements</a>.<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text near this tag may need clarification or removal of jargon. (October 2012)">clarification needed</span></a></i>]</sup></p>
<p>The <a href="/wiki/NOP_slide" title="NOP slide">NOP slide</a> used in <a href="/wiki/Immunity_Aware_Programming" title="Immunity Aware Programming" class="mw-redirect">Immunity Aware Programming</a> is much easier to implement if the "unprogrammed" state of the memory is interpreted as a <a href="/wiki/NOP" title="NOP">NOP</a>.<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Disputed_statement" title="Wikipedia:Disputed statement" class="mw-redirect"><span title="The material near this tag is possibly inaccurate or nonfactual. (October 2012)">dubious</span></a> <span class="metadata">– <a href="/wiki/Talk:Instruction_set#Dubious" title="Talk:Instruction set">discuss</a></span></i>]</sup></p>
<p>On systems with multiple processors, <a href="/wiki/Non-blocking_synchronization" title="Non-blocking synchronization" class="mw-redirect">non-blocking synchronization</a> algorithms are much easier to implement<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2012)">citation needed</span></a></i>]</sup> if the instruction set includes support for something such as "<a href="/wiki/Fetch-and-add" title="Fetch-and-add">fetch-and-add</a>", "<a href="/wiki/Load-link/store-conditional" title="Load-link/store-conditional">load-link/store-conditional</a>" (LL/SC), or "atomic <a href="/wiki/Compare_and_swap" title="Compare and swap" class="mw-redirect">compare and swap</a>".</p>
<h2><span class="mw-headline" id="Instruction_set_implementation">Instruction set implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=13" title="Edit section: Instruction set implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Any given instruction set can be implemented in a variety of ways. All ways of implementing a particular instruction set provide the same <a href="/wiki/Programming_model" title="Programming model" class="mw-redirect">programming model</a>, and all implementations of that instruction set are able to run the same binary executables. The various ways of implementing an instruction set give different tradeoffs between cost, performance, power consumption, size, etc.</p>
<p>When designing the <a href="/wiki/Microarchitecture" title="Microarchitecture">microarchitecture</a> of a processor, engineers use blocks of "hard-wired" electronic circuitry (often designed separately) such as adders, multiplexers, counters, registers, ALUs etc. Some kind of <a href="/wiki/Register_transfer_language" title="Register transfer language">register transfer language</a> is then often used to describe the decoding and sequencing of each instruction of an ISA using this physical microarchitecture. There are two basic ways to build a <a href="/wiki/Control_unit" title="Control unit">control unit</a> to implement this description (although many designs use middle ways or compromises):</p>
<ol>
<li>Some computer designs "hardwire" the complete instruction set decoding and sequencing (just like the rest of the microarchitecture).</li>
<li>Other designs employ <a href="/wiki/Microcode" title="Microcode">microcode</a> routines or tables (or both) to do this—typically as on-chip <a href="/wiki/Read-only_memory" title="Read-only memory">ROMs</a> or <a href="/wiki/Programmable_Logic_Array" title="Programmable Logic Array" class="mw-redirect">PLAs</a> or both (although separate RAMs and <a href="/wiki/Read-only_memory#Historical_examples" title="Read-only memory">ROMs</a> have been used historically).</li>
</ol>
<p>Some designs use a combination of hardwired design and microcode for the control unit.</p>
<p>Some CPU designs compile the instruction set to a writable <a href="/wiki/RAM" title="RAM" class="mw-redirect">RAM</a> or <a href="/wiki/Flash_memory" title="Flash memory">flash</a> inside the CPU (such as the <a href="/wiki/Rekursiv" title="Rekursiv">Rekursiv</a> processor and the <a href="/w/index.php?title=Imsys&amp;action=edit&amp;redlink=1" class="new" title="Imsys (page does not exist)">Imsys</a> <a href="/w/index.php?title=Cjip&amp;action=edit&amp;redlink=1" class="new" title="Cjip (page does not exist)">Cjip</a>),<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> or an FPGA (<a href="/wiki/Reconfigurable_computing" title="Reconfigurable computing">reconfigurable computing</a>). The <a href="/wiki/Western_Digital" title="Western Digital">Western Digital</a> <a href="/wiki/MCP-1600" title="MCP-1600">MCP-1600</a> is an older example, using a dedicated, separate ROM for microcode.</p>
<p>An ISA can also be <a href="/wiki/Emulate" title="Emulate">emulated</a> in software by an <a href="/wiki/Interpreter_(computing)" title="Interpreter (computing)">interpreter</a>. Naturally, due to the interpretation overhead, this is slower than directly running programs on the emulated hardware, unless the hardware running the emulator is an order of magnitude faster. Today, it is common practice for vendors of new ISAs or microarchitectures to make software emulators available to software developers before the hardware implementation is ready.</p>
<p>Often the details of the implementation have a strong influence on the particular instructions selected for the instruction set. For example, many implementations of the <a href="/wiki/Instruction_pipeline" title="Instruction pipeline">instruction pipeline</a> only allow a single memory load or memory store per instruction, leading to a <a href="/wiki/Load-store_architecture" title="Load-store architecture" class="mw-redirect">load-store architecture</a> (RISC). For another example, some early ways of implementing the <a href="/wiki/Instruction_pipeline" title="Instruction pipeline">instruction pipeline</a> led to a <a href="/wiki/Delay_slot" title="Delay slot">delay slot</a>.</p>
<p>The demands of high-speed digital signal processing have pushed in the opposite direction—forcing instructions to be implemented in a particular way. For example, to perform digital filters fast enough, the MAC instruction in a typical <a href="/wiki/Digital_signal_processor" title="Digital signal processor">digital signal processor</a> (DSP) must use a kind of <a href="/wiki/Harvard_architecture" title="Harvard architecture">Harvard architecture</a> that can fetch an instruction and two data words simultaneously, and it requires a single-cycle <a href="/wiki/Multiply%E2%80%93accumulate" title="Multiply–accumulate" class="mw-redirect">multiply–accumulate</a> <a href="/wiki/Multiplication_ALU" title="Multiplication ALU" class="mw-redirect">multiplier</a>.</p>
<h3><span class="mw-headline" id="Code_density">Code density</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=14" title="Edit section: Code density">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In early computers, memory was expensive, so minimizing the size of a program to make sure it would fit in the limited memory was often central. Thus the combined size of all the instructions needed to perform a particular task, the <i>code density</i>, was an important characteristic of any instruction set. Computers with high code density often have complex instructions for procedure entry, parameterized returns, loops etc. (therefore retroactively named <i>Complex Instruction Set Computers</i>, <a href="/wiki/Complex_instruction_set_computer" title="Complex instruction set computer" class="mw-redirect">CISC</a>). However, more typical, or frequent, "CISC" instructions merely combine a basic ALU operation, such as "add", with the access of one or more operands in memory (using <a href="/wiki/Addressing_mode" title="Addressing mode">addressing modes</a> such as direct, indirect, indexed etc.). Certain architectures may allow two or three operands (including the result) directly in memory or may be able to perform functions such as automatic pointer increment etc. Software-implemented instruction sets may have even more complex and powerful instructions.</p>
<p><i>Reduced instruction-set computers</i>, <a href="/wiki/Reduced_instruction_set_computer" title="Reduced instruction set computer" class="mw-redirect">RISC</a>, were first widely implemented during a period of rapidly growing memory subsystems. They sacrifice code density to simplify implementation circuitry, and try to increase performance via higher clock frequencies and more registers. A single RISC instruction typically performs only a single operation, such as an "add" of registers or a "load" from a memory location into a register. A RISC instruction set normally has a fixed <a href="#Instruction_length">instruction width</a>, whereas a typical CISC instruction set has instructions of widely varying length. However, as RISC computers normally require more and often longer instructions to implement a given task, they inherently make less optimal use of bus bandwidth and cache memories.</p>
<p>Certain embedded RISC ISAs like <a href="/wiki/ARM_architecture#Thumb" title="ARM architecture">Thumb</a> and <a href="/wiki/AVR32" title="AVR32">AVR32</a> typically exhibit very high density owing to a technique called code compression. This technique packs two 16-bit instructions into one 32-bit instruction, which is then unpacked at the decode stage and executed as two instructions.<sup id="cite_ref-weaver_7-0" class="reference"><a href="#cite_note-weaver-7"><span>[</span>7<span>]</span></a></sup></p>
<p><a href="/wiki/Minimal_instruction_set_computer" title="Minimal instruction set computer">Minimal instruction set computers</a> (MISC) are a form of <a href="/wiki/Stack_machine" title="Stack machine">stack machine</a>, where there are few separate instructions (16-64), so that multiple instructions can be fit into a single machine word. These type of cores often take little silicon to implement, so they can be easily realized in an <a href="/wiki/Field-programmable_gate_array" title="Field-programmable gate array">FPGA</a> or in a <a href="/wiki/Multi-core" title="Multi-core" class="mw-redirect">multi-core</a> form. The code density of MISC is similar to the code density of RISC; the increased instruction density is offset by requiring more of the primitive instructions to do a task.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (January 2010)">citation needed</span></a></i>]</sup></p>
<p>There has been research into <a href="/wiki/Executable_compression" title="Executable compression">executable compression</a> as a mechanism for improving code density. The mathematics of <a href="/wiki/Kolmogorov_complexity" title="Kolmogorov complexity">Kolmogorov complexity</a> describes the challenges and limits of this.</p>
<h3><span class="mw-headline" id="Number_of_operands">Number of operands</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=15" title="Edit section: Number of operands">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Instruction sets may be categorized by the maximum number of operands <i>explicitly</i> specified in instructions.</p>
<p>(In the examples that follow, <i>a</i>, <i>b</i>, and <i>c</i> are (direct or calculated) addresses referring to memory cells, while <i>reg1</i> and so on refer to machine registers.)</p>
<p><code>C = A+B</code></p>
<ul>
<li>0-operand (<i>zero-address machines</i>), so called <a href="/wiki/Stack_machine" title="Stack machine">stack machines</a>: All arithmetic operations take place using the top one or two positions on the stack: <b>push</b> <i>a</i>, <b>push</b> <i>b</i>, <b>add</b>, <b>pop</b> <i>c</i>.
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>. For stack machines, the terms "0-operand" and "zero-address" apply to arithmetic instructions, but not to all instructions, as 1-operand push and pop instructions are used to access memory.</li>
</ul>
</li>
<li>1-operand (<i>one-address machines</i>), so called <a href="/wiki/Accumulator_machine" title="Accumulator machine" class="mw-redirect">accumulator machines</a>, include early computers and many small <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a>: most instructions specify a single right operand (that is, constant, a register, or a memory location), with the implicit <a href="/wiki/Accumulator_(computing)" title="Accumulator (computing)">accumulator</a> as the left operand (and the destination if there is one): <b>load</b> <i>a</i>, <b>add</b> <i>b</i>, <b>store</b> <i>c</i>.
<ul>
<li><i>C = A+B</i> needs <b>3 instructions</b>.</li>
</ul>
</li>
<li>2-operand — many CISC and RISC machines fall under this category:
<ul>
<li>CISC — <b>move</b> <i>A</i> to <i>C</i>; then <b>add</b> <i>B</i> to <i>C</i>.
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>. This effectively 'stores' the result without an explicit <i>store</i> instruction.</li>
<li>CISC — Often machines are <a rel="nofollow" class="external text" href="http://cs.smith.edu/~thiebaut/ArtOfAssembly/CH04/CH04-3.html#HEADING3-79">limited to one memory operand</a> per instruction: <b>load</b> <i>a,reg1</i>; <b>add</b> <i>b,reg1</i>; <b>store</b> <i>reg1,c</i>; This requires a load/store pair for any memory movement regardless of whether the <b>add</b> result is an augmentation stored to a different place, as in C = A+B, or the same memory location: A = A+B.
<ul>
<li><i>C = A+B</i> needs <b>3 instructions</b>.</li>
</ul>
</li>
</ul>
</li>
<li>RISC — Requiring explicit memory loads, the instructions would be: <b>load</b> <i>a,reg1</i>; <b>load</b> <i>b,reg2</i>; <b>add</b> <i>reg1,reg2</i>; <b>store</b> <i>reg2,c</i>.
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>.</li>
</ul>
</li>
</ul>
</li>
<li>3-operand, allowing better reuse of data:<sup id="cite_ref-Cocke_4-1" class="reference"><a href="#cite_note-Cocke-4"><span>[</span>4<span>]</span></a></sup>
<ul>
<li>CISC — It becomes either a single instruction:<b>add</b> <i>a,b,c</i>
<ul>
<li><i>C = A+B</i> needs <b>1 instruction</b>.</li>
<li>or more typically: <b>move</b> <i>a,reg1</i>; <b>add</b> <i>reg1,b,c</i> as most machines are limited to two memory operands.
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>.</li>
</ul>
</li>
</ul>
</li>
<li>RISC — arithmetic instructions use registers only, so explicit 2-operand load/store instructions are needed: <b>load</b> <i>a,reg1</i>; <b>load</b> <i>b,reg2</i>; <b>add</b> <i>reg1+reg2-&gt;reg3</i>; <b>store</b> <i>reg3,c</i>;
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>.</li>
<li>Unlike 2-operand or 1-operand, this leaves all three values a, b, and c in registers available for further reuse.<sup id="cite_ref-Cocke_4-2" class="reference"><a href="#cite_note-Cocke-4"><span>[</span>4<span>]</span></a></sup></li>
</ul>
</li>
</ul>
</li>
<li>more operands—some CISC machines permit a variety of addressing modes that allow more than 3 operands (registers or memory accesses), such as the <a href="/wiki/VAX" title="VAX">VAX</a> "POLY" polynomial evaluation instruction.</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>. For stack machines, the terms "0-operand" and "zero-address" apply to arithmetic instructions, but not to all instructions, as 1-operand push and pop instructions are used to access memory.</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>3 instructions</b>.</li>
</ul>
<ul>
<li>CISC — <b>move</b> <i>A</i> to <i>C</i>; then <b>add</b> <i>B</i> to <i>C</i>.
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>. This effectively 'stores' the result without an explicit <i>store</i> instruction.</li>
<li>CISC — Often machines are <a rel="nofollow" class="external text" href="http://cs.smith.edu/~thiebaut/ArtOfAssembly/CH04/CH04-3.html#HEADING3-79">limited to one memory operand</a> per instruction: <b>load</b> <i>a,reg1</i>; <b>add</b> <i>b,reg1</i>; <b>store</b> <i>reg1,c</i>; This requires a load/store pair for any memory movement regardless of whether the <b>add</b> result is an augmentation stored to a different place, as in C = A+B, or the same memory location: A = A+B.
<ul>
<li><i>C = A+B</i> needs <b>3 instructions</b>.</li>
</ul>
</li>
</ul>
</li>
<li>RISC — Requiring explicit memory loads, the instructions would be: <b>load</b> <i>a,reg1</i>; <b>load</b> <i>b,reg2</i>; <b>add</b> <i>reg1,reg2</i>; <b>store</b> <i>reg2,c</i>.
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>.</li>
</ul>
</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>. This effectively 'stores' the result without an explicit <i>store</i> instruction.</li>
<li>CISC — Often machines are <a rel="nofollow" class="external text" href="http://cs.smith.edu/~thiebaut/ArtOfAssembly/CH04/CH04-3.html#HEADING3-79">limited to one memory operand</a> per instruction: <b>load</b> <i>a,reg1</i>; <b>add</b> <i>b,reg1</i>; <b>store</b> <i>reg1,c</i>; This requires a load/store pair for any memory movement regardless of whether the <b>add</b> result is an augmentation stored to a different place, as in C = A+B, or the same memory location: A = A+B.
<ul>
<li><i>C = A+B</i> needs <b>3 instructions</b>.</li>
</ul>
</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>3 instructions</b>.</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>.</li>
</ul>
<ul>
<li>CISC — It becomes either a single instruction:<b>add</b> <i>a,b,c</i>
<ul>
<li><i>C = A+B</i> needs <b>1 instruction</b>.</li>
<li>or more typically: <b>move</b> <i>a,reg1</i>; <b>add</b> <i>reg1,b,c</i> as most machines are limited to two memory operands.
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>.</li>
</ul>
</li>
</ul>
</li>
<li>RISC — arithmetic instructions use registers only, so explicit 2-operand load/store instructions are needed: <b>load</b> <i>a,reg1</i>; <b>load</b> <i>b,reg2</i>; <b>add</b> <i>reg1+reg2-&gt;reg3</i>; <b>store</b> <i>reg3,c</i>;
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>.</li>
<li>Unlike 2-operand or 1-operand, this leaves all three values a, b, and c in registers available for further reuse.<sup id="cite_ref-Cocke_4-2" class="reference"><a href="#cite_note-Cocke-4"><span>[</span>4<span>]</span></a></sup></li>
</ul>
</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>1 instruction</b>.</li>
<li>or more typically: <b>move</b> <i>a,reg1</i>; <b>add</b> <i>reg1,b,c</i> as most machines are limited to two memory operands.
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>.</li>
</ul>
</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>2 instructions</b>.</li>
</ul>
<ul>
<li><i>C = A+B</i> needs <b>4 instructions</b>.</li>
<li>Unlike 2-operand or 1-operand, this leaves all three values a, b, and c in registers available for further reuse.<sup id="cite_ref-Cocke_4-2" class="reference"><a href="#cite_note-Cocke-4"><span>[</span>4<span>]</span></a></sup></li>
</ul>
<p>Due to the large number of bits needed to encode the three registers of a 3-operand instruction, RISC processors using 16-bit instructions are invariably 2-operand machines, such as the Atmel AVR, the <a href="/wiki/TI_MSP430" title="TI MSP430">TI MSP430</a>, and some versions of the <a href="/wiki/ARM_Thumb" title="ARM Thumb" class="mw-redirect">ARM Thumb</a>. RISC processors using 32-bit instructions are usually 3-operand machines, such as processors implementing the <a href="/wiki/Power_Architecture" title="Power Architecture">Power Architecture</a>, the <a href="/wiki/SPARC" title="SPARC">SPARC</a> architecture, the <a href="/wiki/MIPS_architecture" title="MIPS architecture" class="mw-redirect">MIPS architecture</a>, the <a href="/wiki/ARM_architecture" title="ARM architecture">ARM architecture</a>, and the <a href="/wiki/AVR32" title="AVR32">AVR32</a> architecture.</p>
<p>Each instruction specifies some number of operands (registers, memory locations, or immediate values) <i>explicitly</i>. Some instructions give one or both operands implicitly, such as by being stored on top of the <a href="/wiki/Stack_(data_structure)" title="Stack (data structure)" class="mw-redirect">stack</a> or in an implicit register. If some of the operands are given implicitly, fewer operands need be specified in the instruction. When a "destination operand" explicitly specifies the destination, an additional operand must be supplied. Consequently, the number of operands encoded in an instruction may differ from the mathematically necessary number of arguments for a logical or arithmetic operation (the <a href="/wiki/Arity" title="Arity">arity</a>). Operands are either encoded in the "opcode" representation of the instruction, or else are given as values or addresses following the instruction.</p>
<h3><span class="mw-headline" id="Register_pressure"><span id="REGISTER-PRESSURE"></span>Register pressure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=16" title="Edit section: Register pressure">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><i>Register pressure</i> is defined as the number of free architectural registers available to use at any given point of time in a program's execution. The number of programmable registers is inversely proportional to the amount of register pressure for any ISA. Register pressure is critical because the higher the register pressure, the more register spills and more trips to the memory.<sup id="cite_ref-venkat_8-0" class="reference"><a href="#cite_note-venkat-8"><span>[</span>8<span>]</span></a></sup></p>
<p>While embedded RISC ISAs like <a href="/wiki/ARM_Thumb" title="ARM Thumb" class="mw-redirect">Thumb</a> suffer from extremely high register pressure due to lack of available programmable registers, general-purpose RISC ISAs like <a href="/wiki/MIPS" title="MIPS" class="mw-disambig">MIPS</a> and <a href="/wiki/Alpha" title="Alpha">Alpha</a> enjoy low register pressure. Interestingly, CISC ISAs like x86-64 offer low register pressure despite the fact that they have fewer programmable registers. This is a manifestation of the many addressing modes and optimizations such as sub-register addressing, absolute addressing, PC-relative addressing, and register-to-register spills, which these ISAs offer.<sup id="cite_ref-venkat_8-1" class="reference"><a href="#cite_note-venkat-8"><span>[</span>8<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=17" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Comparison_of_CPU_architectures" title="Comparison of CPU architectures" class="mw-redirect">Comparison of CPU architectures</a></li>
<li><a href="/wiki/Computer_architecture" title="Computer architecture">Computer architecture</a></li>
<li><a href="/wiki/CPU_design" title="CPU design" class="mw-redirect">CPU design</a></li>
<li><a href="/wiki/Emulator" title="Emulator">Emulator</a></li>
<li><a href="/wiki/Instruction_set_simulator" title="Instruction set simulator">Instruction set simulator</a></li>
<li><a href="/wiki/OVPsim" title="OVPsim">OVPsim</a> full systems simulator providing ability to create/model/emulate any instruction set using C and standard APIs</li>
<li><a href="/wiki/Register_transfer_language" title="Register transfer language">Register transfer language</a> (RTL)</li>
<li><a href="/wiki/List_of_instruction_sets" title="List of instruction sets">List of instruction sets</a></li>
</ul>
<h3><span class="mw-headline" id="Categories_of_ISA">Categories of ISA</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=18" title="Edit section: Categories of ISA">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a href="/wiki/Explicitly_parallel_instruction_computing" title="Explicitly parallel instruction computing">EPIC: Explicitly Parallel Instruction Computing</a></li>
<li><a href="/wiki/Vector_processor" title="Vector processor">Vector processor</a></li>
<li><a href="/wiki/SIMD" title="SIMD">SIMD: Single Instruction Multiple Data</a></li>
<li><a href="/wiki/Flynn%27s_Taxonomy" title="Flynn's Taxonomy" class="mw-redirect">Flynn's Taxonomy</a></li>
<li><a href="/wiki/Orthogonal_instruction_set" title="Orthogonal instruction set">Orthogonal instruction set</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=19" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-Pugh-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-Pugh_1-0">^</a></b></span> <span class="reference-text"><span class="citation book">Pugh, Emerson W.; Johnson, Lyle R.; Palmer, John H. (1991). <a rel="nofollow" class="external text" href="http://www.amazon.com/IBMs-Early-Systems-History-Computing/dp/0262161230"><i>IBM's 360 and Early 370 Systems</i></a>. MIT Press. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-262-16123-0" title="Special:BookSources/0-262-16123-0">0-262-16123-0</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.aufirst=Emerson+W.&amp;rft.au=Johnson%2C+Lyle+R.&amp;rft.aulast=Pugh&amp;rft.au=Palmer%2C+John+H.&amp;rft.au=Pugh%2C+Emerson+W.&amp;rft.btitle=IBM%27s+360+and+Early+370+Systems&amp;rft.date=1991&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.amazon.com%2FIBMs-Early-Systems-History-Computing%2Fdp%2F0262161230&amp;rft.isbn=0-262-16123-0&amp;rft.pub=MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://strangegizmo.com/forth/NOSC/">"Forth Resources : NOSC Mail List Archive"</a>. <i>strangegizmo.com</i><span class="reference-accessdate">. Retrieved 2014-07-25</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.atitle=Forth+Resources+%3A+NOSC+Mail+List+Archive&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fstrangegizmo.com%2Fforth%2FNOSC%2F&amp;rft.jtitle=strangegizmo.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html/">"Intel® 64 and IA-32 Architectures Software Developer’s Manual"</a>. Intel Corporation<span class="reference-accessdate">. Retrieved 12 July 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.btitle=Intel%C2%AE+64+and+IA-32+Architectures+Software+Developer%E2%80%99s+Manual&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.intel.com%2Fcontent%2Fwww%2Fus%2Fen%2Fprocessors%2Farchitectures-software-developer-manuals.html%2F&amp;rft.pub=Intel+Corporation&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Cocke-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-Cocke_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Cocke_4-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Cocke_4-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://domino.watson.ibm.com/tchjr/journalindex.nsf/0/22d06c5aa961e78085256bfa0067fa93?OpenDocument">The evolution of RISC technology at IBM by John Cocke</a> – IBM Journal of R&amp;D, Volume 44, Numbers 1/2, p.48 (2000)</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Ganssle, Jack. <a rel="nofollow" class="external text" href="http://embedded.com/showArticle.jhtml?articleID=9900044">"Proactive Debugging"</a>. Published February 26, 2001.</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://cpushack.net/CPU/cpu7.html">"Great Microprocessors of the Past and Present (V 13.4.0)"</a>. <i>cpushack.net</i><span class="reference-accessdate">. Retrieved 2014-07-25</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.atitle=Great+Microprocessors+of+the+Past+and+Present+%28V+13.4.0%29&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fcpushack.net%2FCPU%2Fcpu7.html&amp;rft.jtitle=cpushack.net&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-weaver-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-weaver_7-0">^</a></b></span> <span class="reference-text"><span class="citation conference">Weaver, Vincent M.; McKee, Sally A. (2009). <a rel="nofollow" class="external text" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5413117&amp;tag=1">"Code density concerns for new architectures"</a>. IEEE International Conference on Computer Design.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.aufirst=Vincent+M.&amp;rft.aulast=Weaver&amp;rft.au=McKee%2C+Sally+A.&amp;rft.au=Weaver%2C+Vincent+M.&amp;rft.btitle=Code+density+concerns+for+new+architectures&amp;rft.date=2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5413117%26tag%3D1&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-venkat-8"><span class="mw-cite-backlink">^ <a href="#cite_ref-venkat_8-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-venkat_8-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">Venkat, Ashish; Tullsen, Dean M. (2014). <a rel="nofollow" class="external text" href="http://dl.acm.org/citation.cfm?id=2665692">"Harnessing ISA Diversity: Design of a Heterogeneous-ISA Chip Multiprocessor"</a>. 41st Annual International Symposium on Computer Architecture.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.aufirst=Ashish&amp;rft.aulast=Venkat&amp;rft.au=Tullsen%2C+Dean+M.&amp;rft.au=Venkat%2C+Ashish&amp;rft.btitle=Harnessing+ISA+Diversity%3A+Design+of+a+Heterogeneous-ISA+Chip+Multiprocessor&amp;rft.date=2014&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D2665692&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=20" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation journal"><a href="/wiki/Jonathan_Bowen" title="Jonathan Bowen">Bowen, Jonathan P.</a> (July–August 1985). "Standard Microprocessor Programming Cards" <b>9</b> (6). pp. 274–290. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0141-9331%2885%2990116-4">10.1016/0141-9331(85)90116-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInstruction+set&amp;rft.au=Bowen%2C+Jonathan+P.&amp;rft.aufirst=Jonathan+P.&amp;rft.aulast=Bowen&amp;rft.btitle=Standard+Microprocessor+Programming+Cards&amp;rft.date=July-August+1985&amp;rft.genre=book&amp;rft_id=info%3Adoi%2F10.1016%2F0141-9331%2885%2990116-4&amp;rft.issue=6&amp;rft.pages=274-290&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=9" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Instruction_set&amp;action=edit&amp;section=21" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.textfiles.com/programming/CARDS/">Programming Textfiles: Bowen's Instruction Summary Cards</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.clemson.edu/~mark/hist.html">Mark Smotherman's Historical Computer Designs Page</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:CPU_technologies" title="Template:CPU technologies"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:CPU_technologies" title="Template talk:CPU technologies"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:CPU_technologies&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Harvard_architecture" title="Harvard architecture">Harvard</a> (<a href="/wiki/Modified_Harvard_architecture" title="Modified Harvard architecture">Modified Harvard</a>)</li>
<li><a href="/wiki/Von_Neumann_architecture" title="Von Neumann architecture">von Neumann</a></li>
<li><a href="/wiki/Dataflow_architecture" title="Dataflow architecture">Dataflow</a></li>
<li><a href="/wiki/Transport_triggered_architecture" title="Transport triggered architecture">TTA</a></li>
<li><a href="/wiki/Comparison_of_instruction_set_architectures" title="Comparison of instruction set architectures">Comparison</a></li>
</ul>
<ul>
<li><a href="/wiki/Application-specific_instruction-set_processor" title="Application-specific instruction-set processor">ASIP</a></li>
<li><a href="/wiki/Complex_instruction_set_computing" title="Complex instruction set computing">CISC</a></li>
<li><a href="/wiki/Explicit_Data_Graph_Execution" title="Explicit Data Graph Execution">EDGE</a></li>
<li><a href="/wiki/Explicitly_parallel_instruction_computing" title="Explicitly parallel instruction computing">EPIC</a></li>
<li><a href="/wiki/Minimal_instruction_set_computer" title="Minimal instruction set computer">MISC</a></li>
<li><a href="/wiki/One_instruction_set_computer" title="One instruction set computer">OISC</a></li>
<li><a href="/wiki/Reduced_instruction_set_computing" title="Reduced instruction set computing">RISC</a></li>
<li><a href="/wiki/Very_long_instruction_word" title="Very long instruction word">VLIW</a></li>
<li><a href="/wiki/No_instruction_set_computing" title="No instruction set computing">NISC</a></li>
<li><a href="/wiki/Zero_instruction_set_computer" title="Zero instruction set computer">ZISC</a></li>
<li><a href="/wiki/TRIPS_architecture" title="TRIPS architecture">TRIPS</a></li>
</ul>
<ul>
<li><a href="/wiki/1-bit_architecture" title="1-bit architecture">1-bit</a></li>
<li><a href="/wiki/4-bit" title="4-bit">4-bit</a></li>
<li><a href="/wiki/8-bit" title="8-bit">8-bit</a></li>
<li><a href="/wiki/Word_(computer_architecture)#Table_of_word_sizes" title="Word (computer architecture)">9-bit</a></li>
<li><a href="/wiki/Ferranti_Mercury" title="Ferranti Mercury">10-bit</a></li>
<li><a href="/wiki/12-bit" title="12-bit">12-bit</a></li>
<li><a href="/wiki/Apollo_Guidance_Computer" title="Apollo Guidance Computer">15-bit</a></li>
<li><a href="/wiki/16-bit" title="16-bit">16-bit</a></li>
<li><a href="/wiki/18-bit" title="18-bit">18-bit</a></li>
<li><a href="/wiki/Z3_(computer)" title="Z3 (computer)">22-bit</a></li>
<li><a href="/wiki/24-bit" title="24-bit">24-bit</a></li>
<li><a href="/wiki/UNIVAC_III" title="UNIVAC III">25-bit</a></li>
<li><a href="/wiki/Saturn_Launch_Vehicle_Digital_Computer" title="Saturn Launch Vehicle Digital Computer">26-bit</a></li>
<li><a href="/wiki/D-17B" title="D-17B">27-bit</a></li>
<li><a href="/wiki/31-bit" title="31-bit">31-bit</a></li>
<li><a href="/wiki/32-bit" title="32-bit">32-bit</a></li>
<li><a href="/wiki/ZEBRA_(computer)" title="ZEBRA (computer)">33-bit</a></li>
<li><a href="/wiki/Fast_Universal_Digital_Computer_M-2" title="Fast Universal Digital Computer M-2">34-bit</a></li>
<li><a href="/wiki/36-bit" title="36-bit">36-bit</a></li>
<li><a href="/wiki/Word_(computer_architecture)#Table_of_word_sizes" title="Word (computer architecture)">39-bit</a></li>
<li><a href="/wiki/IAS_machine" title="IAS machine">40-bit</a></li>
<li><a href="/wiki/48-bit" title="48-bit">48-bit</a></li>
<li><a href="/wiki/Atanasoff%E2%80%93Berry_computer" title="Atanasoff–Berry computer">50-bit</a></li>
<li><a href="/wiki/60-bit" title="60-bit">60-bit</a></li>
<li><a href="/wiki/64-bit_computing" title="64-bit computing">64-bit</a></li>
<li><a href="/wiki/128-bit" title="128-bit">128-bit</a></li>
<li><a href="/wiki/256-bit" title="256-bit">256-bit</a></li>
<li><a href="/wiki/512-bit" title="512-bit">512-bit</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">variable</a></li>
</ul>
<ul>
<li><a href="/wiki/Instruction_pipeline" title="Instruction pipeline">Instruction pipelining</a>
<ul>
<li><a href="/wiki/Bubble_(computing)" title="Bubble (computing)">Bubble</a></li>
<li><a href="/wiki/Operand_forwarding" title="Operand forwarding">Operand forwarding</a></li>
</ul>
</li>
<li><a href="/wiki/Out-of-order_execution" title="Out-of-order execution">Out-of-order execution</a>
<ul>
<li><a href="/wiki/Register_renaming" title="Register renaming">Register renaming</a></li>
</ul>
</li>
<li><a href="/wiki/Speculative_execution" title="Speculative execution">Speculative execution</a>
<ul>
<li><a href="/wiki/Branch_predictor" title="Branch predictor">Branch predictor</a></li>
<li><a href="/wiki/Memory_dependence_prediction" title="Memory dependence prediction">Memory dependence prediction</a></li>
</ul>
</li>
<li><a href="/wiki/Hazard_(computer_architecture)" title="Hazard (computer architecture)">Hazards</a></li>
</ul>
<ul>
<li><a href="/wiki/Bubble_(computing)" title="Bubble (computing)">Bubble</a></li>
<li><a href="/wiki/Operand_forwarding" title="Operand forwarding">Operand forwarding</a></li>
</ul>
<ul>
<li><a href="/wiki/Register_renaming" title="Register renaming">Register renaming</a></li>
</ul>
<ul>
<li><a href="/wiki/Branch_predictor" title="Branch predictor">Branch predictor</a></li>
<li><a href="/wiki/Memory_dependence_prediction" title="Memory dependence prediction">Memory dependence prediction</a></li>
</ul>
<ul>
<li><a href="/wiki/Bit-level_parallelism" title="Bit-level parallelism">Bit</a>
<ul>
<li><a href="/wiki/Bit-serial_architecture" title="Bit-serial architecture">Bit-serial</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
</li>
<li><a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">Instruction</a>
<ul>
<li><a href="/wiki/Scalar_processor" title="Scalar processor">Scalar</a></li>
<li><a href="/wiki/Superscalar" title="Superscalar">Superscalar</a></li>
</ul>
</li>
<li><a href="/wiki/Data_parallelism" title="Data parallelism">Data</a>
<ul>
<li><a href="/wiki/Vector_processor" title="Vector processor">Vector</a></li>
</ul>
</li>
<li><a href="/wiki/Memory-level_parallelism" title="Memory-level parallelism">Memory</a></li>
<li><a href="/wiki/Task_parallelism" title="Task parallelism">Task</a>
<ul>
<li><a href="/wiki/Thread_(computing)" title="Thread (computing)">Thread</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Bit-serial_architecture" title="Bit-serial architecture">Bit-serial</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
<ul>
<li><a href="/wiki/Scalar_processor" title="Scalar processor">Scalar</a></li>
<li><a href="/wiki/Superscalar" title="Superscalar">Superscalar</a></li>
</ul>
<ul>
<li><a href="/wiki/Vector_processor" title="Vector processor">Vector</a></li>
</ul>
<ul>
<li><a href="/wiki/Thread_(computing)" title="Thread (computing)">Thread</a></li>
</ul>
<ul>
<li><a href="/wiki/Temporal_multithreading" title="Temporal multithreading">Temporal multithreading</a></li>
<li><a href="/wiki/Simultaneous_multithreading" title="Simultaneous multithreading">Simultaneous multithreading</a>
<ul>
<li><a href="/wiki/Hyper-threading" title="Hyper-threading">Hyper-threading</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Hyper-threading" title="Hyper-threading">Hyper-threading</a></li>
</ul>
<ul>
<li><a href="/wiki/SISD" title="SISD">SISD</a></li>
<li><a href="/wiki/SIMD" title="SIMD">SIMD</a></li>
<li><a href="/wiki/MISD" title="MISD">MISD</a></li>
<li><a href="/wiki/MIMD" title="MIMD">MIMD</a>
<ul>
<li><a href="/wiki/SPMD" title="SPMD">SPMD</a></li>
</ul>
</li>
<li><a href="/wiki/Addressing_mode" title="Addressing mode">Addressing mode</a></li>
</ul>
<ul>
<li><a href="/wiki/SPMD" title="SPMD">SPMD</a></li>
</ul>
<ul>
<li><a href="/wiki/Digital_signal_processor" title="Digital signal processor">Digital signal processor</a></li>
<li><a href="/wiki/General-purpose_computing_on_graphics_processing_units" title="General-purpose computing on graphics processing units">GPGPU</a></li>
<li><a href="/wiki/Microcontroller" title="Microcontroller">Microcontroller</a></li>
<li><a href="/wiki/Physics_processing_unit" title="Physics processing unit">Physics processing unit</a></li>
<li><a href="/wiki/System_on_a_chip" title="System on a chip">System on a chip</a></li>
<li><a href="/wiki/Cellular_architecture" title="Cellular architecture">Cellular</a></li>
</ul>
<ul>
<li><a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">ALU</a></li>
<li><a href="/wiki/Barrel_shifter" title="Barrel shifter">Barrel shifter</a></li>
<li><a href="/wiki/Floating-point_unit" title="Floating-point unit">Floating-point unit</a></li>
<li><a href="/wiki/Back-side_bus" title="Back-side bus">Back-side bus</a></li>
<li>(<a href="/wiki/Multiplexer" title="Multiplexer">Multiplexer</a>, <a href="/wiki/Demultiplexer" title="Demultiplexer" class="mw-redirect">Demultiplexer</a>)</li>
<li><a href="/wiki/Processor_register" title="Processor register">Registers</a></li>
<li><a href="/wiki/Memory_management_unit" title="Memory management unit">Memory management unit</a></li>
<li><a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">TLB</a></li>
<li><a href="/wiki/CPU_cache" title="CPU cache">Cache</a></li>
<li><a href="/wiki/Register_file" title="Register file">Register file</a></li>
<li><a href="/wiki/Microcode" title="Microcode">Microcode</a></li>
<li><a href="/wiki/Control_unit" title="Control unit">Control unit</a></li>
<li><a href="/wiki/Clock_rate" title="Clock rate">Clock rate</a></li>
</ul>
<ul>
<li><a href="/wiki/Advanced_Power_Management" title="Advanced Power Management">APM</a></li>
<li><a href="/wiki/Advanced_Configuration_and_Power_Interface" title="Advanced Configuration and Power Interface">ACPI</a></li>
<li><a href="/wiki/Dynamic_frequency_scaling" title="Dynamic frequency scaling">Dynamic frequency scaling</a></li>
<li><a href="/wiki/Dynamic_voltage_scaling" title="Dynamic voltage scaling">Dynamic voltage scaling</a></li>
<li><a href="/wiki/Clock_gating" title="Clock gating">Clock gating</a></li>
</ul>
<ul>
<li><a href="/wiki/NX_bit" title="NX bit">NX bit</a></li>
<li><a href="/wiki/Hardware_restriction" title="Hardware restriction">Hardware restriction</a> (<a href="/wiki/Firmware" title="Firmware">firmware</a>)</li>
<li><a href="/wiki/Trusted_Execution_Technology" title="Trusted Execution Technology">Trusted Execution Technology</a></li>
<li><a href="/wiki/Secure_cryptoprocessor" title="Secure cryptoprocessor">Secure cryptoprocessor</a></li>
<li><a href="/wiki/Hardware_security_module" title="Hardware security module">Hardware security module</a></li>
<li><a href="/wiki/Hengzhi_chip" title="Hengzhi chip">Hengzhi chip</a></li>
</ul>
