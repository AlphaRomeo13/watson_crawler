<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Abstraction principle (computer programming)</span></h1>
<p>In <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a> and <a href="/wiki/Programming_language_theory" title="Programming language theory">programming language theory</a>, the <b>abstraction principle</b> (or the <b>principle of abstraction</b>) is a basic <a href="/wiki/Dictum" title="Dictum">dictum</a> that aims to reduce duplication of information in a program (usually with emphasis on <a href="/wiki/Code_duplication" title="Code duplication" class="mw-redirect">code duplication</a>) whenever practical by making use of <a href="/wiki/Abstraction_(computer_science)" title="Abstraction (computer science)">abstractions</a> provided by the programming language or <a href="/wiki/Software_libraries" title="Software libraries" class="mw-redirect">software libraries</a>. The principle is sometimes stated as a recommendation to the programmer, but sometimes stated as requirement of the programming language, assuming it is self-understood why abstractions are desirable to use. The origins of the principle are uncertain; it has been reinvented a number of times, sometimes under a different name, with slight variations.</p>
<p>When read as recommendation to the programmer, the abstraction principle can be generalized as the "<a href="/wiki/Don%27t_repeat_yourself" title="Don't repeat yourself">don't repeat yourself</a>" principle, which recommends avoiding the duplication of information in general, and also avoiding the duplication of human effort involved in the software development process.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#The_principle"><span class="tocnumber">1</span> <span class="toctext">The principle</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#History_and_variations"><span class="tocnumber">2</span> <span class="toctext">History and variations</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Implications"><span class="tocnumber">3</span> <span class="toctext">Implications</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Generalizations"><span class="tocnumber">4</span> <span class="toctext">Generalizations</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="The_principle">The principle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abstraction_principle_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: The principle">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>As a recommendation to the programmer, in its formulation by <a href="/wiki/Benjamin_C._Pierce" title="Benjamin C. Pierce">Benjamin C. Pierce</a> in <i><a href="/wiki/Types_and_Programming_Languages" title="Types and Programming Languages">Types and Programming Languages</a></i> (2002), the abstraction principle reads (emphasis in original):<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>As a requirement of the programming language, in its formulation by David A. Schmidt in <i>The structure of typed programming languages</i> (1994), the abstraction principle reads:.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="History_and_variations">History and variations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abstraction_principle_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: History and variations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Under this very name, the abstraction principle appears into a long list of books. Here we give a necessarily incomplete list, together with the formulation if it is succinct:</p>
<ul>
<li>Alfred John Cole, Ronald Morrison (1982) <i>An introduction to programming with S-algol</i>: "[Abstraction] when applied to language design is to define all the semantically meaningful syntactic categories in the language and allow an abstraction over them".<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></li>
<li>Bruce J. MacLennan (1983) <i>Principles of programming languages: design, evaluation, and implementation</i>: "Avoid requiring something to be stated more than once; factor out the recurring pattern".<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></li>
<li>Jon Pearce (1998) <i>Programming and Meta-Programming in Scheme</i>: "Structure and function should be independent".<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></li>
</ul>
<p>The principle plays a central role in <a href="/wiki/Design_pattern_(computer_science)" title="Design pattern (computer science)" class="mw-redirect">design patterns</a> in <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, although most writings on that topic do not give a name to the principle. The <a href="/wiki/Design_Patterns_(book)" title="Design Patterns (book)" class="mw-redirect">influential book by the Gang of Four</a>, states: "The focus here is <i><a href="/wiki/Encapsulation_(object-oriented_programming)" title="Encapsulation (object-oriented programming)">encapsulating</a> the concept that varies</i>, a theme of many design patterns." This statement has been rephrased by other authors as "Find what varies and encapsulate it."<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<p>In this century, the principle has been reinvented in <a href="/wiki/Extreme_programming" title="Extreme programming">extreme programming</a> under the slogan "Once and Only Once". The definition of this principle was rather succinct in its first appearance: "no duplicate code".<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> It has later been elaborated as applicable to other issues in software development: "Automate every process that's worth automating. If you find yourself performing a task many times, script it."<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Implications">Implications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abstraction_principle_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Implications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The abstraction principle is often stated in the context of some mechanism intended to facilitate abstraction. The basic mechanism of control abstraction is a function or <a href="/wiki/Subroutine" title="Subroutine">subroutine</a>. Data abstractions include various forms of <a href="/wiki/Type_polymorphism" title="Type polymorphism" class="mw-redirect">type polymorphism</a>. More elaborate mechanisms that may combine data and control abstractions include: <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data types</a>, including <a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">classes</a>, <a href="/wiki/Polymorphism_(computer_science)#Polytypism" title="Polymorphism (computer science)">polytypism</a> etc. The quest for richer abstractions that allow less duplication in complex scenarios is one of the driving forces in programming language research and design.</p>
<p>Inexperienced programmers may be tempted to introduce too much abstraction in their program—abstraction that won't be used more than once.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (March 2013)">citation needed</span></a></i>]</sup> A complementary principle that emphasize this issue is "<a href="/wiki/You_Ain%27t_Gonna_Need_It" title="You Ain't Gonna Need It" class="mw-redirect">You Ain't Gonna Need It</a>" and, more generally, the <a href="/wiki/KISS_principle" title="KISS principle">KISS principle</a>.</p>
<p>Since code is usually subject to revisions, following the abstraction principle may entail <a href="/wiki/Refactoring" title="Refactoring" class="mw-redirect">refactoring</a> of code. The effort of rewriting a piece of code generically needs to be amortized against the estimated future benefits of an abstraction. A rule of thumb governing this was devised by <a href="/wiki/Martin_Fowler" title="Martin Fowler">Martin Fowler</a>, and popularized as <a href="/wiki/Rule_of_three_(programming)" title="Rule of three (programming)" class="mw-redirect">the rule of three</a>. It states that if a piece of code is copied more than once, i.e. it would end up having three or more copies, then it needs to be abstracted out.</p>
<h2><span class="mw-headline" id="Generalizations">Generalizations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abstraction_principle_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: Generalizations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>"<a href="/wiki/Don%27t_repeat_yourself" title="Don't repeat yourself">Don't repeat yourself</a>", or the "DRY principle", is a generalization developed in the context of <a href="/wiki/Multi-tier_architecture" title="Multi-tier architecture" class="mw-redirect">multi-tier architectures</a>, where related code is by necessity duplicated to some extent across tiers, usually in different languages. In practical terms, the recommendation here is to rely on automated tools, like <a href="/wiki/Code_generator" title="Code generator" class="mw-redirect">code generators</a> and <a href="/wiki/Data_transformation" title="Data transformation">data transformations</a> to avoid repetition.</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abstraction_principle_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation book">Pierce, Benjamin (2002). <i>Types and Programming Languages</i>. MIT Press. p. 339. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-262-16209-1" title="Special:BookSources/0-262-16209-1">0-262-16209-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbstraction+principle+%28computer+programming%29&amp;rft.aufirst=Benjamin&amp;rft.aulast=Pierce&amp;rft.au=Pierce%2C+Benjamin&amp;rft.btitle=Types+and+Programming+Languages&amp;rft.date=2002&amp;rft.genre=book&amp;rft.isbn=0-262-16209-1&amp;rft.pages=339&amp;rft.pub=MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">David A. Schmidt, <i>The structure of typed programming languages</i>, MIT Press, 1994, <a href="/wiki/Special:BookSources/0262193493" class="internal mw-magiclink-isbn">ISBN 0-262-19349-3</a>, p. 32</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Alfred John Cole, Ronald Morrison, <i>An introduction to programming with S-algol</i>, CUP Archive, 1982, <a href="/wiki/Special:BookSources/0521250013" class="internal mw-magiclink-isbn">ISBN 0-521-25001-3</a>, p. 150</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Bruce J. MacLennan, <i>Principles of programming languages: design, evaluation, and implementation</i>, Holt, Rinehart, and Winston, 1983, p. 53</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Jon Pearce, <i>Programming and meta-programming in scheme</i>, Birkhäuser, 1998, <a href="/wiki/Special:BookSources/0387983201" class="internal mw-magiclink-isbn">ISBN 0-387-98320-1</a>, p. 40</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Alan Shalloway, James Trott, <i>Design patterns explained: a new perspective on object-oriented design</i>, Addison-Wesley, 2002, <a href="/wiki/Special:BookSources/0201715945" class="internal mw-magiclink-isbn">ISBN 0-201-71594-5</a>, p. 115</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Kent Beck, <i>Extreme programming explained: embrace change</i>, 2nd edition, Addison-Wesley, 2000, <a href="/wiki/Special:BookSources/0201616416" class="internal mw-magiclink-isbn">ISBN 0-201-61641-6</a>, p. 61</span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text">Chromatic, <i>Extreme programming pocket guide</i>, O'Reilly, 2003, <a href="/wiki/Special:BookSources/0596004850" class="internal mw-magiclink-isbn">ISBN 0-596-00485-0</a></span></li>
</ol>
