<h1>String Literals</h1>
<p>The most basic form of pattern matching supported by this API is the match of a string literal. For example, if the regular expression is <code>foo</code> and the input string is <code>foo</code>, the match will succeed because the strings are identical. Try this out with the test harness:</p>
<p>WHATSON? 9bf8ea3e-a106-4660-b667-8203d0cc6e74</p>
<pre> 
Enter your regex: foo
Enter input string to search: foo
I found the text foo starting at index 0 and ending at index 3.
</pre>
<p>This match was a success. Note that while the input string is 3 characters long, the start index is 0 and the end index is 3. By convention, ranges are inclusive of the beginning index and exclusive of the end index, as shown in the following figure:</p>
<p class="FigureCaption">The string literal foo, with numbered cells and index values.</p>
<p>Each character in the string resides in its own <i>cell</i>, with the index positions pointing between each cell. The string "foo" starts at index 0 and ends at index 3, even though the characters themselves only occupy cells 0, 1, and 2.</p>
<p>With subsequent matches, you'll notice some overlap; the start index for the next match is the same as the end index of the previous match:</p>
<p>WHATSON? d84c8dce-fda4-42d3-a887-5dca1c1e8e3c</p>
<pre> 
Enter your regex: foo
Enter input string to search: foofoofoo
I found the text foo starting at index 0 and ending at index 3.
I found the text foo starting at index 3 and ending at index 6.
I found the text foo starting at index 6 and ending at index 9.
</pre>
<h2>Metacharacters</h2>
<p>This API also supports a number of special characters that affect the way a pattern is matched. Change the regular expression to <code>cat.</code> and the input string to <code>cats</code>. The output will appear as follows:</p>
<p>WHATSON? ae3d1f86-53a0-4300-8f8e-a3121a4c51cd</p>
<pre>
Enter your regex: cat.
Enter input string to search: cats
I found the text cats starting at index 0 and ending at index 4.
</pre>
<p>The match still succeeds, even though the dot "<code>.</code>" is not present in the input string. It succeeds because the dot is a <i>metacharacter</i> Â— a character with special meaning interpreted by the matcher. The metacharacter "." means "any character" which is why the match succeeds in this example.</p>
<p>The metacharacters supported by this API are: <code>&lt;([{\^-=$!|]})?*+.&gt;</code></p>
<p>There are two ways to force a metacharacter to be treated as an ordinary character:</p>
<ul>
<li>precede the metacharacter with a backslash, or</li>
<li>enclose it within <code>\Q</code> (which starts the quote) and <code>\E</code> (which ends it).</li>
</ul>
<p>When using this technique, the <code>\Q</code> and <code>\E</code> can be placed at any location within the expression, provided that the <code>\Q</code> comes first.</p>
