<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Invariant (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, an <b>invariant</b> is a condition that can be relied upon to be true during execution of a program, or during some portion of it. It is a <a href="/wiki/Logical_assertion" title="Logical assertion">logical assertion</a> that is held to always be true during a certain phase of execution. For example, a <a href="/wiki/Loop_invariant" title="Loop invariant">loop invariant</a> is a condition that is true at the beginning and end of every execution of a loop.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Use"><span class="tocnumber">1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Example"><span class="tocnumber">2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Automatic_invariant_detection_in_imperative_programs"><span class="tocnumber">3</span> <span class="toctext">Automatic invariant detection in imperative programs</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Use">Use</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Invariant_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Use">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Invariants are especially useful when reasoning about whether a computer program is correct. The theory of <a href="/wiki/Optimizing_compiler" title="Optimizing compiler">optimizing compilers</a>, the methodology of <a href="/wiki/Design_by_contract" title="Design by contract">design by contract</a>, and <a href="/wiki/Formal_methods" title="Formal methods">formal methods</a> for determining <a href="/wiki/Program_correctness" title="Program correctness" class="mw-redirect">program correctness</a>, all rely heavily on "<b>invariant</b>"s in <a href="/wiki/Computer_program" title="Computer program">computer programs</a>.</p>
<p>Programmers often use <a href="/wiki/Assertion_(computing)" title="Assertion (computing)" class="mw-redirect">assertions</a> in their code to make invariants explicit. Some <a href="/wiki/Object_oriented" title="Object oriented" class="mw-redirect">object oriented</a> <a href="/wiki/Programming_language" title="Programming language">programming languages</a> have a special syntax for specifying <a href="/wiki/Class_invariant" title="Class invariant">class invariants</a>.</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Invariant_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/MU_puzzle" title="MU puzzle">MU puzzle</a> is a good example of a logical problem where determining an invariant is useful. The puzzle asks one to start with the word MI and transform it into the word MU using in each step one of the following transformation rules:</p>
<ol>
<li>If a string ends with an I, a U may be appended (<i>x</i>I → <i>x</i>IU)</li>
<li>The string after the M may be completely duplicated (M<i>x</i> → M<i>xx</i>)</li>
<li>Any three consecutive I's (III) may be replaced with a single U (<i>x</i>III<i>y</i> → <i>x</i>U<i>y</i>)</li>
<li>Any two consecutive U's may be removed (<i>x</i>UU<i>y</i> → <i>xy</i>)</li>
</ol>
<p>An example derivation (superscripts indicating the applied rules) is</p>
<p>Is it possible to convert MI into MU using these four transformation rules only?</p>
<p>One could spend many hours applying these transformation rules to strings. However, it might be quicker to find a <a href="/wiki/Predicate_(mathematical_logic)" title="Predicate (mathematical logic)">predicate</a> that's invariant to all rules, and makes getting to <i>MU</i> impossible. Logically looking at the puzzle, the only way to get rid of any I's is to have three consecutive I's in the string. This makes the following invariant interesting to consider:</p>
<p>This is an invariant to the problem if for each of the transformation rules the following holds: if the invariant held before applying the rule, it will also hold after applying it. If we look at the net effect of applying the rules on the number of I's and U's we can see this actually is the case for all rules:</p>
<p>The table above shows clearly that the invariant holds for each of the possible transformation rules, which basically means that whichever rule we pick, at whatever state, if the number of I's was not a multiple of three before applying the rule, it won't be afterwards either.</p>
<p>Given that there is a single I in the starting string MI, and one is not a multiple of three, it's impossible to go from MI to MU as zero is a multiple of three.</p>
<h2><span class="mw-headline" id="Automatic_invariant_detection_in_imperative_programs">Automatic invariant detection in imperative programs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Invariant_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Automatic invariant detection in imperative programs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Abstract_interpretation" title="Abstract interpretation">Abstract interpretation</a> tools can compute simple invariants of given imperative computer programs. The kind of properties that can be found depend on the <a href="/wiki/Abstract_interpretation#Examples_of_abstract_domains" title="Abstract interpretation">abstract domains</a> used. Typical example properties are single integer variable ranges like <code>0&lt;=x&lt;1024</code>, relations between several variables like <code>0&lt;=i-j&lt;2*n-1</code>, and modulus information like <code>y%4==0</code>. Academic research prototypes also consider simple properties of pointer structures.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>Any more sophisticated invariants still have to be provided manually. In particular, when verifying an imperative program using the Hoare calculus,<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> a loop invariant has to be provided manually for each loop in the program, which is one of the reasons for that task being extremely tedious.</p>
<p>In the above example, no tool will be able to detect from rules 1-4 that a derivation "MI →...→ MU" is impossible. However, once the abstraction from the string to the number of its "I"s has been made by hand, leading e.g. to the following C program, an abstract interpretation tool will be able to detect that <code>ICount%3</code> can't be 0 and hence the "while"-loop will never terminate.</p>
<p>WHATSON? 63a3d286-3df3-497a-94a8-15b78568aa92</p>
<pre class="de1">
<span class="kw4">void</span> MUPuzzle<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">volatile</span> <span class="kw4">int</span> RandomRule<span class="sy0">;</span>
    <span class="kw4">int</span> ICount<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">,</span> UCount<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
    <span class="kw1">while</span> <span class="br0">(</span>ICount<span class="sy0">%</span><span class="nu19">3</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">)</span>                            <span class="co1">// non-terminating loop</span>
        <span class="kw1">switch</span><span class="br0">(</span>RandomRule<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">case</span> <span class="nu0">1</span><span class="sy0">:</span>                UCount<span class="sy0">+=</span><span class="nu0">1</span><span class="sy0">;</span>   <span class="kw2">break</span><span class="sy0">;</span>
        <span class="kw1">case</span> <span class="nu0">2</span><span class="sy0">:</span>   ICount<span class="sy0">*=</span><span class="nu0">2</span><span class="sy0">;</span>   UCount<span class="sy0">*=</span><span class="nu0">2</span><span class="sy0">;</span>   <span class="kw2">break</span><span class="sy0">;</span>
        <span class="kw1">case</span> <span class="nu0">3</span><span class="sy0">:</span>   ICount<span class="sy0">-=</span><span class="nu0">3</span><span class="sy0">;</span>   UCount<span class="sy0">+=</span><span class="nu0">1</span><span class="sy0">;</span>   <span class="kw2">break</span><span class="sy0">;</span>
        <span class="kw1">case</span> <span class="nu0">4</span><span class="sy0">:</span>                UCount<span class="sy0">-=</span><span class="nu0">2</span><span class="sy0">;</span>   <span class="kw2">break</span><span class="sy0">;</span>
        <span class="br0">}</span>                                          <span class="co1">// computed invariant: ICount%3==1||ICount%3==2</span>
<span class="br0">}</span>
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Invariant_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Hoare_logic" title="Hoare logic">Hoare logic</a></li>
<li><a href="/wiki/Loop_invariant" title="Loop invariant">Loop invariant</a></li>
<li><a href="/wiki/Class_invariant" title="Class invariant">Class invariant</a></li>
<li><a href="/wiki/Const_correctness" title="Const correctness" class="mw-redirect">Const correctness</a></li>
<li><a href="/wiki/Assertion_(software_development)" title="Assertion (software development)">Assertion (software development)</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Invariant_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>J.D. Fokker, <a href="/wiki/Hans_Zantema" title="Hans Zantema">H. Zantema</a>, S.D. Swierstra (1991). "Iteratie en invariatie", Programmeren en Correctheid. Academic Service. <a href="/wiki/Special:BookSources/9062336817" class="internal mw-magiclink-isbn">ISBN 90-6233-681-7</a>.</li>
</ul>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation conference">Bouajjani, A.; Drǎgoi, C.; Enea, C.; Rezine, A.; Sighireanu, M. (2010). "Invariant Synthesis for Programs Manipulating Lists with Unbounded Data". "Proc. CAV".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInvariant+%28computer+science%29&amp;rft.atitle=Proc.+CAV&amp;rft.au=Bouajjani%2C+A.&amp;rft.au=Dr%C7%8Egoi%2C+C.&amp;rft.au=Enea%2C+C.&amp;rft.aufirst=A.&amp;rft.aulast=Bouajjani&amp;rft.au=Rezine%2C+A.&amp;rft.au=Sighireanu%2C+M.&amp;rft.btitle=Invariant+Synthesis+for+Programs+Manipulating+Lists+with+Unbounded+Data&amp;rft.date=2010&amp;rft.genre=bookitem&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation journal"><a href="/wiki/C.A.R._Hoare" title="C.A.R. Hoare" class="mw-redirect">Hoare, C. A. R.</a> (October 1969). <a rel="nofollow" class="external text" href="http://www.spatial.maine.edu/~worboys/processes/hoare%20axiomatic.pdf">"An axiomatic basis for computer programming"</a>. <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i> <b>12</b> (10): 576–580. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F363235.363259">10.1145/363235.363259</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInvariant+%28computer+science%29&amp;rft.atitle=An+axiomatic+basis+for+computer+programming&amp;rft.aufirst=C.+A.+R.&amp;rft.au=Hoare%2C+C.+A.+R.&amp;rft.aulast=Hoare&amp;rft.date=October+1969&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.spatial.maine.edu%2F~worboys%2Fprocesses%2Fhoare%2520axiomatic.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F363235.363259&amp;rft.issue=10&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.pages=576-580&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=12" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1145.2F363235.363259&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Invariant_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.u.arizona.edu/~wbraynen/software/VisualInvariants/index.html">Applet: Visual Invariants in Sorting Algorithms</a></li>
</ul>
