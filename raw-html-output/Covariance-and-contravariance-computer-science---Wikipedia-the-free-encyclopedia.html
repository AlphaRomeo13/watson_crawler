<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Covariance and contravariance (computer science)</span></h1>
<p>Many <a href="/wiki/Programming_language" title="Programming language">programming language</a> <a href="/wiki/Type_system" title="Type system">type systems</a> support <a href="/wiki/Subtyping" title="Subtyping">subtyping</a>. For instance, if <span class="mw-geshi csharp source-csharp">Cat</span> is subtype of <span class="mw-geshi csharp source-csharp">Animal</span>, then an expression of type <span class="mw-geshi csharp source-csharp">Cat</span> can be used whenever an expression of type <span class="mw-geshi csharp source-csharp">Animal</span> could. <b>Variance</b> refers to how subtyping between more complex types (list of <span class="mw-geshi csharp source-csharp">Cat</span>s versus list of <span class="mw-geshi csharp source-csharp">Animal</span>s, function returning <span class="mw-geshi csharp source-csharp">Cat</span> versus function returning <span class="mw-geshi csharp source-csharp">Animal</span>, ...) relates to subtyping between their components. Depending on the variance of the <a href="/wiki/Type_constructor" title="Type constructor">type constructor</a>, the subtyping relation may be either preserved, reversed, or ignored. For example, in <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>:</p>
<ul>
<li><span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span>. The subtyping is preserved because <span class="mw-geshi csharp source-csharp">IEnumerable</span> is <b>covariant</b>.</li>
<li><span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span>. The subtyping is reversed because <span class="mw-geshi csharp source-csharp">Action</span> is <b>contravariant</b>.</li>
<li>Neither <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> nor <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span> is a subtype of the other, because <span class="mw-geshi csharp source-csharp">IList</span> is <b>invariant</b>.</li>
</ul>
<p>The variance of a C# interface is determined by <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>/<span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> annotations on its type parameters; the above interfaces are declared as <span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span><span class="kw1">out</span> T<span class="sy0">&gt;</span></span>, <span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span><span class="kw1">in</span> T<span class="sy0">&gt;</span></span>, and <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>. The <a href="#Interfaces">typing rules for interface variance</a> ensure type safety. For example, an <span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> represents a first-class function expecting an argument of type <span class="mw-geshi csharp source-csharp">T</span>, and a function which can handle any type of animal can always be used instead of one which can only handle cats.</p>
<p>A programming language designer will consider variance when devising typing rules for e.g. arrays, inheritance, and generic datatypes. By making type constructors covariant or contravariant instead of invariant, more programs will be accepted as well-typed. On the other hand, programmers often find contravariance unintuitive, and accurately tracking variance to avoid runtime type errors can lead to complex typing rules. In order to keep the type system simple and allow useful programs, a language may treat a type constructor as invariant even if it would be safe to consider it variant, or treat it as covariant even when that can violate type safety.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Formal_definition"><span class="tocnumber">1</span> <span class="toctext">Formal definition</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Arrays"><span class="tocnumber">2</span> <span class="toctext">Arrays</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Covariant_arrays_in_Java_and_C.23"><span class="tocnumber">2.1</span> <span class="toctext">Covariant arrays in Java and C#</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Function_types"><span class="tocnumber">3</span> <span class="toctext">Function types</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Inheritance_in_object_oriented_languages"><span class="tocnumber">4</span> <span class="toctext">Inheritance in object oriented languages</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Covariant_method_return_type"><span class="tocnumber">4.1</span> <span class="toctext">Covariant method return type</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Contravariant_method_argument_type"><span class="tocnumber">4.2</span> <span class="toctext">Contravariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Covariant_method_argument_type"><span class="tocnumber">4.3</span> <span class="toctext">Covariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Avoiding_the_need_for_covariant_argument_types"><span class="tocnumber">4.4</span> <span class="toctext">Avoiding the need for covariant argument types</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Summary_of_variance_and_inheritance"><span class="tocnumber">4.5</span> <span class="toctext">Summary of variance and inheritance</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Generic_types"><span class="tocnumber">5</span> <span class="toctext">Generic types</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Declaration-site_variance_annotations"><span class="tocnumber">5.1</span> <span class="toctext">Declaration-site variance annotations</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Interfaces"><span class="tocnumber">5.1.1</span> <span class="toctext">Interfaces</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Data"><span class="tocnumber">5.1.2</span> <span class="toctext">Data</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Inferring_Variance"><span class="tocnumber">5.1.3</span> <span class="toctext">Inferring Variance</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Use-site_variance_annotations_.28Wildcards.29"><span class="tocnumber">5.2</span> <span class="toctext">Use-site variance annotations (Wildcards)</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Comparing_Declaration-site_and_Use-site_annotations"><span class="tocnumber">5.3</span> <span class="toctext">Comparing Declaration-site and Use-site annotations</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Covariant_generics_in_Dart"><span class="tocnumber">5.4</span> <span class="toctext">Covariant generics in Dart</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Origin_of_the_term_.22covariance.22"><span class="tocnumber">6</span> <span class="toctext">Origin of the term "covariance"</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Covariant_arrays_in_Java_and_C.23"><span class="tocnumber">2.1</span> <span class="toctext">Covariant arrays in Java and C#</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Covariant_method_return_type"><span class="tocnumber">4.1</span> <span class="toctext">Covariant method return type</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Contravariant_method_argument_type"><span class="tocnumber">4.2</span> <span class="toctext">Contravariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Covariant_method_argument_type"><span class="tocnumber">4.3</span> <span class="toctext">Covariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Avoiding_the_need_for_covariant_argument_types"><span class="tocnumber">4.4</span> <span class="toctext">Avoiding the need for covariant argument types</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Summary_of_variance_and_inheritance"><span class="tocnumber">4.5</span> <span class="toctext">Summary of variance and inheritance</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Declaration-site_variance_annotations"><span class="tocnumber">5.1</span> <span class="toctext">Declaration-site variance annotations</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Interfaces"><span class="tocnumber">5.1.1</span> <span class="toctext">Interfaces</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Data"><span class="tocnumber">5.1.2</span> <span class="toctext">Data</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Inferring_Variance"><span class="tocnumber">5.1.3</span> <span class="toctext">Inferring Variance</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Use-site_variance_annotations_.28Wildcards.29"><span class="tocnumber">5.2</span> <span class="toctext">Use-site variance annotations (Wildcards)</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Comparing_Declaration-site_and_Use-site_annotations"><span class="tocnumber">5.3</span> <span class="toctext">Comparing Declaration-site and Use-site annotations</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Covariant_generics_in_Dart"><span class="tocnumber">5.4</span> <span class="toctext">Covariant generics in Dart</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Interfaces"><span class="tocnumber">5.1.1</span> <span class="toctext">Interfaces</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Data"><span class="tocnumber">5.1.2</span> <span class="toctext">Data</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Inferring_Variance"><span class="tocnumber">5.1.3</span> <span class="toctext">Inferring Variance</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Formal definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Within the <a href="/wiki/Type_system" title="Type system">type system</a> of a <a href="/wiki/Programming_language" title="Programming language">programming language</a>, a typing rule or a type constructor is:</p>
<ul>
<li><b>covariant</b> if it preserves the <a href="/wiki/Subtype" title="Subtype" class="mw-redirect">ordering of types (≤)</a>, which orders types from more specific to more generic;</li>
<li><b>contravariant</b> if it reverses this ordering;</li>
<li><b>bivariant</b> if both of these apply;</li>
<li><b>invariant</b> or <b>nonvariant</b> if neither of these applies.</li>
</ul>
<p>In the rest of the article, we will consider how this applies to some common type constructors.</p>
<h2><span class="mw-headline" id="Arrays">Arrays</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Arrays">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>First consider the <a href="/wiki/Array_data_type" title="Array data type">array type</a> constructor: from the type <span class="mw-geshi java source-java">Animal</span> we can make the type <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> ("array of animals"). Should we treat this as</p>
<ul>
<li>Covariant: a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span> is an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span></li>
<li>Contravariant: an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> is a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span></li>
<li>or neither (invariant)?</li>
</ul>
<p>If we wish to avoid type errors, and the array supports both reading and writing elements, then only the third choice is safe. Clearly, not every <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> can be treated as if it were a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span>, since a client reading from the array will expect a <span class="mw-geshi java source-java">Cat</span>, but an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> may contain e.g. a <span class="mw-geshi java source-java">Dog</span>. So the contravariant rule is not safe.</p>
<p>Conversely, a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span> can not be treated as an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span>. It should always be possible to put a <span class="mw-geshi java source-java">Dog</span> into an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span>. With covariant arrays this can not be guaranteed to be safe, since the backing store might actually be an array of cats. So the covariant rule is also not safe—the array constructor should be <b>invariant</b>. Note that this is only an issue for mutable arrays; the covariant rule is safe for immutable (read-only) arrays.</p>
<p>This illustrates a general phenomenon. Read-only data types (sources) can be covariant; write-only data types (sinks) can be contravariant. Mutable data types which act as both sources and sinks should be invariant.</p>
<h3><span class="mw-headline" id="Covariant_arrays_in_Java_and_C.23">Covariant arrays in Java and C#</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Covariant arrays in Java and C#">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Early versions of Java and C# did not include generics (a.k.a. <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>). In such a setting, making arrays invariant rules out useful polymorphic programs.</p>
<p>For example, consider writing a function to shuffle an array, or a function that tests two arrays for equality using the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a></code>.<span class="mw-geshi java source-java">equals</span> method on the elements. The implementation does not depend on the exact type of element stored in the array, so it should be possible to write a single function that works on all types of arrays. It is easy to implement functions of type</p>
<p>WHATSON? 1e99f286-9d06-47fb-8506-1ccd25fdb283</p>
<pre class="de1">
    <span class="kw4">boolean</span> equalArrays <span class="br0">(</span><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> a1, <span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> a2<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw4">void</span> shuffleArray<span class="br0">(</span><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>However, if array types were treated as invariant, it would only be possible to call these functions on an array of exactly the type <span class="mw-geshi java source-java"><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span></span>. One could not, for example, shuffle an array of strings.</p>
<p>Therefore, both Java and C# treat array types covariantly. For instance, in C# <span class="mw-geshi csharp source-csharp"><span class="kw4">string</span><span class="br0">[</span><span class="br0">]</span></span> is a subtype of <code>object[]</code>, and in Java <span class="mw-geshi java source-java"><span class="kw3">String</span><span class="br0">[</span><span class="br0">]</span></span> is a subtype of <span class="mw-geshi java source-java"><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span></span>.</p>
<p>As discussed above, covariant arrays leads to problem with writes into the array. Java and C# deals with this by marking each array object with a type when it is created. Each time a value is stored into an array, the compiler inserts a check that the run-time type of the value is equal to the run-time type of the array. If there is a mismatch, an <span class="mw-geshi java source-java"><span class="kw3">ArrayStoreException</span></span> (or <span class="mw-geshi csharp source-csharp">ArrayTypeMismatchException</span> in C#) is thrown:</p>
<p>WHATSON? d1cbb5be-4957-4d14-81c7-da20cba811cd</p>
<pre class="de1">
    <span class="co1">// a is a single-element array of String</span>
    <span class="kw3">String</span><span class="br0">[</span><span class="br0">]</span> a <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">String</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
 
    <span class="co1">// b is an array of Object</span>
    <span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> b <span class="sy0">=</span> a<span class="sy0">;</span>
 
    <span class="co1">// Assign an Integer to b. This would be possible if b really were</span>
    <span class="co1">// an array of Object, but since it really is an array of String,</span>
    <span class="co1">// we will get a java.lang.ArrayStoreException.</span>
    b<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
</pre>
<p>In the above example you can <b>read</b> from b safely. It is only trying to <b>write</b> to the array that can lead to trouble.</p>
<p>One drawback of this approach is that it leaves the possibility of a run-time error which a stricter type system could have caught at compile-time. Also, it hurts performance because each write into an array requires an additional runtime check.</p>
<p>With the addition of generics, Java and C# now offer ways to write this kind of polymorphic functions without relying on covariance. The array comparison and shuffling functions can be given the parameterized types</p>
<p>WHATSON? bd03fcb0-4929-4619-be67-dc481f821ede</p>
<pre class="de1">
    <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw4">boolean</span> equalArrays <span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span> a1, T<span class="br0">[</span><span class="br0">]</span> a2<span class="br0">)</span><span class="sy0">;</span>
    <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw4">void</span> shuffleArray<span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>Alternatively, to enforce that a C# method accesses a collection in a read-only way, one can use the interface <span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span><span class="kw4">object</span><span class="sy0">&gt;</span></span> instead of passing it an array <span class="mw-geshi csharp source-csharp"><span class="kw4">object</span><span class="br0">[</span><span class="br0">]</span></span>.</p>
<h2><span class="mw-headline" id="Function_types">Function types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Function types">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Languages with <a href="/wiki/First-class_functions" title="First-class functions" class="mw-redirect">first-class functions</a> have <a href="/wiki/Function_type" title="Function type">function types</a> like "a function expecting a Cat and returning an Animal" (written <span class="mw-geshi ocaml source-ocaml">Cat <span class="sy0">-&gt;</span> Animal</span> in <a href="/wiki/OCaml" title="OCaml">OCaml</a> syntax or <span class="mw-geshi csharp source-csharp">Func<span class="sy0">&lt;</span>Cat,Animal<span class="sy0">&gt;</span></span> in <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> syntax).</p>
<p>Those languages also need to specify when one function type is a subtype of another—that is, when it is safe to use a function of one type in a context that expects a function of a different type. It is safe to substitute a function <i>f</i> instead of a function <i>g</i> if <i>f</i> accepts a more general type of arguments and returns a more specific type than <i>g</i>. For example, a function of type <span class="mw-geshi ocaml source-ocaml">Cat<span class="sy0">-&gt;</span>Cat</span> can safely be used wherever a <span class="mw-geshi ocaml source-ocaml">Cat<span class="sy0">-&gt;</span>Animal</span> was expected, and likewise a function of type <span class="mw-geshi ocaml source-ocaml">Animal<span class="sy0">-&gt;</span>Animal</span> can be used wherever a <span class="mw-geshi ocaml source-ocaml">Cat<span class="sy0">-&gt;</span>Animal</span> was expected. (One can compare this to the <a href="/wiki/Robustness_principle" title="Robustness principle">robustness principle</a> of communication: "be liberal in what you accept and conservative in what you produce"). The general rule is</p>
<p>S<sub>1</sub> → S<sub>2</sub> ≤ T<sub>1</sub> → T<sub>2</sub> if T<sub>1</sub> ≤ S<sub>1</sub> and S<sub>2</sub> ≤ T<sub>2</sub>.</p>
<p>In other words, the → type constructor is <b>contravariant in the input type</b> and <b>covariant in the output type</b>. This rule was first stated formally by <a href="/wiki/John_C._Reynolds" title="John C. Reynolds">John Reynolds</a>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> and further popularized in a paper by Luca Cardelli.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p>When dealing with <a href="/wiki/Higher-order_function" title="Higher-order function">functions that take functions as arguments</a>, this rule can be applied several times. For example, by applying the rule twice, we see that (A'→B)→B ≤ (A→B)→B if A'≤A. In other words, the type (A→B)→B is <i>covariant</i> in the A position. For complicated types it can be confusing to mentally trace why a given type specialization is or isn't type-safe, but it is easy to calculate which positions are co- and contravariant: a position is covariant if it is on the left side of an even number of arrows.</p>
<h2><span class="mw-headline" id="Inheritance_in_object_oriented_languages">Inheritance in object oriented languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Inheritance in object oriented languages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When a subclass <a href="/wiki/Method_overriding" title="Method overriding">overrides</a> a method in a superclass, the compiler must check that the overriding method has the right type. While some languages require that the type exactly matches the type in the superclass (invariance), it is also type safe to allow the overriding method to have a "better" type. By the usual subtyping rule for function types, this means that the overriding method should return a more specific type (return type covariance), and accept a more general argument (argument type contravariance). In <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a> notation, the possibilities are as follows:</p>
<ul class="gallery mw-gallery-traditional" style="max-width: 815px;_width: 815px;">
<li class="gallerycaption">Variance and method overriding: overview</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:28.5px auto;"><a href="/wiki/File:Vererbung_T.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Vererbung_T.svg/120px-Vererbung_T.svg.png" width="120" height="163" data-file-width="125" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p>Subtyping of the argument/return type of the method.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_invariant.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/00/Inheritance_invariant.svg/120px-Inheritance_invariant.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Invariance</b>. The signature of the overrriding method is unchanged.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_covariant_return.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/27/Inheritance_covariant_return.svg/120px-Inheritance_covariant_return.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Covariant return type</b>. The subtyping relation is in the same direction as the relation between ClassA and ClassB.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_contravariant_argument.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Inheritance_contravariant_argument.svg/120px-Inheritance_contravariant_argument.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Contravariant argument type</b>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_covariant_argument.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Inheritance_covariant_argument.svg/120px-Inheritance_covariant_argument.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Covariant argument type</b>. Not type safe.</p>
</div>
</div>
</li>
</ul>
<p>Subtyping of the argument/return type of the method.</p>
<p><b>Invariance</b>. The signature of the overrriding method is unchanged.</p>
<p><b>Covariant return type</b>. The subtyping relation is in the same direction as the relation between ClassA and ClassB.</p>
<p><b>Contravariant argument type</b>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB.</p>
<p><b>Covariant argument type</b>. Not type safe.</p>
<p>For a concrete example, suppose we are writing a class to model an <a href="/wiki/Animal_shelter" title="Animal shelter">animal shelter</a>. We assume that <span class="mw-geshi java source-java">Cat</span> is a subclass of <span class="mw-geshi java source-java">Animal</span>, and that we have a base class (using Java syntax)</p>
<p>WHATSON? 7f538699-423e-4fe8-b746-fce45dc27f5b</p>
<pre class="de1">
    <span class="kw1">class</span> AnimalShelter <span class="br0">{</span>
        Animal getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
 
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>Animal animal<span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Now the question is: if we subclass <span class="mw-geshi java source-java">AnimalShelter</span>, what types are we allowed to give to <span class="mw-geshi java source-java">getAnimalForAdoption</span> and <span class="mw-geshi java source-java">putAnimal</span>?</p>
<h3><span class="mw-headline" id="Covariant_method_return_type">Covariant method return type</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Covariant method return type">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a language which allows covariant return types, a derived class can override the <span class="mw-geshi java source-java">getAnimalForAdoption</span> method to return a more specific type:</p>
<p>WHATSON? b0512b2e-e9a7-48a0-ba04-ad36cb324fba</p>
<pre class="de1">
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> AnimalShelter <span class="br0">{</span>
        Cat getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    	    <span class="kw1">return</span> <span class="kw1">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Among mainstream OO languages, <a href="/wiki/Java_(Programming_language)" title="Java (Programming language)" class="mw-redirect">Java</a> and <a href="/wiki/C%2B%2B" title="C++">C++</a> support covariant return types, while <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> does not. Adding the covariant return type was one of the first modifications of the C++ language approved by the standards committee in 1998.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> and <a href="/wiki/D_(programming_language)" title="D (programming language)">D</a> also support covariant return types.</p>
<h3><span class="mw-headline" id="Contravariant_method_argument_type">Contravariant method argument type</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Contravariant method argument type">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Similarly, it is type safe to allow an overriding method to accept a more general argument than the method in the base class:</p>
<p>WHATSON? db3ca7b6-c869-45a8-a316-3740f7231dbb</p>
<pre class="de1">
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> AnimalShelter <span class="br0">{</span>
        <span class="kw4">void</span> putAnimal<span class="br0">(</span><span class="kw3">Object</span> animal<span class="br0">)</span> <span class="br0">{</span>
           ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Not many object oriented languages actually allow this—C++ and Java would interpret this as an unrelated method with an <a href="/wiki/Function_overloading" title="Function overloading">overloaded</a> name.</p>
<p>However, <a href="/wiki/Sather" title="Sather">Sather</a> supports both covariance and contravariance. Calling convention for overridden methods are covariant with <i>out</i> arguments and return values, and contravariant with normal arguments (with the mode <i>in</i>).</p>
<h3><span class="mw-headline" id="Covariant_method_argument_type">Covariant method argument type</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: Covariant method argument type">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Uniquely among mainstream languages, <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> allows the arguments of an overriding method to have a <i>more</i> specific type than the method in the superclass (argument type covariance). Thus, the Eiffel version of the following code would type check, with <span class="mw-geshi java source-java">putAnimal</span> overriding the method in the base class:</p>
<p>WHATSON? 353190e5-0052-400f-b598-746ac50382ad</p>
<pre class="de1">
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> AnimalShelter <span class="br0">{</span>
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>Cat animal<span class="br0">)</span> <span class="br0">{</span>
           ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>This is not type safe. By up-casting a <span class="mw-geshi java source-java">CatShelter</span> to an <span class="mw-geshi java source-java">AnimalShelter</span>, one can place a dog in a cat shelter. The lack of type safety (known as the "catcall problem" in the Eiffel community) has been a long-standing issue. Over the years, various combinations of global static analysis, local static analysis, and new language features have been proposed to remedy it,<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> <sup id="cite_ref-competentCompilers_5-0" class="reference"><a href="#cite_note-competentCompilers-5"><span>[</span>5<span>]</span></a></sup> and these have been implemented in some Eiffel compilers.</p>
<p>Despite the type safety problem, the Eiffel designers consider covariant argument types crucial for modeling real world requirements.<sup id="cite_ref-competentCompilers_5-1" class="reference"><a href="#cite_note-competentCompilers-5"><span>[</span>5<span>]</span></a></sup> The cat shelter illustrates a common phenomenon: it is <i>a kind of</i> animal shelter but has <i>additional restrictions</i>, and it seems reasonable to use inheritance and restricted argument types to model this. In proposing this use of inheritance, the Eiffel designers reject the <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>, which states that objects of subclasses should always be less restricted than objects of their superclass.</p>
<p>Another example where covariant arguments seem helpful is so-called binary methods, i.e. methods where the argument is expected to be of the same type as the object the method is called on. An example is the <span class="mw-geshi java source-java">compareTo</span> method: <span class="mw-geshi java source-java">a.<span class="me1">compareTo</span><span class="br0">(</span>b<span class="br0">)</span></span> checks whether <span class="mw-geshi java source-java">a</span> comes before or after <span class="mw-geshi java source-java">b</span> in some ordering, but the way to compare, say, two rational numbers will be different from the way to compare two strings. Other common examples of binary methods include equality tests, arithmetic operations, and set operations like subset and union.</p>
<p>In older versions of Java, the comparison method was specified as an interface <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span>:</p>
<p>WHATSON? 527ae6a7-1013-4839-ad99-1251c93a7aac</p>
<pre class="de1">
    <span class="kw1">interface</span> <span class="kw3">Comparable</span> <span class="br0">{</span>
        <span class="kw4">int</span> compareTo<span class="br0">(</span><span class="kw3">Object</span> o<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
</pre>
<p>The drawback of this is that the method is specified to take an argument of type <span class="mw-geshi java source-java"><span class="kw3">Object</span></span>. A typical implementation would first down-cast this argument (throwing an error if it is not of the expected type):</p>
<p>WHATSON? 7e829421-e683-41b5-9b1b-f40428180e82</p>
<pre class="de1">
    <span class="kw1">class</span> RationalNumber <span class="kw1">implements</span> <span class="kw3">Comparable</span> <span class="br0">{</span>
        <span class="kw4">int</span> numerator<span class="sy0">;</span>
        <span class="kw4">int</span> denominator<span class="sy0">;</span>
 
        ...
 
        <span class="kw1">public</span> <span class="kw4">int</span> compareTo<span class="br0">(</span><span class="kw3">Object</span> other<span class="br0">)</span> <span class="br0">{</span>
            RationalNumber otherNum <span class="sy0">=</span> <span class="br0">(</span>RationalNumber<span class="br0">)</span>other<span class="sy0">;</span>
            <span class="kw1">return</span> <span class="kw3">Integer</span>.<span class="me1">compare</span><span class="br0">(</span>numerator<span class="sy0">*</span>otherNum.<span class="me1">denominator</span>,
                                   otherNum.<span class="me1">numerator</span><span class="sy0">*</span>denominator<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>In a language with covariant arguments, the argument to compareTo could be directly given the desired type <span class="mw-geshi java source-java">RationalNumber</span>, hiding the typecast. (Of course, this would still give a runtime error if <span class="mw-geshi java source-java">compareTo</span> was then called on e.g. a <span class="mw-geshi java source-java"><span class="kw3">String</span></span>).</p>
<h3><span class="mw-headline" id="Avoiding_the_need_for_covariant_argument_types">Avoiding the need for covariant argument types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: Avoiding the need for covariant argument types">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Other language features can provide the apparent benefits of covariant arguments while preserving Liskov substitutability.</p>
<p>In a language with <b>generics</b> (a.k.a. <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>) and <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded quantification</a>, the previous examples can be written in a type-safe way <sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> . Instead of defining <span class="mw-geshi java source-java">AnimalShelter</span>, we define a parameterized class <span class="mw-geshi java source-java">Shelter<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>. (One drawback of this is that the implementer of the base class needs to foresee which types will need to be specialized in the subclasses).</p>
<p>WHATSON? d9a2db8d-cd99-4611-bee6-f6437a2338be</p>
<pre class="de1">
    <span class="kw1">class</span> Shelter<span class="sy0">&lt;</span>T <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span> <span class="br0">{</span>
        T getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
 
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>T animal<span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
    <span class="br0">}</span>
 
 
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> Shelter<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span> <span class="br0">{</span>
        Cat getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
 
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>Cat animal<span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Similarly, in recent versions of Java the <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span> interface has been parameterized, which allows the downcast to be omitted in a type-safe way:</p>
<p>WHATSON? af3feb89-abf5-4861-a9af-8aa4da67f013</p>
<pre class="de1">
    <span class="kw1">class</span> RationalNumber <span class="kw1">implements</span> Comparable<span class="sy0">&lt;</span>RationalNumber<span class="sy0">&gt;</span> <span class="br0">{</span>
        <span class="kw4">int</span> numerator<span class="sy0">;</span>
        <span class="kw4">int</span> denominator<span class="sy0">;</span>
 
        ...
 
        <span class="kw1">public</span> <span class="kw4">int</span> compareTo<span class="br0">(</span>RationalNumber otherNum<span class="br0">)</span> <span class="br0">{</span>
            <span class="kw1">return</span> <span class="kw3">Integer</span>.<span class="me1">compare</span><span class="br0">(</span>numerator<span class="sy0">*</span>otherNum.<span class="me1">denominator</span>, 
                                   otherNum.<span class="me1">numerator</span><span class="sy0">*</span>denominator<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Another language feature that can help is <b>multiple dispatch</b>. One reason that binary methods are awkward to write is that in a call like <span class="mw-geshi java source-java">a.<span class="me1">compareTo</span><span class="br0">(</span>b<span class="br0">)</span></span>, selecting the correct implementation of <span class="mw-geshi java source-java">compareTo</span> really depends on the type of both <span class="mw-geshi java source-java">a</span> and <span class="mw-geshi java source-java">b</span>, but in a conventional OO language only the type of <span class="mw-geshi java source-java">a</span> is taken into account. In a language with <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">CLOS</a>-style <a href="/wiki/Multiple_dispatch" title="Multiple dispatch">multiple dispatch</a>, the comparison method could be written as a generic function where both arguments are used for method selection.</p>
<p>Giuseppe Castagna<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> observed that in a typed language with multiple dispatch, a generic function can have some arguments which control dispatch and some "left-over" arguments which do not. Because the method selection rule chooses the most specific applicable method, if a method overrides another method, then the overriding method will have more specific types for the controlling arguments. On the other hand, to ensure type safety the language still must require the left-over arguments to be at least as general. Using the previous terminology, types used for runtime method selection are covariant while types not used for runtime method selection of the method are contravariant. Conventional single-dispatch languages like Java also obey this rule: there only one argument is used for method selection (the receiver object, passed along to a method as the hidden argument <span class="mw-geshi java source-java"><span class="kw1">this</span></span>), and indeed the type of <span class="mw-geshi java source-java"><span class="kw1">this</span></span> is more specialized inside overriding methods than in the superclass.</p>
<p>Castagna suggests that examples where you want covariant argument types, in particular binary methods, should be handled using multiple dispatch which is naturally covariant. Unfortunately, most programming languages do not support multiple dispatch.</p>
<h3><span class="mw-headline" id="Summary_of_variance_and_inheritance">Summary of variance and inheritance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: Summary of variance and inheritance">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following table summarizes the rules for overriding methods in the languages discussed above.</p>
<h2><span class="mw-headline" id="Generic_types">Generic types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: Generic types">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In programming languages that support generics (a.k.a. <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>), the programmer can extend the type system with new constructors. For example, a C# interface like <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> makes it possible to construct new types like <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span> or <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span>. The question then arises what the variance of these type constructors should be.</p>
<p>There are two main approaches. In languages with <b>declaration-site variance annotations</b> (e.g. <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>), the programmer annotates the definition of a generic type with the intended variance of its type parameters. With <b>use-site variance annotations</b> (e.g. <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>), the programmer instead annotates the places where a generic type is instantiated.</p>
<h3><span class="mw-headline" id="Declaration-site_variance_annotations">Declaration-site variance annotations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Declaration-site variance annotations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The most popular languages with declaration-site variance annotations are <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> (using the keywords <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> and <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>), and <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> and <a href="/wiki/OCaml" title="OCaml">OCaml</a> (using the keywords <span class="mw-geshi ocaml source-ocaml"><span class="sy0">+</span></span> and <span class="mw-geshi ocaml source-ocaml"><span class="sy0">-</span></span>). C# only allows variance annotations for interface types, while Scala and OCaml allows them for both interface types and concrete data types.</p>
<h4><span class="mw-headline" id="Interfaces">Interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In C#, each type parameter of a generic interface can be marked covariant (<span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span>), contravariant (<span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>), or invariant (no annotation). For example, we can define an interface <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> of read-only iterators, and declare it to be covariant (out) in its type parameter.</p>
<p>WHATSON? 509cc490-cdba-4b47-a0b7-2659f4011582</p>
<pre class="de1">
    <span class="kw4">interface</span> IEnumerator<span class="sy0">&lt;</span><span class="kw1">out</span> T<span class="sy0">&gt;</span>
    <span class="br0">{</span>
        T Current <span class="br0">{</span> <span class="kw1">get</span><span class="sy0">;</span> <span class="br0">}</span>
        <span class="kw4">bool</span> MoveNext<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
</pre>
<p>With this declaration, <span class="mw-geshi csharp source-csharp">IEnumerator</span> will be treated as covariant in its type argument, e.g. <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span>.</p>
<p>The typechecker enforces that each method declaration in an interface only mentions the type parameters in a way consistent with the <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>/<span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> annotations. That is, a parameter that was declared covariant must not occur in any contravariant positions (where a position is contravariant if it occurs under an odd number of contravariant type constructors). The precise rule<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup><sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup> is that the return types of all methods in the interface must be <i>valid covariantly</i> and all the method argument types must be <i>valid contravariantly</i>, where <i>valid S-ly</i> is defined as follows:</p>
<ul>
<li>Non-generic types (classes, structs, enums, etc.) are valid both co- and contravariantly.</li>
<li>A type argument <span class="mw-geshi csharp source-csharp">T</span> is valid covariantly if it was not marked <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>, and valid contravariantly if it was not marked <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span></li>
<li>An array type <span class="mw-geshi csharp source-csharp">A<span class="br0">[</span><span class="br0">]</span></span> is valid S-ly if <span class="mw-geshi csharp source-csharp">A</span> is. (This is because C# has covariant arrays).</li>
<li>A generic type <span class="mw-geshi csharp source-csharp">G<span class="sy0">&lt;</span>A1,A2,<span class="sy0">...</span>,An<span class="sy0">&gt;</span></span> is valid S-ly if for each argument <span class="mw-geshi csharp source-csharp">Ai</span>,
<ul>
<li>Ai is valid S-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared invariant.</li>
</ul>
</li>
</ul>
<ul>
<li>Ai is valid S-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared invariant.</li>
</ul>
<p>As an example of how these rules apply, consider the <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> interface.</p>
<p>WHATSON? 5853dd2b-9ce8-4c54-a49a-dbd2ffc4afff</p>
<pre class="de1">
    <span class="kw4">interface</span> IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
    <span class="br0">{</span>
	<span class="kw4">void</span> Insert<span class="br0">(</span><span class="kw4">int</span> index, T item<span class="br0">)</span><span class="sy0">;</span>
	IEnumerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> GetEnumerator<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
</pre>
<p>The argument type <span class="mw-geshi csharp source-csharp">T</span> of <span class="mw-geshi csharp source-csharp">Insert</span> must be valid contravariantly, i.e. the type parameter <span class="mw-geshi csharp source-csharp">T</span> must not be tagged <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span>. Similarly, the result type <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> of <span class="mw-geshi csharp source-csharp">GetEnumerator</span> must be valid covariantly, i.e. (since <span class="mw-geshi csharp source-csharp">IEnumerator</span> is a covariant interface) the type <span class="mw-geshi csharp source-csharp">T</span> must be valid covariantly, i.e. the type parameter <span class="mw-geshi csharp source-csharp">T</span> must not be tagged <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>. This shows that the interface <span class="mw-geshi csharp source-csharp">IList</span> is not allowed to be marked either co- or contravariant.</p>
<p>In the common case of a generic data structure such as <span class="mw-geshi csharp source-csharp">IList</span>, these restrictions mean that an <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> parameter can only be used for methods getting data out of the structure, and an <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span> parameter can only be used for methods putting data into the structure, hence the choice of keywords.</p>
<h4><span class="mw-headline" id="Data">Data</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Data">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>C# allows variance annotations on the parameters of interfaces, but not the parameters of classes. Because fields in C# classes are always mutable, variantly parameterized classes in C# would not be very useful. But languages which emphasize immutable data can make good use of covariant data types. For example, both in <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> and <a href="/wiki/OCaml" title="OCaml">OCaml</a> the immutable list type is covariant: <span class="mw-geshi scala source-scala">List<span class="br0">[</span>Cat<span class="br0">]</span></span> is a subtype of <span class="mw-geshi scala source-scala">List<span class="br0">[</span>Animal<span class="br0">]</span></span>.</p>
<p>Scala's rules for checking variance annotations are essentially the same as C#'s. However, there are some idioms that apply to immutable datastructures in particular. They are illustrated by the following (excerpt from the) definition of the <span class="mw-geshi scala source-scala">List<span class="br0">[</span>A<span class="br0">]</span></span> class.</p>
<p>WHATSON? 4bb857a7-36fd-43f6-965b-ed151478aa83</p>
<pre class="de1">
<span class="kw1">sealed</span> <span class="kw1">abstract</span> <span class="kw1">class</span> List<span class="br0">[</span>+A<span class="br0">]</span> <span class="kw1">extends</span> AbstractSeq<span class="br0">[</span>A<span class="br0">]</span> <span class="br0">{</span>
  <span class="kw1">def</span> head<span class="sy0">:</span> A
  <span class="kw1">def</span> tail<span class="sy0">:</span> List<span class="br0">[</span>A<span class="br0">]</span>
 
  <span class="coMULTI">/** Adds an element at the beginning of this list. */</span>
  <span class="kw1">def</span> <span class="sy0">::</span><span class="br0">[</span>B <span class="sy0">&gt;:</span> A<span class="br0">]</span> <span class="br0">(</span>x<span class="sy0">:</span> B<span class="br0">)</span><span class="sy0">:</span> List<span class="br0">[</span>B<span class="br0">]</span> <span class="sy0">=</span>
    <span class="kw1">new</span> scala.<span class="me1">collection</span>.<span class="me1">immutable</span>.<span class="sy0">::</span><span class="br0">(</span>x, <span class="kw1">this</span><span class="br0">)</span>
 
  ...
<span class="br0">}</span>
</pre>
<p>First, class members that have a variant type must be immutable. Here, <span class="mw-geshi scala source-scala">head</span> has the type <span class="mw-geshi scala source-scala">A</span>, which was declared covariant (<span class="mw-geshi scala source-scala">+</span>), and indeed <span class="mw-geshi scala source-scala">head</span> was declared as a method (<span class="mw-geshi scala source-scala"><span class="kw1">def</span></span>). Trying to declare it as a mutable field (<span class="mw-geshi scala source-scala"><span class="kw1">var</span></span>) would be rejected as type error.</p>
<p>Second, even if a data structure is immutable, it will often have methods where the parameter type occurs contravariantly. For example, consider the method <span class="mw-geshi scala source-scala"><span class="sy0">::</span></span> which adds an element to the front of a list. (The implementation works by creating a new object of the similarly-named <i>class</i> <span class="mw-geshi scala source-scala"><span class="sy0">::</span></span>, the class of nonempty lists). The most obvious type to give it would be</p>
<p>WHATSON? 38ab7caa-8bef-4e7f-9cbd-cd7a2a9d8f45</p>
<pre class="de1">
  <span class="kw1">def</span> <span class="sy0">::</span> <span class="br0">(</span>x<span class="sy0">:</span> A<span class="br0">)</span><span class="sy0">:</span> List<span class="br0">[</span>A<span class="br0">]</span>
</pre>
<p>However, this would be a type error, because the covariant parameter <span class="mw-geshi scala source-scala">A</span> appears in a contravariant position (as a function argument). But there is a trick to get around this problem. We give <span class="mw-geshi scala source-scala"><span class="sy0">::</span></span> a more general type, which allows adding an element of any type <span class="mw-geshi scala source-scala">B</span> as long as <span class="mw-geshi scala source-scala">B</span> is a supertype of <span class="mw-geshi scala source-scala">A</span>. Note that this relies on <span class="mw-geshi scala source-scala">List</span> being covariant, since <span class="mw-geshi scala source-scala"><span class="kw1">this</span></span> has type <span class="mw-geshi scala source-scala">List<span class="br0">[</span>A<span class="br0">]</span></span> and we treat it as having type <span class="mw-geshi scala source-scala">List<span class="br0">[</span>B<span class="br0">]</span></span>. At first glance it may not be obvious that the generalized type is sound, but if the programmer starts out with the simpler type declaration, the type errors will point out the place that needs to be generalized.</p>
<h4><span class="mw-headline" id="Inferring_Variance">Inferring Variance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=15" title="Edit section: Inferring Variance">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>It is possible to design a type system where the compiler automatically infers the best possible variance annotations for all datatype parameters.<sup id="cite_ref-tamingCombining_10-0" class="reference"><a href="#cite_note-tamingCombining-10"><span>[</span>10<span>]</span></a></sup> However, the analysis can get complex for several reasons. First, the analysis is nonlocal since the variance of an interface <span class="mw-geshi java source-java">I</span> depends the variance of all interfaces that <span class="mw-geshi java source-java">I</span> mentions. Second, in order to get unique best solutions the type system must allow <i>bivariant</i> parameters (which are simultaneously co- and contravariant). And finally, the variance of type parameters should arguably be a deliberate choice by the designer of an interface, not something that just happens.</p>
<p>For these reasons<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> most languages do very little variance inference. C# and Scala do not infer any variance annotations at all. OCaml can infer the variance of parameterized concrete datatypes, but the programmer must explicitly specify the variance of abstract types (interfaces).</p>
<p>For example, consider an OCaml datatype <span class="mw-geshi ocaml source-ocaml">T</span> which wraps a function</p>
<p>WHATSON? 0f664c0b-3788-4577-9d7e-093e68c6fc07</p>
<pre class="de1">
<span class="kw1">type</span> <span class="br0">(</span><span class="sy0">'</span>a, <span class="sy0">'</span>b<span class="br0">)</span> t <span class="sy0">=</span> T <span class="kw1">of</span> <span class="br0">(</span><span class="sy0">'</span>a <span class="sy0">-&gt;</span> <span class="sy0">'</span>b<span class="br0">)</span>
</pre>
<p>The compiler will automatically infer that <span class="mw-geshi ocaml source-ocaml">T</span> is contravariant in the first parameter, and covariant in the second. The programmer can also provide explicit annotations, which the compiler will check are satisfied. Thus the following declaration is equivalent to the previous one:</p>
<p>WHATSON? 4e7bb6f2-e128-4d93-be49-fb66e00b9e5a</p>
<pre class="de1">
<span class="kw1">type</span> <span class="br0">(</span><span class="sy0">-'</span>a, <span class="sy0">+'</span>b<span class="br0">)</span> t <span class="sy0">=</span> T <span class="kw1">of</span> <span class="br0">(</span><span class="sy0">'</span>a <span class="sy0">-&gt;</span> <span class="sy0">'</span>b<span class="br0">)</span>
</pre>
<p>Explicit annotations in OCaml become useful when specifying interfaces. For example, the standard library interface <span class="mw-geshi ocaml source-ocaml"><span class="kw2">Map</span><span class="sy0">.</span>S</span> for association tables include an annotation saying that the map type constructor is covariant in the result type.</p>
<p>WHATSON? 6f50b946-c135-44c0-8da0-2107a82f8464</p>
<pre class="de1">
<span class="kw1">module</span> <span class="kw1">type</span> S <span class="sy0">=</span>
  <span class="kw1">sig</span>
    <span class="kw1">type</span> key
    <span class="kw1">type</span> <span class="br0">(</span><span class="sy0">+'</span>a<span class="br0">)</span> t
    <span class="kw1">val</span> empty<span class="sy0">:</span> <span class="sy0">'</span>a t
    <span class="kw1">val</span> mem<span class="sy0">:</span> key <span class="sy0">-&gt;</span> <span class="sy0">'</span>a t <span class="sy0">-&gt;</span> <span class="kw4">bool</span>
    <span class="sy0">...</span>
  <span class="kw1">end</span>
</pre>
<p>This ensures that e.g. <span class="mw-geshi ocaml source-ocaml">IntMap<span class="sy0">.</span>t cat</span> is a subtype of <span class="mw-geshi ocaml source-ocaml">IntMap<span class="sy0">.</span>t animal</span>.</p>
<h3><span class="mw-headline" id="Use-site_variance_annotations_.28Wildcards.29">Use-site variance annotations (Wildcards)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=16" title="Edit section: Use-site variance annotations (Wildcards)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>One drawback of the declaration-site approach is that many interface types must be made invariant. For example, we saw above that <span class="mw-geshi csharp source-csharp">IList</span> needed to be invariant, because it contained both <span class="mw-geshi csharp source-csharp">Insert</span> and <span class="mw-geshi csharp source-csharp">GetEnumerator</span>. In order to expose more variance, the API designer could provide additional interfaces which provide subsets of the available methods (e.g. an "insert-only list" which only provides <span class="mw-geshi csharp source-csharp">Insert</span>). However this quickly becomes unwieldy.</p>
<p>Use-site variance annotations aim to give users of a class more opportunities for subtyping without requiring the designer of the class to define multiple interfaces with different variance. Instead, each time a class or interface is used in a type declaration, the programmer can indicate that only a subset of the methods will be used. In effect, each definition of a class also makes available interfaces for the covariant and contravariant "parts" of that class. Therefore the designer of the class no longer needs to take variance into account, increasing re-usability.</p>
<p>Java provides use-site variance annotations through <a href="/wiki/Wildcard_(Java)" title="Wildcard (Java)">wildcards</a>, a restricted form of <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded</a> <a href="/wiki/Existential_type" title="Existential type" class="mw-redirect">existential types</a>. A parameterized type can be instantiated by a wildcard <span class="mw-geshi java source-java"><span class="sy0">?</span></span> together with an upper or lower bound, e.g. <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span> or <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">super</span> Animal<span class="sy0">&gt;</span></span>. (A an unbounded wildcard like <span class="mw-geshi java source-java">List<span class="sy0">&lt;?&gt;</span></span> is equivalent to <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Object<span class="sy0">&gt;</span></span>). Such a type represents <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>X<span class="sy0">&gt;</span></span> for some unknown type <span class="mw-geshi java source-java">X</span> which satisfies the bound. For example, if <span class="mw-geshi java source-java">l</span> has type <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>, then the typechecker will accept</p>
<p>WHATSON? 1e22c4a5-9ce2-4914-bd37-fceba284ea4e</p>
<pre class="de1">
    Animal a <span class="sy0">=</span> l.<span class="me1">get</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>because the type <span class="mw-geshi java source-java">X</span> is known to be a subtype of <span class="mw-geshi java source-java">Animal</span>, but</p>
<p>WHATSON? c8b6d8cd-b4db-472c-918d-9732af1c5a99</p>
<pre class="de1">
    l.<span class="me1">add</span><span class="br0">(</span><span class="kw1">new</span> Animal<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>will be rejected as a type error since an <span class="mw-geshi java source-java">Animal</span> is not necessarily an <span class="mw-geshi java source-java">X</span>. In general, given some interface <span class="mw-geshi java source-java">I<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>, a reference to a <span class="mw-geshi java source-java">I<span class="sy0">&lt;?</span> <span class="kw1">extends</span> A<span class="sy0">&gt;</span></span> forbids using methods from the interface where <span class="mw-geshi java source-java">T</span> occurs contravariantly in the type of the method. Conversely, if <span class="mw-geshi java source-java">l</span> had type <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">super</span> Animal<span class="sy0">&gt;</span></span> one could call <span class="mw-geshi java source-java">l.<span class="me1">add</span></span> but not <span class="mw-geshi java source-java">l.<span class="me1">get</span></span>.</p>
<p>While plain generic types in Java are invariant (e.g. there is no subtyping relationship between <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> and <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span>), wildcard types can be made more specific by specifying a tighter bound, for example <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Cat<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>. This shows that wildcard types are <b>covariant in their upper bounds</b> (and also <b>contravariant in their lower bounds</b>). In total, given a wildcard type like <span class="mw-geshi java source-java">C<span class="sy0">&lt;?</span> <span class="kw1">extends</span> T<span class="sy0">&gt;</span></span>, there are three ways to form a subtype: by specializing the class <span class="mw-geshi java source-java">C</span>, by specifying a tighter bound <span class="mw-geshi java source-java">T</span>, or by replacing the wildcard <span class="mw-geshi java source-java"><span class="sy0">?</span></span> by a specific type (see figure).</p>
<p>By combining two steps of subtyping, it is therefore possible to e.g. pass an argument of type <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> to a method expecting a <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>. This is exactly the kind of programs that covariant interface types allow. The type <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span> acts as an interface type containing only the covariant methods of <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>, but the implementer of <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> did not have to define it ahead of time. This is use-site variance.</p>
<p>In the common case of a generic data structure <span class="mw-geshi csharp source-csharp">IList</span>, covariant parameters are used for methods getting data out of the structure, and contravariant parameters for methods putting data into the structure. The mnemonics PECS (Producer Extends, Consumer Super) from the book <b>Effective Java</b> by <a href="/wiki/Joshua_Bloch" title="Joshua Bloch">Joshua Bloch</a> gives an easy way to remember when to use covariance and contravariance.</p>
<p>Wildcards are flexible, but there is a drawback. While use-site variance means that API designers need not consider variance of type parameters to interfaces, they must often instead use more complicated method signatures. A common example involves the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a></code> interface. Suppose we want to write a function that finds the biggest element in a collection. The elements need to implement the <span class="mw-geshi java source-java">compareTo</span> method, so a first try might be</p>
<p>WHATSON? 8c71525c-f464-406a-a433-d794ce4100d9</p>
<pre class="de1">
    <span class="sy0">&lt;</span>T <span class="kw1">extends</span> Comparable<span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span>  T max<span class="br0">(</span>Collection<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> coll<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>However, this type is not general enough—one can find the max of a <span class="mw-geshi java source-java">Collection<span class="sy0">&lt;</span>Calendar<span class="sy0">&gt;</span></span>, but not a <span class="mw-geshi java source-java">Collection<span class="sy0">&lt;</span>GregorianCalendar<span class="sy0">&gt;</span></span>. The problem is that <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/GregorianCalendar.html">GregorianCalendar</a></code> does not implement <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>GregorianCalendar<span class="sy0">&gt;</span></span>, but instead the (better) interface <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>Calendar<span class="sy0">&gt;</span></span>. In Java, unlike in C#, <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>Calendar<span class="sy0">&gt;</span></span> is not considered a subtype of <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>GregorianCalendar<span class="sy0">&gt;</span></span>. Instead the type of <span class="mw-geshi java source-java">max</span> has to be modified:</p>
<p>WHATSON? 4745735e-8372-41fa-85c5-b7a32e3f5bd6</p>
<pre class="de1">
    <span class="sy0">&lt;</span>T <span class="kw1">extends</span> Comparable<span class="sy0">&lt;?</span> <span class="kw1">super</span> T<span class="sy0">&gt;&gt;</span>  T max<span class="br0">(</span>Collection<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> coll<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The bounded wildcard <span class="mw-geshi java source-java"><span class="sy0">?</span> <span class="kw1">super</span> T</span> conveys the information that <span class="mw-geshi java source-java">max</span> calls only contravariant methods from the <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span> interface. This particular example is frustrating because <i>all</i> the methods in <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span> are contravariant, so that condition is trivially true. A declaration-site system could handle this example with less clutter by annotating only the definition of <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span>.</p>
<h3><span class="mw-headline" id="Comparing_Declaration-site_and_Use-site_annotations">Comparing Declaration-site and Use-site annotations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=17" title="Edit section: Comparing Declaration-site and Use-site annotations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Use-site variance annotations provide additional flexibility, allowing more programs to type-check. However, they have been criticized for the complexity they add to the language, leading to complicated type signatures and error messages.</p>
<p>One way to assess whether the extra flexibility is useful is to see if it is used in existing programs. A survey of a large set of Java libraries<sup id="cite_ref-tamingCombining_10-1" class="reference"><a href="#cite_note-tamingCombining-10"><span>[</span>10<span>]</span></a></sup> found that 39% of wildcard annotations could have been directly replaced by a declaration-site annotations. Thus the remaining 61% is an indication on places where Java benefits from having the use-site system available.</p>
<p>In a declaration-site language, libraries must either expose less variance, or define more interfaces. For example, the Scala Collections library defines three separate interfaces for classes which employ covariance: a covariant base interface containing common methods, an invariant mutable version which adds side-effecting methods, and a covariant immutable version which may specialize the inherited implementations to exploit structural sharing.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup> This design works well with declaration-site annotations, but the large number of interfaces carry a complexity cost for clients of the library. And modifying the library interface may not be an option—in particular, one goal when adding generics to Java was to maintain binary backwards compatibility.</p>
<p>On the other hand, Java wildcards are themselves complex. In a conference presentation<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>13<span>]</span></a></sup> <a href="/wiki/Joshua_Bloch" title="Joshua Bloch">Joshua Bloch</a> criticized them as being too hard to understand and use, stating that when adding support for <a href="/wiki/Closure_(computer_science)" title="Closure (computer science)" class="mw-redirect">closures</a> "we simply cannot afford another <i>wildcards</i>". Early versions of Scala used use-site variance annotations but programmers found them difficult to use in practice, while declaration-site annotations were found to be very helpful when designing classes.<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>14<span>]</span></a></sup> Later versions of Scala added Java-style existential types and wildcards; however, according to <a href="/wiki/Martin_Odersky" title="Martin Odersky">Martin Odersky</a>, if there were no need for interoperability with Java then these would probably not have been included.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>15<span>]</span></a></sup></p>
<p>Ross Tate argues<sup id="cite_ref-MixedSiteVariance_16-0" class="reference"><a href="#cite_note-MixedSiteVariance-16"><span>[</span>16<span>]</span></a></sup> that part of the complexity of Java wildcards is due to the decision to encode use-site variance using a form of existential types. The original proposals<sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>17<span>]</span></a></sup> <sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>18<span>]</span></a></sup> used special-purpose syntax for variance annotations, writing <span class="mw-geshi java source-java">List<span class="sy0">&lt;+</span>Animal<span class="sy0">&gt;</span></span> instead of Java's more verbose <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>.</p>
<p>Since wildcards are a form of existential types they can be used for more things than just variance. A type like <span class="mw-geshi java source-java">List<span class="sy0">&lt;?&gt;</span></span> ("some type of list") lets objects be passed to methods or stored in fields without exactly specifying their type parameters. This is particularly valuable for classes such as <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">Class</a></code> where most of the methods do not mention the type parameter.</p>
<p>However, type inference for existential types is a difficult problem. For the compiler implementer, Java wildcards raise issues with type checker termination, type argument inference, and ambiguous programs.<sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span>[</span>19<span>]</span></a></sup> For the programmer, it leads to complicated type error messages. Java typechecks wildcard types by replacing the wildcards with fresh type variables (so-called <i>capture conversion</i>). This can make error messages harder to read, because they refer to type variables that the programmer did not directly write. For example, trying to add a <span class="mw-geshi java source-java">Cat</span> to a <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span> will give an error like</p>
<p>WHATSON? 71265079-e404-4053-9afb-9a875841f5f4</p>
<pre>
method List.add(capture#1) is not applicable
  (actual argument Cat cannot be converted to capture#1 by method invocation conversion)
where capture#1 is a fresh type-variable:
  capture#1 extends Animal from capture of ? extends Animal
</pre>
<p>Since both declaration-site and use-site annotations can be useful, some type system provide both.<sup id="cite_ref-tamingCombining_10-2" class="reference"><a href="#cite_note-tamingCombining-10"><span>[</span>10<span>]</span></a></sup><sup id="cite_ref-MixedSiteVariance_16-1" class="reference"><a href="#cite_note-MixedSiteVariance-16"><span>[</span>16<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Covariant_generics_in_Dart">Covariant generics in Dart</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=18" title="Edit section: Covariant generics in Dart">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The <a href="/wiki/Dart_(programming_language)" title="Dart (programming language)">Dart</a> programming language does not track variance, and instead treats all parameterized types as covariant. The language specification<sup id="cite_ref-20" class="reference"><a href="#cite_note-20"><span>[</span>20<span>]</span></a></sup> states</p>
<p>The type system is unsound, due to the covariance of generic types. This is a deliberate choice (and undoubtedly controversial). Experience has shown that sound type rules for generics fly in the face of programmer intuition. It is easy for tools to provide a sound type analysis if they choose, which may be useful for tasks like refactoring.</p>
<h2><span class="mw-headline" id="Origin_of_the_term_.22covariance.22">Origin of the term "covariance"</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=19" title='Edit section: Origin of the term "covariance"'>edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>These terms come from the notion of <a href="/wiki/Covariance_and_contravariance_of_functors" title="Covariance and contravariance of functors" class="mw-redirect">covariant and contravariant functors</a> in <a href="/wiki/Category_theory" title="Category theory">category theory</a>. Consider the category <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> whose objects are types and whose morphisms represent the subtype relationship ≤. (This is an example of how any partially ordered set can be considered as a category). Then for example the function type constructor takes two types <i>p</i> and <i>r</i> and creates a new type <i>p</i> → <i>r</i>; so it takes objects in <img class="mwe-math-fallback-image-inline tex" alt="C^2" src="//upload.wikimedia.org/math/2/6/0/260dd56bacf8c0c3908fa94f84298d12.png"> to objects in <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">. By the subtyping rule for function types this operation reverses ≤ for the first argument and preserves it for the second, so it is a contravariant functor in the first argument and a covariant functor in the second.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=20" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">Polymorphism (computer science)</a></li>
<li><a href="/wiki/Inheritance_(computer_science)" title="Inheritance (computer science)" class="mw-redirect">Inheritance (computer science)</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=21" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation conference">John C. Reynolds (1981). <a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/~crary/819-f09/Reynolds81.ps">"The Essence of Algol"</a>. Symposium on Algorithmic Languages. North-Holland.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=John+C.+Reynolds&amp;rft.aulast=John+C.+Reynolds&amp;rft.btitle=The+Essence+of+Algol&amp;rft.date=1981&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.cmu.edu%2F~crary%2F819-f09%2FReynolds81.ps&amp;rft.pub=North-Holland&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation conference">Luca Cardelli (1984). <a rel="nofollow" class="external text" href="http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf">"A semantics of multiple inheritance"</a>. Semantics of Data Types (International Symposium Sophia-Antipolis, France, June 27 – 29, 1984). Lecture Notes in Computer Science <b>173</b>. Springer. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-13346-1_2">10.1007/3-540-13346-1_2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.aulast=Luca+Cardelli&amp;rft.au=Luca+Cardelli&amp;rft.btitle=A+semantics+of+multiple+inheritance&amp;rft.date=1984&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Flucacardelli.name%2FPapers%2FInheritance%2520%28Semantics%2520of%2520Data%2520Types%29.pdf&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-13346-1_2&amp;rft.pub=Springer&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=173" class="Z3988"><span style="display:none;"> </span></span>(Longer version in Information and Computation, 76(2/3): 138-164, February 1988.)</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation news">Allison, Chuck. <a rel="nofollow" class="external text" href="http://www.drdobbs.com/184403580">"What's New in Standard C++?"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Allison%2C+Chuck&amp;rft.aufirst=Chuck&amp;rft.aulast=Allison&amp;rft.btitle=What%27s+New+in+Standard+C%2B%2B%3F&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.drdobbs.com%2F184403580&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation conference">Bertrand Meyer (October 1995). <a rel="nofollow" class="external text" href="http://se.ethz.ch/~meyer/publications/acm/typing.pdf">"Static Typing"</a>. "OOPSLA 95 (Object-Oriented Programming, Systems, Languages and Applications), Atlanta, 1995.".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=OOPSLA+95+%28Object-Oriented+Programming%2C+Systems%2C+Languages+and+Applications%29%2C+Atlanta%2C+1995.&amp;rft.au=Bertrand+Meyer&amp;rft.aulast=Bertrand+Meyer&amp;rft.btitle=Static+Typing&amp;rft.date=October+1995&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fse.ethz.ch%2F~meyer%2Fpublications%2Facm%2Ftyping.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-competentCompilers-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-competentCompilers_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-competentCompilers_5-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Howard, Mark; Bezault, Eric; Meyer, Bertrand; Colnet, Dominique; Stapf, Emmanuel; Arnout, Karine; Keller, Markus (April 2003). <a rel="nofollow" class="external text" href="http://se.ethz.ch/~meyer/ongoing/covariance/recast.pdf">"Type-safe covariance: Competent compilers can catch all catcalls"</a><span class="reference-accessdate">. Retrieved 23 May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Arnout%2C+Karine&amp;rft.au=Bezault%2C+Eric&amp;rft.au=Colnet%2C+Dominique&amp;rft.aufirst=Mark&amp;rft.au=Howard%2C+Mark&amp;rft.au=Keller%2C+Markus&amp;rft.aulast=Howard&amp;rft.au=Meyer%2C+Bertrand&amp;rft.au=Stapf%2C+Emmanuel&amp;rft.btitle=Type-safe+covariance%3A+Competent+compilers+can+catch+all+catcalls&amp;rft.date=April+2003&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fse.ethz.ch%2F~meyer%2Fongoing%2Fcovariance%2Frecast.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation conference">Franz Weber (1992). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.7872">"Getting Class Correctness and System Correctness Equivalent - How to Get Covariance Right"</a>. "TOOLS 8 (8th conference on Technology of Object-Oriented Languages and Systems), Dortmund, 1992".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=TOOLS+8+%288th+conference+on+Technology+of+Object-Oriented+Languages+and+Systems%29%2C+Dortmund%2C+1992&amp;rft.au=Franz+Weber&amp;rft.aulast=Franz+Weber&amp;rft.btitle=Getting+Class+Correctness+and+System+Correctness+Equivalent+-+How+to+Get+Covariance+Right&amp;rft.date=1992&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.52.7872&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Giuseppe Castagna, <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=203096&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">Covariance and contravariance: conflict without a cause</a>, ACM Transactions on Programming Languages and Systems (TOPLAS), Volume 17, Issue 3, May 1995, pages 431-447.</span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web">Eric Lippert (3 December 2009). <a rel="nofollow" class="external text" href="http://blogs.msdn.com/b/ericlippert/archive/2009/12/03/exact-rules-for-variance-validity.aspx">"Exact rules for variance validity"</a><span class="reference-accessdate">. Retrieved July 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Eric+Lippert&amp;rft.aulast=Eric+Lippert&amp;rft.btitle=Exact+rules+for+variance+validity&amp;rft.date=3+December+2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fb%2Fericlippert%2Farchive%2F2009%2F12%2F03%2Fexact-rules-for-variance-validity.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text">Section II.9.7 in <cite>ECMA International Standard ECMA-335 Common Language Infrastructure (CLI) 6th edition (June 2012)</cite>; <a rel="nofollow" class="external text" href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">available online</a></span></li>
<li id="cite_note-tamingCombining-10"><span class="mw-cite-backlink">^ <a href="#cite_ref-tamingCombining_10-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-tamingCombining_10-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-tamingCombining_10-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">John Altidor; Huang Shan Shan; Yannis Smaragdakis (2011). <a rel="nofollow" class="external text" href="http://www.cs.umass.edu/~jaltidor/variance_pldi11.pdf">"Taming the wildcards: combining definition- and use-site variance"</a>. "Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation (PLDI'11)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+32nd+ACM+SIGPLAN+conference+on+Programming+language+design+and+implementation+%28PLDI%2711%29&amp;rft.au=Huang+Shan+Shan&amp;rft.au=John+Altidor&amp;rft.aulast=John+Altidor&amp;rft.au=Yannis+Smaragdakis&amp;rft.btitle=Taming+the+wildcards%3A+combining+definition-+and+use-site+variance&amp;rft.date=2011&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.umass.edu%2F~jaltidor%2Fvariance_pldi11.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation web">Eric Lippert (October 29, 2007). <a rel="nofollow" class="external text" href="http://blogs.msdn.com/ericlippert/archive/2007/10/29/covariance-and-contravariance-in-c-part-seven-why-do-we-need-a-syntax-at-all.aspx">"Covariance and Contravariance in C# Part Seven: Why Do We Need A Syntax At All?"</a><span class="reference-accessdate">. Retrieved October 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Eric+Lippert&amp;rft.aulast=Eric+Lippert&amp;rft.btitle=Covariance+and+Contravariance+in+C%23+Part+Seven%3A+Why+Do+We+Need+A+Syntax+At+All%3F&amp;rft.date=October+29%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fericlippert%2Farchive%2F2007%2F10%2F29%2Fcovariance-and-contravariance-in-c-part-seven-why-do-we-need-a-syntax-at-all.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation web">Marin Odersky; Lex Spoon (September 7, 2010). <a rel="nofollow" class="external text" href="http://www.scala-lang.org/docu/files/collections-api/collections.html">"The Scala 2.8 Collections API"</a><span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.aulast=Marin+Odersky&amp;rft.au=Lex+Spoon&amp;rft.au=Marin+Odersky&amp;rft.btitle=The+Scala+2.8+Collections+API&amp;rft.date=September+7%2C+2010&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.scala-lang.org%2Fdocu%2Ffiles%2Fcollections-api%2Fcollections.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web">Joshua Bloch (November 2007). <a rel="nofollow" class="external text" href="http://parleys.com/play/514892250364bc17fc56bb15/chapter0/about">"The Closures Controversy [video]"</a>. Presentation at Javapolis'07<span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Joshua+Bloch&amp;rft.aulast=Joshua+Bloch&amp;rft.btitle=The+Closures+Controversy+%5Bvideo%5D&amp;rft.date=November+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fparleys.com%2Fplay%2F514892250364bc17fc56bb15%2Fchapter0%2Fabout&amp;rft.place=Presentation+at+Javapolis%2707&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation conference">Martin Odersky; Matthias Zenger (2005). <a rel="nofollow" class="external text" href="http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf">"Scalable component abstractions"</a>. "Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '05)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+20th+annual+ACM+SIGPLAN+conference+on+Object-oriented+programming%2C+systems%2C+languages%2C+and+applications+%28OOPSLA+%2705%29&amp;rft.aulast=Martin+Odersky&amp;rft.au=Martin+Odersky&amp;rft.au=Matthias+Zenger&amp;rft.btitle=Scalable+component+abstractions&amp;rft.date=2005&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Flampwww.epfl.ch%2F~odersky%2Fpapers%2FScalableComponent.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><span class="citation web">Bill Venners and Frank Sommers (May 18, 2009). <a rel="nofollow" class="external text" href="http://www.artima.com/scalazine/articles/scalas_type_system.html">"The Purpose of Scala's Type System: A Conversation with Martin Odersky, Part III"</a><span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Bill+Venners+and+Frank+Sommers&amp;rft.aulast=Bill+Venners+and+Frank+Sommers&amp;rft.btitle=The+Purpose+of+Scala%27s+Type+System%3A+A+Conversation+with+Martin+Odersky%2C+Part+III&amp;rft.date=May+18%2C+2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.artima.com%2Fscalazine%2Farticles%2Fscalas_type_system.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-MixedSiteVariance-16"><span class="mw-cite-backlink">^ <a href="#cite_ref-MixedSiteVariance_16-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-MixedSiteVariance_16-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">Ross Tate (2013). <a rel="nofollow" class="external text" href="http://www.cs.cornell.edu/~ross/publications/mixedsite/index.html">"Mixed-Site Variance"</a>. "FOOL '13: Informal Proceedings of the 20th International Workshop on Foundations of Object-Oriented Languages".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=FOOL+%2713%3A+Informal+Proceedings+of+the+20th+International+Workshop+on+Foundations+of+Object-Oriented+Languages&amp;rft.aulast=Ross+Tate&amp;rft.au=Ross+Tate&amp;rft.btitle=Mixed-Site+Variance&amp;rft.date=2013&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.cornell.edu%2F~ross%2Fpublications%2Fmixedsite%2Findex.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><span class="citation conference">Atsushi Igarashi; Mirko Viroli (2002). <a rel="nofollow" class="external text" href="http://www.sato.kuis.kyoto-u.ac.jp/~igarashi/papers/pdf/variance.ecoop02.pdf">"On Variance-Based Subtyping for Parametric Types"</a>. "Proceedings of the 16th European Conference on Object-Oriented Programming (ECOOP '02)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+16th+European+Conference+on+Object-Oriented+Programming+%28ECOOP+%2702%29&amp;rft.au=Atsushi+Igarashi&amp;rft.aulast=Atsushi+Igarashi&amp;rft.au=Mirko+Viroli&amp;rft.btitle=On+Variance-Based+Subtyping+for+Parametric+Types&amp;rft.date=2002&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.sato.kuis.kyoto-u.ac.jp%2F~igarashi%2Fpapers%2Fpdf%2Fvariance.ecoop02.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text"><span class="citation conference">Kresten Krab Thorup; Mads Torgersen (1999). <a rel="nofollow" class="external text" href="http://www.daimi.au.dk/~madst/tool/papers/unifying.pdf">"Unifying Genericity: Combining the Benefits of Virtual Types and Parameterized Classes"</a>. "Object-Oriented Programming (ECOOP '99)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Object-Oriented+Programming+%28ECOOP+%2799%29&amp;rft.au=Kresten+Krab+Thorup&amp;rft.aulast=Kresten+Krab+Thorup&amp;rft.au=Mads+Torgersen&amp;rft.btitle=Unifying+Genericity%3A+Combining+the+Benefits+of+Virtual+Types+and+Parameterized+Classes&amp;rft.date=1999&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.daimi.au.dk%2F~madst%2Ftool%2Fpapers%2Funifying.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text"><span class="citation conference">Tate, Ross; Leung, Alan; Lerner, Sorin (2011). <a rel="nofollow" class="external text" href="http://www.cs.cornell.edu/~ross/publications/tamewild/">"Taming wildcards in Java's type system"</a>. "Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation (PLDI '11)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+32nd+ACM+SIGPLAN+conference+on+Programming+language+design+and+implementation+%28PLDI+%2711%29&amp;rft.aufirst=Ross&amp;rft.aulast=Tate&amp;rft.au=Lerner%2C+Sorin&amp;rft.au=Leung%2C+Alan&amp;rft.au=Tate%2C+Ross&amp;rft.btitle=Taming+wildcards+in+Java%27s+type+system&amp;rft.date=2011&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.cornell.edu%2F~ross%2Fpublications%2Ftamewild%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-20"><span class="mw-cite-backlink"><b><a href="#cite_ref-20">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.dartlang.org/docs/spec/">"The Dart Programming Language Specification"</a>. May 6, 2013<span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.btitle=The+Dart+Programming+Language+Specification&amp;rft.date=May+6%2C+2013&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.dartlang.org%2Fdocs%2Fspec%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=22" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://blogs.msdn.com/ericlippert/archive/tags/Covariance+and+Contravariance/default.aspx">Fabulous Adventures in Coding</a>: An article series about implementation concerns surrounding co/contravariance in C#</li>
<li><a rel="nofollow" class="external text" href="http://c2.com/cgi/wiki?ContraVsCoVariance">Contra Vs Co Variance</a> (note this article is not updated about C++)</li>
<li><a rel="nofollow" class="external text" href="http://www.javac.info/closures-v05.html">Closures for the Java 7 Programming Language (v0.5)</a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Covariance and contravariance (computer science)</span></h1>
<p>Many <a href="/wiki/Programming_language" title="Programming language">programming language</a> <a href="/wiki/Type_system" title="Type system">type systems</a> support <a href="/wiki/Subtyping" title="Subtyping">subtyping</a>. For instance, if <span class="mw-geshi csharp source-csharp">Cat</span> is subtype of <span class="mw-geshi csharp source-csharp">Animal</span>, then an expression of type <span class="mw-geshi csharp source-csharp">Cat</span> can be used whenever an expression of type <span class="mw-geshi csharp source-csharp">Animal</span> could. <b>Variance</b> refers to how subtyping between more complex types (list of <span class="mw-geshi csharp source-csharp">Cat</span>s versus list of <span class="mw-geshi csharp source-csharp">Animal</span>s, function returning <span class="mw-geshi csharp source-csharp">Cat</span> versus function returning <span class="mw-geshi csharp source-csharp">Animal</span>, ...) relates to subtyping between their components. Depending on the variance of the <a href="/wiki/Type_constructor" title="Type constructor">type constructor</a>, the subtyping relation may be either preserved, reversed, or ignored. For example, in <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>:</p>
<ul>
<li><span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span>. The subtyping is preserved because <span class="mw-geshi csharp source-csharp">IEnumerable</span> is <b>covariant</b>.</li>
<li><span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span>. The subtyping is reversed because <span class="mw-geshi csharp source-csharp">Action</span> is <b>contravariant</b>.</li>
<li>Neither <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> nor <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span> is a subtype of the other, because <span class="mw-geshi csharp source-csharp">IList</span> is <b>invariant</b>.</li>
</ul>
<p>The variance of a C# interface is determined by <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>/<span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> annotations on its type parameters; the above interfaces are declared as <span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span><span class="kw1">out</span> T<span class="sy0">&gt;</span></span>, <span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span><span class="kw1">in</span> T<span class="sy0">&gt;</span></span>, and <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>. The <a href="#Interfaces">typing rules for interface variance</a> ensure type safety. For example, an <span class="mw-geshi csharp source-csharp">Action<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> represents a first-class function expecting an argument of type <span class="mw-geshi csharp source-csharp">T</span>, and a function which can handle any type of animal can always be used instead of one which can only handle cats.</p>
<p>A programming language designer will consider variance when devising typing rules for e.g. arrays, inheritance, and generic datatypes. By making type constructors covariant or contravariant instead of invariant, more programs will be accepted as well-typed. On the other hand, programmers often find contravariance unintuitive, and accurately tracking variance to avoid runtime type errors can lead to complex typing rules. In order to keep the type system simple and allow useful programs, a language may treat a type constructor as invariant even if it would be safe to consider it variant, or treat it as covariant even when that can violate type safety.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Formal_definition"><span class="tocnumber">1</span> <span class="toctext">Formal definition</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Arrays"><span class="tocnumber">2</span> <span class="toctext">Arrays</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Covariant_arrays_in_Java_and_C.23"><span class="tocnumber">2.1</span> <span class="toctext">Covariant arrays in Java and C#</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Function_types"><span class="tocnumber">3</span> <span class="toctext">Function types</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Inheritance_in_object_oriented_languages"><span class="tocnumber">4</span> <span class="toctext">Inheritance in object oriented languages</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Covariant_method_return_type"><span class="tocnumber">4.1</span> <span class="toctext">Covariant method return type</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Contravariant_method_argument_type"><span class="tocnumber">4.2</span> <span class="toctext">Contravariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Covariant_method_argument_type"><span class="tocnumber">4.3</span> <span class="toctext">Covariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Avoiding_the_need_for_covariant_argument_types"><span class="tocnumber">4.4</span> <span class="toctext">Avoiding the need for covariant argument types</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Summary_of_variance_and_inheritance"><span class="tocnumber">4.5</span> <span class="toctext">Summary of variance and inheritance</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Generic_types"><span class="tocnumber">5</span> <span class="toctext">Generic types</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Declaration-site_variance_annotations"><span class="tocnumber">5.1</span> <span class="toctext">Declaration-site variance annotations</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Interfaces"><span class="tocnumber">5.1.1</span> <span class="toctext">Interfaces</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Data"><span class="tocnumber">5.1.2</span> <span class="toctext">Data</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Inferring_Variance"><span class="tocnumber">5.1.3</span> <span class="toctext">Inferring Variance</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Use-site_variance_annotations_.28Wildcards.29"><span class="tocnumber">5.2</span> <span class="toctext">Use-site variance annotations (Wildcards)</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Comparing_Declaration-site_and_Use-site_annotations"><span class="tocnumber">5.3</span> <span class="toctext">Comparing Declaration-site and Use-site annotations</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Covariant_generics_in_Dart"><span class="tocnumber">5.4</span> <span class="toctext">Covariant generics in Dart</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Origin_of_the_term_.22covariance.22"><span class="tocnumber">6</span> <span class="toctext">Origin of the term "covariance"</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Covariant_arrays_in_Java_and_C.23"><span class="tocnumber">2.1</span> <span class="toctext">Covariant arrays in Java and C#</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Covariant_method_return_type"><span class="tocnumber">4.1</span> <span class="toctext">Covariant method return type</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Contravariant_method_argument_type"><span class="tocnumber">4.2</span> <span class="toctext">Contravariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Covariant_method_argument_type"><span class="tocnumber">4.3</span> <span class="toctext">Covariant method argument type</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Avoiding_the_need_for_covariant_argument_types"><span class="tocnumber">4.4</span> <span class="toctext">Avoiding the need for covariant argument types</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Summary_of_variance_and_inheritance"><span class="tocnumber">4.5</span> <span class="toctext">Summary of variance and inheritance</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Declaration-site_variance_annotations"><span class="tocnumber">5.1</span> <span class="toctext">Declaration-site variance annotations</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Interfaces"><span class="tocnumber">5.1.1</span> <span class="toctext">Interfaces</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Data"><span class="tocnumber">5.1.2</span> <span class="toctext">Data</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Inferring_Variance"><span class="tocnumber">5.1.3</span> <span class="toctext">Inferring Variance</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Use-site_variance_annotations_.28Wildcards.29"><span class="tocnumber">5.2</span> <span class="toctext">Use-site variance annotations (Wildcards)</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Comparing_Declaration-site_and_Use-site_annotations"><span class="tocnumber">5.3</span> <span class="toctext">Comparing Declaration-site and Use-site annotations</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Covariant_generics_in_Dart"><span class="tocnumber">5.4</span> <span class="toctext">Covariant generics in Dart</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Interfaces"><span class="tocnumber">5.1.1</span> <span class="toctext">Interfaces</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Data"><span class="tocnumber">5.1.2</span> <span class="toctext">Data</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Inferring_Variance"><span class="tocnumber">5.1.3</span> <span class="toctext">Inferring Variance</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Formal definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Within the <a href="/wiki/Type_system" title="Type system">type system</a> of a <a href="/wiki/Programming_language" title="Programming language">programming language</a>, a typing rule or a type constructor is:</p>
<ul>
<li><b>covariant</b> if it preserves the <a href="/wiki/Subtype" title="Subtype" class="mw-redirect">ordering of types (≤)</a>, which orders types from more specific to more generic;</li>
<li><b>contravariant</b> if it reverses this ordering;</li>
<li><b>bivariant</b> if both of these apply;</li>
<li><b>invariant</b> or <b>nonvariant</b> if neither of these applies.</li>
</ul>
<p>In the rest of the article, we will consider how this applies to some common type constructors.</p>
<h2><span class="mw-headline" id="Arrays">Arrays</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Arrays">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>First consider the <a href="/wiki/Array_data_type" title="Array data type">array type</a> constructor: from the type <span class="mw-geshi java source-java">Animal</span> we can make the type <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> ("array of animals"). Should we treat this as</p>
<ul>
<li>Covariant: a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span> is an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span></li>
<li>Contravariant: an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> is a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span></li>
<li>or neither (invariant)?</li>
</ul>
<p>If we wish to avoid type errors, and the array supports both reading and writing elements, then only the third choice is safe. Clearly, not every <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> can be treated as if it were a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span>, since a client reading from the array will expect a <span class="mw-geshi java source-java">Cat</span>, but an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span> may contain e.g. a <span class="mw-geshi java source-java">Dog</span>. So the contravariant rule is not safe.</p>
<p>Conversely, a <span class="mw-geshi java source-java">Cat<span class="br0">[</span><span class="br0">]</span></span> can not be treated as an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span>. It should always be possible to put a <span class="mw-geshi java source-java">Dog</span> into an <span class="mw-geshi java source-java">Animal<span class="br0">[</span><span class="br0">]</span></span>. With covariant arrays this can not be guaranteed to be safe, since the backing store might actually be an array of cats. So the covariant rule is also not safe—the array constructor should be <b>invariant</b>. Note that this is only an issue for mutable arrays; the covariant rule is safe for immutable (read-only) arrays.</p>
<p>This illustrates a general phenomenon. Read-only data types (sources) can be covariant; write-only data types (sinks) can be contravariant. Mutable data types which act as both sources and sinks should be invariant.</p>
<h3><span class="mw-headline" id="Covariant_arrays_in_Java_and_C.23">Covariant arrays in Java and C#</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Covariant arrays in Java and C#">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Early versions of Java and C# did not include generics (a.k.a. <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>). In such a setting, making arrays invariant rules out useful polymorphic programs.</p>
<p>For example, consider writing a function to shuffle an array, or a function that tests two arrays for equality using the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a></code>.<span class="mw-geshi java source-java">equals</span> method on the elements. The implementation does not depend on the exact type of element stored in the array, so it should be possible to write a single function that works on all types of arrays. It is easy to implement functions of type</p>
<p>WHATSON? ea31b5af-59ef-48d6-a7f8-1b12004fc7bb</p>
<pre class="de1">
    <span class="kw4">boolean</span> equalArrays <span class="br0">(</span><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> a1, <span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> a2<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw4">void</span> shuffleArray<span class="br0">(</span><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>However, if array types were treated as invariant, it would only be possible to call these functions on an array of exactly the type <span class="mw-geshi java source-java"><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span></span>. One could not, for example, shuffle an array of strings.</p>
<p>Therefore, both Java and C# treat array types covariantly. For instance, in C# <span class="mw-geshi csharp source-csharp"><span class="kw4">string</span><span class="br0">[</span><span class="br0">]</span></span> is a subtype of <code>object[]</code>, and in Java <span class="mw-geshi java source-java"><span class="kw3">String</span><span class="br0">[</span><span class="br0">]</span></span> is a subtype of <span class="mw-geshi java source-java"><span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span></span>.</p>
<p>As discussed above, covariant arrays leads to problem with writes into the array. Java and C# deals with this by marking each array object with a type when it is created. Each time a value is stored into an array, the compiler inserts a check that the run-time type of the value is equal to the run-time type of the array. If there is a mismatch, an <span class="mw-geshi java source-java"><span class="kw3">ArrayStoreException</span></span> (or <span class="mw-geshi csharp source-csharp">ArrayTypeMismatchException</span> in C#) is thrown:</p>
<p>WHATSON? 806c0ade-40de-469d-8455-40dc89811f45</p>
<pre class="de1">
    <span class="co1">// a is a single-element array of String</span>
    <span class="kw3">String</span><span class="br0">[</span><span class="br0">]</span> a <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw3">String</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
 
    <span class="co1">// b is an array of Object</span>
    <span class="kw3">Object</span><span class="br0">[</span><span class="br0">]</span> b <span class="sy0">=</span> a<span class="sy0">;</span>
 
    <span class="co1">// Assign an Integer to b. This would be possible if b really were</span>
    <span class="co1">// an array of Object, but since it really is an array of String,</span>
    <span class="co1">// we will get a java.lang.ArrayStoreException.</span>
    b<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
</pre>
<p>In the above example you can <b>read</b> from b safely. It is only trying to <b>write</b> to the array that can lead to trouble.</p>
<p>One drawback of this approach is that it leaves the possibility of a run-time error which a stricter type system could have caught at compile-time. Also, it hurts performance because each write into an array requires an additional runtime check.</p>
<p>With the addition of generics, Java and C# now offer ways to write this kind of polymorphic functions without relying on covariance. The array comparison and shuffling functions can be given the parameterized types</p>
<p>WHATSON? 741c91f6-19fc-4528-a53e-1b2885f171cb</p>
<pre class="de1">
    <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw4">boolean</span> equalArrays <span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span> a1, T<span class="br0">[</span><span class="br0">]</span> a2<span class="br0">)</span><span class="sy0">;</span>
    <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw4">void</span> shuffleArray<span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>Alternatively, to enforce that a C# method accesses a collection in a read-only way, one can use the interface <span class="mw-geshi csharp source-csharp">IEnumerable<span class="sy0">&lt;</span><span class="kw4">object</span><span class="sy0">&gt;</span></span> instead of passing it an array <span class="mw-geshi csharp source-csharp"><span class="kw4">object</span><span class="br0">[</span><span class="br0">]</span></span>.</p>
<h2><span class="mw-headline" id="Function_types">Function types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Function types">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Languages with <a href="/wiki/First-class_functions" title="First-class functions" class="mw-redirect">first-class functions</a> have <a href="/wiki/Function_type" title="Function type">function types</a> like "a function expecting a Cat and returning an Animal" (written <span class="mw-geshi ocaml source-ocaml">Cat <span class="sy0">-&gt;</span> Animal</span> in <a href="/wiki/OCaml" title="OCaml">OCaml</a> syntax or <span class="mw-geshi csharp source-csharp">Func<span class="sy0">&lt;</span>Cat,Animal<span class="sy0">&gt;</span></span> in <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> syntax).</p>
<p>Those languages also need to specify when one function type is a subtype of another—that is, when it is safe to use a function of one type in a context that expects a function of a different type. It is safe to substitute a function <i>f</i> instead of a function <i>g</i> if <i>f</i> accepts a more general type of arguments and returns a more specific type than <i>g</i>. For example, a function of type <span class="mw-geshi ocaml source-ocaml">Cat<span class="sy0">-&gt;</span>Cat</span> can safely be used wherever a <span class="mw-geshi ocaml source-ocaml">Cat<span class="sy0">-&gt;</span>Animal</span> was expected, and likewise a function of type <span class="mw-geshi ocaml source-ocaml">Animal<span class="sy0">-&gt;</span>Animal</span> can be used wherever a <span class="mw-geshi ocaml source-ocaml">Cat<span class="sy0">-&gt;</span>Animal</span> was expected. (One can compare this to the <a href="/wiki/Robustness_principle" title="Robustness principle">robustness principle</a> of communication: "be liberal in what you accept and conservative in what you produce"). The general rule is</p>
<p>S<sub>1</sub> → S<sub>2</sub> ≤ T<sub>1</sub> → T<sub>2</sub> if T<sub>1</sub> ≤ S<sub>1</sub> and S<sub>2</sub> ≤ T<sub>2</sub>.</p>
<p>In other words, the → type constructor is <b>contravariant in the input type</b> and <b>covariant in the output type</b>. This rule was first stated formally by <a href="/wiki/John_C._Reynolds" title="John C. Reynolds">John Reynolds</a>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> and further popularized in a paper by Luca Cardelli.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p>When dealing with <a href="/wiki/Higher-order_function" title="Higher-order function">functions that take functions as arguments</a>, this rule can be applied several times. For example, by applying the rule twice, we see that (A'→B)→B ≤ (A→B)→B if A'≤A. In other words, the type (A→B)→B is <i>covariant</i> in the A position. For complicated types it can be confusing to mentally trace why a given type specialization is or isn't type-safe, but it is easy to calculate which positions are co- and contravariant: a position is covariant if it is on the left side of an even number of arrows.</p>
<h2><span class="mw-headline" id="Inheritance_in_object_oriented_languages">Inheritance in object oriented languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Inheritance in object oriented languages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When a subclass <a href="/wiki/Method_overriding" title="Method overriding">overrides</a> a method in a superclass, the compiler must check that the overriding method has the right type. While some languages require that the type exactly matches the type in the superclass (invariance), it is also type safe to allow the overriding method to have a "better" type. By the usual subtyping rule for function types, this means that the overriding method should return a more specific type (return type covariance), and accept a more general argument (argument type contravariance). In <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a> notation, the possibilities are as follows:</p>
<ul class="gallery mw-gallery-traditional" style="max-width: 815px;_width: 815px;">
<li class="gallerycaption">Variance and method overriding: overview</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:28.5px auto;"><a href="/wiki/File:Vererbung_T.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Vererbung_T.svg/120px-Vererbung_T.svg.png" width="120" height="163" data-file-width="125" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p>Subtyping of the argument/return type of the method.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_invariant.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/00/Inheritance_invariant.svg/120px-Inheritance_invariant.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Invariance</b>. The signature of the overrriding method is unchanged.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_covariant_return.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/27/Inheritance_covariant_return.svg/120px-Inheritance_covariant_return.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Covariant return type</b>. The subtyping relation is in the same direction as the relation between ClassA and ClassB.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_contravariant_argument.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Inheritance_contravariant_argument.svg/120px-Inheritance_contravariant_argument.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Contravariant argument type</b>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB.</p>
</div>
</div>
</li>
<li class="gallerybox" style="width: 155px">
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><a href="/wiki/File:Inheritance_covariant_argument.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Inheritance_covariant_argument.svg/120px-Inheritance_covariant_argument.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></a></div>
</div>
<div class="gallerytext">
<p><b>Covariant argument type</b>. Not type safe.</p>
</div>
</div>
</li>
</ul>
<p>Subtyping of the argument/return type of the method.</p>
<p><b>Invariance</b>. The signature of the overrriding method is unchanged.</p>
<p><b>Covariant return type</b>. The subtyping relation is in the same direction as the relation between ClassA and ClassB.</p>
<p><b>Contravariant argument type</b>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB.</p>
<p><b>Covariant argument type</b>. Not type safe.</p>
<p>For a concrete example, suppose we are writing a class to model an <a href="/wiki/Animal_shelter" title="Animal shelter">animal shelter</a>. We assume that <span class="mw-geshi java source-java">Cat</span> is a subclass of <span class="mw-geshi java source-java">Animal</span>, and that we have a base class (using Java syntax)</p>
<p>WHATSON? 3d915495-25be-480d-91dc-ed6792fede48</p>
<pre class="de1">
    <span class="kw1">class</span> AnimalShelter <span class="br0">{</span>
        Animal getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
 
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>Animal animal<span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Now the question is: if we subclass <span class="mw-geshi java source-java">AnimalShelter</span>, what types are we allowed to give to <span class="mw-geshi java source-java">getAnimalForAdoption</span> and <span class="mw-geshi java source-java">putAnimal</span>?</p>
<h3><span class="mw-headline" id="Covariant_method_return_type">Covariant method return type</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Covariant method return type">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a language which allows covariant return types, a derived class can override the <span class="mw-geshi java source-java">getAnimalForAdoption</span> method to return a more specific type:</p>
<p>WHATSON? bac2df22-5c82-42a4-be49-03c798323cb0</p>
<pre class="de1">
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> AnimalShelter <span class="br0">{</span>
        Cat getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    	    <span class="kw1">return</span> <span class="kw1">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Among mainstream OO languages, <a href="/wiki/Java_(Programming_language)" title="Java (Programming language)" class="mw-redirect">Java</a> and <a href="/wiki/C%2B%2B" title="C++">C++</a> support covariant return types, while <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> does not. Adding the covariant return type was one of the first modifications of the C++ language approved by the standards committee in 1998.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> and <a href="/wiki/D_(programming_language)" title="D (programming language)">D</a> also support covariant return types.</p>
<h3><span class="mw-headline" id="Contravariant_method_argument_type">Contravariant method argument type</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Contravariant method argument type">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Similarly, it is type safe to allow an overriding method to accept a more general argument than the method in the base class:</p>
<p>WHATSON? f0dbd28c-a41b-4e6c-926f-67e30dd4e009</p>
<pre class="de1">
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> AnimalShelter <span class="br0">{</span>
        <span class="kw4">void</span> putAnimal<span class="br0">(</span><span class="kw3">Object</span> animal<span class="br0">)</span> <span class="br0">{</span>
           ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Not many object oriented languages actually allow this—C++ and Java would interpret this as an unrelated method with an <a href="/wiki/Function_overloading" title="Function overloading">overloaded</a> name.</p>
<p>However, <a href="/wiki/Sather" title="Sather">Sather</a> supports both covariance and contravariance. Calling convention for overridden methods are covariant with <i>out</i> arguments and return values, and contravariant with normal arguments (with the mode <i>in</i>).</p>
<h3><span class="mw-headline" id="Covariant_method_argument_type">Covariant method argument type</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: Covariant method argument type">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Uniquely among mainstream languages, <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> allows the arguments of an overriding method to have a <i>more</i> specific type than the method in the superclass (argument type covariance). Thus, the Eiffel version of the following code would type check, with <span class="mw-geshi java source-java">putAnimal</span> overriding the method in the base class:</p>
<p>WHATSON? e120a59e-1c37-4c87-966a-ca6b7c2b15d3</p>
<pre class="de1">
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> AnimalShelter <span class="br0">{</span>
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>Cat animal<span class="br0">)</span> <span class="br0">{</span>
           ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>This is not type safe. By up-casting a <span class="mw-geshi java source-java">CatShelter</span> to an <span class="mw-geshi java source-java">AnimalShelter</span>, one can place a dog in a cat shelter. The lack of type safety (known as the "catcall problem" in the Eiffel community) has been a long-standing issue. Over the years, various combinations of global static analysis, local static analysis, and new language features have been proposed to remedy it,<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> <sup id="cite_ref-competentCompilers_5-0" class="reference"><a href="#cite_note-competentCompilers-5"><span>[</span>5<span>]</span></a></sup> and these have been implemented in some Eiffel compilers.</p>
<p>Despite the type safety problem, the Eiffel designers consider covariant argument types crucial for modeling real world requirements.<sup id="cite_ref-competentCompilers_5-1" class="reference"><a href="#cite_note-competentCompilers-5"><span>[</span>5<span>]</span></a></sup> The cat shelter illustrates a common phenomenon: it is <i>a kind of</i> animal shelter but has <i>additional restrictions</i>, and it seems reasonable to use inheritance and restricted argument types to model this. In proposing this use of inheritance, the Eiffel designers reject the <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>, which states that objects of subclasses should always be less restricted than objects of their superclass.</p>
<p>Another example where covariant arguments seem helpful is so-called binary methods, i.e. methods where the argument is expected to be of the same type as the object the method is called on. An example is the <span class="mw-geshi java source-java">compareTo</span> method: <span class="mw-geshi java source-java">a.<span class="me1">compareTo</span><span class="br0">(</span>b<span class="br0">)</span></span> checks whether <span class="mw-geshi java source-java">a</span> comes before or after <span class="mw-geshi java source-java">b</span> in some ordering, but the way to compare, say, two rational numbers will be different from the way to compare two strings. Other common examples of binary methods include equality tests, arithmetic operations, and set operations like subset and union.</p>
<p>In older versions of Java, the comparison method was specified as an interface <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span>:</p>
<p>WHATSON? a9a4ab49-ca2f-4e22-b625-ae549917af35</p>
<pre class="de1">
    <span class="kw1">interface</span> <span class="kw3">Comparable</span> <span class="br0">{</span>
        <span class="kw4">int</span> compareTo<span class="br0">(</span><span class="kw3">Object</span> o<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
</pre>
<p>The drawback of this is that the method is specified to take an argument of type <span class="mw-geshi java source-java"><span class="kw3">Object</span></span>. A typical implementation would first down-cast this argument (throwing an error if it is not of the expected type):</p>
<p>WHATSON? e8445156-e3d4-489d-a73c-af3bfd5d37cc</p>
<pre class="de1">
    <span class="kw1">class</span> RationalNumber <span class="kw1">implements</span> <span class="kw3">Comparable</span> <span class="br0">{</span>
        <span class="kw4">int</span> numerator<span class="sy0">;</span>
        <span class="kw4">int</span> denominator<span class="sy0">;</span>
 
        ...
 
        <span class="kw1">public</span> <span class="kw4">int</span> compareTo<span class="br0">(</span><span class="kw3">Object</span> other<span class="br0">)</span> <span class="br0">{</span>
            RationalNumber otherNum <span class="sy0">=</span> <span class="br0">(</span>RationalNumber<span class="br0">)</span>other<span class="sy0">;</span>
            <span class="kw1">return</span> <span class="kw3">Integer</span>.<span class="me1">compare</span><span class="br0">(</span>numerator<span class="sy0">*</span>otherNum.<span class="me1">denominator</span>,
                                   otherNum.<span class="me1">numerator</span><span class="sy0">*</span>denominator<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>In a language with covariant arguments, the argument to compareTo could be directly given the desired type <span class="mw-geshi java source-java">RationalNumber</span>, hiding the typecast. (Of course, this would still give a runtime error if <span class="mw-geshi java source-java">compareTo</span> was then called on e.g. a <span class="mw-geshi java source-java"><span class="kw3">String</span></span>).</p>
<h3><span class="mw-headline" id="Avoiding_the_need_for_covariant_argument_types">Avoiding the need for covariant argument types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: Avoiding the need for covariant argument types">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Other language features can provide the apparent benefits of covariant arguments while preserving Liskov substitutability.</p>
<p>In a language with <b>generics</b> (a.k.a. <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>) and <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded quantification</a>, the previous examples can be written in a type-safe way <sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> . Instead of defining <span class="mw-geshi java source-java">AnimalShelter</span>, we define a parameterized class <span class="mw-geshi java source-java">Shelter<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>. (One drawback of this is that the implementer of the base class needs to foresee which types will need to be specialized in the subclasses).</p>
<p>WHATSON? b3c7728b-74e2-4ad8-9666-bc0d6d71b7fd</p>
<pre class="de1">
    <span class="kw1">class</span> Shelter<span class="sy0">&lt;</span>T <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span> <span class="br0">{</span>
        T getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
 
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>T animal<span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
    <span class="br0">}</span>
 
 
    <span class="kw1">class</span> CatShelter <span class="kw1">extends</span> Shelter<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span> <span class="br0">{</span>
        Cat getAnimalForAdoption<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
 
        <span class="kw4">void</span> putAnimal<span class="br0">(</span>Cat animal<span class="br0">)</span> <span class="br0">{</span>
          ...
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Similarly, in recent versions of Java the <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span> interface has been parameterized, which allows the downcast to be omitted in a type-safe way:</p>
<p>WHATSON? 1fba925f-33b4-46ab-9d38-a6410845e669</p>
<pre class="de1">
    <span class="kw1">class</span> RationalNumber <span class="kw1">implements</span> Comparable<span class="sy0">&lt;</span>RationalNumber<span class="sy0">&gt;</span> <span class="br0">{</span>
        <span class="kw4">int</span> numerator<span class="sy0">;</span>
        <span class="kw4">int</span> denominator<span class="sy0">;</span>
 
        ...
 
        <span class="kw1">public</span> <span class="kw4">int</span> compareTo<span class="br0">(</span>RationalNumber otherNum<span class="br0">)</span> <span class="br0">{</span>
            <span class="kw1">return</span> <span class="kw3">Integer</span>.<span class="me1">compare</span><span class="br0">(</span>numerator<span class="sy0">*</span>otherNum.<span class="me1">denominator</span>, 
                                   otherNum.<span class="me1">numerator</span><span class="sy0">*</span>denominator<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
</pre>
<p>Another language feature that can help is <b>multiple dispatch</b>. One reason that binary methods are awkward to write is that in a call like <span class="mw-geshi java source-java">a.<span class="me1">compareTo</span><span class="br0">(</span>b<span class="br0">)</span></span>, selecting the correct implementation of <span class="mw-geshi java source-java">compareTo</span> really depends on the type of both <span class="mw-geshi java source-java">a</span> and <span class="mw-geshi java source-java">b</span>, but in a conventional OO language only the type of <span class="mw-geshi java source-java">a</span> is taken into account. In a language with <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">CLOS</a>-style <a href="/wiki/Multiple_dispatch" title="Multiple dispatch">multiple dispatch</a>, the comparison method could be written as a generic function where both arguments are used for method selection.</p>
<p>Giuseppe Castagna<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> observed that in a typed language with multiple dispatch, a generic function can have some arguments which control dispatch and some "left-over" arguments which do not. Because the method selection rule chooses the most specific applicable method, if a method overrides another method, then the overriding method will have more specific types for the controlling arguments. On the other hand, to ensure type safety the language still must require the left-over arguments to be at least as general. Using the previous terminology, types used for runtime method selection are covariant while types not used for runtime method selection of the method are contravariant. Conventional single-dispatch languages like Java also obey this rule: there only one argument is used for method selection (the receiver object, passed along to a method as the hidden argument <span class="mw-geshi java source-java"><span class="kw1">this</span></span>), and indeed the type of <span class="mw-geshi java source-java"><span class="kw1">this</span></span> is more specialized inside overriding methods than in the superclass.</p>
<p>Castagna suggests that examples where you want covariant argument types, in particular binary methods, should be handled using multiple dispatch which is naturally covariant. Unfortunately, most programming languages do not support multiple dispatch.</p>
<h3><span class="mw-headline" id="Summary_of_variance_and_inheritance">Summary of variance and inheritance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: Summary of variance and inheritance">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following table summarizes the rules for overriding methods in the languages discussed above.</p>
<h2><span class="mw-headline" id="Generic_types">Generic types</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: Generic types">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In programming languages that support generics (a.k.a. <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>), the programmer can extend the type system with new constructors. For example, a C# interface like <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> makes it possible to construct new types like <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span> or <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span>. The question then arises what the variance of these type constructors should be.</p>
<p>There are two main approaches. In languages with <b>declaration-site variance annotations</b> (e.g. <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>), the programmer annotates the definition of a generic type with the intended variance of its type parameters. With <b>use-site variance annotations</b> (e.g. <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>), the programmer instead annotates the places where a generic type is instantiated.</p>
<h3><span class="mw-headline" id="Declaration-site_variance_annotations">Declaration-site variance annotations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Declaration-site variance annotations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The most popular languages with declaration-site variance annotations are <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a> (using the keywords <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> and <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>), and <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> and <a href="/wiki/OCaml" title="OCaml">OCaml</a> (using the keywords <span class="mw-geshi ocaml source-ocaml"><span class="sy0">+</span></span> and <span class="mw-geshi ocaml source-ocaml"><span class="sy0">-</span></span>). C# only allows variance annotations for interface types, while Scala and OCaml allows them for both interface types and concrete data types.</p>
<h4><span class="mw-headline" id="Interfaces">Interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In C#, each type parameter of a generic interface can be marked covariant (<span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span>), contravariant (<span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>), or invariant (no annotation). For example, we can define an interface <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> of read-only iterators, and declare it to be covariant (out) in its type parameter.</p>
<p>WHATSON? 40745d31-bfc2-4d17-b627-38a8eb9e183a</p>
<pre class="de1">
    <span class="kw4">interface</span> IEnumerator<span class="sy0">&lt;</span><span class="kw1">out</span> T<span class="sy0">&gt;</span>
    <span class="br0">{</span>
        T Current <span class="br0">{</span> <span class="kw1">get</span><span class="sy0">;</span> <span class="br0">}</span>
        <span class="kw4">bool</span> MoveNext<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
</pre>
<p>With this declaration, <span class="mw-geshi csharp source-csharp">IEnumerator</span> will be treated as covariant in its type argument, e.g. <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span>.</p>
<p>The typechecker enforces that each method declaration in an interface only mentions the type parameters in a way consistent with the <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>/<span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> annotations. That is, a parameter that was declared covariant must not occur in any contravariant positions (where a position is contravariant if it occurs under an odd number of contravariant type constructors). The precise rule<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup><sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup> is that the return types of all methods in the interface must be <i>valid covariantly</i> and all the method argument types must be <i>valid contravariantly</i>, where <i>valid S-ly</i> is defined as follows:</p>
<ul>
<li>Non-generic types (classes, structs, enums, etc.) are valid both co- and contravariantly.</li>
<li>A type argument <span class="mw-geshi csharp source-csharp">T</span> is valid covariantly if it was not marked <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>, and valid contravariantly if it was not marked <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span></li>
<li>An array type <span class="mw-geshi csharp source-csharp">A<span class="br0">[</span><span class="br0">]</span></span> is valid S-ly if <span class="mw-geshi csharp source-csharp">A</span> is. (This is because C# has covariant arrays).</li>
<li>A generic type <span class="mw-geshi csharp source-csharp">G<span class="sy0">&lt;</span>A1,A2,<span class="sy0">...</span>,An<span class="sy0">&gt;</span></span> is valid S-ly if for each argument <span class="mw-geshi csharp source-csharp">Ai</span>,
<ul>
<li>Ai is valid S-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared invariant.</li>
</ul>
</li>
</ul>
<ul>
<li>Ai is valid S-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <i>i</i>th parameter to <span class="mw-geshi csharp source-csharp">G</span> is declared invariant.</li>
</ul>
<p>As an example of how these rules apply, consider the <span class="mw-geshi csharp source-csharp">IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> interface.</p>
<p>WHATSON? a5d3373e-49e4-464a-a098-a5475ec04153</p>
<pre class="de1">
    <span class="kw4">interface</span> IList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
    <span class="br0">{</span>
	<span class="kw4">void</span> Insert<span class="br0">(</span><span class="kw4">int</span> index, T item<span class="br0">)</span><span class="sy0">;</span>
	IEnumerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> GetEnumerator<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
</pre>
<p>The argument type <span class="mw-geshi csharp source-csharp">T</span> of <span class="mw-geshi csharp source-csharp">Insert</span> must be valid contravariantly, i.e. the type parameter <span class="mw-geshi csharp source-csharp">T</span> must not be tagged <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span>. Similarly, the result type <span class="mw-geshi csharp source-csharp">IEnumerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> of <span class="mw-geshi csharp source-csharp">GetEnumerator</span> must be valid covariantly, i.e. (since <span class="mw-geshi csharp source-csharp">IEnumerator</span> is a covariant interface) the type <span class="mw-geshi csharp source-csharp">T</span> must be valid covariantly, i.e. the type parameter <span class="mw-geshi csharp source-csharp">T</span> must not be tagged <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span>. This shows that the interface <span class="mw-geshi csharp source-csharp">IList</span> is not allowed to be marked either co- or contravariant.</p>
<p>In the common case of a generic data structure such as <span class="mw-geshi csharp source-csharp">IList</span>, these restrictions mean that an <span class="mw-geshi csharp source-csharp"><span class="kw1">out</span></span> parameter can only be used for methods getting data out of the structure, and an <span class="mw-geshi csharp source-csharp"><span class="kw1">in</span></span> parameter can only be used for methods putting data into the structure, hence the choice of keywords.</p>
<h4><span class="mw-headline" id="Data">Data</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Data">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>C# allows variance annotations on the parameters of interfaces, but not the parameters of classes. Because fields in C# classes are always mutable, variantly parameterized classes in C# would not be very useful. But languages which emphasize immutable data can make good use of covariant data types. For example, both in <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> and <a href="/wiki/OCaml" title="OCaml">OCaml</a> the immutable list type is covariant: <span class="mw-geshi scala source-scala">List<span class="br0">[</span>Cat<span class="br0">]</span></span> is a subtype of <span class="mw-geshi scala source-scala">List<span class="br0">[</span>Animal<span class="br0">]</span></span>.</p>
<p>Scala's rules for checking variance annotations are essentially the same as C#'s. However, there are some idioms that apply to immutable datastructures in particular. They are illustrated by the following (excerpt from the) definition of the <span class="mw-geshi scala source-scala">List<span class="br0">[</span>A<span class="br0">]</span></span> class.</p>
<p>WHATSON? d902a0be-5d9c-45da-b920-d3cfd807b1b7</p>
<pre class="de1">
<span class="kw1">sealed</span> <span class="kw1">abstract</span> <span class="kw1">class</span> List<span class="br0">[</span>+A<span class="br0">]</span> <span class="kw1">extends</span> AbstractSeq<span class="br0">[</span>A<span class="br0">]</span> <span class="br0">{</span>
  <span class="kw1">def</span> head<span class="sy0">:</span> A
  <span class="kw1">def</span> tail<span class="sy0">:</span> List<span class="br0">[</span>A<span class="br0">]</span>
 
  <span class="coMULTI">/** Adds an element at the beginning of this list. */</span>
  <span class="kw1">def</span> <span class="sy0">::</span><span class="br0">[</span>B <span class="sy0">&gt;:</span> A<span class="br0">]</span> <span class="br0">(</span>x<span class="sy0">:</span> B<span class="br0">)</span><span class="sy0">:</span> List<span class="br0">[</span>B<span class="br0">]</span> <span class="sy0">=</span>
    <span class="kw1">new</span> scala.<span class="me1">collection</span>.<span class="me1">immutable</span>.<span class="sy0">::</span><span class="br0">(</span>x, <span class="kw1">this</span><span class="br0">)</span>
 
  ...
<span class="br0">}</span>
</pre>
<p>First, class members that have a variant type must be immutable. Here, <span class="mw-geshi scala source-scala">head</span> has the type <span class="mw-geshi scala source-scala">A</span>, which was declared covariant (<span class="mw-geshi scala source-scala">+</span>), and indeed <span class="mw-geshi scala source-scala">head</span> was declared as a method (<span class="mw-geshi scala source-scala"><span class="kw1">def</span></span>). Trying to declare it as a mutable field (<span class="mw-geshi scala source-scala"><span class="kw1">var</span></span>) would be rejected as type error.</p>
<p>Second, even if a data structure is immutable, it will often have methods where the parameter type occurs contravariantly. For example, consider the method <span class="mw-geshi scala source-scala"><span class="sy0">::</span></span> which adds an element to the front of a list. (The implementation works by creating a new object of the similarly-named <i>class</i> <span class="mw-geshi scala source-scala"><span class="sy0">::</span></span>, the class of nonempty lists). The most obvious type to give it would be</p>
<p>WHATSON? 69741da0-9de6-4f18-aaf1-4d9127d453bc</p>
<pre class="de1">
  <span class="kw1">def</span> <span class="sy0">::</span> <span class="br0">(</span>x<span class="sy0">:</span> A<span class="br0">)</span><span class="sy0">:</span> List<span class="br0">[</span>A<span class="br0">]</span>
</pre>
<p>However, this would be a type error, because the covariant parameter <span class="mw-geshi scala source-scala">A</span> appears in a contravariant position (as a function argument). But there is a trick to get around this problem. We give <span class="mw-geshi scala source-scala"><span class="sy0">::</span></span> a more general type, which allows adding an element of any type <span class="mw-geshi scala source-scala">B</span> as long as <span class="mw-geshi scala source-scala">B</span> is a supertype of <span class="mw-geshi scala source-scala">A</span>. Note that this relies on <span class="mw-geshi scala source-scala">List</span> being covariant, since <span class="mw-geshi scala source-scala"><span class="kw1">this</span></span> has type <span class="mw-geshi scala source-scala">List<span class="br0">[</span>A<span class="br0">]</span></span> and we treat it as having type <span class="mw-geshi scala source-scala">List<span class="br0">[</span>B<span class="br0">]</span></span>. At first glance it may not be obvious that the generalized type is sound, but if the programmer starts out with the simpler type declaration, the type errors will point out the place that needs to be generalized.</p>
<h4><span class="mw-headline" id="Inferring_Variance">Inferring Variance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=15" title="Edit section: Inferring Variance">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>It is possible to design a type system where the compiler automatically infers the best possible variance annotations for all datatype parameters.<sup id="cite_ref-tamingCombining_10-0" class="reference"><a href="#cite_note-tamingCombining-10"><span>[</span>10<span>]</span></a></sup> However, the analysis can get complex for several reasons. First, the analysis is nonlocal since the variance of an interface <span class="mw-geshi java source-java">I</span> depends the variance of all interfaces that <span class="mw-geshi java source-java">I</span> mentions. Second, in order to get unique best solutions the type system must allow <i>bivariant</i> parameters (which are simultaneously co- and contravariant). And finally, the variance of type parameters should arguably be a deliberate choice by the designer of an interface, not something that just happens.</p>
<p>For these reasons<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> most languages do very little variance inference. C# and Scala do not infer any variance annotations at all. OCaml can infer the variance of parameterized concrete datatypes, but the programmer must explicitly specify the variance of abstract types (interfaces).</p>
<p>For example, consider an OCaml datatype <span class="mw-geshi ocaml source-ocaml">T</span> which wraps a function</p>
<p>WHATSON? 9228a11a-61af-495c-a74b-087c1e16eba7</p>
<pre class="de1">
<span class="kw1">type</span> <span class="br0">(</span><span class="sy0">'</span>a, <span class="sy0">'</span>b<span class="br0">)</span> t <span class="sy0">=</span> T <span class="kw1">of</span> <span class="br0">(</span><span class="sy0">'</span>a <span class="sy0">-&gt;</span> <span class="sy0">'</span>b<span class="br0">)</span>
</pre>
<p>The compiler will automatically infer that <span class="mw-geshi ocaml source-ocaml">T</span> is contravariant in the first parameter, and covariant in the second. The programmer can also provide explicit annotations, which the compiler will check are satisfied. Thus the following declaration is equivalent to the previous one:</p>
<p>WHATSON? b9c6146e-3566-4f89-b000-a8f8228c8a10</p>
<pre class="de1">
<span class="kw1">type</span> <span class="br0">(</span><span class="sy0">-'</span>a, <span class="sy0">+'</span>b<span class="br0">)</span> t <span class="sy0">=</span> T <span class="kw1">of</span> <span class="br0">(</span><span class="sy0">'</span>a <span class="sy0">-&gt;</span> <span class="sy0">'</span>b<span class="br0">)</span>
</pre>
<p>Explicit annotations in OCaml become useful when specifying interfaces. For example, the standard library interface <span class="mw-geshi ocaml source-ocaml"><span class="kw2">Map</span><span class="sy0">.</span>S</span> for association tables include an annotation saying that the map type constructor is covariant in the result type.</p>
<p>WHATSON? a552c5ea-2dd3-4173-9278-0243ae173afa</p>
<pre class="de1">
<span class="kw1">module</span> <span class="kw1">type</span> S <span class="sy0">=</span>
  <span class="kw1">sig</span>
    <span class="kw1">type</span> key
    <span class="kw1">type</span> <span class="br0">(</span><span class="sy0">+'</span>a<span class="br0">)</span> t
    <span class="kw1">val</span> empty<span class="sy0">:</span> <span class="sy0">'</span>a t
    <span class="kw1">val</span> mem<span class="sy0">:</span> key <span class="sy0">-&gt;</span> <span class="sy0">'</span>a t <span class="sy0">-&gt;</span> <span class="kw4">bool</span>
    <span class="sy0">...</span>
  <span class="kw1">end</span>
</pre>
<p>This ensures that e.g. <span class="mw-geshi ocaml source-ocaml">IntMap<span class="sy0">.</span>t cat</span> is a subtype of <span class="mw-geshi ocaml source-ocaml">IntMap<span class="sy0">.</span>t animal</span>.</p>
<h3><span class="mw-headline" id="Use-site_variance_annotations_.28Wildcards.29">Use-site variance annotations (Wildcards)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=16" title="Edit section: Use-site variance annotations (Wildcards)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>One drawback of the declaration-site approach is that many interface types must be made invariant. For example, we saw above that <span class="mw-geshi csharp source-csharp">IList</span> needed to be invariant, because it contained both <span class="mw-geshi csharp source-csharp">Insert</span> and <span class="mw-geshi csharp source-csharp">GetEnumerator</span>. In order to expose more variance, the API designer could provide additional interfaces which provide subsets of the available methods (e.g. an "insert-only list" which only provides <span class="mw-geshi csharp source-csharp">Insert</span>). However this quickly becomes unwieldy.</p>
<p>Use-site variance annotations aim to give users of a class more opportunities for subtyping without requiring the designer of the class to define multiple interfaces with different variance. Instead, each time a class or interface is used in a type declaration, the programmer can indicate that only a subset of the methods will be used. In effect, each definition of a class also makes available interfaces for the covariant and contravariant "parts" of that class. Therefore the designer of the class no longer needs to take variance into account, increasing re-usability.</p>
<p>Java provides use-site variance annotations through <a href="/wiki/Wildcard_(Java)" title="Wildcard (Java)">wildcards</a>, a restricted form of <a href="/wiki/Bounded_quantification" title="Bounded quantification">bounded</a> <a href="/wiki/Existential_type" title="Existential type" class="mw-redirect">existential types</a>. A parameterized type can be instantiated by a wildcard <span class="mw-geshi java source-java"><span class="sy0">?</span></span> together with an upper or lower bound, e.g. <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span> or <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">super</span> Animal<span class="sy0">&gt;</span></span>. (A an unbounded wildcard like <span class="mw-geshi java source-java">List<span class="sy0">&lt;?&gt;</span></span> is equivalent to <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Object<span class="sy0">&gt;</span></span>). Such a type represents <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>X<span class="sy0">&gt;</span></span> for some unknown type <span class="mw-geshi java source-java">X</span> which satisfies the bound. For example, if <span class="mw-geshi java source-java">l</span> has type <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>, then the typechecker will accept</p>
<p>WHATSON? d5fd1826-4515-492e-ab94-a1dc003b7bce</p>
<pre class="de1">
    Animal a <span class="sy0">=</span> l.<span class="me1">get</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>because the type <span class="mw-geshi java source-java">X</span> is known to be a subtype of <span class="mw-geshi java source-java">Animal</span>, but</p>
<p>WHATSON? 3c815e4f-b8ba-44fe-bd2f-c77a838d5cab</p>
<pre class="de1">
    l.<span class="me1">add</span><span class="br0">(</span><span class="kw1">new</span> Animal<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>will be rejected as a type error since an <span class="mw-geshi java source-java">Animal</span> is not necessarily an <span class="mw-geshi java source-java">X</span>. In general, given some interface <span class="mw-geshi java source-java">I<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>, a reference to a <span class="mw-geshi java source-java">I<span class="sy0">&lt;?</span> <span class="kw1">extends</span> A<span class="sy0">&gt;</span></span> forbids using methods from the interface where <span class="mw-geshi java source-java">T</span> occurs contravariantly in the type of the method. Conversely, if <span class="mw-geshi java source-java">l</span> had type <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">super</span> Animal<span class="sy0">&gt;</span></span> one could call <span class="mw-geshi java source-java">l.<span class="me1">add</span></span> but not <span class="mw-geshi java source-java">l.<span class="me1">get</span></span>.</p>
<p>While plain generic types in Java are invariant (e.g. there is no subtyping relationship between <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> and <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span></span>), wildcard types can be made more specific by specifying a tighter bound, for example <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Cat<span class="sy0">&gt;</span></span> is a subtype of <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>. This shows that wildcard types are <b>covariant in their upper bounds</b> (and also <b>contravariant in their lower bounds</b>). In total, given a wildcard type like <span class="mw-geshi java source-java">C<span class="sy0">&lt;?</span> <span class="kw1">extends</span> T<span class="sy0">&gt;</span></span>, there are three ways to form a subtype: by specializing the class <span class="mw-geshi java source-java">C</span>, by specifying a tighter bound <span class="mw-geshi java source-java">T</span>, or by replacing the wildcard <span class="mw-geshi java source-java"><span class="sy0">?</span></span> by a specific type (see figure).</p>
<p>By combining two steps of subtyping, it is therefore possible to e.g. pass an argument of type <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span></span> to a method expecting a <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>. This is exactly the kind of programs that covariant interface types allow. The type <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span> acts as an interface type containing only the covariant methods of <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span>, but the implementer of <span class="mw-geshi java source-java">List<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span></span> did not have to define it ahead of time. This is use-site variance.</p>
<p>In the common case of a generic data structure <span class="mw-geshi csharp source-csharp">IList</span>, covariant parameters are used for methods getting data out of the structure, and contravariant parameters for methods putting data into the structure. The mnemonics PECS (Producer Extends, Consumer Super) from the book <b>Effective Java</b> by <a href="/wiki/Joshua_Bloch" title="Joshua Bloch">Joshua Bloch</a> gives an easy way to remember when to use covariance and contravariance.</p>
<p>Wildcards are flexible, but there is a drawback. While use-site variance means that API designers need not consider variance of type parameters to interfaces, they must often instead use more complicated method signatures. A common example involves the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a></code> interface. Suppose we want to write a function that finds the biggest element in a collection. The elements need to implement the <span class="mw-geshi java source-java">compareTo</span> method, so a first try might be</p>
<p>WHATSON? a9b16e30-2cbe-4b34-852e-e12e6076ceef</p>
<pre class="de1">
    <span class="sy0">&lt;</span>T <span class="kw1">extends</span> Comparable<span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span>  T max<span class="br0">(</span>Collection<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> coll<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>However, this type is not general enough—one can find the max of a <span class="mw-geshi java source-java">Collection<span class="sy0">&lt;</span>Calendar<span class="sy0">&gt;</span></span>, but not a <span class="mw-geshi java source-java">Collection<span class="sy0">&lt;</span>GregorianCalendar<span class="sy0">&gt;</span></span>. The problem is that <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/GregorianCalendar.html">GregorianCalendar</a></code> does not implement <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>GregorianCalendar<span class="sy0">&gt;</span></span>, but instead the (better) interface <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>Calendar<span class="sy0">&gt;</span></span>. In Java, unlike in C#, <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>Calendar<span class="sy0">&gt;</span></span> is not considered a subtype of <span class="mw-geshi java source-java">Comparable<span class="sy0">&lt;</span>GregorianCalendar<span class="sy0">&gt;</span></span>. Instead the type of <span class="mw-geshi java source-java">max</span> has to be modified:</p>
<p>WHATSON? 3efdf8f2-8dbc-479a-95b0-b5c09a19b85b</p>
<pre class="de1">
    <span class="sy0">&lt;</span>T <span class="kw1">extends</span> Comparable<span class="sy0">&lt;?</span> <span class="kw1">super</span> T<span class="sy0">&gt;&gt;</span>  T max<span class="br0">(</span>Collection<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> coll<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The bounded wildcard <span class="mw-geshi java source-java"><span class="sy0">?</span> <span class="kw1">super</span> T</span> conveys the information that <span class="mw-geshi java source-java">max</span> calls only contravariant methods from the <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span> interface. This particular example is frustrating because <i>all</i> the methods in <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span> are contravariant, so that condition is trivially true. A declaration-site system could handle this example with less clutter by annotating only the definition of <span class="mw-geshi java source-java"><span class="kw3">Comparable</span></span>.</p>
<h3><span class="mw-headline" id="Comparing_Declaration-site_and_Use-site_annotations">Comparing Declaration-site and Use-site annotations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=17" title="Edit section: Comparing Declaration-site and Use-site annotations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Use-site variance annotations provide additional flexibility, allowing more programs to type-check. However, they have been criticized for the complexity they add to the language, leading to complicated type signatures and error messages.</p>
<p>One way to assess whether the extra flexibility is useful is to see if it is used in existing programs. A survey of a large set of Java libraries<sup id="cite_ref-tamingCombining_10-1" class="reference"><a href="#cite_note-tamingCombining-10"><span>[</span>10<span>]</span></a></sup> found that 39% of wildcard annotations could have been directly replaced by a declaration-site annotations. Thus the remaining 61% is an indication on places where Java benefits from having the use-site system available.</p>
<p>In a declaration-site language, libraries must either expose less variance, or define more interfaces. For example, the Scala Collections library defines three separate interfaces for classes which employ covariance: a covariant base interface containing common methods, an invariant mutable version which adds side-effecting methods, and a covariant immutable version which may specialize the inherited implementations to exploit structural sharing.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup> This design works well with declaration-site annotations, but the large number of interfaces carry a complexity cost for clients of the library. And modifying the library interface may not be an option—in particular, one goal when adding generics to Java was to maintain binary backwards compatibility.</p>
<p>On the other hand, Java wildcards are themselves complex. In a conference presentation<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>13<span>]</span></a></sup> <a href="/wiki/Joshua_Bloch" title="Joshua Bloch">Joshua Bloch</a> criticized them as being too hard to understand and use, stating that when adding support for <a href="/wiki/Closure_(computer_science)" title="Closure (computer science)" class="mw-redirect">closures</a> "we simply cannot afford another <i>wildcards</i>". Early versions of Scala used use-site variance annotations but programmers found them difficult to use in practice, while declaration-site annotations were found to be very helpful when designing classes.<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>14<span>]</span></a></sup> Later versions of Scala added Java-style existential types and wildcards; however, according to <a href="/wiki/Martin_Odersky" title="Martin Odersky">Martin Odersky</a>, if there were no need for interoperability with Java then these would probably not have been included.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>15<span>]</span></a></sup></p>
<p>Ross Tate argues<sup id="cite_ref-MixedSiteVariance_16-0" class="reference"><a href="#cite_note-MixedSiteVariance-16"><span>[</span>16<span>]</span></a></sup> that part of the complexity of Java wildcards is due to the decision to encode use-site variance using a form of existential types. The original proposals<sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>17<span>]</span></a></sup> <sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>18<span>]</span></a></sup> used special-purpose syntax for variance annotations, writing <span class="mw-geshi java source-java">List<span class="sy0">&lt;+</span>Animal<span class="sy0">&gt;</span></span> instead of Java's more verbose <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span>.</p>
<p>Since wildcards are a form of existential types they can be used for more things than just variance. A type like <span class="mw-geshi java source-java">List<span class="sy0">&lt;?&gt;</span></span> ("some type of list") lets objects be passed to methods or stored in fields without exactly specifying their type parameters. This is particularly valuable for classes such as <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">Class</a></code> where most of the methods do not mention the type parameter.</p>
<p>However, type inference for existential types is a difficult problem. For the compiler implementer, Java wildcards raise issues with type checker termination, type argument inference, and ambiguous programs.<sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span>[</span>19<span>]</span></a></sup> For the programmer, it leads to complicated type error messages. Java typechecks wildcard types by replacing the wildcards with fresh type variables (so-called <i>capture conversion</i>). This can make error messages harder to read, because they refer to type variables that the programmer did not directly write. For example, trying to add a <span class="mw-geshi java source-java">Cat</span> to a <span class="mw-geshi java source-java">List<span class="sy0">&lt;?</span> <span class="kw1">extends</span> Animal<span class="sy0">&gt;</span></span> will give an error like</p>
<p>WHATSON? a00af9ad-d22a-42c5-a630-9ebc7f2d3c30</p>
<pre>
method List.add(capture#1) is not applicable
  (actual argument Cat cannot be converted to capture#1 by method invocation conversion)
where capture#1 is a fresh type-variable:
  capture#1 extends Animal from capture of ? extends Animal
</pre>
<p>Since both declaration-site and use-site annotations can be useful, some type system provide both.<sup id="cite_ref-tamingCombining_10-2" class="reference"><a href="#cite_note-tamingCombining-10"><span>[</span>10<span>]</span></a></sup><sup id="cite_ref-MixedSiteVariance_16-1" class="reference"><a href="#cite_note-MixedSiteVariance-16"><span>[</span>16<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Covariant_generics_in_Dart">Covariant generics in Dart</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=18" title="Edit section: Covariant generics in Dart">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The <a href="/wiki/Dart_(programming_language)" title="Dart (programming language)">Dart</a> programming language does not track variance, and instead treats all parameterized types as covariant. The language specification<sup id="cite_ref-20" class="reference"><a href="#cite_note-20"><span>[</span>20<span>]</span></a></sup> states</p>
<p>The type system is unsound, due to the covariance of generic types. This is a deliberate choice (and undoubtedly controversial). Experience has shown that sound type rules for generics fly in the face of programmer intuition. It is easy for tools to provide a sound type analysis if they choose, which may be useful for tasks like refactoring.</p>
<h2><span class="mw-headline" id="Origin_of_the_term_.22covariance.22">Origin of the term "covariance"</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=19" title='Edit section: Origin of the term "covariance"'>edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>These terms come from the notion of <a href="/wiki/Covariance_and_contravariance_of_functors" title="Covariance and contravariance of functors" class="mw-redirect">covariant and contravariant functors</a> in <a href="/wiki/Category_theory" title="Category theory">category theory</a>. Consider the category <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> whose objects are types and whose morphisms represent the subtype relationship ≤. (This is an example of how any partially ordered set can be considered as a category). Then for example the function type constructor takes two types <i>p</i> and <i>r</i> and creates a new type <i>p</i> → <i>r</i>; so it takes objects in <img class="mwe-math-fallback-image-inline tex" alt="C^2" src="//upload.wikimedia.org/math/2/6/0/260dd56bacf8c0c3908fa94f84298d12.png"> to objects in <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">. By the subtyping rule for function types this operation reverses ≤ for the first argument and preserves it for the second, so it is a contravariant functor in the first argument and a covariant functor in the second.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=20" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">Polymorphism (computer science)</a></li>
<li><a href="/wiki/Inheritance_(computer_science)" title="Inheritance (computer science)" class="mw-redirect">Inheritance (computer science)</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=21" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation conference">John C. Reynolds (1981). <a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/~crary/819-f09/Reynolds81.ps">"The Essence of Algol"</a>. Symposium on Algorithmic Languages. North-Holland.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=John+C.+Reynolds&amp;rft.aulast=John+C.+Reynolds&amp;rft.btitle=The+Essence+of+Algol&amp;rft.date=1981&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.cmu.edu%2F~crary%2F819-f09%2FReynolds81.ps&amp;rft.pub=North-Holland&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation conference">Luca Cardelli (1984). <a rel="nofollow" class="external text" href="http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf">"A semantics of multiple inheritance"</a>. Semantics of Data Types (International Symposium Sophia-Antipolis, France, June 27 – 29, 1984). Lecture Notes in Computer Science <b>173</b>. Springer. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F3-540-13346-1_2">10.1007/3-540-13346-1_2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.aulast=Luca+Cardelli&amp;rft.au=Luca+Cardelli&amp;rft.btitle=A+semantics+of+multiple+inheritance&amp;rft.date=1984&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Flucacardelli.name%2FPapers%2FInheritance%2520%28Semantics%2520of%2520Data%2520Types%29.pdf&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-13346-1_2&amp;rft.pub=Springer&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=173" class="Z3988"><span style="display:none;"> </span></span>(Longer version in Information and Computation, 76(2/3): 138-164, February 1988.)</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation news">Allison, Chuck. <a rel="nofollow" class="external text" href="http://www.drdobbs.com/184403580">"What's New in Standard C++?"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Allison%2C+Chuck&amp;rft.aufirst=Chuck&amp;rft.aulast=Allison&amp;rft.btitle=What%27s+New+in+Standard+C%2B%2B%3F&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.drdobbs.com%2F184403580&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation conference">Bertrand Meyer (October 1995). <a rel="nofollow" class="external text" href="http://se.ethz.ch/~meyer/publications/acm/typing.pdf">"Static Typing"</a>. "OOPSLA 95 (Object-Oriented Programming, Systems, Languages and Applications), Atlanta, 1995.".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=OOPSLA+95+%28Object-Oriented+Programming%2C+Systems%2C+Languages+and+Applications%29%2C+Atlanta%2C+1995.&amp;rft.au=Bertrand+Meyer&amp;rft.aulast=Bertrand+Meyer&amp;rft.btitle=Static+Typing&amp;rft.date=October+1995&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fse.ethz.ch%2F~meyer%2Fpublications%2Facm%2Ftyping.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-competentCompilers-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-competentCompilers_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-competentCompilers_5-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Howard, Mark; Bezault, Eric; Meyer, Bertrand; Colnet, Dominique; Stapf, Emmanuel; Arnout, Karine; Keller, Markus (April 2003). <a rel="nofollow" class="external text" href="http://se.ethz.ch/~meyer/ongoing/covariance/recast.pdf">"Type-safe covariance: Competent compilers can catch all catcalls"</a><span class="reference-accessdate">. Retrieved 23 May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Arnout%2C+Karine&amp;rft.au=Bezault%2C+Eric&amp;rft.au=Colnet%2C+Dominique&amp;rft.aufirst=Mark&amp;rft.au=Howard%2C+Mark&amp;rft.au=Keller%2C+Markus&amp;rft.aulast=Howard&amp;rft.au=Meyer%2C+Bertrand&amp;rft.au=Stapf%2C+Emmanuel&amp;rft.btitle=Type-safe+covariance%3A+Competent+compilers+can+catch+all+catcalls&amp;rft.date=April+2003&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fse.ethz.ch%2F~meyer%2Fongoing%2Fcovariance%2Frecast.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation conference">Franz Weber (1992). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.7872">"Getting Class Correctness and System Correctness Equivalent - How to Get Covariance Right"</a>. "TOOLS 8 (8th conference on Technology of Object-Oriented Languages and Systems), Dortmund, 1992".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=TOOLS+8+%288th+conference+on+Technology+of+Object-Oriented+Languages+and+Systems%29%2C+Dortmund%2C+1992&amp;rft.au=Franz+Weber&amp;rft.aulast=Franz+Weber&amp;rft.btitle=Getting+Class+Correctness+and+System+Correctness+Equivalent+-+How+to+Get+Covariance+Right&amp;rft.date=1992&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.52.7872&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">Giuseppe Castagna, <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=203096&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">Covariance and contravariance: conflict without a cause</a>, ACM Transactions on Programming Languages and Systems (TOPLAS), Volume 17, Issue 3, May 1995, pages 431-447.</span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web">Eric Lippert (3 December 2009). <a rel="nofollow" class="external text" href="http://blogs.msdn.com/b/ericlippert/archive/2009/12/03/exact-rules-for-variance-validity.aspx">"Exact rules for variance validity"</a><span class="reference-accessdate">. Retrieved July 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Eric+Lippert&amp;rft.aulast=Eric+Lippert&amp;rft.btitle=Exact+rules+for+variance+validity&amp;rft.date=3+December+2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fb%2Fericlippert%2Farchive%2F2009%2F12%2F03%2Fexact-rules-for-variance-validity.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text">Section II.9.7 in <cite>ECMA International Standard ECMA-335 Common Language Infrastructure (CLI) 6th edition (June 2012)</cite>; <a rel="nofollow" class="external text" href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">available online</a></span></li>
<li id="cite_note-tamingCombining-10"><span class="mw-cite-backlink">^ <a href="#cite_ref-tamingCombining_10-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-tamingCombining_10-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-tamingCombining_10-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">John Altidor; Huang Shan Shan; Yannis Smaragdakis (2011). <a rel="nofollow" class="external text" href="http://www.cs.umass.edu/~jaltidor/variance_pldi11.pdf">"Taming the wildcards: combining definition- and use-site variance"</a>. "Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation (PLDI'11)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+32nd+ACM+SIGPLAN+conference+on+Programming+language+design+and+implementation+%28PLDI%2711%29&amp;rft.au=Huang+Shan+Shan&amp;rft.au=John+Altidor&amp;rft.aulast=John+Altidor&amp;rft.au=Yannis+Smaragdakis&amp;rft.btitle=Taming+the+wildcards%3A+combining+definition-+and+use-site+variance&amp;rft.date=2011&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.umass.edu%2F~jaltidor%2Fvariance_pldi11.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation web">Eric Lippert (October 29, 2007). <a rel="nofollow" class="external text" href="http://blogs.msdn.com/ericlippert/archive/2007/10/29/covariance-and-contravariance-in-c-part-seven-why-do-we-need-a-syntax-at-all.aspx">"Covariance and Contravariance in C# Part Seven: Why Do We Need A Syntax At All?"</a><span class="reference-accessdate">. Retrieved October 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Eric+Lippert&amp;rft.aulast=Eric+Lippert&amp;rft.btitle=Covariance+and+Contravariance+in+C%23+Part+Seven%3A+Why+Do+We+Need+A+Syntax+At+All%3F&amp;rft.date=October+29%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fericlippert%2Farchive%2F2007%2F10%2F29%2Fcovariance-and-contravariance-in-c-part-seven-why-do-we-need-a-syntax-at-all.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation web">Marin Odersky; Lex Spoon (September 7, 2010). <a rel="nofollow" class="external text" href="http://www.scala-lang.org/docu/files/collections-api/collections.html">"The Scala 2.8 Collections API"</a><span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.aulast=Marin+Odersky&amp;rft.au=Lex+Spoon&amp;rft.au=Marin+Odersky&amp;rft.btitle=The+Scala+2.8+Collections+API&amp;rft.date=September+7%2C+2010&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.scala-lang.org%2Fdocu%2Ffiles%2Fcollections-api%2Fcollections.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web">Joshua Bloch (November 2007). <a rel="nofollow" class="external text" href="http://parleys.com/play/514892250364bc17fc56bb15/chapter0/about">"The Closures Controversy [video]"</a>. Presentation at Javapolis'07<span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Joshua+Bloch&amp;rft.aulast=Joshua+Bloch&amp;rft.btitle=The+Closures+Controversy+%5Bvideo%5D&amp;rft.date=November+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fparleys.com%2Fplay%2F514892250364bc17fc56bb15%2Fchapter0%2Fabout&amp;rft.place=Presentation+at+Javapolis%2707&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation conference">Martin Odersky; Matthias Zenger (2005). <a rel="nofollow" class="external text" href="http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf">"Scalable component abstractions"</a>. "Proceedings of the 20th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '05)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+20th+annual+ACM+SIGPLAN+conference+on+Object-oriented+programming%2C+systems%2C+languages%2C+and+applications+%28OOPSLA+%2705%29&amp;rft.aulast=Martin+Odersky&amp;rft.au=Martin+Odersky&amp;rft.au=Matthias+Zenger&amp;rft.btitle=Scalable+component+abstractions&amp;rft.date=2005&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Flampwww.epfl.ch%2F~odersky%2Fpapers%2FScalableComponent.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><span class="citation web">Bill Venners and Frank Sommers (May 18, 2009). <a rel="nofollow" class="external text" href="http://www.artima.com/scalazine/articles/scalas_type_system.html">"The Purpose of Scala's Type System: A Conversation with Martin Odersky, Part III"</a><span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.au=Bill+Venners+and+Frank+Sommers&amp;rft.aulast=Bill+Venners+and+Frank+Sommers&amp;rft.btitle=The+Purpose+of+Scala%27s+Type+System%3A+A+Conversation+with+Martin+Odersky%2C+Part+III&amp;rft.date=May+18%2C+2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.artima.com%2Fscalazine%2Farticles%2Fscalas_type_system.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-MixedSiteVariance-16"><span class="mw-cite-backlink">^ <a href="#cite_ref-MixedSiteVariance_16-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-MixedSiteVariance_16-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">Ross Tate (2013). <a rel="nofollow" class="external text" href="http://www.cs.cornell.edu/~ross/publications/mixedsite/index.html">"Mixed-Site Variance"</a>. "FOOL '13: Informal Proceedings of the 20th International Workshop on Foundations of Object-Oriented Languages".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=FOOL+%2713%3A+Informal+Proceedings+of+the+20th+International+Workshop+on+Foundations+of+Object-Oriented+Languages&amp;rft.aulast=Ross+Tate&amp;rft.au=Ross+Tate&amp;rft.btitle=Mixed-Site+Variance&amp;rft.date=2013&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.cornell.edu%2F~ross%2Fpublications%2Fmixedsite%2Findex.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><span class="citation conference">Atsushi Igarashi; Mirko Viroli (2002). <a rel="nofollow" class="external text" href="http://www.sato.kuis.kyoto-u.ac.jp/~igarashi/papers/pdf/variance.ecoop02.pdf">"On Variance-Based Subtyping for Parametric Types"</a>. "Proceedings of the 16th European Conference on Object-Oriented Programming (ECOOP '02)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+16th+European+Conference+on+Object-Oriented+Programming+%28ECOOP+%2702%29&amp;rft.au=Atsushi+Igarashi&amp;rft.aulast=Atsushi+Igarashi&amp;rft.au=Mirko+Viroli&amp;rft.btitle=On+Variance-Based+Subtyping+for+Parametric+Types&amp;rft.date=2002&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.sato.kuis.kyoto-u.ac.jp%2F~igarashi%2Fpapers%2Fpdf%2Fvariance.ecoop02.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text"><span class="citation conference">Kresten Krab Thorup; Mads Torgersen (1999). <a rel="nofollow" class="external text" href="http://www.daimi.au.dk/~madst/tool/papers/unifying.pdf">"Unifying Genericity: Combining the Benefits of Virtual Types and Parameterized Classes"</a>. "Object-Oriented Programming (ECOOP '99)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Object-Oriented+Programming+%28ECOOP+%2799%29&amp;rft.au=Kresten+Krab+Thorup&amp;rft.aulast=Kresten+Krab+Thorup&amp;rft.au=Mads+Torgersen&amp;rft.btitle=Unifying+Genericity%3A+Combining+the+Benefits+of+Virtual+Types+and+Parameterized+Classes&amp;rft.date=1999&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.daimi.au.dk%2F~madst%2Ftool%2Fpapers%2Funifying.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text"><span class="citation conference">Tate, Ross; Leung, Alan; Lerner, Sorin (2011). <a rel="nofollow" class="external text" href="http://www.cs.cornell.edu/~ross/publications/tamewild/">"Taming wildcards in Java's type system"</a>. "Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation (PLDI '11)".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.atitle=Proceedings+of+the+32nd+ACM+SIGPLAN+conference+on+Programming+language+design+and+implementation+%28PLDI+%2711%29&amp;rft.aufirst=Ross&amp;rft.aulast=Tate&amp;rft.au=Lerner%2C+Sorin&amp;rft.au=Leung%2C+Alan&amp;rft.au=Tate%2C+Ross&amp;rft.btitle=Taming+wildcards+in+Java%27s+type+system&amp;rft.date=2011&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.cornell.edu%2F~ross%2Fpublications%2Ftamewild%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-20"><span class="mw-cite-backlink"><b><a href="#cite_ref-20">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.dartlang.org/docs/spec/">"The Dart Programming Language Specification"</a>. May 6, 2013<span class="reference-accessdate">. Retrieved May 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACovariance+and+contravariance+%28computer+science%29&amp;rft.btitle=The+Dart+Programming+Language+Specification&amp;rft.date=May+6%2C+2013&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.dartlang.org%2Fdocs%2Fspec%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Covariance_and_contravariance_(computer_science)&amp;action=edit&amp;section=22" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://blogs.msdn.com/ericlippert/archive/tags/Covariance+and+Contravariance/default.aspx">Fabulous Adventures in Coding</a>: An article series about implementation concerns surrounding co/contravariance in C#</li>
<li><a rel="nofollow" class="external text" href="http://c2.com/cgi/wiki?ContraVsCoVariance">Contra Vs Co Variance</a> (note this article is not updated about C++)</li>
<li><a rel="nofollow" class="external text" href="http://www.javac.info/closures-v05.html">Closures for the Java 7 Programming Language (v0.5)</a></li>
</ul>
