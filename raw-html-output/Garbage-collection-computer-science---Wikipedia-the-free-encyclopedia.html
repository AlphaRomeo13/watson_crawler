<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Garbage collection (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>garbage collection</b> (<b>GC</b>) is a form of automatic <a href="/wiki/Memory_management" title="Memory management">memory management</a>. The <i>garbage collector</i>, or just <i>collector</i>, attempts to reclaim <i><a href="/wiki/Garbage_(computer_science)" title="Garbage (computer science)">garbage</a></i>, or memory occupied by <a href="/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> that are no longer in use by the <a href="/wiki/Application_software" title="Application software">program</a>. Garbage collection was invented by <a href="/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a> around 1959 to solve problems in <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p>Garbage collection is often portrayed as the opposite of <a href="/wiki/Manual_memory_management" title="Manual memory management">manual memory management</a>, which requires the programmer to specify which objects to deallocate and return to the memory system. However, many systems use a combination of approaches, including other techniques such as <a href="/wiki/Stack-based_memory_allocation" title="Stack-based memory allocation">stack allocation</a> and <a href="/wiki/Region_inference" title="Region inference" class="mw-redirect">region inference</a>. Like other memory management techniques, garbage collection may take a significant proportion of total processing time in a program and can thus have significant influence on performance.</p>
<p>Resources other than memory, such as <a href="/wiki/Network_socket" title="Network socket">network sockets</a>, database <a href="/wiki/Handle_(computing)" title="Handle (computing)">handles</a>, user interaction windows, and file and device descriptors, are not typically handled by garbage collection. Methods used to manage such resources, particularly <a href="/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructors</a>, may suffice to manage memory as well, leaving no need for GC. Some GC systems allow such other resources to be associated with a region of memory that, when collected, causes the other resource to be reclaimed; this is called <a href="/wiki/Finalizer" title="Finalizer"><i>finalization</i></a>. Finalization may introduce complications limiting its usability, such as intolerable latency between disuse and reclaim of especially limited resources, or a lack of control over which thread performs the work of reclaiming.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Principles"><span class="tocnumber">1</span> <span class="toctext">Principles</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Advantages"><span class="tocnumber">1.1</span> <span class="toctext">Advantages</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Disadvantages"><span class="tocnumber">1.2</span> <span class="toctext">Disadvantages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Tracing_garbage_collectors"><span class="tocnumber">2</span> <span class="toctext">Tracing garbage collectors</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Reference_counting"><span class="tocnumber">3</span> <span class="toctext">Reference counting</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Escape_analysis"><span class="tocnumber">4</span> <span class="toctext">Escape analysis</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Compile-time"><span class="tocnumber">5</span> <span class="toctext">Compile-time</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Availability"><span class="tocnumber">6</span> <span class="toctext">Availability</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Limited_environments"><span class="tocnumber">7</span> <span class="toctext">Limited environments</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Further_reading"><span class="tocnumber">10</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#External_links"><span class="tocnumber">11</span> <span class="toctext">External links</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Implementations"><span class="tocnumber">11.1</span> <span class="toctext">Implementations</span></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Advantages"><span class="tocnumber">1.1</span> <span class="toctext">Advantages</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Disadvantages"><span class="tocnumber">1.2</span> <span class="toctext">Disadvantages</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Implementations"><span class="tocnumber">11.1</span> <span class="toctext">Implementations</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Principles"><span id="GC-LANGUAGE"></span>Principles</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Principles">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The basic principles of garbage collection are:</p>
<ul>
<li>Find data objects in a program that cannot be accessed in the future.</li>
<li>Reclaim the resources used by those objects.</li>
</ul>
<p>Many <a href="/wiki/Programming_language" title="Programming language">programming languages</a> require garbage collection, either as part of the <a href="/wiki/Language_specification" title="Language specification" class="mw-redirect">language specification</a> (for example, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, <a href="/wiki/D_language" title="D language" class="mw-redirect">D language</a>,<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> <a href="/wiki/Go_(programming_language)" title="Go (programming language)">Go</a> and most <a href="/wiki/Scripting_language" title="Scripting language">scripting languages</a>) or effectively for practical implementation (for example, formal languages like <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>); these are said to be <i>garbage collected languages</i>. Other languages were designed for use with manual memory management, but have garbage collected implementations available (for example, <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>). Some languages, like <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, <a href="/wiki/Modula-3" title="Modula-3">Modula-3</a>, and <a href="/wiki/C%2B%2B/CLI" title="C++/CLI">C++/CLI</a> allow both garbage collection and <a href="/wiki/Manual_memory_management" title="Manual memory management">manual memory management</a> to co-exist in the same application by using separate <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heaps</a> for collected and manually managed objects; others, like <a href="/wiki/D_(programming_language)" title="D (programming language)">D</a>, are garbage collected but allow the user to manually delete objects and also entirely disable garbage collection when speed is required.</p>
<p>While integrating garbage collection into the language's <a href="/wiki/Compiler" title="Compiler">compiler</a> and <a href="/wiki/Run_time_system" title="Run time system" class="mw-redirect">runtime</a> system enables a much wider choice of methods,<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2007)">citation needed</span></a></i>]</sup> <i>post hoc</i> GC systems exist, including some that do not require recompilation. (<i>Post-hoc</i> GC is sometimes distinguished as <i>litter collection</i>.) The garbage collector will almost always be closely integrated with the <a href="/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation" class="mw-redirect">memory allocator</a>.</p>
<h3><span class="mw-headline" id="Advantages">Advantages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Advantages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Garbage collection frees the programmer from manually dealing with memory deallocation. As a result, certain categories of bugs are eliminated or substantially reduced:</p>
<ul>
<li><i><a href="/wiki/Dangling_pointer" title="Dangling pointer">Dangling pointer</a> bugs</i>, which occur when a piece of memory is freed while there are still pointers to it, and one of those pointers is dereferenced. By then the memory may have been reassigned to another use, with unpredictable results.</li>
<li><i>Double free bugs</i>, which occur when the program tries to free a region of memory that has already been freed, and perhaps already been allocated again.</li>
<li>Certain kinds of <i><a href="/wiki/Memory_leak" title="Memory leak">memory leaks</a></i>, in which a program fails to free memory occupied by objects that have become <a href="/wiki/Unreachable" title="Unreachable" class="mw-redirect">unreachable</a>, which can lead to memory exhaustion. (Garbage collection typically does not deal with the unbounded accumulation of data that is reachable, but that will actually not be used by the program.)</li>
<li>Efficient implementations of <a href="/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structures</a></li>
</ul>
<p>Some of the bugs addressed by garbage collection can have security implications.</p>
<h3><span class="mw-headline" id="Disadvantages">Disadvantages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Disadvantages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Typically, garbage collection has certain disadvantages:</p>
<ul>
<li>Garbage collection consumes computing resources in deciding which memory to free, even though the programmer may have already known this information. The penalty for the convenience of not annotating object lifetime manually in the source code is <a href="/wiki/Overhead_(computing)" title="Overhead (computing)">overhead</a>, which can lead to decreased or uneven performance. Interaction with memory hierarchy effects can make this overhead intolerable in circumstances that are hard to predict or to detect in routine testing.</li>
<li>The moment when the garbage is actually collected can be unpredictable, resulting in stalls scattered throughout a session. Unpredictable stalls can be unacceptable in <a href="/wiki/Real-time_computing" title="Real-time computing">real-time environments</a>, in <a href="/wiki/Transaction_processing" title="Transaction processing">transaction processing</a>, or in interactive programs. Incremental, concurrent, and real-time garbage collectors address these problems, with varying trade-offs.</li>
<li>Non-deterministic GC is incompatible with <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">RAII</a> based management of non-GCed resources. As a result, the need for explicit manual resource management (release/close) for non-GCed resources becomes transitive to composition. That is: in a non-deterministic GC system, if a resource or a resource-like object requires manual resource management (release/close), and this object is used as 'part of' another object, then the composed object will also become a resource-like object that itself requires manual resource management (release/close).</li>
</ul>
<h2><span class="mw-headline" id="Tracing_garbage_collectors">Tracing garbage collectors</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Tracing garbage collectors">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Tracing_garbage_collection" title="Tracing garbage collection">Tracing garbage collection</a> is the most common type of garbage collection, so much so that "garbage collection" often refers to tracing garbage collection, rather than other methods such as <a href="/wiki/Reference_counting" title="Reference counting">reference counting</a>. The overall strategy consists of determining which objects should be garbage collected by tracing which objects are <i>reachable</i> by a chain of references from certain root objects, and considering the rest as garbage and collecting them. However, there are a large number of algorithms used in implementation, with widely varying complexity and performance characteristics.</p>
<h2><span class="mw-headline" id="Reference_counting">Reference counting</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Reference counting">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Reference counting is a form of garbage collection whereby each object has a count of the number of references to it. Garbage is identified by having a reference count of zero. An object's reference count is incremented when a reference to it is created, and decremented when a reference is destroyed. The object's memory is reclaimed when the count reaches zero.</p>
<p>As with manual memory management, and unlike tracing garbage collection, reference counting guarantees that objects are destroyed as soon as their last reference is destroyed, and usually only accesses memory which is either in CPU caches, in objects to be freed, or directly pointed by those, and thus tends to not have significant negative side effects on CPU cache and virtual memory operation.</p>
<p>There are a number of disadvantages to reference counting; this can generally be solved or mitigated by more sophisticated algorithms:</p>
<h2><span class="mw-headline" id="Escape_analysis">Escape analysis</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Escape analysis">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Escape_analysis" title="Escape analysis">Escape analysis</a> can be used to convert heap allocations to stack allocations, thus reducing the amount of work needed to be done by the garbage collector. This is done using a compile-time analysis to determine whether an object allocated within a function is not accessible outside of it (i.e. escape) to other functions or threads. In such a case the object may be allocated directly on the thread stack and released when the function returns, reducing its potential garbage collection overhead.</p>
<h2><span class="mw-headline" id="Compile-time">Compile-time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Compile-time">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/w/index.php?title=Compile-time_garbage_collection&amp;action=edit&amp;redlink=1" class="new" title="Compile-time garbage collection (page does not exist)">Compile-time garbage collection</a> is a form of <a href="/wiki/Static_program_analysis" title="Static program analysis">static analysis</a> allowing memory to be reused and reclaimed based on invariants known during compilation. This form of garbage collection has been studied in the <a href="/wiki/Mercury_(programming_language)" title="Mercury (programming language)">Mercury programming language</a>.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Availability">Availability</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: Availability">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Generally speaking, <a href="/wiki/High-level_programming_language" title="High-level programming language">higher-level programming languages</a> are more likely to have garbage collection as a standard feature. In languages that do not have built in garbage collection, it can often be added through a library, as with the <a href="/wiki/Boehm_garbage_collector" title="Boehm garbage collector">Boehm garbage collector</a> for C (for "nearly all programs") and C++. This approach is not without drawbacks, such as changing object creation and destruction mechanisms.</p>
<p>Most <a href="/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming languages</a>, such as <a href="/wiki/ML_(programming_language)" title="ML (programming language)">ML</a>, <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, and <a href="/wiki/APL_(programming_language)" title="APL (programming language)">APL</a>, have garbage collection built in. <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a> is especially notable as both the first <a href="/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming language</a> and the first language to introduce garbage collection.</p>
<p>Other dynamic languages, such as <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a> (but not <a href="/wiki/Perl" title="Perl">Perl</a> 5, or <a href="/wiki/PHP" title="PHP">PHP</a>, which use reference counting), also tend to use GC. <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented programming</a> languages such as <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> and <a href="/wiki/ECMAScript" title="ECMAScript">ECMAScript</a> usually provide integrated garbage collection. Notable exceptions are <a href="/wiki/C%2B%2B" title="C++">C++</a> and <a href="/wiki/Embarcadero_Delphi" title="Embarcadero Delphi" class="mw-redirect">Delphi</a> which have <a href="/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructors</a>. <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a> has not traditionally had it, but Objective-C 2.0 as implemented by Apple for <a href="/wiki/Mac_OS_X" title="Mac OS X" class="mw-redirect">Mac OS X</a> used a runtime collector developed in-house, which was deprecated by <a href="/wiki/LLVM" title="LLVM">LLVM</a>'s <a href="/wiki/Automatic_Reference_Counting" title="Automatic Reference Counting">automatic reference counter</a>. The <a href="/wiki/GNUstep" title="GNUstep">GNUstep</a> project uses a Boehm collector.</p>
<p>Historically, languages intended for beginners, such as <a href="/wiki/BASIC" title="BASIC">BASIC</a> and <a href="/wiki/Logo_(programming_language)" title="Logo (programming language)">Logo</a>, have often used garbage collection for heap-allocated variable-length data types, such as strings and lists, so as not to burden programmers with manual memory management. On early microcomputers, with their limited memory and slow processors, BASIC garbage collection could often cause apparently random, inexplicable pauses in the midst of program operation.</p>
<p>Some BASIC interpreters, such as <a href="/wiki/Applesoft_BASIC" title="Applesoft BASIC">Applesoft BASIC</a> on the Apple II family, repeatedly scanned the string descriptors for the string having the highest address in order to compact it toward high memory, resulting in O(N*N) performance, which could introduce minutes-long pauses in the execution of string-intensive programs. A replacement garbage collector for Applesoft BASIC published in <a href="/wiki/Call-A.P.P.L.E." title="Call-A.P.P.L.E.">Call-A.P.P.L.E.</a> (January 1981, pages 40–45, <a href="/wiki/Randy_Wigginton" title="Randy Wigginton">Randy Wigginton</a>) identified a group of strings in every pass over the heap, which cut collection time dramatically. BASIC.System, released with <a href="/wiki/ProDOS" title="ProDOS" class="mw-redirect">ProDOS</a> in 1983, provided a windowing garbage collector for BASIC that reduced most collections to a fraction of a second.</p>
<h2><span class="mw-headline" id="Limited_environments">Limited environments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: Limited environments">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Garbage collection is rarely used on embedded or real-time systems because of the perceived need for very tight control over the use of limited resources. However, garbage collectors compatible with such limited environments have been developed.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup> The Microsoft <a href="/wiki/.NET_Micro_Framework" title=".NET Micro Framework">.NET Micro Framework</a> and <a href="/wiki/Java_Platform,_Micro_Edition" title="Java Platform, Micro Edition">Java Platform, Micro Edition</a> are embedded software platforms that, like their larger cousins, include garbage collection.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Destructor_(computer_programming)" title="Destructor (computer programming)">Destructor (computer programming)</a></li>
<li><a href="/wiki/International_Symposium_on_Memory_Management" title="International Symposium on Memory Management">International Symposium on Memory Management</a></li>
<li><a href="/wiki/Memory_management" title="Memory management">Memory management</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=367177.367199">"Recursive functions of symbolic expressions and their computation by machine, Part I"</a>. Portal.acm.org<span class="reference-accessdate">. Retrieved 29 March 2009</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.btitle=Recursive+functions+of+symbolic+expressions+and+their+computation+by+machine%2C+Part+I&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D367177.367199&amp;rft.pub=Portal.acm.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www-formal.stanford.edu/jmc/recursive.html">"Recursive functions of symbolic expressions and their computation by machine, Part I"</a><span class="reference-accessdate">. Retrieved 29 May 2009</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.btitle=Recursive+functions+of+symbolic+expressions+and+their+computation+by+machine%2C+Part+I&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww-formal.stanford.edu%2Fjmc%2Frecursive.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://dlang.org/overview.html">"Overview - D Programming Language"</a>. <i>dlang.org</i>. Digital Mars<span class="reference-accessdate">. Retrieved 2014-07-29</span>. "<a href="/wiki/D_(programming_language)" title="D (programming language)">D</a> memory allocation is fully garbage collected."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.atitle=Overview+-+D+Programming+Language&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fdlang.org%2Foverview.html&amp;rft.jtitle=dlang.org&amp;rft.pub=Digital+Mars&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="https://docs.python.org/release/2.5.2/ext/refcounts.html">"Reference Counts"</a>. <i>Extending and Embedding the Python Interpreter</i>. 21 February 2008<span class="reference-accessdate">. Retrieved 22 May 2014</span>. "While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.atitle=Reference+Counts&amp;rft.date=21+February+2008&amp;rft.genre=article&amp;rft_id=https%3A%2F%2Fdocs.python.org%2Frelease%2F2.5.2%2Fext%2Frefcounts.html&amp;rft.jtitle=Extending+and+Embedding+the+Python+Interpreter&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation web">Mike Ash. <a rel="nofollow" class="external text" href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">"Friday Q&amp;A 2013-09-27: ARM64 and You"</a>. mikeash.com<span class="reference-accessdate">. Retrieved 2014-04-27</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.aulast=Mike+Ash&amp;rft.au=Mike+Ash&amp;rft.btitle=Friday+Q%26A+2013-09-27%3A+ARM64+and+You&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fwww.mikeash.com%2Fpyblog%2Ffriday-qa-2013-09-27-arm64-and-you.html&amp;rft.pub=mikeash.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html">"Hamster Emporium: [objc explain]: Non-pointer isa"</a>. Sealiesoftware.com. 2013-09-24<span class="reference-accessdate">. Retrieved 2014-04-27</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.btitle=Hamster+Emporium%3A+%5Bobjc+explain%26%2393%3B%3A+Non-pointer+isa&amp;rft.date=2013-09-24&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.sealiesoftware.com%2Fblog%2Farchive%2F2013%2F09%2F24%2Fobjc_explain_Non-pointer_isa.html&amp;rft.pub=Sealiesoftware.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation thesis">Mazur, Nancy (May 2004). <a rel="nofollow" class="external text" href="https://mercurylang.org/documentation/papers/CW2004_03_mazur.pdf"><i>Compile-time garbage collection for the declarative language Mercury</i></a> (Thesis). Katholieke Universiteit Leuven.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.aufirst=Nancy&amp;rft.aulast=Mazur&amp;rft.au=Mazur%2C+Nancy&amp;rft.btitle=Compile-time+garbage+collection+for+the+declarative+language+Mercury&amp;rft.date=May+2004&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fmercurylang.org%2Fdocumentation%2Fpapers%2FCW2004_03_mazur.pdf&amp;rft.pub=Katholieke+Universiteit+Leuven&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618">"Wei Fu and Carl Hauser, "A Real-Time Garbage Collection Framework for Embedded Systems". ACM SCOPES '05, 2005"</a>. Portal.acm.org<span class="reference-accessdate">. Retrieved 9 July 2010</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.btitle=Wei+Fu+and+Carl+Hauser%2C+%22A+Real-Time+Garbage+Collection+Framework+for+Embedded+Systems%22.+ACM+SCOPES+%2705%2C+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fft_gateway.cfm%3Fid%3D1140392%26type%3Dpdf%26coll%3DGUIDE%26dl%3DGUIDE%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=Portal.acm.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span id="CITEREFJonesHoskingMoss2011" class="citation book">Jones, Richard; Hosking, Antony; Moss, Eliot (19 August 2011). <i>The Garbage Collection Handbook: The Art of Automatic Memory Management</i>. CRC Applied Algorithms and Data Structures Series. Chapman and Hall/CRC. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/1-4200-8279-5" title="Special:BookSources/1-4200-8279-5">1-4200-8279-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.aufirst=Richard&amp;rft.au=Hosking%2C+Antony&amp;rft.au=Jones%2C+Richard&amp;rft.aulast=Jones&amp;rft.au=Moss%2C+Eliot&amp;rft.btitle=The+Garbage+Collection+Handbook%3A+The+Art+of+Automatic+Memory+Management&amp;rft.date=19+August+2011&amp;rft.genre=book&amp;rft.isbn=1-4200-8279-5&amp;rft.pub=Chapman+and+Hall%2FCRC&amp;rft.series=CRC+Applied+Algorithms+and+Data+Structures+Series&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span id="CITEREFJonesLins1996" class="citation book">Jones, Richard; Lins, Rafael D. (1996). <i>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</i>. Wiley. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-94148-4" title="Special:BookSources/0-471-94148-4">0-471-94148-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.aufirst=Richard&amp;rft.au=Jones%2C+Richard&amp;rft.aulast=Jones&amp;rft.au=Lins%2C+Rafael+D.&amp;rft.btitle=Garbage+Collection%3A+Algorithms+for+Automatic+Dynamic+Memory+Management&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-94148-4&amp;rft.pub=Wiley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span id="CITEREFWilsonJohnstoneNeelyBoles1995" class="citation journal">Wilson, Paul R.; Johnstone, M. S.; Neely, M.; Boles, D. (1995). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.275">"Dynamic Storage Allocation: A Survey and Critical Review"</a>. <i><a href="/wiki/International_Workshop_on_Memory_Management" title="International Workshop on Memory Management" class="mw-redirect">International Workshop on Memory Management</a></i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.atitle=Dynamic+Storage+Allocation%3A+A+Survey+and+Critical+Review&amp;rft.au=Boles%2C+D.&amp;rft.aufirst=Paul+R.&amp;rft.au=Johnstone%2C+M.+S.&amp;rft.aulast=Wilson&amp;rft.au=Neely%2C+M.&amp;rft.au=Wilson%2C+Paul+R.&amp;rft.date=1995&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.47.275&amp;rft.jtitle=International+Workshop+on+Memory+Management&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span id="CITEREFWilson1992" class="citation journal">Wilson, Paul R. (1992). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2438">"Uniprocessor Garbage Collection Techniques"</a>. <i>IWMM '92 Proceedings of the International Workshop on Memory Management</i> (Springer-Verlag).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AGarbage+collection+%28computer+science%29&amp;rft.atitle=Uniprocessor+Garbage+Collection+Techniques&amp;rft.aufirst=Paul+R.&amp;rft.aulast=Wilson&amp;rft.au=Wilson%2C+Paul+R.&amp;rft.date=1992&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.47.2438&amp;rft.jtitle=IWMM+%2792+Proceedings+of+the+International+Workshop+on+Memory+Management&amp;rft.pub=Springer-Verlag&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.memorymanagement.org/">The Memory Management Reference</a></li>
<li><a rel="nofollow" class="external text" href="http://basen.oru.se/kurser/koi/2008-2009-p1/texter/gc/index.html">The Very Basics of Garbage Collection</a></li>
<li><a rel="nofollow" class="external text" href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">Java SE 6 HotSpot™ Virtual Machine Garbage Collection Tuning</a></li>
</ul>
<h3><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a href="/wiki/Memory_Pool_System" title="Memory Pool System">Memory Pool System</a></li>
<li><a rel="nofollow" class="external text" href="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html">A Real-Time Garbage Collector Based on the Lifetimes of Objects</a></li>
<li><a rel="nofollow" class="external text" href="http://tinygc.sourceforge.net/">TinyGC - an independent implementation of the BoehmGC API</a></li>
<li><a rel="nofollow" class="external text" href="http://www.codeproject.com/KB/cpp/conservative_gc.aspx">Conservative Garbage Collection Implementation for C Language</a></li>
<li><a rel="nofollow" class="external text" href="http://sourceforge.net/projects/meixnergc/">MeixnerGC - an incremental mark and sweep garbage collector for C++ using smart pointers</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Memory_management_navbox" title="Template:Memory management navbox"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Memory_management_navbox" title="Template talk:Memory management navbox"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Memory_management_navbox&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_management_(operating_systems)" title="Memory management (operating systems)">Memory management as a function of an operating system</a></li>
</ul>
<ul>
<li><a href="/wiki/Static_memory_allocation" title="Static memory allocation">Static memory allocation</a></li>
<li><a href="/wiki/C_dynamic_memory_allocation" title="C dynamic memory allocation">C dynamic memory allocation</a></li>
<li><a href="/wiki/New_(C%2B%2B)" title="New (C++)">new (C++)</a></li>
<li><a href="/wiki/Delete_(C%2B%2B)" title="Delete (C++)">delete (C++)</a></li>
</ul>
<ul>
<li><a href="/wiki/Demand_paging" title="Demand paging">Demand paging</a></li>
<li><a href="/wiki/Page_table" title="Page table">Page table</a></li>
<li><a href="/wiki/Paging" title="Paging">Paging</a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_management_unit" title="Memory management unit">Memory management unit</a></li>
<li><a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">Translation lookaside buffer</a></li>
</ul>
<ul>
<li><a href="/wiki/Boehm_garbage_collector" title="Boehm garbage collector">Boehm garbage collector</a></li>
<li><a href="/wiki/Finalizer" title="Finalizer">Finalizer</a></li>
<li><a href="/wiki/Garbage_(computer_science)" title="Garbage (computer science)">Garbage</a></li>
<li><a href="/wiki/Mark-compact_algorithm" title="Mark-compact algorithm">Mark-compact algorithm</a></li>
<li><a href="/wiki/Reference_counting" title="Reference counting">Reference counting</a></li>
<li><a href="/wiki/Strong_reference" title="Strong reference">Strong reference</a></li>
<li><a href="/wiki/Weak_reference" title="Weak reference">Weak reference</a></li>
</ul>
<ul>
<li><a href="/wiki/Protected_mode" title="Protected mode">Protected mode</a></li>
<li><a href="/wiki/Real_mode" title="Real mode">Real mode</a></li>
<li><a href="/wiki/Virtual_8086_mode" title="Virtual 8086 mode">Virtual 8086 mode</a></li>
<li><a href="/wiki/X86_memory_segmentation" title="X86 memory segmentation">x86 memory segmentation</a></li>
</ul>
<ul>
<li><a href="/wiki/Buffer_overflow" title="Buffer overflow">Buffer overflow</a></li>
<li><a href="/wiki/Buffer_over-read" title="Buffer over-read">Buffer over-read</a></li>
<li><a href="/wiki/Dangling_pointer" title="Dangling pointer">Dangling pointer</a></li>
<li><a href="/wiki/Stack_overflow" title="Stack overflow">Stack overflow</a></li>
</ul>
<ul>
<li><a href="/wiki/Fragmentation_(computing)" title="Fragmentation (computing)">Fragmentation</a></li>
<li><a href="/wiki/Memory_leak" title="Memory leak">Memory leak</a></li>
<li><a href="/wiki/Unreachable_memory" title="Unreachable memory">Unreachable memory</a></li>
</ul>
<ul>
<li><a href="/wiki/Automatic_variable" title="Automatic variable">Automatic variable</a></li>
<li><a href="/wiki/International_Symposium_on_Memory_Management" title="International Symposium on Memory Management">International Symposium on Memory Management</a></li>
<li><a href="/wiki/Region-based_memory_management" title="Region-based memory management">Region-based memory management</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:John_McCarthy_navbox" title="Template:John McCarthy navbox"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:John_McCarthy_navbox" title="Template talk:John McCarthy navbox"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:John_McCarthy_navbox&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Artificial_intelligence" title="Artificial intelligence">Artificial intelligence</a></li>
<li><a href="/wiki/Circumscription_(logic)" title="Circumscription (logic)">Circumscription</a></li>
<li><a href="/wiki/Dartmouth_Conferences" title="Dartmouth Conferences">Dartmouth Conferences</a></li>
<li><a href="/wiki/Frame_problem" title="Frame problem">Frame problem</a></li>
<li><strong class="selflink">Garbage collection</strong></li>
<li><a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a></li>
<li><a href="/wiki/McCarthy_91_function" title="McCarthy 91 function">McCarthy 91 function</a></li>
<li><a href="/wiki/Situation_calculus" title="Situation calculus">Situation calculus</a></li>
<li><a href="/wiki/Space_fountain" title="Space fountain">Space fountain</a></li>
<li><a href="/w/index.php?title=Vera_Watson&amp;action=edit&amp;redlink=1" class="new" title="Vera Watson (page does not exist)">Vera Watson</a></li>
</ul>
