<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Late binding</span></h1>
<p><b>Late binding</b>, or <b>dynamic binding</b>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> is a computer programming mechanism in which the method being called upon an object is looked up by name at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">runtime</a>.</p>
<p>With <a href="/wiki/Early_binding" title="Early binding" class="mw-redirect">early binding</a>, or <a href="/wiki/Static_binding" title="Static binding" class="mw-redirect">static binding</a>, the compilation phase fixes all types of variables and expressions. This is usually stored in the compiled program as an offset in a <a href="/wiki/Virtual_method_table" title="Virtual method table">virtual method table</a> ("v-table") and is very efficient. With late binding the compiler does not have enough information to verify the method even exists, let alone bind to its particular slot on the v-table. Instead the method is looked up by name at runtime.</p>
<p>The primary advantage of using late binding in <a href="/wiki/Component_Object_Model" title="Component Object Model">Component Object Model</a> (COM) programming is that it does not require the compiler to reference the libraries that contain the object at <a href="/wiki/Compile_time" title="Compile time">compile time</a>. This makes the compilation process more resistant to version conflicts, in which the class's v-table may be accidentally modified. (This is not a concern in <a href="/wiki/Just-in-time_compilation" title="Just-in-time compilation">JIT</a>-compiled platforms such as .NET or Java, because the v-table is created at runtime by the <a href="/wiki/Virtual_machine" title="Virtual machine">virtual machine</a> against the libraries as they are being loaded into the running application.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup>)</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Late_binding_implementations"><span class="tocnumber">2</span> <span class="toctext">Late binding implementations</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Late_binding_in_dynamically-typed_languages"><span class="tocnumber">2.1</span> <span class="toctext">Late binding in dynamically-typed languages</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Late_binding_in_C.2B.2B"><span class="tocnumber">2.2</span> <span class="toctext">Late binding in C++</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Late_binding_in_COM_languages"><span class="tocnumber">2.3</span> <span class="toctext">Late binding in COM languages</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Late_binding_in_.NET"><span class="tocnumber">2.4</span> <span class="toctext">Late binding in .NET</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Late_binding_in_Java"><span class="tocnumber">2.5</span> <span class="toctext">Late binding in Java</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Early_vs._late_binding_in_PL.2FSQL_and_Ada"><span class="tocnumber">2.6</span> <span class="toctext">Early vs. late binding in PL/SQL and Ada</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Criticism"><span class="tocnumber">3</span> <span class="toctext">Criticism</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Late_binding_in_dynamically-typed_languages"><span class="tocnumber">2.1</span> <span class="toctext">Late binding in dynamically-typed languages</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Late_binding_in_C.2B.2B"><span class="tocnumber">2.2</span> <span class="toctext">Late binding in C++</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Late_binding_in_COM_languages"><span class="tocnumber">2.3</span> <span class="toctext">Late binding in COM languages</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Late_binding_in_.NET"><span class="tocnumber">2.4</span> <span class="toctext">Late binding in .NET</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Late_binding_in_Java"><span class="tocnumber">2.5</span> <span class="toctext">Late binding in Java</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Early_vs._late_binding_in_PL.2FSQL_and_Ada"><span class="tocnumber">2.6</span> <span class="toctext">Early vs. late binding in PL/SQL and Ada</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The term "late binding" dates back to at least the 1960s, where it can be found in <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i>. The term was widely used to describe languages such as LISP, though usually with negative connotations about performance.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p>In the 1980s <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a> popularized <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a> (OOP) and with it late binding. <a href="/wiki/Alan_Kay" title="Alan Kay">Dr. Alan Kay</a> once said, "OOP to me means only messaging, local retention, and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them."<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<p>In the early to mid-1990s, Microsoft heavily promoted its COM standard as a binary interface between different OOP programming languages. COM programming equally promoted early and late binding, with many languages supporting both at the syntax level.</p>
<p>In 2000, <a href="/wiki/Alex_Martelli" title="Alex Martelli">Alex Martelli</a> coined the term "<a href="/wiki/Duck_typing" title="Duck typing">duck typing</a>" to refer to the same concept, but with a different emphasis. While late binding generally focuses on implementation details, duck typing focuses on the ability to ignore types and concentrate on the methods an object currently has.</p>
<h2><span class="mw-headline" id="Late_binding_implementations">Late binding implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=2" title="Edit section: Late binding implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Late_binding_in_dynamically-typed_languages">Late binding in dynamically-typed languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=3" title="Edit section: Late binding in dynamically-typed languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In most dynamically-typed languages, the list of methods on an object can be altered at runtime. For this reason most or all method calls on a dynamically-typed language are done exclusively via a late binding. These languages may not even have v-tables and instead store the methods in a dictionary.</p>
<h3><span class="mw-headline" id="Late_binding_in_C.2B.2B">Late binding in C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=4" title="Edit section: Late binding in C++">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In C++, late binding (also called "dynamic binding") is normally made happen by prepending the <i>virtual</i> keyword to a method. C++ will then create a so-called virtual table, which is a look-up table for functions that from now on will always be consulted on each function call.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> You may find further information about this type of late binding under the related article of <a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">dynamic dispatch</a>; however, it must be noted that even in textbooks the "late binding" term <i>is</i> used in favor of "dynamic dispatch".</p>
<h3><span class="mw-headline" id="Late_binding_in_COM_languages">Late binding in COM languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=5" title="Edit section: Late binding in COM languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In COM programming a late-bound method call is performed using the <a href="/wiki/IDispatch" title="IDispatch">IDispatch</a> interface. Some COM-based languages such as Visual Basic 6 have syntactical support for calling this interface.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> This is done by defining the variable's type as Object. Others such as C++ require that you explicitly call GetIDsOfNames to look up a method and Invoke to call it.</p>
<h3><span class="mw-headline" id="Late_binding_in_.NET">Late binding in .NET</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=6" title="Edit section: Late binding in .NET">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Like COM and Java, the Common Language Runtime provides reflection APIs that make late binding calls possible. The use of these calls varies by language (C# and Visual Basic).</p>
<p>Prior to version 4, C# only allowed late binding via the appropriate reflection API. A different API would be needed for each of .NET, COM, and DLR objects. With C# 4, the language gained the "dynamic" pseudo-type. This would be used in place of the Object type to indicate that late binding is desired. The specific late binding mechanism needed is determined at runtime using the Dynamic Language Runtime as a starting point.</p>
<p>Visual Basic uses them whenever the variable is of type Object and the compiler directive "Option Strict Off" is in force. This is the default setting for a new VB project. Prior to version 9, only .NET and COM objects could be late bound. With VB 10, this has been extended to DLR-based objects.</p>
<h3><span class="mw-headline" id="Late_binding_in_Java">Late binding in Java</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=7" title="Edit section: Late binding in Java">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There are three definitions for late binding in Java.</p>
<p>Early documents on Java discussed how classes were not linked together at compile time. While types are statically checked at compile time, different implementations for classes could be swapped out just prior to runtime simply by overwriting the class file. As long as the new class definition had the same class and method names, the code would still work. In this sense it is similar to the traditional definition of late binding.</p>
<p>Currently, it is popular to use the term late binding in Java programming as a synonym for <a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">dynamic dispatch</a>. Specifically, this refers to Java's single dispatch mechanism used with virtual methods.</p>
<p>Finally, Java can use late binding using its reflection APIs and <a href="/wiki/Type_introspection" title="Type introspection">type introspection</a> much in the same way it is done in COM and .NET programming. Generally speaking those who only program in Java do not call this late binding. Likewise the use of "duck typing" techniques is frowned upon in Java programming, with abstract interfaces used instead.</p>
<p>It should be noted that Oracle, the current owner of Java, has been known to use the term late binding in the "duck typing" sense when discussing both Java and other languages in the same documentation.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Early_vs._late_binding_in_PL.2FSQL_and_Ada">Early vs. late binding in PL/SQL and Ada</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=8" title="Edit section: Early vs. late binding in PL/SQL and Ada">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When using early binding between Ada and a database-stored procedure, a timestamp is checked to verify that the stored procedure has not changed since the code was compiled. This allows for faster executions and prevents the application from running against the wrong version of a stored procedure.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup></p>
<p>When using late binding the timestamp check is not performed, and the stored procedure is executed via an anonymous PL/SQL block. While this can be slower, it removes the need to recompile all of the client applications when a stored procedure changes.</p>
<p>This distinction appears to be unique to PL/SQL and Ada. Other languages that can call PL/SQL procedures, as well as other database engines, only use late binding.</p>
<h2><span class="mw-headline" id="Criticism">Criticism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=9" title="Edit section: Criticism">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Late binding has poorer performance than an early bound method call. Under most implementations the correct method address must be looked up by name with each call, requiring relatively expensive dictionary search and possibly overload resolution logic.</p>
<p>Late binding necessarily prevents the use of static type checking. When making a late bound call, the compiler has to assume that the method exists. This means a simple spelling error can cause a runtime error to be thrown. The exact exception varies by language, but it is usually named something like "Method Not Found" or "Method Missing".</p>
<p>Late binding prevents many forms of static analysis needed by an <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a> (IDE). For example, an IDE's "go to definition" feature cannot be used on a late-bound call, because the IDE has no way to know which class the call may refer to. Another problem is that the lack of typing information prevents the creation of dependency graphs. However, other programming methods such as abstract interfaces can result in the same problems.</p>
<p>Using late binding in medium or large software projects often makes them harder to maintain and troubleshoot. For example, a function called during runtime might not obtain a required lock, and tracing that down can be quite challenging and time-consuming.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Late_linking" title="Late linking" class="mw-redirect">Late linking</a></li>
<li><a href="/wiki/Dynamic_linking" title="Dynamic linking" class="mw-redirect">Dynamic linking</a></li>
<li><a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">Dynamic dispatch</a></li>
<li><a href="/wiki/Name_binding" title="Name binding">Name binding</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=11" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Booch, Grady. Object-oriented Analysis and Design. Addison-Wesley, 1994. p71</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/specs/jvms/se5.0/html/Overview.doc.html#1913">"The Structure of the Java Virtual Machine: Dynamic Linking"</a>. <a href="/wiki/Sun_Microsystems" title="Sun Microsystems">Sun Microsystems</a>. 1999. sec. 3.6.3<span class="reference-accessdate">. Retrieved 2013-09-21</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=The+Structure+of+the+Java+Virtual+Machine%3A+Dynamic+Linking&amp;rft.date=1999&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse5.0%2Fhtml%2FOverview.doc.html%231913&amp;rft.pages=sec.+3.6.3&amp;rft.pub=Sun+Microsystems&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Software engineering techniques, J. N. Buxton, Brian Randell, NATO Science Committee, NATO Science Committee, 1970</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.purl.org/stefan_ram/pub/doc_kay_oop_en">"Dr. Alan Kay on the Meaning of "Object-Oriented Programming<span style="padding-right:0.2em;">"</span>"</a>. Purl.org<span class="reference-accessdate">. Retrieved 2013-08-16</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Dr.+Alan+Kay+on+the+Meaning+of+%22Object-Oriented+Programming%22&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.purl.org%2Fstefan_ram%2Fpub%2Fdoc_kay_oop_en&amp;rft.pub=Purl.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/">"12.5 — The virtual table « Learn C"</a>. Learncpp.com. 2008-02-08<span class="reference-accessdate">. Retrieved 2013-08-16</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=12.5+%E2%80%94+The+virtual+table+%C2%AB+Learn+C&amp;rft.date=2008-02-08&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.learncpp.com%2Fcpp-tutorial%2F125-the-virtual-table%2F&amp;rft.pub=Learncpp.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://support.microsoft.com/kb/245115">"Using early binding and late binding in Automation"</a>. Support.microsoft.com<span class="reference-accessdate">. Retrieved 2011-01-15</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Using+early+binding+and+late+binding+in+Automation&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fsupport.microsoft.com%2Fkb%2F245115&amp;rft.pub=Support.microsoft.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/docs/cd/E12840_01/wls/docs103/jcom/comtowls.html">"Calling into WebLogic Server from a COM Client Application"</a>. Download.oracle.com<span class="reference-accessdate">. Retrieved 2013-08-16</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Calling+into+WebLogic+Server+from+a+COM+Client+Application&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fdocs%2Fcd%2FE12840_01%2Fwls%2Fdocs103%2Fjcom%2Fcomtowls.html&amp;rft.pub=Download.oracle.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/docs/cd/B19306_01/appdev.102/a58231/ch3.htm#i1007434">"Early and Late Binding, Oracle SQL *Module for Ada Programmer's Guide"</a>. Download.oracle.com<span class="reference-accessdate">. Retrieved 2011-01-15</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Early+and+Late+Binding%2C+Oracle+SQL+%2AModule+for+Ada+Programmer%27s+Guide&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fdocs%2Fcd%2FB19306_01%2Fappdev.102%2Fa58231%2Fch3.htm%23i1007434&amp;rft.pub=Download.oracle.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Late binding</span></h1>
<p><b>Late binding</b>, or <b>dynamic binding</b>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> is a computer programming mechanism in which the method being called upon an object is looked up by name at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">runtime</a>.</p>
<p>With <a href="/wiki/Early_binding" title="Early binding" class="mw-redirect">early binding</a>, or <a href="/wiki/Static_binding" title="Static binding" class="mw-redirect">static binding</a>, the compilation phase fixes all types of variables and expressions. This is usually stored in the compiled program as an offset in a <a href="/wiki/Virtual_method_table" title="Virtual method table">virtual method table</a> ("v-table") and is very efficient. With late binding the compiler does not have enough information to verify the method even exists, let alone bind to its particular slot on the v-table. Instead the method is looked up by name at runtime.</p>
<p>The primary advantage of using late binding in <a href="/wiki/Component_Object_Model" title="Component Object Model">Component Object Model</a> (COM) programming is that it does not require the compiler to reference the libraries that contain the object at <a href="/wiki/Compile_time" title="Compile time">compile time</a>. This makes the compilation process more resistant to version conflicts, in which the class's v-table may be accidentally modified. (This is not a concern in <a href="/wiki/Just-in-time_compilation" title="Just-in-time compilation">JIT</a>-compiled platforms such as .NET or Java, because the v-table is created at runtime by the <a href="/wiki/Virtual_machine" title="Virtual machine">virtual machine</a> against the libraries as they are being loaded into the running application.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup>)</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Late_binding_implementations"><span class="tocnumber">2</span> <span class="toctext">Late binding implementations</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Late_binding_in_dynamically-typed_languages"><span class="tocnumber">2.1</span> <span class="toctext">Late binding in dynamically-typed languages</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Late_binding_in_C.2B.2B"><span class="tocnumber">2.2</span> <span class="toctext">Late binding in C++</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Late_binding_in_COM_languages"><span class="tocnumber">2.3</span> <span class="toctext">Late binding in COM languages</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Late_binding_in_.NET"><span class="tocnumber">2.4</span> <span class="toctext">Late binding in .NET</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Late_binding_in_Java"><span class="tocnumber">2.5</span> <span class="toctext">Late binding in Java</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Early_vs._late_binding_in_PL.2FSQL_and_Ada"><span class="tocnumber">2.6</span> <span class="toctext">Early vs. late binding in PL/SQL and Ada</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Criticism"><span class="tocnumber">3</span> <span class="toctext">Criticism</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Late_binding_in_dynamically-typed_languages"><span class="tocnumber">2.1</span> <span class="toctext">Late binding in dynamically-typed languages</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Late_binding_in_C.2B.2B"><span class="tocnumber">2.2</span> <span class="toctext">Late binding in C++</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Late_binding_in_COM_languages"><span class="tocnumber">2.3</span> <span class="toctext">Late binding in COM languages</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Late_binding_in_.NET"><span class="tocnumber">2.4</span> <span class="toctext">Late binding in .NET</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Late_binding_in_Java"><span class="tocnumber">2.5</span> <span class="toctext">Late binding in Java</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Early_vs._late_binding_in_PL.2FSQL_and_Ada"><span class="tocnumber">2.6</span> <span class="toctext">Early vs. late binding in PL/SQL and Ada</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The term "late binding" dates back to at least the 1960s, where it can be found in <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i>. The term was widely used to describe languages such as LISP, though usually with negative connotations about performance.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p>In the 1980s <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a> popularized <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a> (OOP) and with it late binding. <a href="/wiki/Alan_Kay" title="Alan Kay">Dr. Alan Kay</a> once said, "OOP to me means only messaging, local retention, and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them."<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<p>In the early to mid-1990s, Microsoft heavily promoted its COM standard as a binary interface between different OOP programming languages. COM programming equally promoted early and late binding, with many languages supporting both at the syntax level.</p>
<p>In 2000, <a href="/wiki/Alex_Martelli" title="Alex Martelli">Alex Martelli</a> coined the term "<a href="/wiki/Duck_typing" title="Duck typing">duck typing</a>" to refer to the same concept, but with a different emphasis. While late binding generally focuses on implementation details, duck typing focuses on the ability to ignore types and concentrate on the methods an object currently has.</p>
<h2><span class="mw-headline" id="Late_binding_implementations">Late binding implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=2" title="Edit section: Late binding implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Late_binding_in_dynamically-typed_languages">Late binding in dynamically-typed languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=3" title="Edit section: Late binding in dynamically-typed languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In most dynamically-typed languages, the list of methods on an object can be altered at runtime. For this reason most or all method calls on a dynamically-typed language are done exclusively via a late binding. These languages may not even have v-tables and instead store the methods in a dictionary.</p>
<h3><span class="mw-headline" id="Late_binding_in_C.2B.2B">Late binding in C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=4" title="Edit section: Late binding in C++">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In C++, late binding (also called "dynamic binding") is normally made happen by prepending the <i>virtual</i> keyword to a method. C++ will then create a so-called virtual table, which is a look-up table for functions that from now on will always be consulted on each function call.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> You may find further information about this type of late binding under the related article of <a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">dynamic dispatch</a>; however, it must be noted that even in textbooks the "late binding" term <i>is</i> used in favor of "dynamic dispatch".</p>
<h3><span class="mw-headline" id="Late_binding_in_COM_languages">Late binding in COM languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=5" title="Edit section: Late binding in COM languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In COM programming a late-bound method call is performed using the <a href="/wiki/IDispatch" title="IDispatch">IDispatch</a> interface. Some COM-based languages such as Visual Basic 6 have syntactical support for calling this interface.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> This is done by defining the variable's type as Object. Others such as C++ require that you explicitly call GetIDsOfNames to look up a method and Invoke to call it.</p>
<h3><span class="mw-headline" id="Late_binding_in_.NET">Late binding in .NET</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=6" title="Edit section: Late binding in .NET">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Like COM and Java, the Common Language Runtime provides reflection APIs that make late binding calls possible. The use of these calls varies by language (C# and Visual Basic).</p>
<p>Prior to version 4, C# only allowed late binding via the appropriate reflection API. A different API would be needed for each of .NET, COM, and DLR objects. With C# 4, the language gained the "dynamic" pseudo-type. This would be used in place of the Object type to indicate that late binding is desired. The specific late binding mechanism needed is determined at runtime using the Dynamic Language Runtime as a starting point.</p>
<p>Visual Basic uses them whenever the variable is of type Object and the compiler directive "Option Strict Off" is in force. This is the default setting for a new VB project. Prior to version 9, only .NET and COM objects could be late bound. With VB 10, this has been extended to DLR-based objects.</p>
<h3><span class="mw-headline" id="Late_binding_in_Java">Late binding in Java</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=7" title="Edit section: Late binding in Java">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There are three definitions for late binding in Java.</p>
<p>Early documents on Java discussed how classes were not linked together at compile time. While types are statically checked at compile time, different implementations for classes could be swapped out just prior to runtime simply by overwriting the class file. As long as the new class definition had the same class and method names, the code would still work. In this sense it is similar to the traditional definition of late binding.</p>
<p>Currently, it is popular to use the term late binding in Java programming as a synonym for <a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">dynamic dispatch</a>. Specifically, this refers to Java's single dispatch mechanism used with virtual methods.</p>
<p>Finally, Java can use late binding using its reflection APIs and <a href="/wiki/Type_introspection" title="Type introspection">type introspection</a> much in the same way it is done in COM and .NET programming. Generally speaking those who only program in Java do not call this late binding. Likewise the use of "duck typing" techniques is frowned upon in Java programming, with abstract interfaces used instead.</p>
<p>It should be noted that Oracle, the current owner of Java, has been known to use the term late binding in the "duck typing" sense when discussing both Java and other languages in the same documentation.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Early_vs._late_binding_in_PL.2FSQL_and_Ada">Early vs. late binding in PL/SQL and Ada</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=8" title="Edit section: Early vs. late binding in PL/SQL and Ada">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When using early binding between Ada and a database-stored procedure, a timestamp is checked to verify that the stored procedure has not changed since the code was compiled. This allows for faster executions and prevents the application from running against the wrong version of a stored procedure.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup></p>
<p>When using late binding the timestamp check is not performed, and the stored procedure is executed via an anonymous PL/SQL block. While this can be slower, it removes the need to recompile all of the client applications when a stored procedure changes.</p>
<p>This distinction appears to be unique to PL/SQL and Ada. Other languages that can call PL/SQL procedures, as well as other database engines, only use late binding.</p>
<h2><span class="mw-headline" id="Criticism">Criticism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=9" title="Edit section: Criticism">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Late binding has poorer performance than an early bound method call. Under most implementations the correct method address must be looked up by name with each call, requiring relatively expensive dictionary search and possibly overload resolution logic.</p>
<p>Late binding necessarily prevents the use of static type checking. When making a late bound call, the compiler has to assume that the method exists. This means a simple spelling error can cause a runtime error to be thrown. The exact exception varies by language, but it is usually named something like "Method Not Found" or "Method Missing".</p>
<p>Late binding prevents many forms of static analysis needed by an <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a> (IDE). For example, an IDE's "go to definition" feature cannot be used on a late-bound call, because the IDE has no way to know which class the call may refer to. Another problem is that the lack of typing information prevents the creation of dependency graphs. However, other programming methods such as abstract interfaces can result in the same problems.</p>
<p>Using late binding in medium or large software projects often makes them harder to maintain and troubleshoot. For example, a function called during runtime might not obtain a required lock, and tracing that down can be quite challenging and time-consuming.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Late_linking" title="Late linking" class="mw-redirect">Late linking</a></li>
<li><a href="/wiki/Dynamic_linking" title="Dynamic linking" class="mw-redirect">Dynamic linking</a></li>
<li><a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">Dynamic dispatch</a></li>
<li><a href="/wiki/Name_binding" title="Name binding">Name binding</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Late_binding&amp;action=edit&amp;section=11" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Booch, Grady. Object-oriented Analysis and Design. Addison-Wesley, 1994. p71</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/specs/jvms/se5.0/html/Overview.doc.html#1913">"The Structure of the Java Virtual Machine: Dynamic Linking"</a>. <a href="/wiki/Sun_Microsystems" title="Sun Microsystems">Sun Microsystems</a>. 1999. sec. 3.6.3<span class="reference-accessdate">. Retrieved 2013-09-21</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=The+Structure+of+the+Java+Virtual+Machine%3A+Dynamic+Linking&amp;rft.date=1999&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse5.0%2Fhtml%2FOverview.doc.html%231913&amp;rft.pages=sec.+3.6.3&amp;rft.pub=Sun+Microsystems&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Software engineering techniques, J. N. Buxton, Brian Randell, NATO Science Committee, NATO Science Committee, 1970</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.purl.org/stefan_ram/pub/doc_kay_oop_en">"Dr. Alan Kay on the Meaning of "Object-Oriented Programming<span style="padding-right:0.2em;">"</span>"</a>. Purl.org<span class="reference-accessdate">. Retrieved 2013-08-16</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Dr.+Alan+Kay+on+the+Meaning+of+%22Object-Oriented+Programming%22&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.purl.org%2Fstefan_ram%2Fpub%2Fdoc_kay_oop_en&amp;rft.pub=Purl.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/">"12.5 — The virtual table « Learn C"</a>. Learncpp.com. 2008-02-08<span class="reference-accessdate">. Retrieved 2013-08-16</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=12.5+%E2%80%94+The+virtual+table+%C2%AB+Learn+C&amp;rft.date=2008-02-08&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.learncpp.com%2Fcpp-tutorial%2F125-the-virtual-table%2F&amp;rft.pub=Learncpp.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://support.microsoft.com/kb/245115">"Using early binding and late binding in Automation"</a>. Support.microsoft.com<span class="reference-accessdate">. Retrieved 2011-01-15</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Using+early+binding+and+late+binding+in+Automation&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fsupport.microsoft.com%2Fkb%2F245115&amp;rft.pub=Support.microsoft.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/docs/cd/E12840_01/wls/docs103/jcom/comtowls.html">"Calling into WebLogic Server from a COM Client Application"</a>. Download.oracle.com<span class="reference-accessdate">. Retrieved 2013-08-16</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Calling+into+WebLogic+Server+from+a+COM+Client+Application&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fdocs%2Fcd%2FE12840_01%2Fwls%2Fdocs103%2Fjcom%2Fcomtowls.html&amp;rft.pub=Download.oracle.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/docs/cd/B19306_01/appdev.102/a58231/ch3.htm#i1007434">"Early and Late Binding, Oracle SQL *Module for Ada Programmer's Guide"</a>. Download.oracle.com<span class="reference-accessdate">. Retrieved 2011-01-15</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ALate+binding&amp;rft.btitle=Early+and+Late+Binding%2C+Oracle+SQL+%2AModule+for+Ada+Programmer%27s+Guide&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fdocs%2Fcd%2FB19306_01%2Fappdev.102%2Fa58231%2Fch3.htm%23i1007434&amp;rft.pub=Download.oracle.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
