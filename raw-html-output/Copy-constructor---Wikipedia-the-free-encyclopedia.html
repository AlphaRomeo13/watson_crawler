<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Copy constructor</span></h1>
<p>A <b>copy constructor</b> is a special <a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">constructor</a> in the <a href="/wiki/C%2B%2B" title="C++">C++</a> <a href="/wiki/Programming_language" title="Programming language">programming language</a> for creating a new <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> <a href="/wiki/Object_copy" title="Object copy">as a copy</a> of an existing object. The first argument of such a constructor is a reference to an object of the same type as is being constructed (const or non-const), which might be followed by parameters of any type (all having default values).</p>
<p>Normally the <a href="/wiki/Compiler" title="Compiler">compiler</a> automatically creates a copy constructor for each <a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a> (known as an <b>implicit</b> copy constructor) but for special cases the <a href="/wiki/Programmer" title="Programmer">programmer</a> creates the copy constructor, known as a <b>user-defined</b> copy constructor. In such cases, the compiler does not create one. Hence, there is always one copy constructor that is either defined by the user or by the system.</p>
<p>A user-defined copy constructor is generally needed when an object owns <a href="/wiki/Data_pointer" title="Data pointer" class="mw-redirect">pointers</a> or non-shareable <a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a>, such as to a <a href="/wiki/Computer_file" title="Computer file">file</a>, in which case a <a href="/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructor</a> and an <a href="/wiki/Assignment_operator_in_C%2B%2B" title="Assignment operator in C++" class="mw-redirect">assignment operator</a> should also be written (see <a href="/wiki/Rule_of_three_(C%2B%2B_programming)" title="Rule of three (C++ programming)">Rule of three</a>).</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Definition"><span class="tocnumber">1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Operation"><span class="tocnumber">2</span> <span class="toctext">Operation</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Explicit_assignment_in_an_expression"><span class="tocnumber">2.1</span> <span class="toctext">Explicit assignment in an expression</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Initialization"><span class="tocnumber">2.2</span> <span class="toctext">Initialization</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Examples"><span class="tocnumber">3</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Implicit_copy_constructor"><span class="tocnumber">3.1</span> <span class="toctext">Implicit copy constructor</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#User-defined_copy_constructor"><span class="tocnumber">3.2</span> <span class="toctext">User-defined copy constructor</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Copy_constructors_and_templates"><span class="tocnumber">3.3</span> <span class="toctext">Copy constructors and templates</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Bitwise_Copy_Constructor"><span class="tocnumber">4</span> <span class="toctext">Bitwise Copy Constructor</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Logical_Copy_Constructor"><span class="tocnumber">5</span> <span class="toctext">Logical Copy Constructor</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Explicit_copy_constructor"><span class="tocnumber">6</span> <span class="toctext">Explicit copy constructor</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Notes"><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Explicit_assignment_in_an_expression"><span class="tocnumber">2.1</span> <span class="toctext">Explicit assignment in an expression</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Initialization"><span class="tocnumber">2.2</span> <span class="toctext">Initialization</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Implicit_copy_constructor"><span class="tocnumber">3.1</span> <span class="toctext">Implicit copy constructor</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#User-defined_copy_constructor"><span class="tocnumber">3.2</span> <span class="toctext">User-defined copy constructor</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Copy_constructors_and_templates"><span class="tocnumber">3.3</span> <span class="toctext">Copy constructors and templates</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=1" title="Edit section: Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Copying of objects is achieved by the use of a copy constructor and an <a href="/wiki/Assignment_operator_in_C%2B%2B" title="Assignment operator in C++" class="mw-redirect">assignment operator</a>. A copy constructor has as its first parameter a (possibly const or <a href="/wiki/Volatile_variable" title="Volatile variable" class="mw-redirect">volatile</a>) <a href="/wiki/Reference_(C%2B%2B)" title="Reference (C++)">reference</a> to its own class type. It can have more arguments, but the rest must have default values associated with them.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> The following would be valid copy constructors for class <code>X</code>:</p>
<p>WHATSON? a1f650d6-f2c3-4012-b841-c8e67a7a3b68</p>
<pre class="de1">
X<span class="br0">(</span><span class="kw4">const</span> X<span class="sy3">&amp;</span> copy_from_me<span class="br0">)</span><span class="sy4">;</span>
X<span class="br0">(</span>X<span class="sy3">&amp;</span> copy_from_me<span class="br0">)</span><span class="sy4">;</span>
X<span class="br0">(</span><span class="kw4">volatile</span> X<span class="sy3">&amp;</span> copy_from_me<span class="br0">)</span><span class="sy4">;</span>
X<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">volatile</span> X<span class="sy3">&amp;</span> copy_from_me<span class="br0">)</span><span class="sy4">;</span>
X<span class="br0">(</span>X<span class="sy3">&amp;</span> copy_from_me, <span class="kw4">int</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
X<span class="br0">(</span><span class="kw4">const</span> X<span class="sy3">&amp;</span> copy_from_me, <span class="kw4">double</span> <span class="sy1">=</span> <span class="nu16">1.0</span>, <span class="kw4">int</span> <span class="sy1">=</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span>
...
</pre>
<p>The first one should be used unless there is a good reason to use one of the others. One of the differences between the first and the second is that temporaries can be copied with the first. For example:</p>
<p>WHATSON? fb08e266-c7fd-41e5-bb6d-631e67dbe5a6</p>
<pre class="de1">
X a <span class="sy1">=</span> X<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// valid given X(const X&amp; copy_from_me) but not valid given X(X&amp; copy_from_me)</span>
               <span class="co1">// because the second wants a non-const X&amp;</span>
               <span class="co1">// to create a, the compiler first creates a temporary by invoking the default constructor</span>
               <span class="co1">// of X, then uses the copy constructor to initialize as a copy of that temporary. </span>
               <span class="co1">// For some compilers both versions actually work but this behaviour should not be relied </span>
               <span class="co1">// upon because it's non-standard.</span>
</pre>
<p>Another difference between them is the obvious:</p>
<p>WHATSON? c0cfb694-c595-43fd-b4af-8884a2df7177</p>
<pre class="de1">
<span class="kw4">const</span> X a<span class="sy4">;</span>
X b <span class="sy1">=</span> a<span class="sy4">;</span>       <span class="co1">// valid given X(const X&amp; copy_from_me) but not valid given X(X&amp; copy_from_me)</span>
               <span class="co1">// because the second wants a non-const X&amp;</span>
</pre>
<p>The <code>X&amp;</code> form of the copy constructor is used when it is necessary to modify the copied object. This is very rare but it can be seen used in the standard library's <code><a href="/wiki/Std::auto_ptr" title="Std::auto ptr" class="mw-redirect">std::auto_ptr</a></code>. A reference must be provided:</p>
<p>WHATSON? b560010b-65c5-41fd-bfad-8b523b3088bc</p>
<pre class="de1">
X a<span class="sy4">;</span>
X b <span class="sy1">=</span> a<span class="sy4">;</span>       <span class="co1">// valid if any of the copy constructors are defined</span>
               <span class="co1">// since a reference is being passed.</span>
</pre>
<p>The following are invalid copy constructors (Reason - <code>copy_from_me</code> is not passed as reference)ย:</p>
<p>WHATSON? d0a7eff1-36a0-48f0-b147-26ee856c59ad</p>
<pre class="de1">
X<span class="br0">(</span>X copy_from_me<span class="br0">)</span><span class="sy4">;</span>
X<span class="br0">(</span><span class="kw4">const</span> X copy_from_me<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>because the call to those constructors would require a copy as well, which would result in an infinitely recursive call.</p>
<p>The following cases may result in a call to a copy constructor:</p>
<ol>
<li>When an object is returned by value</li>
<li>When an object is passed (to a function) by value as an argument</li>
<li>When an object is thrown</li>
<li>When an object is caught</li>
<li>When an object is placed in a brace-enclosed initializer list</li>
</ol>
<p>These cases are collectively called <i>copy-initialization</i> and are equivalent to:<sup id="cite_ref-C.2B.2B03_8.5.2F12_2-0" class="reference"><a href="#cite_note-C.2B.2B03_8.5.2F12-2"><span>[</span>2<span>]</span></a></sup> <code>T x = a;</code></p>
<p>It is however, not guaranteed that a copy constructor will be called in these cases, because the <a href="/wiki/ISO/IEC_14882" title="ISO/IEC 14882" class="mw-redirect">C++ Standard</a> allows the compiler to optimize the copy away in certain cases, one example being the <a href="/wiki/Return_value_optimization" title="Return value optimization">return value optimization</a> (sometimes referred to as RVO).</p>
<h2><span class="mw-headline" id="Operation">Operation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=2" title="Edit section: Operation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An object can be assigned value using one of the two techniques:</p>
<ul>
<li>Explicit assignment in an expression</li>
<li>Initialization</li>
</ul>
<h3><span class="mw-headline" id="Explicit_assignment_in_an_expression">Explicit assignment in an expression</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=3" title="Edit section: Explicit assignment in an expression">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>WHATSON? f4f5cf04-02ff-4566-ad92-36927743eda8</p>
<pre class="de1">
Object a<span class="sy4">;</span>
Object b<span class="sy4">;</span>
a <span class="sy1">=</span> b<span class="sy4">;</span>       <span class="co1">// translates as Object::operator=(const Object&amp;), thus A.operator=(B) is called </span>
             <span class="co1">// (invoke simple copy, not copy constructor!)</span>
</pre>
<h3><span class="mw-headline" id="Initialization">Initialization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=4" title="Edit section: Initialization">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An object can be initialized by any one of the following ways.</p>
<p>a. Through declaration</p>
<p>WHATSON? 43682b89-6c11-4b4e-ab2c-76c48a5774ad</p>
<pre class="de1">
Object b <span class="sy1">=</span> a<span class="sy4">;</span> <span class="co1">// translates as Object::Object(const Object&amp;) (invoke copy constructor)</span>
</pre>
<p>b. Through function arguments</p>
<p>WHATSON? 1c3bc1fa-e21c-423c-b99c-c5f7c6d6a7eb</p>
<pre class="de1">
type function<span class="br0">(</span>Object a<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>c. Through function return value</p>
<p>WHATSON? f97a0bfd-e52e-4791-9be0-4cba9849f1e9</p>
<pre class="de1">
Object a <span class="sy1">=</span> function<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>The copy constructor is used only for initializations, and does not apply to assignments where the assignment operator is used instead.</p>
<p>The implicit copy constructor of a class calls base copy constructors and copies its members by means appropriate to their type. If it is a class type, the copy constructor is called. If it is a scalar type, the built-in assignment operator is used. Finally, if it is an array, each element is copied in the manner appropriate to its type.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p>By using a user-defined copy constructor the programmer can define the behavior to be performed when an object is copied.</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=5" title="Edit section: Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>These examples illustrate how copy constructors work and why they are required sometimes.</p>
<h3><span class="mw-headline" id="Implicit_copy_constructor">Implicit copy constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=6" title="Edit section: Implicit copy constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Let us consider the following example:</p>
<p>WHATSON? 4c1e5334-d055-4884-b3ee-a9b5e9004c68</p>
<pre class="de1">
<span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw2">class</span> Person <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
    <span class="kw4">int</span> age<span class="sy4">;</span>
 
    <span class="kw2">explicit</span> Person<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">)</span> 
        <span class="sy4">:</span> age<span class="br0">(</span>a<span class="br0">)</span>
    <span class="br0">{</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span>
    Person timmy<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy4">;</span>
    Person sally<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy4">;</span>
 
    Person timmy_clone <span class="sy1">=</span> timmy<span class="sy4">;</span>
    std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> timmy.<span class="me1">age</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> sally.<span class="me1">age</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> timmy_clone.<span class="me1">age</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
    timmy.<span class="me1">age</span> <span class="sy1">=</span> <span class="nu0">23</span><span class="sy4">;</span>
    std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> timmy.<span class="me1">age</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> sally.<span class="me1">age</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> timmy_clone.<span class="me1">age</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<p><b>Output</b></p>
<p>WHATSON? 62d8189d-85c0-4e14-8009-dba02a8cf319</p>
<pre>
10 15 10
23 15 10
</pre>
<p>As expected, <i>timmy</i> has been copied to the new object, <i>timmy_clone</i>. While <i>timmy's</i> age was changed, <i>timmy_clone's</i> age remained the same. This is because they are totally different objects.</p>
<p>The compiler has generated a copy constructor for us, and it could be written like this:</p>
<p>WHATSON? e421af36-34b5-45c8-9f58-1b3bc9e3377c</p>
<pre class="de1">
Person<span class="br0">(</span><span class="kw4">const</span> Person<span class="sy3">&amp;</span> other<span class="br0">)</span> 
    <span class="sy4">:</span> age<span class="br0">(</span>other.<span class="me1">age</span><span class="br0">)</span> <span class="co1">// calls the copy constructor of the age</span>
<span class="br0">{</span>
<span class="br0">}</span>
</pre>
<p>So, when do we really need a user-defined copy constructor? The next section will explore that question.</p>
<h3><span class="mw-headline" id="User-defined_copy_constructor">User-defined copy constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=7" title="Edit section: User-defined copy constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Now, consider a very simple <a href="/wiki/Dynamic_array" title="Dynamic array">dynamic array</a> class like the following:</p>
<p>WHATSON? decf4115-decd-4a78-aceb-fcb73c635ff9</p>
<pre class="de1">
<span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw2">class</span> Array <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
    <span class="kw4">int</span> size<span class="sy4">;</span>
    <span class="kw4">int</span><span class="sy2">*</span> data<span class="sy4">;</span>
 
    <span class="kw2">explicit</span> Array<span class="br0">(</span><span class="kw4">int</span> sz<span class="br0">)</span> 
        <span class="sy4">:</span> size<span class="br0">(</span>sz<span class="br0">)</span>, data<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">int</span><span class="br0">[</span>size<span class="br0">]</span><span class="br0">)</span>
    <span class="br0">{</span>
    <span class="br0">}</span>
 
    ~Array<span class="br0">(</span><span class="br0">)</span> 
    <span class="br0">{</span>
        <span class="kw3">delete</span><span class="br0">[</span><span class="br0">]</span> this<span class="sy2">-</span><span class="sy1">&gt;</span>data<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span>
    Array first<span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="sy4">;</span>
    first.<span class="me1">data</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> <span class="nu0">25</span><span class="sy4">;</span>
 
    <span class="br0">{</span>
        Array copy <span class="sy1">=</span> first<span class="sy4">;</span>
        std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> first.<span class="me1">data</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">" "</span> <span class="sy1">&lt;&lt;</span> copy.<span class="me1">data</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
    <span class="br0">}</span>    <span class="co1">// (1)</span>
 
    first.<span class="me1">data</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>    <span class="co1">// (2)</span>
<span class="br0">}</span>
</pre>
<p><b>Output</b></p>
<p>WHATSON? 6f383759-0dd8-494b-9756-f4ac6607b189</p>
<pre>
25 25
Segmentation fault
</pre>
<p>Since we did not specify a copy constructor, the compiler generated one for us. The generated constructor would look something like:</p>
<p>WHATSON? 0ead734b-2320-45ad-89e0-ac4f22803821</p>
<pre class="de1">
Array<span class="br0">(</span><span class="kw4">const</span> Array<span class="sy3">&amp;</span> other<span class="br0">)</span>
  <span class="sy4">:</span> size<span class="br0">(</span>other.<span class="me1">size</span><span class="br0">)</span>, data<span class="br0">(</span>other.<span class="me1">data</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
</pre>
<p>The problem with this constructor is that it performs a <a href="/wiki/Shallow_copy" title="Shallow copy" class="mw-redirect">shallow copy</a> of the <i>data</i> pointer. It only copies the address of the original data member; this means they both share a pointer to the same chunk of memory, which is not what we want. When the program reaches line <b>(1)</b>, <i>copy's</i> destructor gets called (because objects on the stack are destroyed automatically when their scope ends). <i>Array's</i> destructor deletes the <i>data</i> array of the original, therefore when it deleted <i>copy's</i> data, because they share the same pointer, it also deleted <i>first's</i> data. Line <b>(2)</b> now accesses invalid data and writes to it! This produces the infamous <a href="/wiki/Segmentation_fault" title="Segmentation fault">segmentation fault</a>.</p>
<p>If we write our own copy constructor that performs a <i>deep copy</i> then this problem goes away.</p>
<p>WHATSON? 88a6aad4-fc0c-41e9-a25a-76b7a717b155</p>
<pre class="de1">
<span class="co1">// for std::copy</span>
<span class="co2">#include &lt;algorithm&gt;</span>
 
Array<span class="br0">(</span><span class="kw4">const</span> Array<span class="sy3">&amp;</span> other<span class="br0">)</span>
    <span class="sy4">:</span> size<span class="br0">(</span>other.<span class="me1">size</span><span class="br0">)</span>, data<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">int</span><span class="br0">[</span>other.<span class="me1">size</span><span class="br0">]</span><span class="br0">)</span> 
<span class="br0">{</span>
    std<span class="sy4">::</span><span class="me2">copy</span><span class="br0">(</span>other.<span class="me1">data</span>, other.<span class="me1">data</span> <span class="sy2">+</span> other.<span class="me1">size</span>, data<span class="br0">)</span><span class="sy4">;</span> 
<span class="br0">}</span>
</pre>
<p>Here, we are creating a new <b>int</b> array and copying the contents to it. Now, <i>other's</i> destructor deletes only its data, and not <i>first's</i> data. Line <b>(2)</b> will not produce a segmentation fault anymore.</p>
<p>Instead of doing a deep copy right away, there are some optimization strategies that can be used. These allow you to safely share the same data between several objects, thus saving space. The <a href="/wiki/Copy-on-write" title="Copy-on-write">copy-on-write</a> strategy makes a copy of the data only when it is written to. <a href="/wiki/Reference_counting" title="Reference counting">Reference counting</a> keeps the count of how many objects are referencing the data, and will delete it only when this count reaches zero (e.g. boost::shared_ptr).</p>
<h3><span class="mw-headline" id="Copy_constructors_and_templates">Copy constructors and templates</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=8" title="Edit section: Copy constructors and templates">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Contrary to expectations, a template copy constructor is not a user-defined copy constructor. Thus it is not enough to just have:</p>
<p>WHATSON? 273487eb-59a1-420f-a06e-5b8f4bff91d9</p>
<pre class="de1">
<span class="kw2">template</span> <span class="sy1">&lt;</span><span class="kw2">typename</span> A<span class="sy1">&gt;</span> Array<span class="sy4">::</span><span class="me2">Array</span><span class="br0">(</span>A <span class="kw4">const</span><span class="sy3">&amp;</span> other<span class="br0">)</span>
    <span class="sy4">:</span> size<span class="br0">(</span>other.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>, data<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">int</span><span class="br0">[</span>other.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">]</span><span class="br0">)</span> 
<span class="br0">{</span>
    std<span class="sy4">::</span><span class="me2">copy</span><span class="br0">(</span>other.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, other.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, data<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<p>(Note that the type of <code>A</code> can be <code>Array</code>.) A user-defined, non-template copy constructor must also be provided for construction of Array from Array.</p>
<h2><span class="mw-headline" id="Bitwise_Copy_Constructor">Bitwise Copy Constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=9" title="Edit section: Bitwise Copy Constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A bitwise copy constructor performs a simple variable-by-variable assignment copy of all the components of an object. The bitwise copy constructor is so named as it merely copies bit-by-bit from the original object to the new object.</p>
<p>It is clear from the above figure that in a bitwise copy constructor the original as well as the new object point to the same variable. Hence, the value of the variable is changed for both the objects even if it is changed by only one object. <sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Logical_Copy_Constructor">Logical Copy Constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=10" title="Edit section: Logical Copy Constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A logical copy constructor makes a true copy of the structure as well as its dynamic structures. Logical copy constructors come into the picture mainly when there are pointers or complex objects within the object being copied.</p>
<p>It can be seen from the above figure that in a logical copy constructor, a new dynamic - member variable is created for the pointer along with copying the values. <sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Explicit_copy_constructor">Explicit copy constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=11" title="Edit section: Explicit copy constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An explicit copy constructor is one that is declared explicit by using the <b>explicit</b> keyword. For example:</p>
<p>WHATSON? ef35b280-5c9c-43a0-823e-aa2b959a958d</p>
<pre class="de1">
<span class="kw2">explicit</span> X<span class="br0">(</span><span class="kw4">const</span> X<span class="sy3">&amp;</span> copy_from_me<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>It is used to prevent copying of objects at function calls or with the copy-initialization syntax.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=12" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Assignment_operator_in_C%2B%2B" title="Assignment operator in C++" class="mw-redirect">Assignment operator in C++</a></li>
<li><a href="/wiki/Object_copy" title="Object copy">Object copy</a></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=13" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">INCITS ISO IEC 14882-2003 12.8.2. <i><a rel="nofollow" class="external autonumber" href="http://webstore.ansi.org/ansidocstore/product.asp?sku=INCITS%2FISO%2FIEC+14882%2D2003">[1]</a></i></span></li>
<li id="cite_note-C.2B.2B03_8.5.2F12-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-C.2B.2B03_8.5.2F12_2-0">^</a></b></span> <span class="reference-text"><a href="/wiki/International_Organization_for_Standardization" title="International Organization for Standardization">ISO</a>/<a href="/wiki/International_Electrotechnical_Commission" title="International Electrotechnical Commission">IEC</a> (2003). <i><a href="/wiki/ISO/IEC_14882" title="ISO/IEC 14882" class="mw-redirect">ISO/IEC 14882:2003(E): Programming Languages - C++</a> ยง8.5 Initializers [dcl.init]</i> para. 12</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">INCITS ISO IEC 14882-2003 12.8.8. <i><a rel="nofollow" class="external autonumber" href="http://webstore.ansi.org/ansidocstore/product.asp?sku=INCITS%2FISO%2FIEC+14882%2D2003">[2]</a></i></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Computer Science A Structured Approach Using C++ by Behrouz A. Forouzan and Richard F. Gilberg,figure 10-9, page 507</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Computer Science A Structured Approach Using C++ by Behrouz A. Forouzan and Richard F. Gilberg,figure 10-9, page 507</span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Copy_constructor&amp;action=edit&amp;section=14" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/ms173116.aspx">How to: Write a Copy Constructor (C# Programming Guide)</a> on MSDN</li>
</ul>
