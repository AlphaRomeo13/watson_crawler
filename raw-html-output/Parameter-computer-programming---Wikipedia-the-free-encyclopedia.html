<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Parameter (computer programming)</span></h1>
<p>In <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>, a <b>parameter</b> is a special kind of <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variable</a>, used in a <a href="/wiki/Subroutine" title="Subroutine">subroutine</a> to refer to one of the pieces of data provided as input to the subroutine.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>a<span>]</span></a></sup> These pieces of data are called <b>arguments</b>. An ordered list of parameters is usually included in the definition of a subroutine, so that, each time the subroutine is called, its arguments for that call can be assigned to the corresponding parameters.</p>
<p>Just as in standard mathematical usage, the <i>argument</i> is thus the actual input passed to a function, procedure, or routine, whereas the <i>parameter</i> is the variable inside the implementation of the subroutine. For example, if one defines the <code>add</code> subroutine as <code>def add(x, y): return x + y</code>, then <code>x, y</code> are parameters, while if this is called as <code>add(2, 3)</code>, then <code>2, 3</code> are the arguments. Note that variables from the calling context can be arguments: if the subroutine is called as <code>a = 2; b = 3; add(a, b)</code> then the <i>variables</i> <code>a, b</code> are the arguments, not only the <i>values</i> <code>2, 3</code>. See the <a href="#Parameters_and_arguments">Parameters and arguments</a> section for more information.</p>
<p>In the most common case, <a href="/wiki/Call_by_value" title="Call by value" class="mw-redirect">call by value</a>, a parameter acts within the subroutine as a variable initialized to the value of the argument (a <a href="/wiki/Local_variable" title="Local variable">local</a> (isolated) copy of the argument if the argument is a variable), but in other cases, e.g. <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a>, the argument supplied by the caller can be affected by actions within the called subroutine (as discussed in <a href="/wiki/Evaluation_strategy" title="Evaluation strategy">evaluation strategy</a>). In call by value, one can thus think of arguments as values (properly, think of the <i>value</i> of arguments as the "arguments" themselves), but in general arguments are not simply values.</p>
<p>The semantics for how parameters can be declared and how the arguments get passed to the parameters of subroutines are defined by the language, but the details of how this is represented in any particular computer system depend on the <a href="/wiki/Calling_convention" title="Calling convention">calling conventions</a> of that system.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Example"><span class="tocnumber">1</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Parameters_and_arguments"><span class="tocnumber">2</span> <span class="toctext">Parameters and arguments</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Alternative_convention_in_Eiffel"><span class="tocnumber">2.1</span> <span class="toctext">Alternative convention in Eiffel</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Datatypes"><span class="tocnumber">3</span> <span class="toctext">Datatypes</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Argument_passing"><span class="tocnumber">4</span> <span class="toctext">Argument passing</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Default_arguments"><span class="tocnumber">4.1</span> <span class="toctext">Default arguments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Variable-length_parameter_lists"><span class="tocnumber">4.2</span> <span class="toctext">Variable-length parameter lists</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Named_parameters"><span class="tocnumber">4.3</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Multiple_parameters_in_functional_languages"><span class="tocnumber">4.4</span> <span class="toctext">Multiple parameters in functional languages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Output_parameters"><span class="tocnumber">5</span> <span class="toctext">Output parameters</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Use"><span class="tocnumber">5.1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Drawbacks"><span class="tocnumber">5.2</span> <span class="toctext">Drawbacks</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Alternatives"><span class="tocnumber">5.3</span> <span class="toctext">Alternatives</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Notes"><span class="tocnumber">7</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Alternative_convention_in_Eiffel"><span class="tocnumber">2.1</span> <span class="toctext">Alternative convention in Eiffel</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Default_arguments"><span class="tocnumber">4.1</span> <span class="toctext">Default arguments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Variable-length_parameter_lists"><span class="tocnumber">4.2</span> <span class="toctext">Variable-length parameter lists</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Named_parameters"><span class="tocnumber">4.3</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Multiple_parameters_in_functional_languages"><span class="tocnumber">4.4</span> <span class="toctext">Multiple parameters in functional languages</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Use"><span class="tocnumber">5.1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Drawbacks"><span class="tocnumber">5.2</span> <span class="toctext">Drawbacks</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Alternatives"><span class="tocnumber">5.3</span> <span class="toctext">Alternatives</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following program in the <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> programming language defines a function that is named "sales_tax" and has one parameter named "price". The type of price is "double" (i.e. a <a href="/wiki/Floating_point" title="Floating point">double-precision floating point</a> number). The function's return type is also a double.</p>
<p>WHATSON? f5310ca4-ed37-4b2a-a7de-c947fc0c005d</p>
<pre class="de1">
<span class="kw4">double</span> sales_tax<span class="br0">(</span><span class="kw4">double</span> price<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="nu16">0.05</span> <span class="sy0">*</span> price<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>After the function has been defined, it can be invoked as follows:</p>
<p>WHATSON? 7cc01452-328f-47c4-8257-bf40a31f3d4c</p>
<pre class="de1">
sales_tax<span class="br0">(</span><span class="nu16">10.00</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>In this example, the function has been invoked with the number 10.00. When this happens, 10.00 will be assigned to price, and the function begins calculating its result. The steps for producing the result are specified below enclosed in {} "0.05 * price" indicates that the first thing to do is multiply 0.05 by the value of price, which gives 0.50. "return" means the function will produce the result of "0.05 * price". Therefore, the final result is 0.50.</p>
<h2><span class="mw-headline" id="Parameters_and_arguments">Parameters and arguments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: Parameters and arguments">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The terms <i>parameter</i> and <i>argument</i> are sometimes loosely used interchangeably, and the context is used to distinguish the meaning. The term <i>parameter</i> (sometimes called <i>formal parameter</i>) is often used to refer to the variable as found in the function definition, while <i>argument</i> (sometimes called <i>actual parameter</i>) refers to the actual input passed. For example, if one defines a function as <code>def f(x): ...</code>, then <code>x</code> is the parameter, while if it called by <code>a = ...; f(a)</code> then <code>a</code> is the argument. In both cases a parameter is an (unbound) variable, while the argument can be thought of as a value or variable, depending on the calling convention. In case of call by value, one can think of the argument as a value (properly, as the <i>value</i> of the argument) – for example, <code>f(2)</code> and <code>a = 2; f(a)</code> are equivalent calls – while in call by reference one can think of the argument as a variable in the calling context.</p>
<p>Parameters appear in procedure definitions; arguments appear in procedure calls. In the function definition <code>f(x) = x*x</code> the variable <var>x</var> is a parameter; in the function call <code>f(2)</code> the value 2 is the argument of the function. Loosely, a parameter is a type, and an argument is an instance.</p>
<p>A parameter is an intrinsic property of the procedure, included in its definition. For example, in many languages, a procedure to add two supplied integers together and calculate the sum would need two parameters, one for each integer. In general, a procedure may be defined with any number of parameters, or no parameters at all. If a procedure has parameters, the part of its definition that specifies the parameters is called its <i>parameter list</i>.</p>
<p>By contrast, the arguments are the values supplied to the procedure when it is called. Unlike the parameters, which form an unchanging part of the procedure's definition, the arguments may vary from call to call. Each time a procedure is called, the part of the procedure call that specifies the arguments is called the <i>argument list</i>.</p>
<p>Although parameters are also commonly referred to as arguments, arguments are more properly thought of as the actual values or references assigned to the parameter variables when the subroutine is called at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run-time</a>. When discussing code that is calling into a subroutine, any values or references passed into the subroutine are the arguments, and the place in the code where these values or references are given is the <i>parameter list</i>. When discussing the code inside the subroutine definition, the variables in the subroutine's parameter list are the parameters, while the values of the parameters at runtime are the arguments. For example in C, when dealing with threads it's common to pass in an argument of type void* and cast it to an expected type:</p>
<p>WHATSON? ed842fc7-9626-449e-9b4b-6bb1c22f0560</p>
<pre class="de1">
<span class="kw4">void</span> ThreadFunction<span class="br0">(</span> <span class="kw4">void</span><span class="sy0">*</span> pThreadArgument <span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Naming the first parameter 'pThreadArgument' is correct, rather than</span>
    <span class="co1">// 'pThreadParameter'. At run time the value we use is an argument. As mentioned</span>
    <span class="co1">// above, reserve the term parameter for when discussing subroutine definitions.</span>
<span class="br0">}</span>
</pre>
<p>To better understand the difference, consider the following function written in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>:</p>
<p>WHATSON? 98ab4ed3-2086-469a-9b56-6d22b7c75c0a</p>
<pre class="de1">
<span class="kw4">int</span> sum<span class="br0">(</span><span class="kw4">int</span> addend1<span class="sy0">,</span> <span class="kw4">int</span> addend2<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> addend1 <span class="sy0">+</span> addend2<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>The function <i>sum</i> has two parameters, named <i>addend1</i> and <i>addend2</i>. It adds the values passed into the parameters, and returns the result to the subroutine's caller (using a technique automatically supplied by the C compiler).</p>
<p>The code which calls the <i>sum</i> function might look like this:</p>
<p>WHATSON? acc655d2-bcc5-4eb8-b377-fbd0c11d0e79</p>
<pre class="de1">
<span class="kw4">int</span> sumValue<span class="sy0">;</span>
<span class="kw4">int</span> value1 <span class="sy0">=</span> <span class="nu0">40</span><span class="sy0">;</span>
<span class="kw4">int</span> value2 <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
 
sumValue <span class="sy0">=</span> sum<span class="br0">(</span>value1<span class="sy0">,</span> value2<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The variables <i>value1</i> and <i>value2</i> are initialized with values. <i>value1</i> and <i>value2</i> are both arguments to the <i>sum</i> function in this context.</p>
<p>At runtime, the values assigned to these variables are passed to the function <i>sum</i> as arguments. In the <i>sum</i> function, the parameters <i>addend1</i> and <i>addend2</i> are evaluated, yielding the arguments 40 and 2, respectively. The values of the arguments are added, and the result is returned to the caller, where it is assigned to the variable <i>sumValue</i>.</p>
<p>Because of the difference between parameters and arguments, it is possible to supply inappropriate arguments to a procedure. The call may supply too many or too few arguments; one or more of the arguments may be a wrong type; or arguments may be supplied in the wrong order. Any of these situations causes a mismatch between the parameter and argument lists, and the procedure will often return an unintended answer or generate a <a href="/wiki/Runtime_error" title="Runtime error" class="mw-redirect">runtime error</a>.</p>
<h3><span class="mw-headline" id="Alternative_convention_in_Eiffel">Alternative convention in Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Alternative convention in Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Within the <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> software development method and language, the terms <i>argument</i> and <i>parameter</i> have distinct uses established by convention. The term <i>argument</i> is used exclusively in reference to a routine's inputs,<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>1<span>]</span></a></sup> and the term <i>parameter</i> is used exclusively in type parameterization for <a href="/wiki/Generic_programming" title="Generic programming">generic classes</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>2<span>]</span></a></sup></p>
<p>Consider the following routine definition:</p>
<p>WHATSON? 6232e16c-e7e6-44e8-91e5-c9407c8e8a27</p>
<pre class="de1">
    sum <span class="br0">(</span>addend1<span class="sy0">:</span> <span class="kw4">INTEGER</span>; addend2<span class="sy0">:</span> <span class="kw4">INTEGER</span><span class="br0">)</span><span class="sy0">:</span> <span class="kw4">INTEGER</span>
        <span class="kw2">do</span>
            <span class="kw3">Result</span> <span class="sy0">:=</span> addend1 <span class="sy0">+</span> addend2
        <span class="kw2">end</span>
</pre>
<p>The routine <code>sum</code> takes two arguments <code>addend1</code> and <code>addend2</code>, which are called the routine's <b>formal arguments</b>. A call to <code>sum</code> specifies <b>actual arguments</b>, as shown below with <code>value1</code> and <code>value2</code>.</p>
<p>WHATSON? 05c4bfea-2b25-4e30-b37b-4d2033b6ffac</p>
<pre class="de1">
    sum_value<span class="sy0">:</span> <span class="kw4">INTEGER</span>
    value1<span class="sy0">:</span> <span class="kw4">INTEGER</span> <span class="sy0">=</span> <span class="nu0">40</span>
    value2<span class="sy0">:</span> <span class="kw4">INTEGER</span> <span class="sy0">=</span> <span class="nu0">2</span>
                …
            sum_value <span class="sy0">:=</span> sum <span class="br0">(</span>value1, value2<span class="br0">)</span>
</pre>
<p>Parameters are also thought of as either <b>formal</b> or <b>actual</b>. <b>Formal generic parameters</b> are used in the definition of generic classes. In the example below, the class <code>HASH_TABLE</code> is declared as a generic class which has two formal generic parameters, <code>G</code> representing data of interest and <code>K</code> representing the hash key for the data:</p>
<p>WHATSON? 45f5d08c-1614-48fa-a189-2684cab96da7</p>
<pre class="de1">
<span class="kw1">class</span> <span class="kw4">HASH_TABLE</span> <span class="br0">[</span>G, K <span class="sy0">-&gt;</span> <span class="kw4">HASHABLE</span><span class="br0">]</span> 
            …
</pre>
<p>When a class becomes a client to <code>HASH_TABLE</code>, the formal generic parameters are substituted with <b>actual generic parameters</b> in a <b>generic derivation</b>. In the following attribute declaration, <code>my_dictionary</code> is to be used as a character string based <a href="/wiki/Associative_array" title="Associative array">dictionary</a>. As such, both data and key formal generic parameters are substituted with actual generic parameters of type <code>STRING</code>.</p>
<p>WHATSON? a5d3c512-becd-40fd-a8ae-a5072493a0c9</p>
<pre class="de1">
    my_dictionary<span class="sy0">:</span> <span class="kw4">HASH_TABLE</span> <span class="br0">[</span><span class="kw4">STRING</span>, <span class="kw4">STRING</span><span class="br0">]</span>
</pre>
<h2><span class="mw-headline" id="Datatypes">Datatypes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: Datatypes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Strongly_typed_programming_language" title="Strongly typed programming language" class="mw-redirect">strongly typed programming languages</a>, each parameter's <a href="/wiki/Datatype" title="Datatype" class="mw-redirect">type</a> must be specified in the procedure's declaration. Languages using <a href="/wiki/Type_inference" title="Type inference">type inference</a> attempt to discover the types automatically from the function's body and usage. Dynamically typed programming languages defer type resolution until run-time. Weakly typed languages perform little to no type resolution, relying instead on the programmer for correctness.</p>
<p>Some languages use a special keyword (e.g. <i>void</i>) to indicate that the subroutine has no parameters; in formal <a href="/wiki/Type_theory" title="Type theory">type theory</a>, such functions take an empty parameter list (whose type is not <i>void</i>, but rather <i><a href="/wiki/Unit_type" title="Unit type">unit</a></i>).</p>
<h2><span class="mw-headline" id="Argument_passing">Argument passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: Argument passing">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The exact mechanism for assigning arguments to parameters, called <i>argument passing</i>, depends upon the <a href="/wiki/Evaluation_strategy" title="Evaluation strategy">evaluation strategy</a> used for that parameter (typically call by value), which may be specified using keywords.</p>
<h3><span class="mw-headline" id="Default_arguments">Default arguments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: Default arguments">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some programming languages such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/Clojure" title="Clojure">Clojure</a>, <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>, <a href="/wiki/Fortran_90" title="Fortran 90" class="mw-redirect">Fortran 90</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a>, <a href="/wiki/Tcl_(programming_language)" title="Tcl (programming language)" class="mw-redirect">Tcl</a>, and <a href="/wiki/Windows_PowerShell" title="Windows PowerShell">Windows PowerShell</a> allow for a <a href="/wiki/Default_argument" title="Default argument">default argument</a> to be explicitly or implicitly given in a subroutine's declaration. This allows the caller to omit that argument when calling the subroutine. If the default argument is explicitly given, then that value is used if it is not provided by the caller. If the default argument is implicit (sometimes by using a keyword such as <i>Optional</i>) then the language provides a well-known value (such as <i><a href="/wiki/Null_pointer" title="Null pointer" class="mw-redirect">null</a></i>, <i>Empty</i>, zero, an empty string, etc.) if a value is not provided by the caller.</p>
<p>PowerShell example:</p>
<p>WHATSON? c58e796c-ea49-403a-b12d-97e9ca7b06b8</p>
<pre class="de1">
 <span class="kw3">function</span> doc<span class="br0">(</span><span class="re0">$g</span> <span class="sy0">=</span> <span class="nu0">1.21</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="st0">"$g gigawatts? $g gigawatts? Great Scott!"</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? dd908b9f-13d2-449e-a0a4-88dfb4edba67</p>
<pre>
<b>PS&gt;</b> doc
1.21 gigawatts? 1.21 gigawatts? Great Scott!
</pre>
<p>WHATSON? fad59b9a-786d-45f7-b1df-a6edb4f0c234</p>
<pre>
<b>PS&gt;</b> doc 88
88 gigawatts? 88 gigawatts? Great Scott!
</pre>
<p>Default arguments can be seen as a special case of the variable-length argument list.</p>
<h3><span class="mw-headline" id="Variable-length_parameter_lists">Variable-length parameter lists</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: Variable-length parameter lists">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages allow subroutines to be defined to accept a <a href="/wiki/Variadic_function" title="Variadic function">variable number of arguments</a>. For such languages, the subroutines must iterate through the list of arguments.</p>
<p>PowerShell example:</p>
<p>WHATSON? 772a40f9-7383-4cf6-a74c-d98f6ef53e33</p>
<pre class="de1">
 <span class="kw3">function</span> marty <span class="br0">{</span>
   <span class="kw6">$args</span> <span class="sy0">|</span> <span class="kw3">foreach</span> <span class="br0">{</span> <span class="st0">"back to the year $_"</span> <span class="br0">}</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? 1c5b7f3a-8b89-4c5f-9e29-6d8d46d0d01d</p>
<pre>
<b>PS&gt;</b> marty 1985
back to the year 1985
</pre>
<p>WHATSON? 6a9b4214-4a5b-4514-95c5-7a214d0a2e00</p>
<pre>
<b>PS&gt;</b> marty 2015 1985 1955
back to the year 2015
back to the year 1985
back to the year 1955
</pre>
<h3><span class="mw-headline" id="Named_parameters">Named parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=8" title="Edit section: Named parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some programming languages—such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a> and <a href="/wiki/Windows_PowerShell" title="Windows PowerShell">Windows PowerShell</a>—allow subroutines to have <a href="/wiki/Named_parameter" title="Named parameter">named parameters</a>. This allows the calling code to be more <a href="/wiki/Self-documenting" title="Self-documenting">self-documenting</a>. It also provides more flexibility to the caller, often allowing the order of the arguments to be changed, or for arguments to be omitted as needed.</p>
<p>PowerShell example:</p>
<p>WHATSON? f4f8ad68-dd88-412b-8edd-991d93229635</p>
<pre class="de1">
 <span class="kw3">function</span> jennifer<span class="br0">(</span><span class="re0">$adjectiveYoung</span><span class="sy0">,</span> <span class="re0">$adjectiveOld</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="st0">"Young Jennifer: I'm $adjectiveYoung!"</span>
   <span class="st0">"Old Jennifer: I'm $adjectiveOld!"</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? 209467c3-047e-414f-9300-03497bfaad8e</p>
<pre>
<b>PS&gt;</b> jennifer 'fresh' 'experienced'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<p>WHATSON? dc5b6b51-6c59-4cdf-be3d-4bff99d6c0c3</p>
<pre>
<b>PS&gt;</b> jennifer -adjectiveOld 'experienced' -adjectiveYoung 'fresh'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<h3><span class="mw-headline" id="Multiple_parameters_in_functional_languages">Multiple parameters in functional languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=9" title="Edit section: Multiple parameters in functional languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>, each function has exactly one parameter. What is thought of as functions with multiple parameters is usually represented in lambda calculus as a function which takes the first argument, and returns a function which takes the rest of the arguments; this is a transformation known as <a href="/wiki/Currying" title="Currying">currying</a>. Some programming languages, like <a href="/wiki/ML_(programming_language)" title="ML (programming language)">ML</a> and <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, follow this scheme. In these languages, every function has exactly one parameter, and what may look like the definition of a function of multiple parameters, is actually <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> for the definition of a function that returns a function, etc. Function application is <a href="/wiki/Operator_associativity" title="Operator associativity">left-associative</a> in these languages as well as in lambda calculus, so what looks like an application of a function to multiple arguments is correctly evaluated as the function applied to the first argument, then the resulting function applied to the second argument, etc.</p>
<h2><span class="mw-headline" id="Output_parameters">Output parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=10" title="Edit section: Output parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An <b>output parameter</b>, also known as an <b>out parameter</b> or <b>return parameter</b>, is a parameter used for output, rather than the more usual use for input. Using <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a> parameters, or call by value parameters where the value is a reference, as output parameters is an idiom in some languages, notably C and C++,<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>b<span>]</span></a></sup> while other languages have built-in support for output parameters. Languages with built-in support for output parameters include <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a><sup id="cite_ref-ada_5-0" class="reference"><a href="#cite_note-ada-5"><span>[</span>3<span>]</span></a></sup> (see <a href="//en.wikibooks.org/wiki/Ada_Programming/Subprograms" class="extiw" title="b:Ada Programming/Subprograms">Ada subprograms</a>), <a href="/wiki/Fortran" title="Fortran">Fortran</a> (since <a href="/wiki/Fortran_90" title="Fortran 90" class="mw-redirect">Fortran 90</a>; see <a href="//en.wikibooks.org/wiki/Fortran/Fortran_procedures_and_functions#Intent" class="extiw" title="b:Fortran/Fortran procedures and functions">Fortran "intent"</a>), various procedural extensions to <a href="/wiki/SQL" title="SQL">SQL</a>, such as <a href="/wiki/PL/SQL" title="PL/SQL">PL/SQL</a> (see <a href="/wiki/PL/SQL#Functions" title="PL/SQL">PL/SQL functions</a>)<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>4<span>]</span></a></sup> and <a href="/wiki/Transact-SQL" title="Transact-SQL">Transact-SQL</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a><sup id="cite_ref-hallam_7-0" class="reference"><a href="#cite_note-hallam-7"><span>[</span>5<span>]</span></a></sup> and the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>,<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>6<span>]</span></a></sup> and the scripting language <a href="/wiki/TScript" title="TScript">TScript</a> (see <a href="/wiki/TScript#Function_declarations" title="TScript">TScript function declarations</a>).</p>
<p>More precisely, one may distinguish three types of parameters or <b>parameter modes</b>: <i><span id="input_parameter">input parameter</span>s</i>, <i>output parameters,</i> and <i><span id="input.2Foutput_parameter">input/output parameter</span>s;</i> these are often denoted <code>in</code>, <code>out</code>, and <code>in out</code> or <code>inout</code>. An input argument (the argument to an input parameter) must be a value, such as an initialized variable or literal, and must not be redefined or assigned to; an output argument must be an assignable variable, but it need not be initialized, any existing value is not accessible, and must be assigned a value; and an input/output argument must be an initialized, assignable variable, and can optionally be assigned a value. The exact requirements and enforcement vary between languages – for example, in <a href="/wiki/Ada_83" title="Ada 83" class="mw-redirect">Ada 83</a> output parameters can only be assigned to, not read, even after assignment (this was removed in <a href="/wiki/Ada_95" title="Ada 95" class="mw-redirect">Ada 95</a> to remove the need for an auxiliary accumulator variable). These are analogous to the notion of a <a href="/wiki/Value_(computer_science)" title="Value (computer science)">value</a> in an expression being an r-value (has a value), an l-value (can be assigned), or an r-value/l-value (has a value and can be assigned), respectively, though these terms have specialized meanings in C.</p>
<p>In some cases only input and input/output are distinguished, with output being considered a specific use of input/output, and in other cases only input and output (but not input/output) are supported. The default mode varies between languages: in Fortran 90 input/output is default, while in C# and SQL extensions input is default, and in TScript each parameter is explicitly specified as input or output.</p>
<p>Syntactically, parameter mode is generally indicated with a keyword in the function declaration, such as <code>void f(out int x)</code> in C#. Conventionally output parameters are often put at the end of the parameter list to clearly distinguish them, though this is not always followed. TScript uses a different approach, where in the function declaration input parameters are listed, then output parameters, separated by a colon (:) and there is no return type to the function itself, as in this function, which computes the size of a text fragment:</p>
<p>WHATSON? f8af5c4e-e057-46c7-94ff-3310d379885e</p>
<pre class="de1">
 TextExtent<span class="br0">(</span>WString text, Font font <span class="sy4">:</span> Integer width, Integer height<span class="br0">)</span>
</pre>
<p>Parameter modes are a form of <a href="/wiki/Denotational_semantics" title="Denotational semantics">denotational semantics</a>, stating the programmer's intent and allowing compilers to catch errors and apply optimizations – they do not necessarily imply <a href="/wiki/Operational_semantics" title="Operational semantics">operational semantics</a> (how the parameter passing actually occurs). Notably, while input parameters can be implemented by call by value, and output and input/output parameters by call by reference – and this is a straightforward way to implement these modes in languages without built-in support – this is not always how they are implemented. This distinction is discussed in detail in the <i>Ada '83 Rationale,</i> which emphasizes that the parameter mode is abstracted from which parameter passing mechanism (by reference or by copy) is actually implemented.<sup id="cite_ref-ada_5-1" class="reference"><a href="#cite_note-ada-5"><span>[</span>3<span>]</span></a></sup> For instance, while in C# input parameters (default, no keyword) are passed by value, and output and input/output parameters (<code>out</code> and <code>ref</code>) are passed by reference, in PL/SQL input parameters (<code>IN</code>) are passed by reference, and output and input/output parameters (<code>OUT</code> and <code>IN OUT</code>) are by default passed by value and the result copied back, but can be passed by reference by using the <code>NOCOPY</code> compiler hint.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>7<span>]</span></a></sup></p>
<p>A syntactically similar construction to output parameters is to assign the <a href="/wiki/Return_value" title="Return value" class="mw-redirect">return value</a> to a variable with the same name as the function. This is found in <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a> and <a href="/wiki/Fortran_66" title="Fortran 66" class="mw-redirect">Fortran 66</a> and <a href="/wiki/Fortran_77" title="Fortran 77" class="mw-redirect">Fortran 77</a>, as in this Pascal example:</p>
<p>WHATSON? 80936467-838f-470e-add8-6d6dde123fb8</p>
<pre class="de1">
<span class="kw1">function</span> f<span class="br0">(</span>x<span class="sy1">,</span> y<span class="sy1">:</span> <span class="kw4">integer</span><span class="br0">)</span><span class="sy1">:</span> <span class="kw4">integer</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    f <span class="sy1">:</span><span class="sy3">=</span> x <span class="sy3">+</span> y<span class="sy1">;</span>
<span class="kw1">end</span><span class="sy1">;</span>
</pre>
<p>This is semantically different in that when called, the function is simply evaluated – it is not passed a variable from the calling scope to store the output in.</p>
<h3><span class="mw-headline" id="Use">Use</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=11" title="Edit section: Use">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The primary use of output parameters is to return multiple values from a function, while the use of input/output parameters is to modify state using parameter passing (rather than by shared environment, as in global variables). An important use of returning multiple values is to solve the <a href="/wiki/Semipredicate_problem" title="Semipredicate problem">semipredicate problem</a> of returning both a value and an error status – see <a href="/wiki/Semipredicate_problem#Multivalued_return" title="Semipredicate problem">Semipredicate problem: Multivalued return</a>.</p>
<p>For example, to return two variables from a function in C, one may write:</p>
<p>WHATSON? 3dee6b22-a512-4b3f-91dd-0d80c839e3fd</p>
<pre class="de1">
<span class="kw4">int</span> width<span class="sy0">,</span> height<span class="sy0">;</span>
f<span class="br0">(</span>x<span class="sy0">,</span> <span class="sy0">&amp;</span>width<span class="sy0">,</span> <span class="sy0">&amp;</span>height<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>where <code>x</code> is an input parameter and <code>width</code> and <code>height</code> are output parameters, passed by reference.</p>
<p>A common use case in C and related languages is for <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a>, where a function places the return value in an output variable, and returns a boolean corresponding to whether the function succeeded or not. An archetypal example is the <code>TryParse</code> method in .NET, especially C#, which parses a string into an integer, returning <code>true</code> on success and <code>false</code> on failure. This has the following signature:<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>8<span>]</span></a></sup></p>
<p>WHATSON? 576b768c-47aa-4b55-b238-82583678f22c</p>
<pre class="de1">
<span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">bool</span> TryParse<span class="br0">(</span><span class="kw4">string</span> s, <span class="kw1">out</span> <span class="kw4">int</span> result<span class="br0">)</span>
</pre>
<p>and may be used as follows:</p>
<p>WHATSON? 76d13ba9-68f6-441e-9dd4-7ae86a2b01be</p>
<pre class="de1">
<span class="kw4">int</span> result<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>Int32<span class="sy0">.</span><span class="me1">TryParse</span><span class="br0">(</span>s, result<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// exception handling</span>
<span class="br0">}</span>
</pre>
<p>Similar considerations apply to returning a value of one of several possible types, where the return value can specify the type and then value is stored in one of several output variables.</p>
<p>Another use is as a micro-optimization, to avoid assigning a local variable in a function and then needing to copy it when returning. This can be done when output parameters are implemented by <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a>. For example, in C++, instead of the more usual:</p>
<p>WHATSON? f08fe5c3-27d4-4a2c-80ca-dc96d2ea749d</p>
<pre class="de1">
LargeObject obj <span class="sy1">=</span> f<span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>one might instead write:</p>
<p>WHATSON? a4e0f3d4-1356-46b5-abe5-54a2fbfcceaf</p>
<pre class="de1">
LargeObject obj<span class="sy4">;</span>
f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>so the function <code>f</code> does not need to assign space for the object or copy it on returning.</p>
<h3><span class="mw-headline" id="Drawbacks">Drawbacks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=12" title="Edit section: Drawbacks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Output parameters are often discouraged in modern programming, essentially as being awkward, confusing, and too low-level – commonplace return values are considerably easier to understand and work with.<sup id="cite_ref-CA1021_11-0" class="reference"><a href="#cite_note-CA1021-11"><span>[</span>9<span>]</span></a></sup> Notably, output parameters involve functions with side effects (modifying the output parameter) and are semantically similar to references, which are more confusing than pure functions and values, and the distinction between output parameters and input/output parameters can be subtle. Further, since in common programming styles most parameters are simply input parameters, output parameters and input/output parameters are unusual and hence susceptible to misunderstanding.</p>
<p>Output and input/output parameters prevent function composition, since the output is stored in variables, rather than in the value of an expression. Thus one must initially declare a variable, and then each step of a chain of functions must be a separate statement. For example, in C++ the following function composition:</p>
<p>WHATSON? 18a768df-0dbc-4e63-90f7-df858e1525c5</p>
<pre class="de1">
Object obj <span class="sy1">=</span> g<span class="br0">(</span>y, f<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>when written with output and input/output parameters instead becomes (for <code>f</code> it is an output parameter, for <code>g</code> an input/output parameter):</p>
<p>WHATSON? 0f0567f3-b7ee-4fae-b3ce-298f3feabbd7</p>
<pre class="de1">
Object obj<span class="sy4">;</span>
f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
g<span class="br0">(</span>y, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>In the special case of a function with a single output or input/output parameter and no return value, function composition is possible if the output or input/output parameter (or in C/C++, its address) is also returned by the function, in which case the above becomes:</p>
<p>WHATSON? 087f2add-4ef8-4fb3-9e12-7527e0d323cd</p>
<pre class="de1">
Object obj<span class="sy4">;</span>
g<span class="br0">(</span>y, f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<h3><span class="mw-headline" id="Alternatives">Alternatives</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=13" title="Edit section: Alternatives">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There are various alternatives to the use cases of output parameters.</p>
<p>For returning multiple values from a function, an alternative is to return a <a href="/wiki/Tuple" title="Tuple">tuple</a>. Syntactically this is clearer if automatic sequence unpacking and <a href="/wiki/Parallel_assignment" title="Parallel assignment" class="mw-redirect">parallel assignment</a> can be used, as in <a href="/wiki/Go_(programming_language)" title="Go (programming language)">Go</a> or Python, such as:</p>
<p>WHATSON? 42dc0835-c8c9-4d33-97ad-90eac30da1fe</p>
<pre class="de1">
<span class="kw1">def</span> f<span class="br0">(</span><span class="br0">)</span>:
    <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span>
a<span class="sy0">,</span> b <span class="sy0">=</span> f<span class="br0">(</span><span class="br0">)</span>
</pre>
<p>For returning a value of one of several types, a <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a> can be used instead; the most common cases are <a href="/wiki/Nullable_type" title="Nullable type">nullable types</a> (<a href="/wiki/Option_type" title="Option type">option types</a>), where the return value can be null to indicate failure. For exception handling, one can return a nullable type, or raise an exception. For example, in Python one might have either:</p>
<p>WHATSON? b3a23756-d518-4bb3-80ab-688a2596be99</p>
<pre class="de1">
result <span class="sy0">=</span> Parse<span class="br0">(</span>s<span class="br0">)</span>
<span class="kw1">if</span> result <span class="kw1">is</span> <span class="kw2">None</span>:
    <span class="co1"># exception handling</span>
</pre>
<p>or, more idiomatically:</p>
<p>WHATSON? 58600591-904e-4e9e-8998-b5b1f7b25f30</p>
<pre class="de1">
<span class="kw1">try</span>:
    result <span class="sy0">=</span> Parse<span class="br0">(</span>s<span class="br0">)</span>
<span class="kw1">except</span> ParseError:
    <span class="co1"># exception handling</span>
</pre>
<p>The micro-optimization of not requiring a local variable and copying the return when using output variables can also be applied to conventional functions and return values by sufficiently sophisticated compilers.</p>
<p>The usual alternative to output parameters in C and related languages is to return a single data structure containing all return values.<sup id="cite_ref-hallam_7-1" class="reference"><a href="#cite_note-hallam-7"><span>[</span>5<span>]</span></a></sup> For example, given a structure encapsulating width and height, one can write:</p>
<p>WHATSON? 3e2f720f-c5cf-4b78-9207-1ff3dba18828</p>
<pre class="de1">
WidthHeight width_and_height <span class="sy0">=</span> f<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>In object-oriented languages, instead of using input/output parameters, one can often use <a href="/wiki/Call_by_sharing" title="Call by sharing" class="mw-redirect">call by sharing</a>, passing a reference to an object and then mutating the object, though not changing which object the variable refers to.<sup id="cite_ref-CA1021_11-1" class="reference"><a href="#cite_note-CA1021-11"><span>[</span>9<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=14" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Command-line_argument" title="Command-line argument" class="mw-redirect">Command-line argument</a></li>
<li><a href="/wiki/Evaluation_strategy" title="Evaluation strategy">Evaluation strategy</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Free_variables_and_bound_variables" title="Free variables and bound variables">Free variables and bound variables</a></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=15" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">In this article, the term "subroutine" refers to any subroutine-like construct, which have different names and slightly different meanings depending on the <a href="/wiki/Programming_language" title="Programming language">programming language</a> being discussed.</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">C and C++ are call by value, but if type is a reference (a C/C++ pointer or C++ reference), then setting the value of the reference can be used to produce call by reference style behavior.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=16" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Meyer, Bertrand. <i><a href="/wiki/Object-Oriented_Software_Construction" title="Object-Oriented Software Construction">Object-Oriented Software Construction</a>, 2nd Edition,</i> Prentice Hall, 1997, p 444.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Meyer, p. 96.</span></li>
<li id="cite_note-ada-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-ada_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-ada_5-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://archive.adaic.com/standards/83rat/html/ratl-08-02.html">8.2 Parameter Modes</a>, "<a rel="nofollow" class="external text" href="http://archive.adaic.com/standards/83rat/html/Welcome.html">Rationale for the Design of the Ada® Programming Language</a>"</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://docs.oracle.com/cd/B10500_01/appdev.920/a96624/08_subs.htm#895">8. PL/SQL Subprograms: Specifying Subprogram Parameter Modes</a></span></li>
<li id="cite_note-hallam-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-hallam_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-hallam_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Peter Hallam. <a rel="nofollow" class="external text" href="http://web.archive.org/web/20110926113834/http://msdn.microsoft.com/en-us/vcsharp/aa336814.aspx">"Why does C# have both 'ref' and 'out'?"</a>. Archived from <a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/vcsharp/aa336814.aspx">the original</a> on 2011-09-26.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AParameter+%28computer+programming%29&amp;rft.aulast=Peter+Hallam&amp;rft.au=Peter+Hallam&amp;rft.btitle=Why+does+C%23+have+both+%27ref%27+and+%27out%27%3F&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Fvcsharp%2Faa336814.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/system.data.parameterdirection.aspx">ParameterDirection Enumeration</a></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://docs.oracle.com/cd/B10500_01/appdev.920/a96624/08_subs.htm#12813">8. PL/SQL Subprograms: Passing Large Data Structures with the NOCOPY Compiler Hint</a></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/f02979c7.aspx">Int32.TryParse Method (String, Int32)</a></span></li>
<li id="cite_note-CA1021-11"><span class="mw-cite-backlink">^ <a href="#cite_ref-CA1021_11-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-CA1021_11-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/ms182131.aspx">CA1021: Avoid out parameters</a></span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Parameter (computer programming)</span></h1>
<p>In <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>, a <b>parameter</b> is a special kind of <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variable</a>, used in a <a href="/wiki/Subroutine" title="Subroutine">subroutine</a> to refer to one of the pieces of data provided as input to the subroutine.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>a<span>]</span></a></sup> These pieces of data are called <b>arguments</b>. An ordered list of parameters is usually included in the definition of a subroutine, so that, each time the subroutine is called, its arguments for that call can be assigned to the corresponding parameters.</p>
<p>Just as in standard mathematical usage, the <i>argument</i> is thus the actual input passed to a function, procedure, or routine, whereas the <i>parameter</i> is the variable inside the implementation of the subroutine. For example, if one defines the <code>add</code> subroutine as <code>def add(x, y): return x + y</code>, then <code>x, y</code> are parameters, while if this is called as <code>add(2, 3)</code>, then <code>2, 3</code> are the arguments. Note that variables from the calling context can be arguments: if the subroutine is called as <code>a = 2; b = 3; add(a, b)</code> then the <i>variables</i> <code>a, b</code> are the arguments, not only the <i>values</i> <code>2, 3</code>. See the <a href="#Parameters_and_arguments">Parameters and arguments</a> section for more information.</p>
<p>In the most common case, <a href="/wiki/Call_by_value" title="Call by value" class="mw-redirect">call by value</a>, a parameter acts within the subroutine as a variable initialized to the value of the argument (a <a href="/wiki/Local_variable" title="Local variable">local</a> (isolated) copy of the argument if the argument is a variable), but in other cases, e.g. <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a>, the argument supplied by the caller can be affected by actions within the called subroutine (as discussed in <a href="/wiki/Evaluation_strategy" title="Evaluation strategy">evaluation strategy</a>). In call by value, one can thus think of arguments as values (properly, think of the <i>value</i> of arguments as the "arguments" themselves), but in general arguments are not simply values.</p>
<p>The semantics for how parameters can be declared and how the arguments get passed to the parameters of subroutines are defined by the language, but the details of how this is represented in any particular computer system depend on the <a href="/wiki/Calling_convention" title="Calling convention">calling conventions</a> of that system.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Example"><span class="tocnumber">1</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Parameters_and_arguments"><span class="tocnumber">2</span> <span class="toctext">Parameters and arguments</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Alternative_convention_in_Eiffel"><span class="tocnumber">2.1</span> <span class="toctext">Alternative convention in Eiffel</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Datatypes"><span class="tocnumber">3</span> <span class="toctext">Datatypes</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Argument_passing"><span class="tocnumber">4</span> <span class="toctext">Argument passing</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Default_arguments"><span class="tocnumber">4.1</span> <span class="toctext">Default arguments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Variable-length_parameter_lists"><span class="tocnumber">4.2</span> <span class="toctext">Variable-length parameter lists</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Named_parameters"><span class="tocnumber">4.3</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Multiple_parameters_in_functional_languages"><span class="tocnumber">4.4</span> <span class="toctext">Multiple parameters in functional languages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Output_parameters"><span class="tocnumber">5</span> <span class="toctext">Output parameters</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Use"><span class="tocnumber">5.1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Drawbacks"><span class="tocnumber">5.2</span> <span class="toctext">Drawbacks</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Alternatives"><span class="tocnumber">5.3</span> <span class="toctext">Alternatives</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Notes"><span class="tocnumber">7</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Alternative_convention_in_Eiffel"><span class="tocnumber">2.1</span> <span class="toctext">Alternative convention in Eiffel</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Default_arguments"><span class="tocnumber">4.1</span> <span class="toctext">Default arguments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Variable-length_parameter_lists"><span class="tocnumber">4.2</span> <span class="toctext">Variable-length parameter lists</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Named_parameters"><span class="tocnumber">4.3</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Multiple_parameters_in_functional_languages"><span class="tocnumber">4.4</span> <span class="toctext">Multiple parameters in functional languages</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Use"><span class="tocnumber">5.1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Drawbacks"><span class="tocnumber">5.2</span> <span class="toctext">Drawbacks</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Alternatives"><span class="tocnumber">5.3</span> <span class="toctext">Alternatives</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following program in the <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> programming language defines a function that is named "sales_tax" and has one parameter named "price". The type of price is "double" (i.e. a <a href="/wiki/Floating_point" title="Floating point">double-precision floating point</a> number). The function's return type is also a double.</p>
<p>WHATSON? 4114aefc-8ecd-48e1-b024-4320c5b937e5</p>
<pre class="de1">
<span class="kw4">double</span> sales_tax<span class="br0">(</span><span class="kw4">double</span> price<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="nu16">0.05</span> <span class="sy0">*</span> price<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>After the function has been defined, it can be invoked as follows:</p>
<p>WHATSON? 27b1de53-3286-4dd3-8fd7-f2f97921c15b</p>
<pre class="de1">
sales_tax<span class="br0">(</span><span class="nu16">10.00</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>In this example, the function has been invoked with the number 10.00. When this happens, 10.00 will be assigned to price, and the function begins calculating its result. The steps for producing the result are specified below enclosed in {} "0.05 * price" indicates that the first thing to do is multiply 0.05 by the value of price, which gives 0.50. "return" means the function will produce the result of "0.05 * price". Therefore, the final result is 0.50.</p>
<h2><span class="mw-headline" id="Parameters_and_arguments">Parameters and arguments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: Parameters and arguments">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The terms <i>parameter</i> and <i>argument</i> are sometimes loosely used interchangeably, and the context is used to distinguish the meaning. The term <i>parameter</i> (sometimes called <i>formal parameter</i>) is often used to refer to the variable as found in the function definition, while <i>argument</i> (sometimes called <i>actual parameter</i>) refers to the actual input passed. For example, if one defines a function as <code>def f(x): ...</code>, then <code>x</code> is the parameter, while if it called by <code>a = ...; f(a)</code> then <code>a</code> is the argument. In both cases a parameter is an (unbound) variable, while the argument can be thought of as a value or variable, depending on the calling convention. In case of call by value, one can think of the argument as a value (properly, as the <i>value</i> of the argument) – for example, <code>f(2)</code> and <code>a = 2; f(a)</code> are equivalent calls – while in call by reference one can think of the argument as a variable in the calling context.</p>
<p>Parameters appear in procedure definitions; arguments appear in procedure calls. In the function definition <code>f(x) = x*x</code> the variable <var>x</var> is a parameter; in the function call <code>f(2)</code> the value 2 is the argument of the function. Loosely, a parameter is a type, and an argument is an instance.</p>
<p>A parameter is an intrinsic property of the procedure, included in its definition. For example, in many languages, a procedure to add two supplied integers together and calculate the sum would need two parameters, one for each integer. In general, a procedure may be defined with any number of parameters, or no parameters at all. If a procedure has parameters, the part of its definition that specifies the parameters is called its <i>parameter list</i>.</p>
<p>By contrast, the arguments are the values supplied to the procedure when it is called. Unlike the parameters, which form an unchanging part of the procedure's definition, the arguments may vary from call to call. Each time a procedure is called, the part of the procedure call that specifies the arguments is called the <i>argument list</i>.</p>
<p>Although parameters are also commonly referred to as arguments, arguments are more properly thought of as the actual values or references assigned to the parameter variables when the subroutine is called at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run-time</a>. When discussing code that is calling into a subroutine, any values or references passed into the subroutine are the arguments, and the place in the code where these values or references are given is the <i>parameter list</i>. When discussing the code inside the subroutine definition, the variables in the subroutine's parameter list are the parameters, while the values of the parameters at runtime are the arguments. For example in C, when dealing with threads it's common to pass in an argument of type void* and cast it to an expected type:</p>
<p>WHATSON? af9dac2e-dea4-42b3-90f5-351f3fcc24bd</p>
<pre class="de1">
<span class="kw4">void</span> ThreadFunction<span class="br0">(</span> <span class="kw4">void</span><span class="sy0">*</span> pThreadArgument <span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Naming the first parameter 'pThreadArgument' is correct, rather than</span>
    <span class="co1">// 'pThreadParameter'. At run time the value we use is an argument. As mentioned</span>
    <span class="co1">// above, reserve the term parameter for when discussing subroutine definitions.</span>
<span class="br0">}</span>
</pre>
<p>To better understand the difference, consider the following function written in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>:</p>
<p>WHATSON? 79db6cee-1722-4637-8890-0f3df6bece9a</p>
<pre class="de1">
<span class="kw4">int</span> sum<span class="br0">(</span><span class="kw4">int</span> addend1<span class="sy0">,</span> <span class="kw4">int</span> addend2<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> addend1 <span class="sy0">+</span> addend2<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>The function <i>sum</i> has two parameters, named <i>addend1</i> and <i>addend2</i>. It adds the values passed into the parameters, and returns the result to the subroutine's caller (using a technique automatically supplied by the C compiler).</p>
<p>The code which calls the <i>sum</i> function might look like this:</p>
<p>WHATSON? 4c444833-3c84-4bc6-a59c-5eb21693189c</p>
<pre class="de1">
<span class="kw4">int</span> sumValue<span class="sy0">;</span>
<span class="kw4">int</span> value1 <span class="sy0">=</span> <span class="nu0">40</span><span class="sy0">;</span>
<span class="kw4">int</span> value2 <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
 
sumValue <span class="sy0">=</span> sum<span class="br0">(</span>value1<span class="sy0">,</span> value2<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The variables <i>value1</i> and <i>value2</i> are initialized with values. <i>value1</i> and <i>value2</i> are both arguments to the <i>sum</i> function in this context.</p>
<p>At runtime, the values assigned to these variables are passed to the function <i>sum</i> as arguments. In the <i>sum</i> function, the parameters <i>addend1</i> and <i>addend2</i> are evaluated, yielding the arguments 40 and 2, respectively. The values of the arguments are added, and the result is returned to the caller, where it is assigned to the variable <i>sumValue</i>.</p>
<p>Because of the difference between parameters and arguments, it is possible to supply inappropriate arguments to a procedure. The call may supply too many or too few arguments; one or more of the arguments may be a wrong type; or arguments may be supplied in the wrong order. Any of these situations causes a mismatch between the parameter and argument lists, and the procedure will often return an unintended answer or generate a <a href="/wiki/Runtime_error" title="Runtime error" class="mw-redirect">runtime error</a>.</p>
<h3><span class="mw-headline" id="Alternative_convention_in_Eiffel">Alternative convention in Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Alternative convention in Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Within the <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> software development method and language, the terms <i>argument</i> and <i>parameter</i> have distinct uses established by convention. The term <i>argument</i> is used exclusively in reference to a routine's inputs,<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>1<span>]</span></a></sup> and the term <i>parameter</i> is used exclusively in type parameterization for <a href="/wiki/Generic_programming" title="Generic programming">generic classes</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>2<span>]</span></a></sup></p>
<p>Consider the following routine definition:</p>
<p>WHATSON? d2524bbd-eea5-4d52-a2a4-a57de17c7a28</p>
<pre class="de1">
    sum <span class="br0">(</span>addend1<span class="sy0">:</span> <span class="kw4">INTEGER</span>; addend2<span class="sy0">:</span> <span class="kw4">INTEGER</span><span class="br0">)</span><span class="sy0">:</span> <span class="kw4">INTEGER</span>
        <span class="kw2">do</span>
            <span class="kw3">Result</span> <span class="sy0">:=</span> addend1 <span class="sy0">+</span> addend2
        <span class="kw2">end</span>
</pre>
<p>The routine <code>sum</code> takes two arguments <code>addend1</code> and <code>addend2</code>, which are called the routine's <b>formal arguments</b>. A call to <code>sum</code> specifies <b>actual arguments</b>, as shown below with <code>value1</code> and <code>value2</code>.</p>
<p>WHATSON? 41d025ff-095e-4f66-89b9-7aa533aae05b</p>
<pre class="de1">
    sum_value<span class="sy0">:</span> <span class="kw4">INTEGER</span>
    value1<span class="sy0">:</span> <span class="kw4">INTEGER</span> <span class="sy0">=</span> <span class="nu0">40</span>
    value2<span class="sy0">:</span> <span class="kw4">INTEGER</span> <span class="sy0">=</span> <span class="nu0">2</span>
                …
            sum_value <span class="sy0">:=</span> sum <span class="br0">(</span>value1, value2<span class="br0">)</span>
</pre>
<p>Parameters are also thought of as either <b>formal</b> or <b>actual</b>. <b>Formal generic parameters</b> are used in the definition of generic classes. In the example below, the class <code>HASH_TABLE</code> is declared as a generic class which has two formal generic parameters, <code>G</code> representing data of interest and <code>K</code> representing the hash key for the data:</p>
<p>WHATSON? 83c3b061-9103-480d-aafd-21a7b9c06bad</p>
<pre class="de1">
<span class="kw1">class</span> <span class="kw4">HASH_TABLE</span> <span class="br0">[</span>G, K <span class="sy0">-&gt;</span> <span class="kw4">HASHABLE</span><span class="br0">]</span> 
            …
</pre>
<p>When a class becomes a client to <code>HASH_TABLE</code>, the formal generic parameters are substituted with <b>actual generic parameters</b> in a <b>generic derivation</b>. In the following attribute declaration, <code>my_dictionary</code> is to be used as a character string based <a href="/wiki/Associative_array" title="Associative array">dictionary</a>. As such, both data and key formal generic parameters are substituted with actual generic parameters of type <code>STRING</code>.</p>
<p>WHATSON? a66778f6-0708-4c44-bd12-b25e0fba22ab</p>
<pre class="de1">
    my_dictionary<span class="sy0">:</span> <span class="kw4">HASH_TABLE</span> <span class="br0">[</span><span class="kw4">STRING</span>, <span class="kw4">STRING</span><span class="br0">]</span>
</pre>
<h2><span class="mw-headline" id="Datatypes">Datatypes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: Datatypes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Strongly_typed_programming_language" title="Strongly typed programming language" class="mw-redirect">strongly typed programming languages</a>, each parameter's <a href="/wiki/Datatype" title="Datatype" class="mw-redirect">type</a> must be specified in the procedure's declaration. Languages using <a href="/wiki/Type_inference" title="Type inference">type inference</a> attempt to discover the types automatically from the function's body and usage. Dynamically typed programming languages defer type resolution until run-time. Weakly typed languages perform little to no type resolution, relying instead on the programmer for correctness.</p>
<p>Some languages use a special keyword (e.g. <i>void</i>) to indicate that the subroutine has no parameters; in formal <a href="/wiki/Type_theory" title="Type theory">type theory</a>, such functions take an empty parameter list (whose type is not <i>void</i>, but rather <i><a href="/wiki/Unit_type" title="Unit type">unit</a></i>).</p>
<h2><span class="mw-headline" id="Argument_passing">Argument passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: Argument passing">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The exact mechanism for assigning arguments to parameters, called <i>argument passing</i>, depends upon the <a href="/wiki/Evaluation_strategy" title="Evaluation strategy">evaluation strategy</a> used for that parameter (typically call by value), which may be specified using keywords.</p>
<h3><span class="mw-headline" id="Default_arguments">Default arguments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: Default arguments">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some programming languages such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/Clojure" title="Clojure">Clojure</a>, <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>, <a href="/wiki/Fortran_90" title="Fortran 90" class="mw-redirect">Fortran 90</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a>, <a href="/wiki/Tcl_(programming_language)" title="Tcl (programming language)" class="mw-redirect">Tcl</a>, and <a href="/wiki/Windows_PowerShell" title="Windows PowerShell">Windows PowerShell</a> allow for a <a href="/wiki/Default_argument" title="Default argument">default argument</a> to be explicitly or implicitly given in a subroutine's declaration. This allows the caller to omit that argument when calling the subroutine. If the default argument is explicitly given, then that value is used if it is not provided by the caller. If the default argument is implicit (sometimes by using a keyword such as <i>Optional</i>) then the language provides a well-known value (such as <i><a href="/wiki/Null_pointer" title="Null pointer" class="mw-redirect">null</a></i>, <i>Empty</i>, zero, an empty string, etc.) if a value is not provided by the caller.</p>
<p>PowerShell example:</p>
<p>WHATSON? 4292727b-2e72-445a-a9be-8865faeee827</p>
<pre class="de1">
 <span class="kw3">function</span> doc<span class="br0">(</span><span class="re0">$g</span> <span class="sy0">=</span> <span class="nu0">1.21</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="st0">"$g gigawatts? $g gigawatts? Great Scott!"</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? b05f49ca-ce6a-44cb-bd04-6b9736746ddb</p>
<pre>
<b>PS&gt;</b> doc
1.21 gigawatts? 1.21 gigawatts? Great Scott!
</pre>
<p>WHATSON? e1b10ac3-510c-461c-b480-8e470ff49886</p>
<pre>
<b>PS&gt;</b> doc 88
88 gigawatts? 88 gigawatts? Great Scott!
</pre>
<p>Default arguments can be seen as a special case of the variable-length argument list.</p>
<h3><span class="mw-headline" id="Variable-length_parameter_lists">Variable-length parameter lists</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: Variable-length parameter lists">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages allow subroutines to be defined to accept a <a href="/wiki/Variadic_function" title="Variadic function">variable number of arguments</a>. For such languages, the subroutines must iterate through the list of arguments.</p>
<p>PowerShell example:</p>
<p>WHATSON? ee8c8745-949a-4074-a569-3813001ab08e</p>
<pre class="de1">
 <span class="kw3">function</span> marty <span class="br0">{</span>
   <span class="kw6">$args</span> <span class="sy0">|</span> <span class="kw3">foreach</span> <span class="br0">{</span> <span class="st0">"back to the year $_"</span> <span class="br0">}</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? 07edfd73-1eed-433a-aded-a781b4a6843a</p>
<pre>
<b>PS&gt;</b> marty 1985
back to the year 1985
</pre>
<p>WHATSON? af5b60d3-b9ce-4ae3-879d-b70ae9e5de9f</p>
<pre>
<b>PS&gt;</b> marty 2015 1985 1955
back to the year 2015
back to the year 1985
back to the year 1955
</pre>
<h3><span class="mw-headline" id="Named_parameters">Named parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=8" title="Edit section: Named parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some programming languages—such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a> and <a href="/wiki/Windows_PowerShell" title="Windows PowerShell">Windows PowerShell</a>—allow subroutines to have <a href="/wiki/Named_parameter" title="Named parameter">named parameters</a>. This allows the calling code to be more <a href="/wiki/Self-documenting" title="Self-documenting">self-documenting</a>. It also provides more flexibility to the caller, often allowing the order of the arguments to be changed, or for arguments to be omitted as needed.</p>
<p>PowerShell example:</p>
<p>WHATSON? a39fc867-eaeb-4f50-985f-9fcd991a017d</p>
<pre class="de1">
 <span class="kw3">function</span> jennifer<span class="br0">(</span><span class="re0">$adjectiveYoung</span><span class="sy0">,</span> <span class="re0">$adjectiveOld</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="st0">"Young Jennifer: I'm $adjectiveYoung!"</span>
   <span class="st0">"Old Jennifer: I'm $adjectiveOld!"</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? 5604cbdc-0e7d-4ec1-8042-98e0d6cabe35</p>
<pre>
<b>PS&gt;</b> jennifer 'fresh' 'experienced'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<p>WHATSON? be285b57-e92f-4518-8325-616ac19f764f</p>
<pre>
<b>PS&gt;</b> jennifer -adjectiveOld 'experienced' -adjectiveYoung 'fresh'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<h3><span class="mw-headline" id="Multiple_parameters_in_functional_languages">Multiple parameters in functional languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=9" title="Edit section: Multiple parameters in functional languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>, each function has exactly one parameter. What is thought of as functions with multiple parameters is usually represented in lambda calculus as a function which takes the first argument, and returns a function which takes the rest of the arguments; this is a transformation known as <a href="/wiki/Currying" title="Currying">currying</a>. Some programming languages, like <a href="/wiki/ML_(programming_language)" title="ML (programming language)">ML</a> and <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, follow this scheme. In these languages, every function has exactly one parameter, and what may look like the definition of a function of multiple parameters, is actually <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> for the definition of a function that returns a function, etc. Function application is <a href="/wiki/Operator_associativity" title="Operator associativity">left-associative</a> in these languages as well as in lambda calculus, so what looks like an application of a function to multiple arguments is correctly evaluated as the function applied to the first argument, then the resulting function applied to the second argument, etc.</p>
<h2><span class="mw-headline" id="Output_parameters">Output parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=10" title="Edit section: Output parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An <b>output parameter</b>, also known as an <b>out parameter</b> or <b>return parameter</b>, is a parameter used for output, rather than the more usual use for input. Using <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a> parameters, or call by value parameters where the value is a reference, as output parameters is an idiom in some languages, notably C and C++,<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>b<span>]</span></a></sup> while other languages have built-in support for output parameters. Languages with built-in support for output parameters include <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a><sup id="cite_ref-ada_5-0" class="reference"><a href="#cite_note-ada-5"><span>[</span>3<span>]</span></a></sup> (see <a href="//en.wikibooks.org/wiki/Ada_Programming/Subprograms" class="extiw" title="b:Ada Programming/Subprograms">Ada subprograms</a>), <a href="/wiki/Fortran" title="Fortran">Fortran</a> (since <a href="/wiki/Fortran_90" title="Fortran 90" class="mw-redirect">Fortran 90</a>; see <a href="//en.wikibooks.org/wiki/Fortran/Fortran_procedures_and_functions#Intent" class="extiw" title="b:Fortran/Fortran procedures and functions">Fortran "intent"</a>), various procedural extensions to <a href="/wiki/SQL" title="SQL">SQL</a>, such as <a href="/wiki/PL/SQL" title="PL/SQL">PL/SQL</a> (see <a href="/wiki/PL/SQL#Functions" title="PL/SQL">PL/SQL functions</a>)<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>4<span>]</span></a></sup> and <a href="/wiki/Transact-SQL" title="Transact-SQL">Transact-SQL</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a><sup id="cite_ref-hallam_7-0" class="reference"><a href="#cite_note-hallam-7"><span>[</span>5<span>]</span></a></sup> and the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>,<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>6<span>]</span></a></sup> and the scripting language <a href="/wiki/TScript" title="TScript">TScript</a> (see <a href="/wiki/TScript#Function_declarations" title="TScript">TScript function declarations</a>).</p>
<p>More precisely, one may distinguish three types of parameters or <b>parameter modes</b>: <i><span id="input_parameter">input parameter</span>s</i>, <i>output parameters,</i> and <i><span id="input.2Foutput_parameter">input/output parameter</span>s;</i> these are often denoted <code>in</code>, <code>out</code>, and <code>in out</code> or <code>inout</code>. An input argument (the argument to an input parameter) must be a value, such as an initialized variable or literal, and must not be redefined or assigned to; an output argument must be an assignable variable, but it need not be initialized, any existing value is not accessible, and must be assigned a value; and an input/output argument must be an initialized, assignable variable, and can optionally be assigned a value. The exact requirements and enforcement vary between languages – for example, in <a href="/wiki/Ada_83" title="Ada 83" class="mw-redirect">Ada 83</a> output parameters can only be assigned to, not read, even after assignment (this was removed in <a href="/wiki/Ada_95" title="Ada 95" class="mw-redirect">Ada 95</a> to remove the need for an auxiliary accumulator variable). These are analogous to the notion of a <a href="/wiki/Value_(computer_science)" title="Value (computer science)">value</a> in an expression being an r-value (has a value), an l-value (can be assigned), or an r-value/l-value (has a value and can be assigned), respectively, though these terms have specialized meanings in C.</p>
<p>In some cases only input and input/output are distinguished, with output being considered a specific use of input/output, and in other cases only input and output (but not input/output) are supported. The default mode varies between languages: in Fortran 90 input/output is default, while in C# and SQL extensions input is default, and in TScript each parameter is explicitly specified as input or output.</p>
<p>Syntactically, parameter mode is generally indicated with a keyword in the function declaration, such as <code>void f(out int x)</code> in C#. Conventionally output parameters are often put at the end of the parameter list to clearly distinguish them, though this is not always followed. TScript uses a different approach, where in the function declaration input parameters are listed, then output parameters, separated by a colon (:) and there is no return type to the function itself, as in this function, which computes the size of a text fragment:</p>
<p>WHATSON? 220d34f9-bf36-4ec7-bb2e-633f392221e3</p>
<pre class="de1">
 TextExtent<span class="br0">(</span>WString text, Font font <span class="sy4">:</span> Integer width, Integer height<span class="br0">)</span>
</pre>
<p>Parameter modes are a form of <a href="/wiki/Denotational_semantics" title="Denotational semantics">denotational semantics</a>, stating the programmer's intent and allowing compilers to catch errors and apply optimizations – they do not necessarily imply <a href="/wiki/Operational_semantics" title="Operational semantics">operational semantics</a> (how the parameter passing actually occurs). Notably, while input parameters can be implemented by call by value, and output and input/output parameters by call by reference – and this is a straightforward way to implement these modes in languages without built-in support – this is not always how they are implemented. This distinction is discussed in detail in the <i>Ada '83 Rationale,</i> which emphasizes that the parameter mode is abstracted from which parameter passing mechanism (by reference or by copy) is actually implemented.<sup id="cite_ref-ada_5-1" class="reference"><a href="#cite_note-ada-5"><span>[</span>3<span>]</span></a></sup> For instance, while in C# input parameters (default, no keyword) are passed by value, and output and input/output parameters (<code>out</code> and <code>ref</code>) are passed by reference, in PL/SQL input parameters (<code>IN</code>) are passed by reference, and output and input/output parameters (<code>OUT</code> and <code>IN OUT</code>) are by default passed by value and the result copied back, but can be passed by reference by using the <code>NOCOPY</code> compiler hint.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>7<span>]</span></a></sup></p>
<p>A syntactically similar construction to output parameters is to assign the <a href="/wiki/Return_value" title="Return value" class="mw-redirect">return value</a> to a variable with the same name as the function. This is found in <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a> and <a href="/wiki/Fortran_66" title="Fortran 66" class="mw-redirect">Fortran 66</a> and <a href="/wiki/Fortran_77" title="Fortran 77" class="mw-redirect">Fortran 77</a>, as in this Pascal example:</p>
<p>WHATSON? a6cb74cf-a135-47d3-8122-626026a5b839</p>
<pre class="de1">
<span class="kw1">function</span> f<span class="br0">(</span>x<span class="sy1">,</span> y<span class="sy1">:</span> <span class="kw4">integer</span><span class="br0">)</span><span class="sy1">:</span> <span class="kw4">integer</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    f <span class="sy1">:</span><span class="sy3">=</span> x <span class="sy3">+</span> y<span class="sy1">;</span>
<span class="kw1">end</span><span class="sy1">;</span>
</pre>
<p>This is semantically different in that when called, the function is simply evaluated – it is not passed a variable from the calling scope to store the output in.</p>
<h3><span class="mw-headline" id="Use">Use</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=11" title="Edit section: Use">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The primary use of output parameters is to return multiple values from a function, while the use of input/output parameters is to modify state using parameter passing (rather than by shared environment, as in global variables). An important use of returning multiple values is to solve the <a href="/wiki/Semipredicate_problem" title="Semipredicate problem">semipredicate problem</a> of returning both a value and an error status – see <a href="/wiki/Semipredicate_problem#Multivalued_return" title="Semipredicate problem">Semipredicate problem: Multivalued return</a>.</p>
<p>For example, to return two variables from a function in C, one may write:</p>
<p>WHATSON? 223cf177-3309-4c6e-9b20-1a8d525d02dd</p>
<pre class="de1">
<span class="kw4">int</span> width<span class="sy0">,</span> height<span class="sy0">;</span>
f<span class="br0">(</span>x<span class="sy0">,</span> <span class="sy0">&amp;</span>width<span class="sy0">,</span> <span class="sy0">&amp;</span>height<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>where <code>x</code> is an input parameter and <code>width</code> and <code>height</code> are output parameters, passed by reference.</p>
<p>A common use case in C and related languages is for <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a>, where a function places the return value in an output variable, and returns a boolean corresponding to whether the function succeeded or not. An archetypal example is the <code>TryParse</code> method in .NET, especially C#, which parses a string into an integer, returning <code>true</code> on success and <code>false</code> on failure. This has the following signature:<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>8<span>]</span></a></sup></p>
<p>WHATSON? 90580044-3c8f-4b69-9e7e-28def9521916</p>
<pre class="de1">
<span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">bool</span> TryParse<span class="br0">(</span><span class="kw4">string</span> s, <span class="kw1">out</span> <span class="kw4">int</span> result<span class="br0">)</span>
</pre>
<p>and may be used as follows:</p>
<p>WHATSON? 10cb95ca-f35a-431d-98cc-a38de4f4e543</p>
<pre class="de1">
<span class="kw4">int</span> result<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>Int32<span class="sy0">.</span><span class="me1">TryParse</span><span class="br0">(</span>s, result<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// exception handling</span>
<span class="br0">}</span>
</pre>
<p>Similar considerations apply to returning a value of one of several possible types, where the return value can specify the type and then value is stored in one of several output variables.</p>
<p>Another use is as a micro-optimization, to avoid assigning a local variable in a function and then needing to copy it when returning. This can be done when output parameters are implemented by <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a>. For example, in C++, instead of the more usual:</p>
<p>WHATSON? 0d8c292b-7c89-4913-99e1-11609a68e813</p>
<pre class="de1">
LargeObject obj <span class="sy1">=</span> f<span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>one might instead write:</p>
<p>WHATSON? 6ae696e4-8940-415f-8bcb-3c7e7f13fd48</p>
<pre class="de1">
LargeObject obj<span class="sy4">;</span>
f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>so the function <code>f</code> does not need to assign space for the object or copy it on returning.</p>
<h3><span class="mw-headline" id="Drawbacks">Drawbacks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=12" title="Edit section: Drawbacks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Output parameters are often discouraged in modern programming, essentially as being awkward, confusing, and too low-level – commonplace return values are considerably easier to understand and work with.<sup id="cite_ref-CA1021_11-0" class="reference"><a href="#cite_note-CA1021-11"><span>[</span>9<span>]</span></a></sup> Notably, output parameters involve functions with side effects (modifying the output parameter) and are semantically similar to references, which are more confusing than pure functions and values, and the distinction between output parameters and input/output parameters can be subtle. Further, since in common programming styles most parameters are simply input parameters, output parameters and input/output parameters are unusual and hence susceptible to misunderstanding.</p>
<p>Output and input/output parameters prevent function composition, since the output is stored in variables, rather than in the value of an expression. Thus one must initially declare a variable, and then each step of a chain of functions must be a separate statement. For example, in C++ the following function composition:</p>
<p>WHATSON? 5faf0f43-0ea7-46b1-9ec4-78b5cc2349af</p>
<pre class="de1">
Object obj <span class="sy1">=</span> g<span class="br0">(</span>y, f<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>when written with output and input/output parameters instead becomes (for <code>f</code> it is an output parameter, for <code>g</code> an input/output parameter):</p>
<p>WHATSON? 03222d7e-f772-4095-a384-a2309fd50fbb</p>
<pre class="de1">
Object obj<span class="sy4">;</span>
f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
g<span class="br0">(</span>y, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>In the special case of a function with a single output or input/output parameter and no return value, function composition is possible if the output or input/output parameter (or in C/C++, its address) is also returned by the function, in which case the above becomes:</p>
<p>WHATSON? 816f5f29-8a7b-4c61-b0fc-1c2a06a39802</p>
<pre class="de1">
Object obj<span class="sy4">;</span>
g<span class="br0">(</span>y, f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<h3><span class="mw-headline" id="Alternatives">Alternatives</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=13" title="Edit section: Alternatives">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There are various alternatives to the use cases of output parameters.</p>
<p>For returning multiple values from a function, an alternative is to return a <a href="/wiki/Tuple" title="Tuple">tuple</a>. Syntactically this is clearer if automatic sequence unpacking and <a href="/wiki/Parallel_assignment" title="Parallel assignment" class="mw-redirect">parallel assignment</a> can be used, as in <a href="/wiki/Go_(programming_language)" title="Go (programming language)">Go</a> or Python, such as:</p>
<p>WHATSON? 6fdd118c-8360-4474-91c0-f99d71839255</p>
<pre class="de1">
<span class="kw1">def</span> f<span class="br0">(</span><span class="br0">)</span>:
    <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span>
a<span class="sy0">,</span> b <span class="sy0">=</span> f<span class="br0">(</span><span class="br0">)</span>
</pre>
<p>For returning a value of one of several types, a <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a> can be used instead; the most common cases are <a href="/wiki/Nullable_type" title="Nullable type">nullable types</a> (<a href="/wiki/Option_type" title="Option type">option types</a>), where the return value can be null to indicate failure. For exception handling, one can return a nullable type, or raise an exception. For example, in Python one might have either:</p>
<p>WHATSON? ef48c0af-65fd-4f06-93cc-4cae14bc5a16</p>
<pre class="de1">
result <span class="sy0">=</span> Parse<span class="br0">(</span>s<span class="br0">)</span>
<span class="kw1">if</span> result <span class="kw1">is</span> <span class="kw2">None</span>:
    <span class="co1"># exception handling</span>
</pre>
<p>or, more idiomatically:</p>
<p>WHATSON? a3482323-3b96-48c5-8f76-c09e588cdeca</p>
<pre class="de1">
<span class="kw1">try</span>:
    result <span class="sy0">=</span> Parse<span class="br0">(</span>s<span class="br0">)</span>
<span class="kw1">except</span> ParseError:
    <span class="co1"># exception handling</span>
</pre>
<p>The micro-optimization of not requiring a local variable and copying the return when using output variables can also be applied to conventional functions and return values by sufficiently sophisticated compilers.</p>
<p>The usual alternative to output parameters in C and related languages is to return a single data structure containing all return values.<sup id="cite_ref-hallam_7-1" class="reference"><a href="#cite_note-hallam-7"><span>[</span>5<span>]</span></a></sup> For example, given a structure encapsulating width and height, one can write:</p>
<p>WHATSON? 473e0587-8520-4b6c-9790-ca323666e95b</p>
<pre class="de1">
WidthHeight width_and_height <span class="sy0">=</span> f<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>In object-oriented languages, instead of using input/output parameters, one can often use <a href="/wiki/Call_by_sharing" title="Call by sharing" class="mw-redirect">call by sharing</a>, passing a reference to an object and then mutating the object, though not changing which object the variable refers to.<sup id="cite_ref-CA1021_11-1" class="reference"><a href="#cite_note-CA1021-11"><span>[</span>9<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=14" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Command-line_argument" title="Command-line argument" class="mw-redirect">Command-line argument</a></li>
<li><a href="/wiki/Evaluation_strategy" title="Evaluation strategy">Evaluation strategy</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Free_variables_and_bound_variables" title="Free variables and bound variables">Free variables and bound variables</a></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=15" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">In this article, the term "subroutine" refers to any subroutine-like construct, which have different names and slightly different meanings depending on the <a href="/wiki/Programming_language" title="Programming language">programming language</a> being discussed.</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">C and C++ are call by value, but if type is a reference (a C/C++ pointer or C++ reference), then setting the value of the reference can be used to produce call by reference style behavior.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=16" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Meyer, Bertrand. <i><a href="/wiki/Object-Oriented_Software_Construction" title="Object-Oriented Software Construction">Object-Oriented Software Construction</a>, 2nd Edition,</i> Prentice Hall, 1997, p 444.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Meyer, p. 96.</span></li>
<li id="cite_note-ada-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-ada_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-ada_5-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://archive.adaic.com/standards/83rat/html/ratl-08-02.html">8.2 Parameter Modes</a>, "<a rel="nofollow" class="external text" href="http://archive.adaic.com/standards/83rat/html/Welcome.html">Rationale for the Design of the Ada® Programming Language</a>"</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://docs.oracle.com/cd/B10500_01/appdev.920/a96624/08_subs.htm#895">8. PL/SQL Subprograms: Specifying Subprogram Parameter Modes</a></span></li>
<li id="cite_note-hallam-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-hallam_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-hallam_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Peter Hallam. <a rel="nofollow" class="external text" href="http://web.archive.org/web/20110926113834/http://msdn.microsoft.com/en-us/vcsharp/aa336814.aspx">"Why does C# have both 'ref' and 'out'?"</a>. Archived from <a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/vcsharp/aa336814.aspx">the original</a> on 2011-09-26.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AParameter+%28computer+programming%29&amp;rft.aulast=Peter+Hallam&amp;rft.au=Peter+Hallam&amp;rft.btitle=Why+does+C%23+have+both+%27ref%27+and+%27out%27%3F&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Fvcsharp%2Faa336814.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/system.data.parameterdirection.aspx">ParameterDirection Enumeration</a></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://docs.oracle.com/cd/B10500_01/appdev.920/a96624/08_subs.htm#12813">8. PL/SQL Subprograms: Passing Large Data Structures with the NOCOPY Compiler Hint</a></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/f02979c7.aspx">Int32.TryParse Method (String, Int32)</a></span></li>
<li id="cite_note-CA1021-11"><span class="mw-cite-backlink">^ <a href="#cite_ref-CA1021_11-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-CA1021_11-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/ms182131.aspx">CA1021: Avoid out parameters</a></span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Parameter (computer programming)</span></h1>
<p>In <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>, a <b>parameter</b> is a special kind of <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variable</a>, used in a <a href="/wiki/Subroutine" title="Subroutine">subroutine</a> to refer to one of the pieces of data provided as input to the subroutine.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>a<span>]</span></a></sup> These pieces of data are called <b>arguments</b>. An ordered list of parameters is usually included in the definition of a subroutine, so that, each time the subroutine is called, its arguments for that call can be assigned to the corresponding parameters.</p>
<p>Just as in standard mathematical usage, the <i>argument</i> is thus the actual input passed to a function, procedure, or routine, whereas the <i>parameter</i> is the variable inside the implementation of the subroutine. For example, if one defines the <code>add</code> subroutine as <code>def add(x, y): return x + y</code>, then <code>x, y</code> are parameters, while if this is called as <code>add(2, 3)</code>, then <code>2, 3</code> are the arguments. Note that variables from the calling context can be arguments: if the subroutine is called as <code>a = 2; b = 3; add(a, b)</code> then the <i>variables</i> <code>a, b</code> are the arguments, not only the <i>values</i> <code>2, 3</code>. See the <a href="#Parameters_and_arguments">Parameters and arguments</a> section for more information.</p>
<p>In the most common case, <a href="/wiki/Call_by_value" title="Call by value" class="mw-redirect">call by value</a>, a parameter acts within the subroutine as a variable initialized to the value of the argument (a <a href="/wiki/Local_variable" title="Local variable">local</a> (isolated) copy of the argument if the argument is a variable), but in other cases, e.g. <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a>, the argument supplied by the caller can be affected by actions within the called subroutine (as discussed in <a href="/wiki/Evaluation_strategy" title="Evaluation strategy">evaluation strategy</a>). In call by value, one can thus think of arguments as values (properly, think of the <i>value</i> of arguments as the "arguments" themselves), but in general arguments are not simply values.</p>
<p>The semantics for how parameters can be declared and how the arguments get passed to the parameters of subroutines are defined by the language, but the details of how this is represented in any particular computer system depend on the <a href="/wiki/Calling_convention" title="Calling convention">calling conventions</a> of that system.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Example"><span class="tocnumber">1</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Parameters_and_arguments"><span class="tocnumber">2</span> <span class="toctext">Parameters and arguments</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Alternative_convention_in_Eiffel"><span class="tocnumber">2.1</span> <span class="toctext">Alternative convention in Eiffel</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Datatypes"><span class="tocnumber">3</span> <span class="toctext">Datatypes</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Argument_passing"><span class="tocnumber">4</span> <span class="toctext">Argument passing</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Default_arguments"><span class="tocnumber">4.1</span> <span class="toctext">Default arguments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Variable-length_parameter_lists"><span class="tocnumber">4.2</span> <span class="toctext">Variable-length parameter lists</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Named_parameters"><span class="tocnumber">4.3</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Multiple_parameters_in_functional_languages"><span class="tocnumber">4.4</span> <span class="toctext">Multiple parameters in functional languages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Output_parameters"><span class="tocnumber">5</span> <span class="toctext">Output parameters</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Use"><span class="tocnumber">5.1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Drawbacks"><span class="tocnumber">5.2</span> <span class="toctext">Drawbacks</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Alternatives"><span class="tocnumber">5.3</span> <span class="toctext">Alternatives</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Notes"><span class="tocnumber">7</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Alternative_convention_in_Eiffel"><span class="tocnumber">2.1</span> <span class="toctext">Alternative convention in Eiffel</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Default_arguments"><span class="tocnumber">4.1</span> <span class="toctext">Default arguments</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Variable-length_parameter_lists"><span class="tocnumber">4.2</span> <span class="toctext">Variable-length parameter lists</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Named_parameters"><span class="tocnumber">4.3</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Multiple_parameters_in_functional_languages"><span class="tocnumber">4.4</span> <span class="toctext">Multiple parameters in functional languages</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Use"><span class="tocnumber">5.1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Drawbacks"><span class="tocnumber">5.2</span> <span class="toctext">Drawbacks</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Alternatives"><span class="tocnumber">5.3</span> <span class="toctext">Alternatives</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following program in the <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> programming language defines a function that is named "sales_tax" and has one parameter named "price". The type of price is "double" (i.e. a <a href="/wiki/Floating_point" title="Floating point">double-precision floating point</a> number). The function's return type is also a double.</p>
<p>WHATSON? fd78ca34-e2fb-4f57-9df9-481f463aec8e</p>
<pre class="de1">
<span class="kw4">double</span> sales_tax<span class="br0">(</span><span class="kw4">double</span> price<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="nu16">0.05</span> <span class="sy0">*</span> price<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>After the function has been defined, it can be invoked as follows:</p>
<p>WHATSON? 395fb11e-caa2-4fb0-956a-1d40a544b30c</p>
<pre class="de1">
sales_tax<span class="br0">(</span><span class="nu16">10.00</span><span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>In this example, the function has been invoked with the number 10.00. When this happens, 10.00 will be assigned to price, and the function begins calculating its result. The steps for producing the result are specified below enclosed in {} "0.05 * price" indicates that the first thing to do is multiply 0.05 by the value of price, which gives 0.50. "return" means the function will produce the result of "0.05 * price". Therefore, the final result is 0.50.</p>
<h2><span class="mw-headline" id="Parameters_and_arguments">Parameters and arguments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: Parameters and arguments">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The terms <i>parameter</i> and <i>argument</i> are sometimes loosely used interchangeably, and the context is used to distinguish the meaning. The term <i>parameter</i> (sometimes called <i>formal parameter</i>) is often used to refer to the variable as found in the function definition, while <i>argument</i> (sometimes called <i>actual parameter</i>) refers to the actual input passed. For example, if one defines a function as <code>def f(x): ...</code>, then <code>x</code> is the parameter, while if it called by <code>a = ...; f(a)</code> then <code>a</code> is the argument. In both cases a parameter is an (unbound) variable, while the argument can be thought of as a value or variable, depending on the calling convention. In case of call by value, one can think of the argument as a value (properly, as the <i>value</i> of the argument) – for example, <code>f(2)</code> and <code>a = 2; f(a)</code> are equivalent calls – while in call by reference one can think of the argument as a variable in the calling context.</p>
<p>Parameters appear in procedure definitions; arguments appear in procedure calls. In the function definition <code>f(x) = x*x</code> the variable <var>x</var> is a parameter; in the function call <code>f(2)</code> the value 2 is the argument of the function. Loosely, a parameter is a type, and an argument is an instance.</p>
<p>A parameter is an intrinsic property of the procedure, included in its definition. For example, in many languages, a procedure to add two supplied integers together and calculate the sum would need two parameters, one for each integer. In general, a procedure may be defined with any number of parameters, or no parameters at all. If a procedure has parameters, the part of its definition that specifies the parameters is called its <i>parameter list</i>.</p>
<p>By contrast, the arguments are the values supplied to the procedure when it is called. Unlike the parameters, which form an unchanging part of the procedure's definition, the arguments may vary from call to call. Each time a procedure is called, the part of the procedure call that specifies the arguments is called the <i>argument list</i>.</p>
<p>Although parameters are also commonly referred to as arguments, arguments are more properly thought of as the actual values or references assigned to the parameter variables when the subroutine is called at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run-time</a>. When discussing code that is calling into a subroutine, any values or references passed into the subroutine are the arguments, and the place in the code where these values or references are given is the <i>parameter list</i>. When discussing the code inside the subroutine definition, the variables in the subroutine's parameter list are the parameters, while the values of the parameters at runtime are the arguments. For example in C, when dealing with threads it's common to pass in an argument of type void* and cast it to an expected type:</p>
<p>WHATSON? 814284cd-f08c-439b-8a1b-c4980230369a</p>
<pre class="de1">
<span class="kw4">void</span> ThreadFunction<span class="br0">(</span> <span class="kw4">void</span><span class="sy0">*</span> pThreadArgument <span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Naming the first parameter 'pThreadArgument' is correct, rather than</span>
    <span class="co1">// 'pThreadParameter'. At run time the value we use is an argument. As mentioned</span>
    <span class="co1">// above, reserve the term parameter for when discussing subroutine definitions.</span>
<span class="br0">}</span>
</pre>
<p>To better understand the difference, consider the following function written in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>:</p>
<p>WHATSON? 1ecb0f2c-485e-425e-8cda-c578b715095d</p>
<pre class="de1">
<span class="kw4">int</span> sum<span class="br0">(</span><span class="kw4">int</span> addend1<span class="sy0">,</span> <span class="kw4">int</span> addend2<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> addend1 <span class="sy0">+</span> addend2<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>The function <i>sum</i> has two parameters, named <i>addend1</i> and <i>addend2</i>. It adds the values passed into the parameters, and returns the result to the subroutine's caller (using a technique automatically supplied by the C compiler).</p>
<p>The code which calls the <i>sum</i> function might look like this:</p>
<p>WHATSON? b532707c-5db1-44ed-bea0-4da82f55f531</p>
<pre class="de1">
<span class="kw4">int</span> sumValue<span class="sy0">;</span>
<span class="kw4">int</span> value1 <span class="sy0">=</span> <span class="nu0">40</span><span class="sy0">;</span>
<span class="kw4">int</span> value2 <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
 
sumValue <span class="sy0">=</span> sum<span class="br0">(</span>value1<span class="sy0">,</span> value2<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>The variables <i>value1</i> and <i>value2</i> are initialized with values. <i>value1</i> and <i>value2</i> are both arguments to the <i>sum</i> function in this context.</p>
<p>At runtime, the values assigned to these variables are passed to the function <i>sum</i> as arguments. In the <i>sum</i> function, the parameters <i>addend1</i> and <i>addend2</i> are evaluated, yielding the arguments 40 and 2, respectively. The values of the arguments are added, and the result is returned to the caller, where it is assigned to the variable <i>sumValue</i>.</p>
<p>Because of the difference between parameters and arguments, it is possible to supply inappropriate arguments to a procedure. The call may supply too many or too few arguments; one or more of the arguments may be a wrong type; or arguments may be supplied in the wrong order. Any of these situations causes a mismatch between the parameter and argument lists, and the procedure will often return an unintended answer or generate a <a href="/wiki/Runtime_error" title="Runtime error" class="mw-redirect">runtime error</a>.</p>
<h3><span class="mw-headline" id="Alternative_convention_in_Eiffel">Alternative convention in Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Alternative convention in Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Within the <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> software development method and language, the terms <i>argument</i> and <i>parameter</i> have distinct uses established by convention. The term <i>argument</i> is used exclusively in reference to a routine's inputs,<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>1<span>]</span></a></sup> and the term <i>parameter</i> is used exclusively in type parameterization for <a href="/wiki/Generic_programming" title="Generic programming">generic classes</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>2<span>]</span></a></sup></p>
<p>Consider the following routine definition:</p>
<p>WHATSON? 0b94dedd-8d6e-4482-ab1d-b4250a523805</p>
<pre class="de1">
    sum <span class="br0">(</span>addend1<span class="sy0">:</span> <span class="kw4">INTEGER</span>; addend2<span class="sy0">:</span> <span class="kw4">INTEGER</span><span class="br0">)</span><span class="sy0">:</span> <span class="kw4">INTEGER</span>
        <span class="kw2">do</span>
            <span class="kw3">Result</span> <span class="sy0">:=</span> addend1 <span class="sy0">+</span> addend2
        <span class="kw2">end</span>
</pre>
<p>The routine <code>sum</code> takes two arguments <code>addend1</code> and <code>addend2</code>, which are called the routine's <b>formal arguments</b>. A call to <code>sum</code> specifies <b>actual arguments</b>, as shown below with <code>value1</code> and <code>value2</code>.</p>
<p>WHATSON? 4d00c2e7-d62d-4305-814a-d1ec6ca12365</p>
<pre class="de1">
    sum_value<span class="sy0">:</span> <span class="kw4">INTEGER</span>
    value1<span class="sy0">:</span> <span class="kw4">INTEGER</span> <span class="sy0">=</span> <span class="nu0">40</span>
    value2<span class="sy0">:</span> <span class="kw4">INTEGER</span> <span class="sy0">=</span> <span class="nu0">2</span>
                …
            sum_value <span class="sy0">:=</span> sum <span class="br0">(</span>value1, value2<span class="br0">)</span>
</pre>
<p>Parameters are also thought of as either <b>formal</b> or <b>actual</b>. <b>Formal generic parameters</b> are used in the definition of generic classes. In the example below, the class <code>HASH_TABLE</code> is declared as a generic class which has two formal generic parameters, <code>G</code> representing data of interest and <code>K</code> representing the hash key for the data:</p>
<p>WHATSON? e9cc6629-c256-47a6-bc2c-11b7fa83ca92</p>
<pre class="de1">
<span class="kw1">class</span> <span class="kw4">HASH_TABLE</span> <span class="br0">[</span>G, K <span class="sy0">-&gt;</span> <span class="kw4">HASHABLE</span><span class="br0">]</span> 
            …
</pre>
<p>When a class becomes a client to <code>HASH_TABLE</code>, the formal generic parameters are substituted with <b>actual generic parameters</b> in a <b>generic derivation</b>. In the following attribute declaration, <code>my_dictionary</code> is to be used as a character string based <a href="/wiki/Associative_array" title="Associative array">dictionary</a>. As such, both data and key formal generic parameters are substituted with actual generic parameters of type <code>STRING</code>.</p>
<p>WHATSON? 5a7e4c36-7840-4105-9582-c0a81492740f</p>
<pre class="de1">
    my_dictionary<span class="sy0">:</span> <span class="kw4">HASH_TABLE</span> <span class="br0">[</span><span class="kw4">STRING</span>, <span class="kw4">STRING</span><span class="br0">]</span>
</pre>
<h2><span class="mw-headline" id="Datatypes">Datatypes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: Datatypes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Strongly_typed_programming_language" title="Strongly typed programming language" class="mw-redirect">strongly typed programming languages</a>, each parameter's <a href="/wiki/Datatype" title="Datatype" class="mw-redirect">type</a> must be specified in the procedure's declaration. Languages using <a href="/wiki/Type_inference" title="Type inference">type inference</a> attempt to discover the types automatically from the function's body and usage. Dynamically typed programming languages defer type resolution until run-time. Weakly typed languages perform little to no type resolution, relying instead on the programmer for correctness.</p>
<p>Some languages use a special keyword (e.g. <i>void</i>) to indicate that the subroutine has no parameters; in formal <a href="/wiki/Type_theory" title="Type theory">type theory</a>, such functions take an empty parameter list (whose type is not <i>void</i>, but rather <i><a href="/wiki/Unit_type" title="Unit type">unit</a></i>).</p>
<h2><span class="mw-headline" id="Argument_passing">Argument passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: Argument passing">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The exact mechanism for assigning arguments to parameters, called <i>argument passing</i>, depends upon the <a href="/wiki/Evaluation_strategy" title="Evaluation strategy">evaluation strategy</a> used for that parameter (typically call by value), which may be specified using keywords.</p>
<h3><span class="mw-headline" id="Default_arguments">Default arguments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: Default arguments">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some programming languages such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/Clojure" title="Clojure">Clojure</a>, <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>, <a href="/wiki/Fortran_90" title="Fortran 90" class="mw-redirect">Fortran 90</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a>, <a href="/wiki/Tcl_(programming_language)" title="Tcl (programming language)" class="mw-redirect">Tcl</a>, and <a href="/wiki/Windows_PowerShell" title="Windows PowerShell">Windows PowerShell</a> allow for a <a href="/wiki/Default_argument" title="Default argument">default argument</a> to be explicitly or implicitly given in a subroutine's declaration. This allows the caller to omit that argument when calling the subroutine. If the default argument is explicitly given, then that value is used if it is not provided by the caller. If the default argument is implicit (sometimes by using a keyword such as <i>Optional</i>) then the language provides a well-known value (such as <i><a href="/wiki/Null_pointer" title="Null pointer" class="mw-redirect">null</a></i>, <i>Empty</i>, zero, an empty string, etc.) if a value is not provided by the caller.</p>
<p>PowerShell example:</p>
<p>WHATSON? ef28567a-bcde-400a-b894-e634edb7d0b1</p>
<pre class="de1">
 <span class="kw3">function</span> doc<span class="br0">(</span><span class="re0">$g</span> <span class="sy0">=</span> <span class="nu0">1.21</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="st0">"$g gigawatts? $g gigawatts? Great Scott!"</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? 79eecd03-04a1-4918-8eb2-84da65698310</p>
<pre>
<b>PS&gt;</b> doc
1.21 gigawatts? 1.21 gigawatts? Great Scott!
</pre>
<p>WHATSON? 3ab13969-4e25-4ac9-af24-77c3a07ba194</p>
<pre>
<b>PS&gt;</b> doc 88
88 gigawatts? 88 gigawatts? Great Scott!
</pre>
<p>Default arguments can be seen as a special case of the variable-length argument list.</p>
<h3><span class="mw-headline" id="Variable-length_parameter_lists">Variable-length parameter lists</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: Variable-length parameter lists">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages allow subroutines to be defined to accept a <a href="/wiki/Variadic_function" title="Variadic function">variable number of arguments</a>. For such languages, the subroutines must iterate through the list of arguments.</p>
<p>PowerShell example:</p>
<p>WHATSON? 236d2d50-94c5-4658-8fc3-be16db163541</p>
<pre class="de1">
 <span class="kw3">function</span> marty <span class="br0">{</span>
   <span class="kw6">$args</span> <span class="sy0">|</span> <span class="kw3">foreach</span> <span class="br0">{</span> <span class="st0">"back to the year $_"</span> <span class="br0">}</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? ed571043-1da5-43c4-801b-8504ddbd3ce5</p>
<pre>
<b>PS&gt;</b> marty 1985
back to the year 1985
</pre>
<p>WHATSON? 7b496e26-f68e-46e7-a4cd-d236b05f7e50</p>
<pre>
<b>PS&gt;</b> marty 2015 1985 1955
back to the year 2015
back to the year 1985
back to the year 1955
</pre>
<h3><span class="mw-headline" id="Named_parameters">Named parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=8" title="Edit section: Named parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some programming languages—such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a> and <a href="/wiki/Windows_PowerShell" title="Windows PowerShell">Windows PowerShell</a>—allow subroutines to have <a href="/wiki/Named_parameter" title="Named parameter">named parameters</a>. This allows the calling code to be more <a href="/wiki/Self-documenting" title="Self-documenting">self-documenting</a>. It also provides more flexibility to the caller, often allowing the order of the arguments to be changed, or for arguments to be omitted as needed.</p>
<p>PowerShell example:</p>
<p>WHATSON? cea77c24-a544-4aed-90cf-007296098ae6</p>
<pre class="de1">
 <span class="kw3">function</span> jennifer<span class="br0">(</span><span class="re0">$adjectiveYoung</span><span class="sy0">,</span> <span class="re0">$adjectiveOld</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="st0">"Young Jennifer: I'm $adjectiveYoung!"</span>
   <span class="st0">"Old Jennifer: I'm $adjectiveOld!"</span>
 <span class="br0">}</span>
</pre>
<p>WHATSON? ea2d90e5-9581-4060-84ce-475f6b62cd7e</p>
<pre>
<b>PS&gt;</b> jennifer 'fresh' 'experienced'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<p>WHATSON? 82308f78-ec90-4f7e-85d1-f14472ca85f7</p>
<pre>
<b>PS&gt;</b> jennifer -adjectiveOld 'experienced' -adjectiveYoung 'fresh'
Young Jennifer: I'm fresh!
Old Jennifer: I'm experienced!
</pre>
<h3><span class="mw-headline" id="Multiple_parameters_in_functional_languages">Multiple parameters in functional languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=9" title="Edit section: Multiple parameters in functional languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>, each function has exactly one parameter. What is thought of as functions with multiple parameters is usually represented in lambda calculus as a function which takes the first argument, and returns a function which takes the rest of the arguments; this is a transformation known as <a href="/wiki/Currying" title="Currying">currying</a>. Some programming languages, like <a href="/wiki/ML_(programming_language)" title="ML (programming language)">ML</a> and <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, follow this scheme. In these languages, every function has exactly one parameter, and what may look like the definition of a function of multiple parameters, is actually <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> for the definition of a function that returns a function, etc. Function application is <a href="/wiki/Operator_associativity" title="Operator associativity">left-associative</a> in these languages as well as in lambda calculus, so what looks like an application of a function to multiple arguments is correctly evaluated as the function applied to the first argument, then the resulting function applied to the second argument, etc.</p>
<h2><span class="mw-headline" id="Output_parameters">Output parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=10" title="Edit section: Output parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An <b>output parameter</b>, also known as an <b>out parameter</b> or <b>return parameter</b>, is a parameter used for output, rather than the more usual use for input. Using <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a> parameters, or call by value parameters where the value is a reference, as output parameters is an idiom in some languages, notably C and C++,<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>b<span>]</span></a></sup> while other languages have built-in support for output parameters. Languages with built-in support for output parameters include <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a><sup id="cite_ref-ada_5-0" class="reference"><a href="#cite_note-ada-5"><span>[</span>3<span>]</span></a></sup> (see <a href="//en.wikibooks.org/wiki/Ada_Programming/Subprograms" class="extiw" title="b:Ada Programming/Subprograms">Ada subprograms</a>), <a href="/wiki/Fortran" title="Fortran">Fortran</a> (since <a href="/wiki/Fortran_90" title="Fortran 90" class="mw-redirect">Fortran 90</a>; see <a href="//en.wikibooks.org/wiki/Fortran/Fortran_procedures_and_functions#Intent" class="extiw" title="b:Fortran/Fortran procedures and functions">Fortran "intent"</a>), various procedural extensions to <a href="/wiki/SQL" title="SQL">SQL</a>, such as <a href="/wiki/PL/SQL" title="PL/SQL">PL/SQL</a> (see <a href="/wiki/PL/SQL#Functions" title="PL/SQL">PL/SQL functions</a>)<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>4<span>]</span></a></sup> and <a href="/wiki/Transact-SQL" title="Transact-SQL">Transact-SQL</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a><sup id="cite_ref-hallam_7-0" class="reference"><a href="#cite_note-hallam-7"><span>[</span>5<span>]</span></a></sup> and the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>,<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>6<span>]</span></a></sup> and the scripting language <a href="/wiki/TScript" title="TScript">TScript</a> (see <a href="/wiki/TScript#Function_declarations" title="TScript">TScript function declarations</a>).</p>
<p>More precisely, one may distinguish three types of parameters or <b>parameter modes</b>: <i><span id="input_parameter">input parameter</span>s</i>, <i>output parameters,</i> and <i><span id="input.2Foutput_parameter">input/output parameter</span>s;</i> these are often denoted <code>in</code>, <code>out</code>, and <code>in out</code> or <code>inout</code>. An input argument (the argument to an input parameter) must be a value, such as an initialized variable or literal, and must not be redefined or assigned to; an output argument must be an assignable variable, but it need not be initialized, any existing value is not accessible, and must be assigned a value; and an input/output argument must be an initialized, assignable variable, and can optionally be assigned a value. The exact requirements and enforcement vary between languages – for example, in <a href="/wiki/Ada_83" title="Ada 83" class="mw-redirect">Ada 83</a> output parameters can only be assigned to, not read, even after assignment (this was removed in <a href="/wiki/Ada_95" title="Ada 95" class="mw-redirect">Ada 95</a> to remove the need for an auxiliary accumulator variable). These are analogous to the notion of a <a href="/wiki/Value_(computer_science)" title="Value (computer science)">value</a> in an expression being an r-value (has a value), an l-value (can be assigned), or an r-value/l-value (has a value and can be assigned), respectively, though these terms have specialized meanings in C.</p>
<p>In some cases only input and input/output are distinguished, with output being considered a specific use of input/output, and in other cases only input and output (but not input/output) are supported. The default mode varies between languages: in Fortran 90 input/output is default, while in C# and SQL extensions input is default, and in TScript each parameter is explicitly specified as input or output.</p>
<p>Syntactically, parameter mode is generally indicated with a keyword in the function declaration, such as <code>void f(out int x)</code> in C#. Conventionally output parameters are often put at the end of the parameter list to clearly distinguish them, though this is not always followed. TScript uses a different approach, where in the function declaration input parameters are listed, then output parameters, separated by a colon (:) and there is no return type to the function itself, as in this function, which computes the size of a text fragment:</p>
<p>WHATSON? 9b0f5ab4-6e97-4a33-be77-8daec1220428</p>
<pre class="de1">
 TextExtent<span class="br0">(</span>WString text, Font font <span class="sy4">:</span> Integer width, Integer height<span class="br0">)</span>
</pre>
<p>Parameter modes are a form of <a href="/wiki/Denotational_semantics" title="Denotational semantics">denotational semantics</a>, stating the programmer's intent and allowing compilers to catch errors and apply optimizations – they do not necessarily imply <a href="/wiki/Operational_semantics" title="Operational semantics">operational semantics</a> (how the parameter passing actually occurs). Notably, while input parameters can be implemented by call by value, and output and input/output parameters by call by reference – and this is a straightforward way to implement these modes in languages without built-in support – this is not always how they are implemented. This distinction is discussed in detail in the <i>Ada '83 Rationale,</i> which emphasizes that the parameter mode is abstracted from which parameter passing mechanism (by reference or by copy) is actually implemented.<sup id="cite_ref-ada_5-1" class="reference"><a href="#cite_note-ada-5"><span>[</span>3<span>]</span></a></sup> For instance, while in C# input parameters (default, no keyword) are passed by value, and output and input/output parameters (<code>out</code> and <code>ref</code>) are passed by reference, in PL/SQL input parameters (<code>IN</code>) are passed by reference, and output and input/output parameters (<code>OUT</code> and <code>IN OUT</code>) are by default passed by value and the result copied back, but can be passed by reference by using the <code>NOCOPY</code> compiler hint.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>7<span>]</span></a></sup></p>
<p>A syntactically similar construction to output parameters is to assign the <a href="/wiki/Return_value" title="Return value" class="mw-redirect">return value</a> to a variable with the same name as the function. This is found in <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a> and <a href="/wiki/Fortran_66" title="Fortran 66" class="mw-redirect">Fortran 66</a> and <a href="/wiki/Fortran_77" title="Fortran 77" class="mw-redirect">Fortran 77</a>, as in this Pascal example:</p>
<p>WHATSON? 01008ab9-98ad-4d14-be6d-0a0ca773e746</p>
<pre class="de1">
<span class="kw1">function</span> f<span class="br0">(</span>x<span class="sy1">,</span> y<span class="sy1">:</span> <span class="kw4">integer</span><span class="br0">)</span><span class="sy1">:</span> <span class="kw4">integer</span><span class="sy1">;</span>
<span class="kw1">begin</span>
    f <span class="sy1">:</span><span class="sy3">=</span> x <span class="sy3">+</span> y<span class="sy1">;</span>
<span class="kw1">end</span><span class="sy1">;</span>
</pre>
<p>This is semantically different in that when called, the function is simply evaluated – it is not passed a variable from the calling scope to store the output in.</p>
<h3><span class="mw-headline" id="Use">Use</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=11" title="Edit section: Use">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The primary use of output parameters is to return multiple values from a function, while the use of input/output parameters is to modify state using parameter passing (rather than by shared environment, as in global variables). An important use of returning multiple values is to solve the <a href="/wiki/Semipredicate_problem" title="Semipredicate problem">semipredicate problem</a> of returning both a value and an error status – see <a href="/wiki/Semipredicate_problem#Multivalued_return" title="Semipredicate problem">Semipredicate problem: Multivalued return</a>.</p>
<p>For example, to return two variables from a function in C, one may write:</p>
<p>WHATSON? 1a89b81b-8436-4825-94bd-370820a830a2</p>
<pre class="de1">
<span class="kw4">int</span> width<span class="sy0">,</span> height<span class="sy0">;</span>
f<span class="br0">(</span>x<span class="sy0">,</span> <span class="sy0">&amp;</span>width<span class="sy0">,</span> <span class="sy0">&amp;</span>height<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>where <code>x</code> is an input parameter and <code>width</code> and <code>height</code> are output parameters, passed by reference.</p>
<p>A common use case in C and related languages is for <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a>, where a function places the return value in an output variable, and returns a boolean corresponding to whether the function succeeded or not. An archetypal example is the <code>TryParse</code> method in .NET, especially C#, which parses a string into an integer, returning <code>true</code> on success and <code>false</code> on failure. This has the following signature:<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>8<span>]</span></a></sup></p>
<p>WHATSON? b6e164b5-94da-4d18-8d8e-df87250bfdfb</p>
<pre class="de1">
<span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">bool</span> TryParse<span class="br0">(</span><span class="kw4">string</span> s, <span class="kw1">out</span> <span class="kw4">int</span> result<span class="br0">)</span>
</pre>
<p>and may be used as follows:</p>
<p>WHATSON? f6cc3e62-875e-452d-921b-cf23bf14996a</p>
<pre class="de1">
<span class="kw4">int</span> result<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>Int32<span class="sy0">.</span><span class="me1">TryParse</span><span class="br0">(</span>s, result<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// exception handling</span>
<span class="br0">}</span>
</pre>
<p>Similar considerations apply to returning a value of one of several possible types, where the return value can specify the type and then value is stored in one of several output variables.</p>
<p>Another use is as a micro-optimization, to avoid assigning a local variable in a function and then needing to copy it when returning. This can be done when output parameters are implemented by <a href="/wiki/Call_by_reference" title="Call by reference" class="mw-redirect">call by reference</a>. For example, in C++, instead of the more usual:</p>
<p>WHATSON? 8db7ef85-22c2-4776-8abb-3fc76bcc07c6</p>
<pre class="de1">
LargeObject obj <span class="sy1">=</span> f<span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>one might instead write:</p>
<p>WHATSON? 40f65057-5cc0-4086-9b22-235703c3b7be</p>
<pre class="de1">
LargeObject obj<span class="sy4">;</span>
f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>so the function <code>f</code> does not need to assign space for the object or copy it on returning.</p>
<h3><span class="mw-headline" id="Drawbacks">Drawbacks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=12" title="Edit section: Drawbacks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Output parameters are often discouraged in modern programming, essentially as being awkward, confusing, and too low-level – commonplace return values are considerably easier to understand and work with.<sup id="cite_ref-CA1021_11-0" class="reference"><a href="#cite_note-CA1021-11"><span>[</span>9<span>]</span></a></sup> Notably, output parameters involve functions with side effects (modifying the output parameter) and are semantically similar to references, which are more confusing than pure functions and values, and the distinction between output parameters and input/output parameters can be subtle. Further, since in common programming styles most parameters are simply input parameters, output parameters and input/output parameters are unusual and hence susceptible to misunderstanding.</p>
<p>Output and input/output parameters prevent function composition, since the output is stored in variables, rather than in the value of an expression. Thus one must initially declare a variable, and then each step of a chain of functions must be a separate statement. For example, in C++ the following function composition:</p>
<p>WHATSON? 96c3652a-a94f-4fef-ae0c-5c33330fafb1</p>
<pre class="de1">
Object obj <span class="sy1">=</span> g<span class="br0">(</span>y, f<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>when written with output and input/output parameters instead becomes (for <code>f</code> it is an output parameter, for <code>g</code> an input/output parameter):</p>
<p>WHATSON? 730f4631-206c-416b-b3b0-3f1cc05722c1</p>
<pre class="de1">
Object obj<span class="sy4">;</span>
f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
g<span class="br0">(</span>y, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="sy4">;</span>
</pre>
<p>In the special case of a function with a single output or input/output parameter and no return value, function composition is possible if the output or input/output parameter (or in C/C++, its address) is also returned by the function, in which case the above becomes:</p>
<p>WHATSON? 60a87e9e-b19b-49d4-a723-0554f787512b</p>
<pre class="de1">
Object obj<span class="sy4">;</span>
g<span class="br0">(</span>y, f<span class="br0">(</span>x, <span class="sy3">&amp;</span>obj<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
</pre>
<h3><span class="mw-headline" id="Alternatives">Alternatives</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=13" title="Edit section: Alternatives">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There are various alternatives to the use cases of output parameters.</p>
<p>For returning multiple values from a function, an alternative is to return a <a href="/wiki/Tuple" title="Tuple">tuple</a>. Syntactically this is clearer if automatic sequence unpacking and <a href="/wiki/Parallel_assignment" title="Parallel assignment" class="mw-redirect">parallel assignment</a> can be used, as in <a href="/wiki/Go_(programming_language)" title="Go (programming language)">Go</a> or Python, such as:</p>
<p>WHATSON? 66cc25de-34f2-486f-ae0d-66477280c454</p>
<pre class="de1">
<span class="kw1">def</span> f<span class="br0">(</span><span class="br0">)</span>:
    <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span>
a<span class="sy0">,</span> b <span class="sy0">=</span> f<span class="br0">(</span><span class="br0">)</span>
</pre>
<p>For returning a value of one of several types, a <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a> can be used instead; the most common cases are <a href="/wiki/Nullable_type" title="Nullable type">nullable types</a> (<a href="/wiki/Option_type" title="Option type">option types</a>), where the return value can be null to indicate failure. For exception handling, one can return a nullable type, or raise an exception. For example, in Python one might have either:</p>
<p>WHATSON? d87cffc7-75d5-4e1c-a52e-7206f72ebb03</p>
<pre class="de1">
result <span class="sy0">=</span> Parse<span class="br0">(</span>s<span class="br0">)</span>
<span class="kw1">if</span> result <span class="kw1">is</span> <span class="kw2">None</span>:
    <span class="co1"># exception handling</span>
</pre>
<p>or, more idiomatically:</p>
<p>WHATSON? fcd15f0c-7a21-480e-8191-5cbd17389499</p>
<pre class="de1">
<span class="kw1">try</span>:
    result <span class="sy0">=</span> Parse<span class="br0">(</span>s<span class="br0">)</span>
<span class="kw1">except</span> ParseError:
    <span class="co1"># exception handling</span>
</pre>
<p>The micro-optimization of not requiring a local variable and copying the return when using output variables can also be applied to conventional functions and return values by sufficiently sophisticated compilers.</p>
<p>The usual alternative to output parameters in C and related languages is to return a single data structure containing all return values.<sup id="cite_ref-hallam_7-1" class="reference"><a href="#cite_note-hallam-7"><span>[</span>5<span>]</span></a></sup> For example, given a structure encapsulating width and height, one can write:</p>
<p>WHATSON? a63c4c48-4a17-4720-a663-7f2df5b19a3a</p>
<pre class="de1">
WidthHeight width_and_height <span class="sy0">=</span> f<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
</pre>
<p>In object-oriented languages, instead of using input/output parameters, one can often use <a href="/wiki/Call_by_sharing" title="Call by sharing" class="mw-redirect">call by sharing</a>, passing a reference to an object and then mutating the object, though not changing which object the variable refers to.<sup id="cite_ref-CA1021_11-1" class="reference"><a href="#cite_note-CA1021-11"><span>[</span>9<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=14" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Command-line_argument" title="Command-line argument" class="mw-redirect">Command-line argument</a></li>
<li><a href="/wiki/Evaluation_strategy" title="Evaluation strategy">Evaluation strategy</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Free_variables_and_bound_variables" title="Free variables and bound variables">Free variables and bound variables</a></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=15" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">In this article, the term "subroutine" refers to any subroutine-like construct, which have different names and slightly different meanings depending on the <a href="/wiki/Programming_language" title="Programming language">programming language</a> being discussed.</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">C and C++ are call by value, but if type is a reference (a C/C++ pointer or C++ reference), then setting the value of the reference can be used to produce call by reference style behavior.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Parameter_(computer_programming)&amp;action=edit&amp;section=16" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Meyer, Bertrand. <i><a href="/wiki/Object-Oriented_Software_Construction" title="Object-Oriented Software Construction">Object-Oriented Software Construction</a>, 2nd Edition,</i> Prentice Hall, 1997, p 444.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Meyer, p. 96.</span></li>
<li id="cite_note-ada-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-ada_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-ada_5-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://archive.adaic.com/standards/83rat/html/ratl-08-02.html">8.2 Parameter Modes</a>, "<a rel="nofollow" class="external text" href="http://archive.adaic.com/standards/83rat/html/Welcome.html">Rationale for the Design of the Ada® Programming Language</a>"</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://docs.oracle.com/cd/B10500_01/appdev.920/a96624/08_subs.htm#895">8. PL/SQL Subprograms: Specifying Subprogram Parameter Modes</a></span></li>
<li id="cite_note-hallam-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-hallam_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-hallam_7-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Peter Hallam. <a rel="nofollow" class="external text" href="http://web.archive.org/web/20110926113834/http://msdn.microsoft.com/en-us/vcsharp/aa336814.aspx">"Why does C# have both 'ref' and 'out'?"</a>. Archived from <a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/vcsharp/aa336814.aspx">the original</a> on 2011-09-26.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AParameter+%28computer+programming%29&amp;rft.aulast=Peter+Hallam&amp;rft.au=Peter+Hallam&amp;rft.btitle=Why+does+C%23+have+both+%27ref%27+and+%27out%27%3F&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Fvcsharp%2Faa336814.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/system.data.parameterdirection.aspx">ParameterDirection Enumeration</a></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://docs.oracle.com/cd/B10500_01/appdev.920/a96624/08_subs.htm#12813">8. PL/SQL Subprograms: Passing Large Data Structures with the NOCOPY Compiler Hint</a></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/f02979c7.aspx">Int32.TryParse Method (String, Int32)</a></span></li>
<li id="cite_note-CA1021-11"><span class="mw-cite-backlink">^ <a href="#cite_ref-CA1021_11-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-CA1021_11-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/ms182131.aspx">CA1021: Avoid out parameters</a></span></li>
</ol>
