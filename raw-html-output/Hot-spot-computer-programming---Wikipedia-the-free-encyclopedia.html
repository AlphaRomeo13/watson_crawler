<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Hot spot (computer programming)</span></h1>
<p>A <b>hot spot</b> in <a href="/wiki/Computer_science" title="Computer science">computer science</a> is most usually defined as a region of a <a href="/wiki/Computer_program" title="Computer program">computer program</a> where a high proportion of executed instructions occur or where most time is spent during the program's execution (not necessarily the same thing since some instructions are faster than others).</p>
<p>If a program is stopped randomly, the <a href="/wiki/Program_counter" title="Program counter">program counter</a> (the <a href="/wiki/Pointer_(computer_programming)" title="Pointer (computer programming)">pointer</a> to the next instruction to be executed) is frequently found to contain the address of an instruction within a certain range, possibly indicating code that is in need of optimization or even indicating the existence of a 'tight' <a href="/wiki/CPU" title="CPU" class="mw-redirect">CPU</a> <a href="/wiki/Program_loop" title="Program loop" class="mw-redirect">loop</a>. This simple technique can actually be used as a method of detecting highly used instructions although somewhat more sophisticated methods, such as <a href="/wiki/Instruction_set_simulator" title="Instruction set simulator">instruction set simulators</a> or <a href="/wiki/Profiling_(computer_programming)" title="Profiling (computer programming)">performance analyzers</a>, achieve this more accurately and consistently.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History_of_hot_spot_detection"><span class="tocnumber">1</span> <span class="toctext">History of hot spot detection</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Iteration"><span class="tocnumber">1.1</span> <span class="toctext">Iteration</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#Instruction_set_simulation_as_a_hot_spot_detector"><span class="tocnumber">2</span> <span class="toctext">Instruction set simulation as a hot spot detector</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Iteration"><span class="tocnumber">1.1</span> <span class="toctext">Iteration</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History_of_hot_spot_detection">History of hot spot detection</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Hot_spot_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: History of hot spot detection">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/Computer_science" title="Computer science">computer scientist</a> <a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a> described his first encounter with what he refers to as a <i>jump trace</i> in an interview for <i><a href="/wiki/Dr._Dobb%27s_Journal" title="Dr. Dobb's Journal">Dr. Dobb's Journal</a></i> in 1996, saying:</p>
<p>In the '60s, someone invented the concept of a 'jump trace'. This was a way of altering the <a href="/wiki/Machine_code" title="Machine code">machine language</a> of a program so it would change the next branch or <a href="/wiki/Jump_instruction" title="Jump instruction" class="mw-redirect">jump instruction</a> to retain control, so you could execute the program at fairly high speed instead of interpreting each instruction one at a time and record in a file just where a program diverged from sequentiality. By processing this file you could figure out where the program was spending most of its time. So the first day we had this software running, we applied it to our <a href="/wiki/Fortran" title="Fortran">Fortran</a> <a href="/wiki/Compiler" title="Compiler">compiler</a> supplied by, I suppose it was in those days, <a href="/wiki/Control_Data_Corporation" title="Control Data Corporation">Control Data Corporation</a>. We found out it was spending 87 percent of its time reading <a href="/wiki/Comment_(computer_programming)" title="Comment (computer programming)">comments</a>! The reason was that it was translating from one code system into another into another.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Iteration">Iteration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Hot_spot_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: Iteration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The example above serves to illustrate that effective hot spot detection is often an <a href="/wiki/Iteration" title="Iteration">iterative</a> process and perhaps one that should always be carried out (instead of simply accepting that a program is performing reasonably). After eliminating all extraneous processing (just by removing all the embedded comments for instance), a new runtime analysis would more accurately detect the "genuine" hot spots in the translation. If no hot spot detection had taken place at all, the program may well have consumed vastly more resources than necessary, possibly for many years on numerous machines, without anyone ever being fully aware of this.</p>
<h2><span class="mw-headline" id="Instruction_set_simulation_as_a_hot_spot_detector">Instruction set simulation as a hot spot detector</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Hot_spot_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Instruction set simulation as a hot spot detector">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An <a href="/wiki/Instruction_set_simulator" title="Instruction set simulator">instruction set simulator</a> can be used to count each time a particular instruction is executed and later produce either an on-screen display, a printed program listing (with counts and/or percentages of total <a href="/wiki/Instruction_path_length" title="Instruction path length">instruction path length</a>) or a separate report, showing precisely where the highest number of instructions took place. This only provides a <i>relative</i> view of hot spots (from an instruction step perspective) since most instructions have different timings on many machines. It nevertheless provides a measure of highly used code and one that is quite useful in itself when tuning an algorithm.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Hot_spot_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Algorithmic_efficiency#Hot_spot_analyzers" title="Algorithmic efficiency">Hot spot analyzers</a></li>
<li><a href="/wiki/Profiling_(computer_programming)" title="Profiling (computer programming)">Performance analysis</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Hot_spot_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.ntg.nl/maps/16/14.pdf">Jack Woehr: An interview with Donald Knuth, April 1996.</a></span></li>
</ol>
