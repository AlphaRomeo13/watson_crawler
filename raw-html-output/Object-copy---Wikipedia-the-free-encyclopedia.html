<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Object copy</span></h1>
<p>An <b>object copy</b> is an action in computing where a data object has its <a href="/wiki/Attribute_(computing)" title="Attribute (computing)">attributes</a> copied to another object of the same data type. An <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> is a composite <a href="/wiki/Data_type" title="Data type">data type</a> in <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a> languages. The copying of data is one of the most common procedures that occurs in computer programs. An object may be copied to reuse all or part of its data in a new context.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Methods_of_copying"><span class="tocnumber">1</span> <span class="toctext">Methods of copying</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Shallow_copy"><span class="tocnumber">1.1</span> <span class="toctext">Shallow copy</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Deep_copy"><span class="tocnumber">1.2</span> <span class="toctext">Deep copy</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Lazy_copy"><span class="tocnumber">1.3</span> <span class="toctext">Lazy copy</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Implementation"><span class="tocnumber">2</span> <span class="toctext">Implementation</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#In_C.2B.2B"><span class="tocnumber">2.1</span> <span class="toctext">In C++</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#In_Java"><span class="tocnumber">2.2</span> <span class="toctext">In Java</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#In_Eiffel"><span class="tocnumber">2.3</span> <span class="toctext">In Eiffel</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#In_other_languages"><span class="tocnumber">2.4</span> <span class="toctext">In other languages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Shallow_copy"><span class="tocnumber">1.1</span> <span class="toctext">Shallow copy</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Deep_copy"><span class="tocnumber">1.2</span> <span class="toctext">Deep copy</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Lazy_copy"><span class="tocnumber">1.3</span> <span class="toctext">Lazy copy</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#In_C.2B.2B"><span class="tocnumber">2.1</span> <span class="toctext">In C++</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#In_Java"><span class="tocnumber">2.2</span> <span class="toctext">In Java</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#In_Eiffel"><span class="tocnumber">2.3</span> <span class="toctext">In Eiffel</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#In_other_languages"><span class="tocnumber">2.4</span> <span class="toctext">In other languages</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Methods_of_copying">Methods of copying</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=1" title="Edit section: Methods of copying">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The design goal of most objects is to give the resemblance of being made out of one monolithic block even though most are not. As objects are made up of several different parts, copying becomes nontrivial. Several strategies exist to attack this problem.</p>
<p>Consider two objects, A and B, which each <a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">refer</a> to two memory blocks x<sub>i</sub> and y<sub>i</sub> (i = 1, 2,...). Think of A and B as strings and of x<sub>i</sub> and y<sub>i</sub> (i = 1, 2,...) as the characters they contain. There are different strategies for copying A into B.</p>
<h3><span class="mw-headline" id="Shallow_copy">Shallow copy</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=2" title="Edit section: Shallow copy">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>One method of copying an object is the shallow copy. In the process of shallow copying A, B will copy all of A's field values.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup><sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup><sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> If the field value is a memory address it copies the memory address, and if the field value is a primitive type it copies the value of the primitive type.</p>
<p><br>
The disadvantage is if you modify the memory address that one of B's fields point to, you are also modifying what A's fields point to.</p>
<h3><span class="mw-headline" id="Deep_copy">Deep copy</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=3" title="Edit section: Deep copy">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An alternative is a deep copy. Here the data is actually copied over. The result is different from the result a shallow copy gives. The advantage is that A and B do not depend on each other but at the cost of a slower and more expensive copy.</p>
<h3><span class="mw-headline" id="Lazy_copy">Lazy copy</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=4" title="Edit section: Lazy copy">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A lazy copy is a combination of both strategies above. When initially copying an object, a (fast) shallow copy is used. A counter is also used to track how many objects share the data. When the program wants to modify an object, it can determine if the data is shared (by examining the counter) and can do a deep copy if necessary.</p>
<p>Lazy copy looks to the outside just as a deep copy but takes advantage of the speed of a shallow copy whenever possible. The downside are rather high but constant base costs because of the counter. Also, in certain situations, <a href="/wiki/Circular_reference" title="Circular reference">circular references</a> can cause problems.</p>
<p>Lazy copy is related to <a href="/wiki/Copy-on-write" title="Copy-on-write">copy-on-write</a>.</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=5" title="Edit section: Implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Nearly all <a href="/wiki/Object-oriented" title="Object-oriented" class="mw-redirect">object-oriented</a> <a href="/wiki/Programming_language" title="Programming language">programming languages</a> provide some way to copy objects. As the majority of languages do not provide most objects themselves, the programmer has to define how an object should be copied, just as he or she has to define if two objects are identical or even comparable in the first place. Many languages provide some default behavior.</p>
<p>How copying is solved varies from language to language and what concept of an object it has. The following presents examples for two of the most widely used object-oriented languages, <a href="/wiki/C%2B%2B" title="C++">C++</a> and <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, which should cover nearly every way that an object-oriented language can attack this problem.</p>
<h3><span class="mw-headline" id="In_C.2B.2B">In C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=6" title="Edit section: In C++">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++ is designed so that user-defined types should be able to function exactly like native types such as <b>char</b> and <b>int</b>. One way in which C++ achieves this is by allowing any class to define a <a href="/wiki/Copy_constructor" title="Copy constructor">copy constructor</a> and an assignment operator. C++ provides default versions of these which perform a memberwise copy, but any class is free to disable copying or define its own copy behaviour.</p>
<h3><span class="mw-headline" id="In_Java">In Java</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=7" title="Edit section: In Java">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Unlike in C++, objects in Java are always accessed indirectly through <a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a>. Objects are never created implicitly but instead are always passed or assigned by a reference variable. (Methods in Java are always <i>pass by value</i>, however, it is the value of the reference variable that is being passed.)<sup id="cite_ref-Passing_Information_to_a_Method_or_a_Constructor_5-0" class="reference"><a href="#cite_note-Passing_Information_to_a_Method_or_a_Constructor-5"><span>[</span>5<span>]</span></a></sup> The <a href="/wiki/Java_Virtual_Machine" title="Java Virtual Machine" class="mw-redirect">Java Virtual Machine</a> manages <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">garbage collection</a> so that objects are cleaned up after they are no longer reachable. There is no automatic way to copy any given object in Java.</p>
<p>Copying is usually performed by a <a href="/wiki/Clone_(Java_method)" title="Clone (Java method)">clone() method</a> of a class. This method usually, in turn, calls the clone() method of its parent class to obtain a copy, and then does any custom copying procedures. Eventually this gets to the clone() method of <code>Object</code> (the uppermost class), which creates a new instance of the same class as the object and copies all the fields to the new instance (a "shallow copy"). If this method is used, the class must implement the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html">Cloneable</a></code> marker interface, or else it will <a href="/wiki/Exception_handling" title="Exception handling">throw</a> a CloneNotSupportedException. After obtaining a copy from the parent class, a class' own clone() method may then provide custom cloning capability, like deep copying (i.e. duplicate some of the structures referred to by the object) or giving the new instance a new unique ID.</p>
<p>The return type of clone() is <code>Object</code>, but implementers of a clone method could write the type of the object being cloned instead due to Java's support for <a href="/wiki/Covariant_return_types" title="Covariant return types" class="mw-redirect">covariant return types</a>. One advantage of using clone() is that since it is an <a href="/wiki/Method_overriding_(programming)" title="Method overriding (programming)" class="mw-redirect">overridable method</a>, we can call clone() on any object, and it will use the clone() method of its actual class, without the calling code needing to know what that class is (which would be necessary with a copy constructor).</p>
<p>Another disadvantage is that one often cannot access the clone() method on an abstract type. Most interfaces and abstract classes in Java do not specify a public clone() method. As a result, often the only way to use the clone() method is if the actual class of an object is known, which is contrary to the abstraction principle of using the most generic type possible. For example, if one has a List reference in Java, one cannot invoke clone() on that reference because List specifies no public clone() method. Actual implementations of List like ArrayList and LinkedList all generally have clone() methods themselves, but it is inconvenient and bad abstraction to carry around the actual class type of an object.</p>
<p>Another way to copy objects in Java is to <a href="/wiki/Serialization" title="Serialization">serialize</a> them through the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">Serializable</a></code> interface. This is typically used for <a href="/wiki/Persistence_(computer_science)" title="Persistence (computer science)">persistence</a> and <a href="/wiki/Wire_protocol" title="Wire protocol">wire protocol</a> purposes, but it does create copies of objects and, unlike clone, a deep copy that gracefully handles cycled graphs of objects is readily available with minimal effort from the programmer.</p>
<p>Both of these methods suffer from a notable problem: the <a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">constructor</a> is not used for objects copied with clone or serialization. This can lead to bugs with improperly initialized data, prevents the use of <a href="/wiki/Final_(Java)" title="Final (Java)"><code>final</code></a> member fields, and makes maintenance challenging. Some utilities attempt to overcome these issues by using reflection to deep copy objects, such as the deep-cloning library.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="In_Eiffel">In Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=8" title="Edit section: In Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Runtime objects in <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> are accessible either indirectly through <a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a> or as <i>expanded</i> objects whose fields are embedded within the objects that use them. That is, fields of an object are stored either <a href="/wiki/Internal_storage" title="Internal storage" class="mw-redirect">externally or internally</a>.</p>
<p>The Eiffel class <code lang="eiffel" xml:lang="eiffel">ANY</code> contains features for shallow and deep copying and cloning of objects. All Eiffel classes inherit from <code lang="eiffel" xml:lang="eiffel">ANY</code>, so these features are available within all classes, and are applicable both to reference and expanded objects.</p>
<p>The <code lang="eiffel" xml:lang="eiffel">copy</code> feature effects a shallow, field-by-field copy from one object to another. In this case no new object is created. If <code lang="eiffel" xml:lang="eiffel">y</code> were copied to <code lang="eiffel" xml:lang="eiffel">x</code>, then the same objects referenced by <code lang="eiffel" xml:lang="eiffel">y</code> before the application of <code lang="eiffel" xml:lang="eiffel">copy</code>, will also be referenced by <code lang="eiffel" xml:lang="eiffel">x</code> after the <code lang="eiffel" xml:lang="eiffel">copy</code> feature completes.</p>
<p>To effect the creation of a new object which is a shallow duplicate of <code lang="eiffel" xml:lang="eiffel">y</code>, the feature <code lang="eiffel" xml:lang="eiffel">twin</code> is used. In this case, a single new object is created with its fields identical to those of the source.</p>
<p>The feature <code lang="eiffel" xml:lang="eiffel">twin</code> relies on the feature <code lang="eiffel" xml:lang="eiffel">copy</code>, which can be redefined in descendants of <code lang="eiffel" xml:lang="eiffel">ANY</code>, if necessary. The result of <code lang="eiffel" xml:lang="eiffel">twin</code> is of the anchored type <code lang="eiffel" xml:lang="eiffel">like Current</code>.</p>
<p>Deep copying and creating deep twins can be done using the features <code lang="eiffel" xml:lang="eiffel">deep_copy</code> and <code lang="eiffel" xml:lang="eiffel">deep_twin</code>, again inherited from class <code lang="eiffel" xml:lang="eiffel">ANY</code>. These features have the potential to create many new objects, because they duplicate all the objects in an entire object structure. Because new duplicate objects are created instead of simply copying references to existing objects, deep operations will become a source of performance issues more readily than shallow operations.</p>
<h3><span class="mw-headline" id="In_other_languages">In other languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=9" title="Edit section: In other languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C Sharp</a> (C#), rather than using the interface <code>ICloneable</code>, a generic extension method can be used to create a deep copy using reflection. This has two advantages: First, it provides the flexibility to copy every object without having to specify each property and variable to be copied manually. Second, because the type is generic, the compiler ensures that the destination object and the source object have the same type.</p>
<p>In <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, the methods <code>copy</code> and <code>mutableCopy</code> are inherited by all objects and intended for performing copies; the latter is for creating a mutable type of the original object. These methods in turn call the <code>copyWithZone</code> and <code>mutableCopyWithZone</code> methods, respectively, to perform the copying. An object must implement the corresponding <code>copyWithZone</code> method to be copyable.</p>
<p>In <a href="/wiki/OCaml" title="OCaml">OCaml</a>, the <a href="/wiki/Library_(computing)" title="Library (computing)">library</a> function <a rel="nofollow" class="external text" href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Oo.html#VALcopy">Oo.copy</a> performs shallow copying of an object.</p>
<p>In <a href="/wiki/PHP" title="PHP">PHP</a>, the <code>clone</code> keyword performs shallow copying of an object.<a rel="nofollow" class="external autonumber" href="http://www.php.net/manual/en/language.oop5.cloning.php">[1]</a> Programmers may define a special method <code><a rel="nofollow" class="external text" href="http://www.php.net/manual/en/language.oop5.cloning.php#object.clone">__clone()</a></code> in an object to provide custom copying implementation.</p>
<p>In <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, the library's <a rel="nofollow" class="external text" href="https://docs.python.org/library/copy.html">copy</a> module provides shallow copy and deep copy of objects through the <code>copy()</code> and <code>deepcopy()</code> functions, respectively. Programmers may define special methods <code>__copy__()</code> and <code>__deepcopy__()</code> in an object to provide custom copying implementation.</p>
<p>In <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a>, all objects inherit two methods for performing shallow copies, <a rel="nofollow" class="external text" href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ref_c_object.html#Object.clone">clone</a> and <a rel="nofollow" class="external text" href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/ref_c_object.html#Object.dup">dup</a>. The two methods differ in that <code>clone</code> copies an object's tainted state, frozen state, and any <a href="/wiki/Singleton_pattern" title="Singleton pattern">singleton</a> methods it may have, whereas <code>dup</code> copies only its tainted state. Deep copies may be achieved by dumping and loading an object's byte stream or YAML serialization.<a rel="nofollow" class="external autonumber" href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/classes.html#S5">[2]</a> Alternatively, you can use the deep_dive gem to do a controlled deep copy of your object graphs. <a rel="nofollow" class="external autonumber" href="https://rubygems.org/gems/deep_dive">[3]</a></p>
<p>In <a href="/wiki/Perl" title="Perl">perl</a>, nested structures are stored by the use of references, thus a developer can either loop over the entire structure and re-reference the data or use the <code lang="perl" xml:lang="perl">dclone()</code> function from the module <a rel="nofollow" class="external text" href="https://metacpan.org/module/Storable">Storable</a>.</p>
<p>In <a href="/wiki/Visual_Basic_for_Applications" title="Visual Basic for Applications">VBA</a>, an assignment of variables of type <code>Object</code> is a shallow copy, an assignment for all other types (numeric types, String, user defined types, arrays) is a deep copy. So the keyword <code>Set</code> for an assignment signals a shallow copy and the (optional) keyword <code>Let</code> signals a deep copy. There is no built-in method for deep copies of Objects in VBA.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Copy_constructor" title="Copy constructor">Copy constructor</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Reference_counting" title="Reference counting">Reference counting</a></li>
<li><a href="/wiki/Copy-on-write" title="Copy-on-write">Copy-on-write</a></li>
<li><a href="/wiki/Clone_(Java_method)" title="Clone (Java method)">Clone (Java method)</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_copy&amp;action=edit&amp;section=11" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.fredosaurus.com/notes-cpp/oop-condestructors/shallowdeepcopy.html">"C++ Shallow vs Deep Copy Explanation"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+copy&amp;rft.btitle=C%2B%2B+Shallow+vs+Deep+Copy+Explanation&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.fredosaurus.com%2Fnotes-cpp%2Foop-condestructors%2Fshallowdeepcopy.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.codeproject.com/Articles/28952/Shallow-Copy-vs-Deep-Copy-in-NET">".NET Shallow vs Deep Copy Explanation"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+copy&amp;rft.btitle=.NET+Shallow+vs+Deep+Copy+Explanation&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.codeproject.com%2FArticles%2F28952%2FShallow-Copy-vs-Deep-Copy-in-NET&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://javapapers.com/core-java/java-clone-shallow-copy-and-deep-copy/">"Java Shallow vs Deep Copy Explanation"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+copy&amp;rft.btitle=Java+Shallow+vs+Deep+Copy+Explanation&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fjavapapers.com%2Fcore-java%2Fjava-clone-shallow-copy-and-deep-copy%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="https://secweb.cs.odu.edu/~zeil/cs361/web/website/Lectures/big3/pages/shallowvsdeep.html">"Generic Shallow vs Deep Copy Explanation"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+copy&amp;rft.btitle=Generic+Shallow+vs+Deep+Copy+Explanation&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fsecweb.cs.odu.edu%2F~zeil%2Fcs361%2Fweb%2Fwebsite%2FLectures%2Fbig3%2Fpages%2Fshallowvsdeep.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Passing_Information_to_a_Method_or_a_Constructor-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-Passing_Information_to_a_Method_or_a_Constructor_5-0">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html">"Passing Information to a Method or a Constructor"</a><span class="reference-accessdate">. Retrieved 8 October 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+copy&amp;rft.btitle=Passing+Information+to+a+Method+or+a+Constructor&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fjava%2FjavaOO%2Farguments.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://code.google.com/p/cloning/">Java deep-cloning library</a></span></li>
</ol>
