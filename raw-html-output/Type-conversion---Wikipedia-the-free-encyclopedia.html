<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Type conversion</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>type conversion</b>, <b>typecasting</b>, and <b>coercion</b> are different ways of, implicitly or explicitly, changing an entity of one <a href="/wiki/Data_type" title="Data type">data type</a> into another. This is done to take advantage of certain features of type hierarchies or type representations. One example would be small integers, which can be stored in a compact format and converted to a larger representation when used in arithmetic computations. In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, type conversion allows programs to treat objects of one type as one of their ancestor types to simplify interacting with them.</p>
<p>Each <a href="/wiki/Programming_language" title="Programming language">programming language</a> has its own rules on how types can be converted. In general, both objects and fundamental data types can be converted. In most languages, the word <i>coercion</i> is used to denote an <i>implicit</i> conversion, either during compilation or during <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run time</a>. A typical example would be an expression mixing integer and floating point numbers (like 5 + 0.1), where the integers are normally converted into the latter. Explicit type conversions can either be performed via built-in routines (or a special syntax) or via separately defined conversion routines such as an <a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">overloaded</a> <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> <a href="/wiki/Constructor_(object-oriented_programming)" title="Constructor (object-oriented programming)">constructor</a>.</p>
<p>In most <a href="/wiki/ALGOL" title="ALGOL">ALGOL</a>-based languages with <a href="/wiki/Nested_function" title="Nested function">nested function</a> definitions, such as Ada, Delphi, Modula 2 and Pascal, <i>conversion</i> and <i>casting</i> are distinctly different concepts. In these languages, <i>conversion</i> refers to either implicitly or explicitly changing a value from one data type to another, e.g. a 16-bit integer to a 32-bit integer. The storage requirements may change as a result of the conversion. A loss of precision or truncation may also occur. The word <i>cast</i>, on the other hand, refers to explicitly changing the <i>interpretation</i> of the <i>bit pattern</i> representing a value from one type to another. For example 32 contiguous bits may be treated as an array of 32 booleans, a 4-byte string, an unsigned 32-bit integer or an IEEE single precision floating point value. While the storage requirements are never changed, it still requires knowledge of low level details such as representation format, byte order, and alignment requirements in order to be meaningful.</p>
<p>In the C family of languages and <a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a>, the word <i>cast</i> typically refers to an <i>explicit</i> type conversion (as opposed to an implicit conversion), regardless of whether this is a re-interpretation of a bit-pattern or a real conversion.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#C-like_languages"><span class="tocnumber">1</span> <span class="toctext">C-like languages</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Implicit_type_conversion"><span class="tocnumber">1.1</span> <span class="toctext">Implicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Type_promotion"><span class="tocnumber">1.1.1</span> <span class="toctext">Type promotion</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-4"><a href="#Explicit_type_conversion"><span class="tocnumber">1.2</span> <span class="toctext">Explicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Using_overloaded_object_constructor"><span class="tocnumber">1.2.1</span> <span class="toctext">Using overloaded object constructor</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#C.23"><span class="tocnumber">2</span> <span class="toctext">C#</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Eiffel"><span class="tocnumber">3</span> <span class="toctext">Eiffel</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Definition_of_type_conversion_in_Eiffel"><span class="tocnumber">3.1</span> <span class="toctext">Definition of type conversion in Eiffel</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Example"><span class="tocnumber">3.2</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Implicit_type_conversion"><span class="tocnumber">1.1</span> <span class="toctext">Implicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Type_promotion"><span class="tocnumber">1.1.1</span> <span class="toctext">Type promotion</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-4"><a href="#Explicit_type_conversion"><span class="tocnumber">1.2</span> <span class="toctext">Explicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Using_overloaded_object_constructor"><span class="tocnumber">1.2.1</span> <span class="toctext">Using overloaded object constructor</span></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Type_promotion"><span class="tocnumber">1.1.1</span> <span class="toctext">Type promotion</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Using_overloaded_object_constructor"><span class="tocnumber">1.2.1</span> <span class="toctext">Using overloaded object constructor</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Definition_of_type_conversion_in_Eiffel"><span class="tocnumber">3.1</span> <span class="toctext">Definition of type conversion in Eiffel</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Example"><span class="tocnumber">3.2</span> <span class="toctext">Example</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="C-like_languages">C-like languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=1" title="Edit section: C-like languages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Implicit_type_conversion">Implicit type conversion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=2" title="Edit section: Implicit type conversion">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Implicit type conversion, also known as <i>coercion</i>, is an automatic type conversion by the <a href="/wiki/Compiler" title="Compiler">compiler</a>. Some <a href="/wiki/Programming_language" title="Programming language">languages</a> allow compilers to provide coercion; others require it.</p>
<p>In a mixed-type expression, data of one or more <a href="/wiki/Subtyping" title="Subtyping">subtypes</a> can be <a href="/wiki/Type_conversion_in_C" title="Type conversion in C">converted</a> to a supertype as needed at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">runtime</a> so that the program will run correctly. For example, the following is legal <a href="/wiki/C_(programming_language)" title="C (programming language)">C language</a> code:</p>
<p>WHATSON? a7f5a5d6-45ad-47f8-9dc7-fccd7dc4db69</p>
<pre class="de1">
<span class="kw4">double</span>  d<span class="sy0">;</span>
<span class="kw4">long</span>    l<span class="sy0">;</span>
<span class="kw4">int</span>     i<span class="sy0">;</span>
 
<span class="kw1">if</span> <span class="br0">(</span>d <span class="sy0">&gt;</span> i<span class="br0">)</span>   d <span class="sy0">=</span> i<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;</span> l<span class="br0">)</span>   l <span class="sy0">=</span> i<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span>d <span class="sy0">==</span> l<span class="br0">)</span>  d <span class="sy0">*=</span> <span class="nu0">2</span><span class="sy0">;</span>
</pre>
<p>Although <span class="mw-geshi c source-c">d</span>, <span class="mw-geshi c source-c">l</span> and <span class="mw-geshi c source-c">i</span> belong to different data types, they will be automatically converted to equal data types each time a comparison or assignment is executed. This behavior should be used with caution, as unintended consequences can arise. Data can be lost when floating-point representations are converted to integer representations as the fractional components of the floating-point values will be truncated (rounded towards zero). Conversely, converting from an integer representation to a floating-point one can also lose precision, since the floating-point type may be unable to represent the integer exactly (for example, <span class="mw-geshi c source-c"><span class="kw4">float</span></span> might be an <a href="/wiki/IEEE_754" title="IEEE 754" class="mw-redirect">IEEE 754</a> single precision type, which cannot represent the integer 16777217 exactly, while a 32-bit integer type can). This can lead to unintuitive behavior, as demonstrated by the following code:</p>
<p>WHATSON? e86963a6-8562-4f33-a48c-e7d85296e212</p>
<pre class="de1">
<span class="co2">#include &lt;stdio.h&gt;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> i_value   <span class="sy0">=</span> <span class="nu0">16777217</span><span class="sy0">;</span>
    <span class="kw4">float</span> f_value <span class="sy0">=</span> <span class="nu16">16777216.0</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"The integer is: %d<span class="es1">\n</span>"</span><span class="sy0">,</span> i_value<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"The float is:   %f<span class="es1">\n</span>"</span><span class="sy0">,</span> f_value<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Their equality: %d<span class="es1">\n</span>"</span><span class="sy0">,</span> i_value <span class="sy0">==</span> f_value<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>On compilers that implement floats as IEEE single precision, and ints as at least 32 bits, this code will give this peculiar print-out:</p>
<p>WHATSON? 8d810af3-b040-4529-a94a-57e10cba6fd7</p>
<pre class="de1">
    The integer is<span class="sy0">:</span> <span class="nu0">16777217</span>
    The <span class="kw4">float</span> is<span class="sy0">:</span> <span class="nu16">16777216.000000</span>
    Their equality<span class="sy0">:</span> <span class="nu0">1</span>
</pre>
<p>Note that 1 represents equality in the last line of the print-out. This odd behavior is caused by an implicit conversion of <span class="mw-geshi c source-c">i_value</span> to float when it is compared with <span class="mw-geshi c source-c">f_value</span>. The conversion causes loss of precision, which makes the values equal before the comparison.</p>
<p>Important takeaways:</p>
<ol>
<li><span class="mw-geshi c source-c"><span class="kw4">float</span></span> to <span class="mw-geshi c source-c"><span class="kw4">int</span></span> causes <a href="/wiki/Truncation" title="Truncation">truncation</a>, i.e. removal of the fractional part;</li>
<li><span class="mw-geshi c source-c"><span class="kw4">double</span></span> to <span class="mw-geshi c source-c"><span class="kw4">float</span></span> causes rounding of digit;</li>
<li><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">long</span></span> to <span class="mw-geshi c source-c"><span class="kw4">int</span></span> causes dropping of excess higher order bits.</li>
</ol>
<h4><span class="mw-headline" id="Type_promotion">Type promotion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=3" title="Edit section: Type promotion">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>One special case of implicit type conversion is type promotion, where the compiler automatically expands the binary representation of objects of integer or floating-point types. Promotions are commonly used with types smaller than the native type of the target platform's <a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">ALU</a> prior to arithmetic and logical operations in order to make such operations possible, or more efficient if the ALU can work with more than one type. C and C++ perform such promotion for objects of boolean, character, wide character, enumeration, and short integer types which are promoted to int, and for objects of type float, which are promoted to double. Unlike some other type conversions, promotions never lose precision or modify the value stored in the object.</p>
<p>In <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>:</p>
<p>WHATSON? fcd2b40f-d93a-4fdf-b4df-92475d774e5b</p>
<pre class="de1">
<span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
<span class="kw4">double</span> y <span class="sy0">=</span> <span class="nu0">3.5</span><span class="sy0">;</span>
<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>x<span class="sy0">+</span>y<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//The output will be 6.5</span>
</pre>
<h3><span class="mw-headline" id="Explicit_type_conversion">Explicit type conversion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=4" title="Edit section: Explicit type conversion">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Explicit type conversion is a type conversion which is explicitly defined within a program (instead of being done by a compiler for implicit type conversion).</p>
<p>WHATSON? d8532d9d-67c5-484c-a48e-aacd8d4a3693</p>
<pre class="de1">
<span class="kw4">double</span> da <span class="sy1">=</span> <span class="nu16">3.3</span><span class="sy4">;</span>
<span class="kw4">double</span> db <span class="sy1">=</span> <span class="nu16">3.3</span><span class="sy4">;</span>
<span class="kw4">double</span> dc <span class="sy1">=</span> <span class="nu16">3.4</span><span class="sy4">;</span>
<span class="kw4">int</span> result <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>da <span class="sy2">+</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>db <span class="sy2">+</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>dc<span class="sy4">;</span> <span class="co1">//result == 9</span>
<span class="co1">//if implicit conversion would be used (as with "result = da + db + dc"), result would be equal to 10</span>
</pre>
<p>There are several kinds of explicit conversion.</p>
<p>In object-oriented programming languages, objects can also be <a href="/wiki/Downcasting" title="Downcasting">downcast</a> : a reference of a base class is cast to one of its derived classes.</p>
<h4><span class="mw-headline" id="Using_overloaded_object_constructor">Using overloaded object constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=5" title="Edit section: Using overloaded object constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>WHATSON? c0d46783-9d61-4d87-a9f7-87097b02e43c</p>
<pre class="de1">
<span class="kw2">class</span> Myclass <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
    <span class="kw4">double</span> myD<span class="sy4">;</span>
    Myclass<span class="br0">(</span><span class="kw4">double</span> d<span class="br0">)</span> <span class="sy4">:</span> myD<span class="br0">(</span>d<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span> <span class="sy2">*</span>argv<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    Myclass obj <span class="sy1">=</span> <span class="nu16">5.2</span><span class="sy4">;</span> <span class="co1">// here is the type conversion</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<h2><span class="mw-headline" id="C.23">C#</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=6" title="Edit section: C#">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, type conversion can be made in a safe or unsafe (i.e. C-like) manner, the former called <i>checked type cast</i>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>WHATSON? 020eb18d-c2f7-4529-af61-64f7907ffd9d</p>
<pre class="de1">
Animal animal <span class="sy0">=</span> <span class="kw3">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
Bulldog b <span class="sy0">=</span> <span class="br0">(</span>Bulldog<span class="br0">)</span> animal<span class="sy0">;</span>   <span class="co1">// if (animal is Bulldog), stat.type(animal) is Bulldog, else an exception</span>
b <span class="sy0">=</span> animal <span class="kw1">as</span> Bulldog<span class="sy0">;</span>          <span class="co1">// if (animal is Bulldog), b = (Bulldog) animal, else b = null</span>
 
animal <span class="sy0">=</span> <span class="kw1">null</span><span class="sy0">;</span>
b <span class="sy0">=</span> animal <span class="kw1">as</span> Bulldog<span class="sy0">;</span>          <span class="co1">// b == null</span>
</pre>
<h2><span class="mw-headline" id="Eiffel">Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=7" title="Edit section: Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> the notion of type conversion is integrated into the rules of the type system. The Assignment Rule says that an assignment, such as:</p>
<p>WHATSON? e2db51dd-09bb-430f-b69d-624d50c4806b</p>
<pre class="de1">
 x <span class="sy0">:=</span> y
</pre>
<p>is valid if and only if the type of its source expression, <code lang="eiffel" xml:lang="eiffel">y</code> in this case, is <i>compatible with</i> the type of its target entity, <code lang="eiffel" xml:lang="eiffel">x</code> in this case. In this rule, <i>compatible with</i> means that the type of the source expression either <i>conforms to</i> or <i>converts to</i> that of the target. Conformance of types is defined by the familiar rules for <a href="/wiki/Polymorphism_in_object-oriented_programming" title="Polymorphism in object-oriented programming" class="mw-redirect">polymorphism in object-oriented programming</a>. For example, in the assignment above, the type of <code lang="eiffel" xml:lang="eiffel">y</code> conforms to the type of <code lang="eiffel" xml:lang="eiffel">x</code> if the class upon which <code lang="eiffel" xml:lang="eiffel">y</code> is based is a descendant of that upon which <code lang="eiffel" xml:lang="eiffel">x</code> is based.</p>
<h3><span class="mw-headline" id="Definition_of_type_conversion_in_Eiffel">Definition of type conversion in Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=8" title="Edit section: Definition of type conversion in Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The actions of type conversion in Eiffel, specifically <i>converts to</i> and <i>converts from</i> are defined as:</p>
<p>A type based on a class CU <i>converts to</i> a type T based on a class CT (and T <i>converts from</i> U) if either</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=9" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Eiffel is a fully compliant <a href="/wiki/List_of_CLI_languages" title="List of CLI languages">language</a> for <a href="/wiki/Microsoft_.Net" title="Microsoft .Net" class="mw-redirect">Microsoft .Net</a>. Prior to the development of .Net, Eiffel was already equipped with an extensive class libraries. Using the .Net type libraries, particularly with commonly used types such as strings, poses a conversion problem. Existing Eiffel software uses the string classes (such as <code lang="eiffel" xml:lang="eiffel">STRING_8</code>) from the Eiffel libraries, but Eiffel software written for .Net must use the .Net string class (<code lang="eiffel" xml:lang="eiffel">System.String</code>) in many cases, for example when calling .Net methods which expect items of the .Net type to be passed as arguments. So, the conversion of these types back and forth needs to be as seamless as possible.</p>
<p>WHATSON? 3ed2e21f-b9ce-49d7-8d93-d43caa59768b</p>
<pre class="de1">
    my_string<span class="sy0">:</span> STRING_8                 <span class="co1">-- Native Eiffel string</span>
    my_system_string<span class="sy0">:</span> SYSTEM_STRING     <span class="co1">-- Native Microsoft .Net string</span>
 
        …
 
            my_string <span class="sy0">:=</span> my_system_string
</pre>
<p>In the code above, two strings are declared, one of each different type (<code lang="eiffel" xml:lang="eiffel">SYSTEM_STRING</code> is the Eiffel compliant alias for System.String). Because <code lang="eiffel" xml:lang="eiffel">System.String</code> does not conform to <code lang="eiffel" xml:lang="eiffel">STRING_8</code>, then the assignment above is valid only if <code lang="eiffel" xml:lang="eiffel">System.String</code> converts to <code lang="eiffel" xml:lang="eiffel">STRING_8</code>.</p>
<p>The Eiffel class <code lang="eiffel" xml:lang="eiffel">STRING_8</code> has a conversion procedure <code lang="eiffel" xml:lang="eiffel">make_from_cil</code> for objects of type <code lang="eiffel" xml:lang="eiffel">System.String</code>. Conversion procedures are also always designated as creation procedures (similar to constructors). The following is an excerpt from the <code lang="eiffel" xml:lang="eiffel">STRING_8</code> class:</p>
<p>WHATSON? 6d651012-fa3b-44e7-a60a-0b13d62db4f9</p>
<pre class="de1">
    <span class="kw1">class</span> STRING_8
        …
    <span class="kw2">create</span>
        make_from_cil
        …
    convert
        make_from_cil <span class="br0">(</span><span class="br0">{</span>SYSTEM_STRING<span class="br0">}</span><span class="br0">)</span>
        …
</pre>
<p>The presence of the conversion procedure makes the assignment:</p>
<p>WHATSON? df6d0606-6e8a-4afe-ad6d-63f39bf6e15e</p>
<pre class="de1">
            my_string <span class="sy0">:=</span> my_system_string
</pre>
<p>semantically equivalent to:</p>
<p>WHATSON? fb0cf4cf-47eb-47af-8deb-89bb8db6a051</p>
<pre class="de1">
            <span class="kw2">create</span> my_string.<span class="me1">make_from_cil</span> <span class="br0">(</span>my_system_string<span class="br0">)</span>
</pre>
<p>in which <code lang="eiffel" xml:lang="eiffel">my_string</code> is constructed as a new object of type <code lang="eiffel" xml:lang="eiffel">STRING_8</code> with content equivalent to that of <code lang="eiffel" xml:lang="eiffel">my_system_string</code>.</p>
<p>To handle an assignment with original source and target reversed:</p>
<p>WHATSON? 9204d76e-99a5-42b1-b526-622cce9f9910</p>
<pre class="de1">
            my_system_string <span class="sy0">:=</span> my_string
</pre>
<p>the class <code lang="eiffel" xml:lang="eiffel">STRING_8</code> also contains a conversion query <code lang="eiffel" xml:lang="eiffel">to_cil</code> which will produce a <code lang="eiffel" xml:lang="eiffel">System.String</code> from an instance of <code lang="eiffel" xml:lang="eiffel">STRING_8</code>.</p>
<p>WHATSON? d26184e1-666e-4890-83b8-5de2fb4abfb5</p>
<pre class="de1">
    <span class="kw1">class</span> STRING_8
        …
    <span class="kw2">create</span>
        make_from_cil
        …
    convert
        make_from_cil <span class="br0">(</span><span class="br0">{</span>SYSTEM_STRING<span class="br0">}</span><span class="br0">)</span>
        to_cil<span class="sy0">:</span> <span class="br0">{</span>SYSTEM_STRING<span class="br0">}</span>
        …
</pre>
<p>The assignment:</p>
<p>WHATSON? 9ea05b92-e4e1-49d7-8b7d-e1016a3bb91c</p>
<pre class="de1">
            my_system_string <span class="sy0">:=</span> my_string
</pre>
<p>then, becomes equivalent to:</p>
<p>WHATSON? 64031b85-e566-4e77-a42e-dc25f96cb115</p>
<pre class="de1">
            my_system_string <span class="sy0">:=</span> my_string.<span class="me1">to_cil</span>
</pre>
<p>In Eiffel, the setup for type conversion is included in the class code, but then appears to happen as automatically as <a href="#Explicit_type_conversion">explicit type conversion</a> in client code. The includes not just assignments but other types of attachments as well, such as argument (parameter) substitution.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Downcasting" title="Downcasting">Downcasting</a></li>
<li><a href="/wiki/Dynamic_cast" title="Dynamic cast">dynamic_cast</a></li>
<li><a href="/wiki/Type_punning" title="Type punning">Type punning</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=11" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web">Mössenböck, Hanspeter (25 March 2002). <a rel="nofollow" class="external text" href="http://ssw.jku.at/Teaching/Lectures/CSharp/Tutorial/Part2.pdf">"Advanced C#: Checked Type Casts"</a>. Institut für Systemsoftware, Johannes Kepler Universität Linz, Fachbereich Informatik. p. 5<span class="reference-accessdate">. Retrieved 4 August 2011</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AType+conversion&amp;rft.aufirst=Hanspeter&amp;rft.aulast=M%C3%B6ssenb%C3%B6ck&amp;rft.au=M%C3%B6ssenb%C3%B6ck%2C+Hanspeter&amp;rft.btitle=Advanced+C%23%3A+Checked+Type+Casts&amp;rft.date=25+March+2002&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fssw.jku.at%2FTeaching%2FLectures%2FCSharp%2FTutorial%2FPart2.pdf&amp;rft.pages=5&amp;rft.pub=Institut+f%C3%BCr+Systemsoftware%2C+Johannes+Kepler+Universit%C3%A4t+Linz%2C+Fachbereich+Informatik&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> at <a rel="nofollow" class="external text" href="http://ssw.jku.at/Teaching/Lectures/CSharp/Tutorial/">C# Tutorial</a></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=12" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://help.sap.com/abapdocu_70/en/ABENCAST_CASTING_GLOSRY.htm">Casting in ABAP</a></li>
<li><a rel="nofollow" class="external text" href="http://www.adapower.com/index.php?Command=Class&amp;ClassID=FAQ&amp;CID=354">Casting in Ada</a></li>
<li><a class="external text" href="http://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Statements/Variables/Type_Casting">Casting in C++</a></li>
<li><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5">Casting in Java</a></li>
<li><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/aa691280(v=vs.71).aspx">Implicit Conversions in C#</a></li>
<li><a rel="nofollow" class="external text" href="http://cppreference.com/wiki/language/implicit_cast">Implicit Type Casting at Cppreference.com</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/cast.html">Static and Reinterpretation castings in C++</a></li>
<li><a class="external text" href="http://en.wikibooks.org/wiki/F_Sharp_Programming/Inheritance#Up-casting_and_Down-casting">Upcasting and Downcasting</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_types" title="Template:Data types"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_types" title="Template talk:Data types"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_types&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Bit" title="Bit">Bit</a></li>
<li><a href="/wiki/Byte" title="Byte">Byte</a></li>
<li><a href="/wiki/Ternary_numeral_system" title="Ternary numeral system">Trit</a></li>
<li><a href="/wiki/Ternary_numeral_system#Tryte" title="Ternary numeral system">Tryte</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
<ul>
<li><a href="/wiki/Arbitrary-precision_arithmetic" title="Arbitrary-precision arithmetic">Bignum</a></li>
<li><a href="/wiki/Complex_data_type" title="Complex data type">Complex</a></li>
<li><a href="/wiki/Decimal_data_type" title="Decimal data type">Decimal</a></li>
<li><a href="/wiki/Fixed-point_arithmetic" title="Fixed-point arithmetic">Fixed-point</a></li>
<li><a href="/wiki/Floating_point" title="Floating point">Floating-point</a></li>
<li><a href="/wiki/Integer_(computer_science)" title="Integer (computer science)">Integer</a>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
</li>
<li><a href="/wiki/Interval_arithmetic" title="Interval arithmetic">Interval</a></li>
<li><a href="/wiki/Rational_data_type" title="Rational data type">Rational</a></li>
</ul>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
<ul>
<li><a href="/wiki/Character_(computing)" title="Character (computing)">Character</a></li>
<li><a href="/wiki/String_(computer_science)" title="String (computer science)">String</a>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_address" title="Memory address">Address</a>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
</li>
<li><a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">Reference</a></li>
</ul>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
<ul>
<li><a href="/wiki/Algebraic_data_type" title="Algebraic data type">Algebraic data type</a>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
</li>
<li><a href="/wiki/Array_data_type" title="Array data type">Array</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">Class</a></li>
<li><a href="/wiki/Dependent_type" title="Dependent type">Dependent</a></li>
<li><a href="/wiki/Intuitionistic_type_theory#Equality_type" title="Intuitionistic type theory">Equality</a></li>
<li><a href="/wiki/Inductive_type" title="Inductive type">Inductive</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Object_(computer_science)" title="Object (computer science)">Object</a>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
</li>
<li><a href="/wiki/Option_type" title="Option type">Option type</a></li>
<li><a href="/wiki/Product_type" title="Product type">Product</a></li>
<li><a href="/wiki/Record_(computer_science)" title="Record (computer science)">Record</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a></li>
<li><a href="/wiki/Union_type" title="Union type">Union</a>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
<ul>
<li><a href="/wiki/Boolean_data_type" title="Boolean data type">Boolean</a></li>
<li><a href="/wiki/Bottom_type" title="Bottom type">Bottom type</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Collection</a></li>
<li><a href="/wiki/Enumerated_type" title="Enumerated type">Enumerated type</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception</a></li>
<li><a href="/wiki/Function_type" title="Function type">Function type</a></li>
<li><a href="/wiki/Opaque_data_type" title="Opaque data type">Opaque data type</a></li>
<li><a href="/wiki/Recursive_data_type" title="Recursive data type">Recursive data type</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Stream_(computing)" title="Stream (computing)">Stream</a></li>
<li><a href="/wiki/Top_type" title="Top type">Top type</a></li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Unit_type" title="Unit type">Unit type</a></li>
<li><a href="/wiki/Void_type" title="Void type">Void</a></li>
</ul>
<ul>
<li><a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract data type</a></li>
<li><a href="/wiki/Data_structure" title="Data structure">Data structure</a></li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Kind_(type_theory)" title="Kind (type theory)">Kind</a>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
</li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Primitive_data_type" title="Primitive data type">Primitive data type</a></li>
<li><a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">Protocol</a>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Type_constructor" title="Type constructor">Type constructor</a></li>
<li><strong class="selflink">Type conversion</strong></li>
<li><a href="/wiki/Type_system" title="Type system">Type system</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Type conversion</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>type conversion</b>, <b>typecasting</b>, and <b>coercion</b> are different ways of, implicitly or explicitly, changing an entity of one <a href="/wiki/Data_type" title="Data type">data type</a> into another. This is done to take advantage of certain features of type hierarchies or type representations. One example would be small integers, which can be stored in a compact format and converted to a larger representation when used in arithmetic computations. In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, type conversion allows programs to treat objects of one type as one of their ancestor types to simplify interacting with them.</p>
<p>Each <a href="/wiki/Programming_language" title="Programming language">programming language</a> has its own rules on how types can be converted. In general, both objects and fundamental data types can be converted. In most languages, the word <i>coercion</i> is used to denote an <i>implicit</i> conversion, either during compilation or during <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run time</a>. A typical example would be an expression mixing integer and floating point numbers (like 5 + 0.1), where the integers are normally converted into the latter. Explicit type conversions can either be performed via built-in routines (or a special syntax) or via separately defined conversion routines such as an <a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">overloaded</a> <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> <a href="/wiki/Constructor_(object-oriented_programming)" title="Constructor (object-oriented programming)">constructor</a>.</p>
<p>In most <a href="/wiki/ALGOL" title="ALGOL">ALGOL</a>-based languages with <a href="/wiki/Nested_function" title="Nested function">nested function</a> definitions, such as Ada, Delphi, Modula 2 and Pascal, <i>conversion</i> and <i>casting</i> are distinctly different concepts. In these languages, <i>conversion</i> refers to either implicitly or explicitly changing a value from one data type to another, e.g. a 16-bit integer to a 32-bit integer. The storage requirements may change as a result of the conversion. A loss of precision or truncation may also occur. The word <i>cast</i>, on the other hand, refers to explicitly changing the <i>interpretation</i> of the <i>bit pattern</i> representing a value from one type to another. For example 32 contiguous bits may be treated as an array of 32 booleans, a 4-byte string, an unsigned 32-bit integer or an IEEE single precision floating point value. While the storage requirements are never changed, it still requires knowledge of low level details such as representation format, byte order, and alignment requirements in order to be meaningful.</p>
<p>In the C family of languages and <a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a>, the word <i>cast</i> typically refers to an <i>explicit</i> type conversion (as opposed to an implicit conversion), regardless of whether this is a re-interpretation of a bit-pattern or a real conversion.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#C-like_languages"><span class="tocnumber">1</span> <span class="toctext">C-like languages</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Implicit_type_conversion"><span class="tocnumber">1.1</span> <span class="toctext">Implicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Type_promotion"><span class="tocnumber">1.1.1</span> <span class="toctext">Type promotion</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-4"><a href="#Explicit_type_conversion"><span class="tocnumber">1.2</span> <span class="toctext">Explicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Using_overloaded_object_constructor"><span class="tocnumber">1.2.1</span> <span class="toctext">Using overloaded object constructor</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#C.23"><span class="tocnumber">2</span> <span class="toctext">C#</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Eiffel"><span class="tocnumber">3</span> <span class="toctext">Eiffel</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Definition_of_type_conversion_in_Eiffel"><span class="tocnumber">3.1</span> <span class="toctext">Definition of type conversion in Eiffel</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Example"><span class="tocnumber">3.2</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Implicit_type_conversion"><span class="tocnumber">1.1</span> <span class="toctext">Implicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Type_promotion"><span class="tocnumber">1.1.1</span> <span class="toctext">Type promotion</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-4"><a href="#Explicit_type_conversion"><span class="tocnumber">1.2</span> <span class="toctext">Explicit type conversion</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Using_overloaded_object_constructor"><span class="tocnumber">1.2.1</span> <span class="toctext">Using overloaded object constructor</span></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Type_promotion"><span class="tocnumber">1.1.1</span> <span class="toctext">Type promotion</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Using_overloaded_object_constructor"><span class="tocnumber">1.2.1</span> <span class="toctext">Using overloaded object constructor</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Definition_of_type_conversion_in_Eiffel"><span class="tocnumber">3.1</span> <span class="toctext">Definition of type conversion in Eiffel</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Example"><span class="tocnumber">3.2</span> <span class="toctext">Example</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="C-like_languages">C-like languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=1" title="Edit section: C-like languages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Implicit_type_conversion">Implicit type conversion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=2" title="Edit section: Implicit type conversion">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Implicit type conversion, also known as <i>coercion</i>, is an automatic type conversion by the <a href="/wiki/Compiler" title="Compiler">compiler</a>. Some <a href="/wiki/Programming_language" title="Programming language">languages</a> allow compilers to provide coercion; others require it.</p>
<p>In a mixed-type expression, data of one or more <a href="/wiki/Subtyping" title="Subtyping">subtypes</a> can be <a href="/wiki/Type_conversion_in_C" title="Type conversion in C">converted</a> to a supertype as needed at <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">runtime</a> so that the program will run correctly. For example, the following is legal <a href="/wiki/C_(programming_language)" title="C (programming language)">C language</a> code:</p>
<p>WHATSON? ce44182c-3567-4ade-98db-d6dca4b15f57</p>
<pre class="de1">
<span class="kw4">double</span>  d<span class="sy0">;</span>
<span class="kw4">long</span>    l<span class="sy0">;</span>
<span class="kw4">int</span>     i<span class="sy0">;</span>
 
<span class="kw1">if</span> <span class="br0">(</span>d <span class="sy0">&gt;</span> i<span class="br0">)</span>   d <span class="sy0">=</span> i<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;</span> l<span class="br0">)</span>   l <span class="sy0">=</span> i<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span>d <span class="sy0">==</span> l<span class="br0">)</span>  d <span class="sy0">*=</span> <span class="nu0">2</span><span class="sy0">;</span>
</pre>
<p>Although <span class="mw-geshi c source-c">d</span>, <span class="mw-geshi c source-c">l</span> and <span class="mw-geshi c source-c">i</span> belong to different data types, they will be automatically converted to equal data types each time a comparison or assignment is executed. This behavior should be used with caution, as unintended consequences can arise. Data can be lost when floating-point representations are converted to integer representations as the fractional components of the floating-point values will be truncated (rounded towards zero). Conversely, converting from an integer representation to a floating-point one can also lose precision, since the floating-point type may be unable to represent the integer exactly (for example, <span class="mw-geshi c source-c"><span class="kw4">float</span></span> might be an <a href="/wiki/IEEE_754" title="IEEE 754" class="mw-redirect">IEEE 754</a> single precision type, which cannot represent the integer 16777217 exactly, while a 32-bit integer type can). This can lead to unintuitive behavior, as demonstrated by the following code:</p>
<p>WHATSON? 00f6067e-3065-423d-822a-78e719900ce1</p>
<pre class="de1">
<span class="co2">#include &lt;stdio.h&gt;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> i_value   <span class="sy0">=</span> <span class="nu0">16777217</span><span class="sy0">;</span>
    <span class="kw4">float</span> f_value <span class="sy0">=</span> <span class="nu16">16777216.0</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"The integer is: %d<span class="es1">\n</span>"</span><span class="sy0">,</span> i_value<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"The float is:   %f<span class="es1">\n</span>"</span><span class="sy0">,</span> f_value<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Their equality: %d<span class="es1">\n</span>"</span><span class="sy0">,</span> i_value <span class="sy0">==</span> f_value<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>On compilers that implement floats as IEEE single precision, and ints as at least 32 bits, this code will give this peculiar print-out:</p>
<p>WHATSON? 75dfe645-a423-4fe5-a80b-4cda7a862fe6</p>
<pre class="de1">
    The integer is<span class="sy0">:</span> <span class="nu0">16777217</span>
    The <span class="kw4">float</span> is<span class="sy0">:</span> <span class="nu16">16777216.000000</span>
    Their equality<span class="sy0">:</span> <span class="nu0">1</span>
</pre>
<p>Note that 1 represents equality in the last line of the print-out. This odd behavior is caused by an implicit conversion of <span class="mw-geshi c source-c">i_value</span> to float when it is compared with <span class="mw-geshi c source-c">f_value</span>. The conversion causes loss of precision, which makes the values equal before the comparison.</p>
<p>Important takeaways:</p>
<ol>
<li><span class="mw-geshi c source-c"><span class="kw4">float</span></span> to <span class="mw-geshi c source-c"><span class="kw4">int</span></span> causes <a href="/wiki/Truncation" title="Truncation">truncation</a>, i.e. removal of the fractional part;</li>
<li><span class="mw-geshi c source-c"><span class="kw4">double</span></span> to <span class="mw-geshi c source-c"><span class="kw4">float</span></span> causes rounding of digit;</li>
<li><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">long</span></span> to <span class="mw-geshi c source-c"><span class="kw4">int</span></span> causes dropping of excess higher order bits.</li>
</ol>
<h4><span class="mw-headline" id="Type_promotion">Type promotion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=3" title="Edit section: Type promotion">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>One special case of implicit type conversion is type promotion, where the compiler automatically expands the binary representation of objects of integer or floating-point types. Promotions are commonly used with types smaller than the native type of the target platform's <a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">ALU</a> prior to arithmetic and logical operations in order to make such operations possible, or more efficient if the ALU can work with more than one type. C and C++ perform such promotion for objects of boolean, character, wide character, enumeration, and short integer types which are promoted to int, and for objects of type float, which are promoted to double. Unlike some other type conversions, promotions never lose precision or modify the value stored in the object.</p>
<p>In <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>:</p>
<p>WHATSON? e6f9a5f1-c577-43ac-8d99-a50acf539606</p>
<pre class="de1">
<span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
<span class="kw4">double</span> y <span class="sy0">=</span> <span class="nu0">3.5</span><span class="sy0">;</span>
<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>x<span class="sy0">+</span>y<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//The output will be 6.5</span>
</pre>
<h3><span class="mw-headline" id="Explicit_type_conversion">Explicit type conversion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=4" title="Edit section: Explicit type conversion">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Explicit type conversion is a type conversion which is explicitly defined within a program (instead of being done by a compiler for implicit type conversion).</p>
<p>WHATSON? dbca6470-69f3-4332-9e63-c6d86b924aab</p>
<pre class="de1">
<span class="kw4">double</span> da <span class="sy1">=</span> <span class="nu16">3.3</span><span class="sy4">;</span>
<span class="kw4">double</span> db <span class="sy1">=</span> <span class="nu16">3.3</span><span class="sy4">;</span>
<span class="kw4">double</span> dc <span class="sy1">=</span> <span class="nu16">3.4</span><span class="sy4">;</span>
<span class="kw4">int</span> result <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>da <span class="sy2">+</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>db <span class="sy2">+</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>dc<span class="sy4">;</span> <span class="co1">//result == 9</span>
<span class="co1">//if implicit conversion would be used (as with "result = da + db + dc"), result would be equal to 10</span>
</pre>
<p>There are several kinds of explicit conversion.</p>
<p>In object-oriented programming languages, objects can also be <a href="/wiki/Downcasting" title="Downcasting">downcast</a> : a reference of a base class is cast to one of its derived classes.</p>
<h4><span class="mw-headline" id="Using_overloaded_object_constructor">Using overloaded object constructor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=5" title="Edit section: Using overloaded object constructor">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>WHATSON? 3f8c0197-2768-45d7-811c-21b567e402ed</p>
<pre class="de1">
<span class="kw2">class</span> Myclass <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
    <span class="kw4">double</span> myD<span class="sy4">;</span>
    Myclass<span class="br0">(</span><span class="kw4">double</span> d<span class="br0">)</span> <span class="sy4">:</span> myD<span class="br0">(</span>d<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span> <span class="sy2">*</span>argv<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span>
<span class="br0">{</span>
    Myclass obj <span class="sy1">=</span> <span class="nu16">5.2</span><span class="sy4">;</span> <span class="co1">// here is the type conversion</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<h2><span class="mw-headline" id="C.23">C#</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=6" title="Edit section: C#">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, type conversion can be made in a safe or unsafe (i.e. C-like) manner, the former called <i>checked type cast</i>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>WHATSON? f880e986-bc22-4974-a1de-c670a2feac43</p>
<pre class="de1">
Animal animal <span class="sy0">=</span> <span class="kw3">new</span> Cat<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 
Bulldog b <span class="sy0">=</span> <span class="br0">(</span>Bulldog<span class="br0">)</span> animal<span class="sy0">;</span>   <span class="co1">// if (animal is Bulldog), stat.type(animal) is Bulldog, else an exception</span>
b <span class="sy0">=</span> animal <span class="kw1">as</span> Bulldog<span class="sy0">;</span>          <span class="co1">// if (animal is Bulldog), b = (Bulldog) animal, else b = null</span>
 
animal <span class="sy0">=</span> <span class="kw1">null</span><span class="sy0">;</span>
b <span class="sy0">=</span> animal <span class="kw1">as</span> Bulldog<span class="sy0">;</span>          <span class="co1">// b == null</span>
</pre>
<h2><span class="mw-headline" id="Eiffel">Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=7" title="Edit section: Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a> the notion of type conversion is integrated into the rules of the type system. The Assignment Rule says that an assignment, such as:</p>
<p>WHATSON? 185a434e-d297-40cf-936e-c4227b1a4f6b</p>
<pre class="de1">
 x <span class="sy0">:=</span> y
</pre>
<p>is valid if and only if the type of its source expression, <code lang="eiffel" xml:lang="eiffel">y</code> in this case, is <i>compatible with</i> the type of its target entity, <code lang="eiffel" xml:lang="eiffel">x</code> in this case. In this rule, <i>compatible with</i> means that the type of the source expression either <i>conforms to</i> or <i>converts to</i> that of the target. Conformance of types is defined by the familiar rules for <a href="/wiki/Polymorphism_in_object-oriented_programming" title="Polymorphism in object-oriented programming" class="mw-redirect">polymorphism in object-oriented programming</a>. For example, in the assignment above, the type of <code lang="eiffel" xml:lang="eiffel">y</code> conforms to the type of <code lang="eiffel" xml:lang="eiffel">x</code> if the class upon which <code lang="eiffel" xml:lang="eiffel">y</code> is based is a descendant of that upon which <code lang="eiffel" xml:lang="eiffel">x</code> is based.</p>
<h3><span class="mw-headline" id="Definition_of_type_conversion_in_Eiffel">Definition of type conversion in Eiffel</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=8" title="Edit section: Definition of type conversion in Eiffel">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The actions of type conversion in Eiffel, specifically <i>converts to</i> and <i>converts from</i> are defined as:</p>
<p>A type based on a class CU <i>converts to</i> a type T based on a class CT (and T <i>converts from</i> U) if either</p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=9" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Eiffel is a fully compliant <a href="/wiki/List_of_CLI_languages" title="List of CLI languages">language</a> for <a href="/wiki/Microsoft_.Net" title="Microsoft .Net" class="mw-redirect">Microsoft .Net</a>. Prior to the development of .Net, Eiffel was already equipped with an extensive class libraries. Using the .Net type libraries, particularly with commonly used types such as strings, poses a conversion problem. Existing Eiffel software uses the string classes (such as <code lang="eiffel" xml:lang="eiffel">STRING_8</code>) from the Eiffel libraries, but Eiffel software written for .Net must use the .Net string class (<code lang="eiffel" xml:lang="eiffel">System.String</code>) in many cases, for example when calling .Net methods which expect items of the .Net type to be passed as arguments. So, the conversion of these types back and forth needs to be as seamless as possible.</p>
<p>WHATSON? 554e6735-26c1-42a7-8942-9dc107d5cd70</p>
<pre class="de1">
    my_string<span class="sy0">:</span> STRING_8                 <span class="co1">-- Native Eiffel string</span>
    my_system_string<span class="sy0">:</span> SYSTEM_STRING     <span class="co1">-- Native Microsoft .Net string</span>
 
        …
 
            my_string <span class="sy0">:=</span> my_system_string
</pre>
<p>In the code above, two strings are declared, one of each different type (<code lang="eiffel" xml:lang="eiffel">SYSTEM_STRING</code> is the Eiffel compliant alias for System.String). Because <code lang="eiffel" xml:lang="eiffel">System.String</code> does not conform to <code lang="eiffel" xml:lang="eiffel">STRING_8</code>, then the assignment above is valid only if <code lang="eiffel" xml:lang="eiffel">System.String</code> converts to <code lang="eiffel" xml:lang="eiffel">STRING_8</code>.</p>
<p>The Eiffel class <code lang="eiffel" xml:lang="eiffel">STRING_8</code> has a conversion procedure <code lang="eiffel" xml:lang="eiffel">make_from_cil</code> for objects of type <code lang="eiffel" xml:lang="eiffel">System.String</code>. Conversion procedures are also always designated as creation procedures (similar to constructors). The following is an excerpt from the <code lang="eiffel" xml:lang="eiffel">STRING_8</code> class:</p>
<p>WHATSON? 7638be24-11fe-4174-a6f8-b60ab9f65e27</p>
<pre class="de1">
    <span class="kw1">class</span> STRING_8
        …
    <span class="kw2">create</span>
        make_from_cil
        …
    convert
        make_from_cil <span class="br0">(</span><span class="br0">{</span>SYSTEM_STRING<span class="br0">}</span><span class="br0">)</span>
        …
</pre>
<p>The presence of the conversion procedure makes the assignment:</p>
<p>WHATSON? de7d7094-a8ad-4194-85ac-5d4010dd702a</p>
<pre class="de1">
            my_string <span class="sy0">:=</span> my_system_string
</pre>
<p>semantically equivalent to:</p>
<p>WHATSON? 6fdd94c7-5707-4596-9525-3333c7d608f1</p>
<pre class="de1">
            <span class="kw2">create</span> my_string.<span class="me1">make_from_cil</span> <span class="br0">(</span>my_system_string<span class="br0">)</span>
</pre>
<p>in which <code lang="eiffel" xml:lang="eiffel">my_string</code> is constructed as a new object of type <code lang="eiffel" xml:lang="eiffel">STRING_8</code> with content equivalent to that of <code lang="eiffel" xml:lang="eiffel">my_system_string</code>.</p>
<p>To handle an assignment with original source and target reversed:</p>
<p>WHATSON? 1d82f091-3a08-49e9-93e4-d9762cd695a2</p>
<pre class="de1">
            my_system_string <span class="sy0">:=</span> my_string
</pre>
<p>the class <code lang="eiffel" xml:lang="eiffel">STRING_8</code> also contains a conversion query <code lang="eiffel" xml:lang="eiffel">to_cil</code> which will produce a <code lang="eiffel" xml:lang="eiffel">System.String</code> from an instance of <code lang="eiffel" xml:lang="eiffel">STRING_8</code>.</p>
<p>WHATSON? 79e5672f-134f-4691-9def-8a170c4342f0</p>
<pre class="de1">
    <span class="kw1">class</span> STRING_8
        …
    <span class="kw2">create</span>
        make_from_cil
        …
    convert
        make_from_cil <span class="br0">(</span><span class="br0">{</span>SYSTEM_STRING<span class="br0">}</span><span class="br0">)</span>
        to_cil<span class="sy0">:</span> <span class="br0">{</span>SYSTEM_STRING<span class="br0">}</span>
        …
</pre>
<p>The assignment:</p>
<p>WHATSON? 2f92909b-cec5-4352-a63e-edb84583ca0e</p>
<pre class="de1">
            my_system_string <span class="sy0">:=</span> my_string
</pre>
<p>then, becomes equivalent to:</p>
<p>WHATSON? 4a129f74-bc86-4893-bbe1-773c3d0aa0a5</p>
<pre class="de1">
            my_system_string <span class="sy0">:=</span> my_string.<span class="me1">to_cil</span>
</pre>
<p>In Eiffel, the setup for type conversion is included in the class code, but then appears to happen as automatically as <a href="#Explicit_type_conversion">explicit type conversion</a> in client code. The includes not just assignments but other types of attachments as well, such as argument (parameter) substitution.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Downcasting" title="Downcasting">Downcasting</a></li>
<li><a href="/wiki/Dynamic_cast" title="Dynamic cast">dynamic_cast</a></li>
<li><a href="/wiki/Type_punning" title="Type punning">Type punning</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=11" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web">Mössenböck, Hanspeter (25 March 2002). <a rel="nofollow" class="external text" href="http://ssw.jku.at/Teaching/Lectures/CSharp/Tutorial/Part2.pdf">"Advanced C#: Checked Type Casts"</a>. Institut für Systemsoftware, Johannes Kepler Universität Linz, Fachbereich Informatik. p. 5<span class="reference-accessdate">. Retrieved 4 August 2011</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AType+conversion&amp;rft.aufirst=Hanspeter&amp;rft.aulast=M%C3%B6ssenb%C3%B6ck&amp;rft.au=M%C3%B6ssenb%C3%B6ck%2C+Hanspeter&amp;rft.btitle=Advanced+C%23%3A+Checked+Type+Casts&amp;rft.date=25+March+2002&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fssw.jku.at%2FTeaching%2FLectures%2FCSharp%2FTutorial%2FPart2.pdf&amp;rft.pages=5&amp;rft.pub=Institut+f%C3%BCr+Systemsoftware%2C+Johannes+Kepler+Universit%C3%A4t+Linz%2C+Fachbereich+Informatik&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> at <a rel="nofollow" class="external text" href="http://ssw.jku.at/Teaching/Lectures/CSharp/Tutorial/">C# Tutorial</a></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Type_conversion&amp;action=edit&amp;section=12" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://help.sap.com/abapdocu_70/en/ABENCAST_CASTING_GLOSRY.htm">Casting in ABAP</a></li>
<li><a rel="nofollow" class="external text" href="http://www.adapower.com/index.php?Command=Class&amp;ClassID=FAQ&amp;CID=354">Casting in Ada</a></li>
<li><a class="external text" href="http://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Statements/Variables/Type_Casting">Casting in C++</a></li>
<li><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/specs/jls/se5.0/html/conversions.html#5.5">Casting in Java</a></li>
<li><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/aa691280(v=vs.71).aspx">Implicit Conversions in C#</a></li>
<li><a rel="nofollow" class="external text" href="http://cppreference.com/wiki/language/implicit_cast">Implicit Type Casting at Cppreference.com</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/cast.html">Static and Reinterpretation castings in C++</a></li>
<li><a class="external text" href="http://en.wikibooks.org/wiki/F_Sharp_Programming/Inheritance#Up-casting_and_Down-casting">Upcasting and Downcasting</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_types" title="Template:Data types"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_types" title="Template talk:Data types"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_types&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Bit" title="Bit">Bit</a></li>
<li><a href="/wiki/Byte" title="Byte">Byte</a></li>
<li><a href="/wiki/Ternary_numeral_system" title="Ternary numeral system">Trit</a></li>
<li><a href="/wiki/Ternary_numeral_system#Tryte" title="Ternary numeral system">Tryte</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
<ul>
<li><a href="/wiki/Arbitrary-precision_arithmetic" title="Arbitrary-precision arithmetic">Bignum</a></li>
<li><a href="/wiki/Complex_data_type" title="Complex data type">Complex</a></li>
<li><a href="/wiki/Decimal_data_type" title="Decimal data type">Decimal</a></li>
<li><a href="/wiki/Fixed-point_arithmetic" title="Fixed-point arithmetic">Fixed-point</a></li>
<li><a href="/wiki/Floating_point" title="Floating point">Floating-point</a></li>
<li><a href="/wiki/Integer_(computer_science)" title="Integer (computer science)">Integer</a>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
</li>
<li><a href="/wiki/Interval_arithmetic" title="Interval arithmetic">Interval</a></li>
<li><a href="/wiki/Rational_data_type" title="Rational data type">Rational</a></li>
</ul>
<ul>
<li><a href="/wiki/Signedness" title="Signedness">signedness</a></li>
</ul>
<ul>
<li><a href="/wiki/Character_(computing)" title="Character (computing)">Character</a></li>
<li><a href="/wiki/String_(computer_science)" title="String (computer science)">String</a>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Null-terminated_string" title="Null-terminated string">null-terminated</a></li>
</ul>
<ul>
<li><a href="/wiki/Memory_address" title="Memory address">Address</a>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
</li>
<li><a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">Reference</a></li>
</ul>
<ul>
<li><a href="/wiki/Physical_address" title="Physical address">physical</a></li>
<li><a href="/wiki/Virtual_address_space" title="Virtual address space">virtual</a></li>
</ul>
<ul>
<li><a href="/wiki/Algebraic_data_type" title="Algebraic data type">Algebraic data type</a>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
</li>
<li><a href="/wiki/Array_data_type" title="Array data type">Array</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">Class</a></li>
<li><a href="/wiki/Dependent_type" title="Dependent type">Dependent</a></li>
<li><a href="/wiki/Intuitionistic_type_theory#Equality_type" title="Intuitionistic type theory">Equality</a></li>
<li><a href="/wiki/Inductive_type" title="Inductive type">Inductive</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Object_(computer_science)" title="Object (computer science)">Object</a>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
</li>
<li><a href="/wiki/Option_type" title="Option type">Option type</a></li>
<li><a href="/wiki/Product_type" title="Product type">Product</a></li>
<li><a href="/wiki/Record_(computer_science)" title="Record (computer science)">Record</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a></li>
<li><a href="/wiki/Union_type" title="Union type">Union</a>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Generalized_algebraic_data_type" title="Generalized algebraic data type">generalized</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaobject" title="Metaobject">metaobject</a></li>
</ul>
<ul>
<li><a href="/wiki/Tagged_union" title="Tagged union">tagged</a></li>
</ul>
<ul>
<li><a href="/wiki/Boolean_data_type" title="Boolean data type">Boolean</a></li>
<li><a href="/wiki/Bottom_type" title="Bottom type">Bottom type</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Collection</a></li>
<li><a href="/wiki/Enumerated_type" title="Enumerated type">Enumerated type</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception</a></li>
<li><a href="/wiki/Function_type" title="Function type">Function type</a></li>
<li><a href="/wiki/Opaque_data_type" title="Opaque data type">Opaque data type</a></li>
<li><a href="/wiki/Recursive_data_type" title="Recursive data type">Recursive data type</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Stream_(computing)" title="Stream (computing)">Stream</a></li>
<li><a href="/wiki/Top_type" title="Top type">Top type</a></li>
<li><a href="/wiki/Type_class" title="Type class">Type class</a></li>
<li><a href="/wiki/Unit_type" title="Unit type">Unit type</a></li>
<li><a href="/wiki/Void_type" title="Void type">Void</a></li>
</ul>
<ul>
<li><a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract data type</a></li>
<li><a href="/wiki/Data_structure" title="Data structure">Data structure</a></li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Kind_(type_theory)" title="Kind (type theory)">Kind</a>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
</li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Primitive_data_type" title="Primitive data type">Primitive data type</a></li>
<li><a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">Protocol</a>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
</li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><a href="/wiki/Type_constructor" title="Type constructor">Type constructor</a></li>
<li><strong class="selflink">Type conversion</strong></li>
<li><a href="/wiki/Type_system" title="Type system">Type system</a></li>
</ul>
<ul>
<li><a href="/wiki/Metaclass" title="Metaclass">metaclass</a></li>
</ul>
<ul>
<li><a href="/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages" title="Interface (computing)">interface</a></li>
</ul>
