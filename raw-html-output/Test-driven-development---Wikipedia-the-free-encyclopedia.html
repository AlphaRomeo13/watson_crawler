<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Test-driven development</span></h1>
<ul>
<li><a href="/wiki/Requirements_analysis" title="Requirements analysis">Requirements</a></li>
<li><a href="/wiki/Functional_specification" title="Functional specification">Specification</a></li>
<li><a href="/wiki/Software_architecture" title="Software architecture">Architecture</a></li>
<li><a href="/wiki/Software_construction" title="Software construction">Construction</a></li>
<li><a href="/wiki/Software_design" title="Software design">Design</a></li>
<li><a href="/wiki/Software_testing" title="Software testing">Testing</a></li>
<li><a href="/wiki/Debugging" title="Debugging">Debugging</a></li>
<li><a href="/wiki/Software_deployment" title="Software deployment">Deployment</a></li>
<li><a href="/wiki/Software_maintenance" title="Software maintenance">Maintenance</a></li>
</ul>
<ul>
<li><a href="/wiki/Waterfall_model" title="Waterfall model">Waterfall</a></li>
<li><a href="/wiki/Software_prototyping" title="Software prototyping">Prototype model</a></li>
<li><a href="/wiki/Incremental_build_model" title="Incremental build model">Incremental</a></li>
<li><a href="/wiki/Iterative_and_incremental_development" title="Iterative and incremental development">Iterative</a></li>
<li><a href="/wiki/V-Model_(software_development)" title="V-Model (software development)">V-Model</a></li>
<li><a href="/wiki/Spiral_model" title="Spiral model">Spiral</a></li>
<li><a href="/wiki/Scrum_(software_development)" title="Scrum (software development)">Scrum</a></li>
<li><a href="/wiki/Cleanroom_software_engineering" title="Cleanroom software engineering">Cleanroom</a></li>
<li><a href="/wiki/Rapid_application_development" title="Rapid application development">RAD</a></li>
<li><a href="/wiki/Dynamic_systems_development_method" title="Dynamic systems development method">DSDM</a></li>
<li><a href="/wiki/Unified_Process" title="Unified Process">UP</a></li>
<li><a href="/wiki/Extreme_programming" title="Extreme programming">XP</a></li>
<li><a href="/wiki/Agile_software_development" title="Agile software development">Agile</a></li>
<li><a href="/wiki/Lean_software_development" title="Lean software development">Lean</a></li>
<li><a href="/wiki/Dual_Vee_Model" title="Dual Vee Model">Dual Vee Model</a></li>
<li><strong class="selflink">TDD</strong></li>
<li><a href="/wiki/Behavior-driven_development" title="Behavior-driven development">BDD</a></li>
<li><a href="/wiki/Feature-driven_development" title="Feature-driven development">FDD</a></li>
<li><a href="/wiki/Domain-driven_design" title="Domain-driven design">DDD</a></li>
<li><a href="/wiki/Model-driven_development" title="Model-driven development" class="mw-redirect">MDD</a></li>
</ul>
<ul>
<li><a href="/wiki/Software_configuration_management" title="Software configuration management">Configuration management</a></li>
<li><a href="/wiki/Software_documentation" title="Software documentation">Documentation</a></li>
<li><a href="/wiki/Software_quality_assurance" title="Software quality assurance">Software Quality assurance (SQA)</a></li>
<li><a href="/wiki/Software_project_management" title="Software project management">Project management</a></li>
<li><a href="/wiki/User_experience" title="User experience">User experience</a></li>
</ul>
<ul>
<li><a href="/wiki/Compiler" title="Compiler">Compiler</a></li>
<li><a href="/wiki/Debugger" title="Debugger">Debugger</a></li>
<li><a href="/wiki/Profiling_(computer_programming)" title="Profiling (computer programming)">Profiler</a></li>
<li><a href="/wiki/Graphical_user_interface_builder" title="Graphical user interface builder">GUI designer</a></li>
<li><a href="/wiki/UML_tools" title="UML tools" class="mw-redirect">Modeling</a></li>
<li><a href="/wiki/Integrated_development_environment" title="Integrated development environment">IDE</a></li>
<li><a href="/wiki/Build_automation" title="Build automation">Build automation</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Software_development_process" title="Template:Software development process"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Software_development_process" title="Template talk:Software development process"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Software_development_process&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p><b>Test-driven development</b> (<b>TDD</b>) is a <a href="/wiki/Software_development_process" title="Software development process">software development process</a> that relies on the repetition of a very short development cycle: first the developer writes an (initially failing) automated <a href="/wiki/Test_case" title="Test case">test case</a> that defines a desired improvement or new function, then produces the minimum amount of code to pass that test, and finally <a href="/wiki/Code_refactoring" title="Code refactoring">refactors</a> the new code to acceptable standards. <a href="/wiki/Kent_Beck" title="Kent Beck">Kent Beck</a>, who is credited with having developed or 'rediscovered' the technique, stated in 2003 that TDD encourages simple designs and inspires confidence.<sup id="cite_ref-Beck_1-0" class="reference"><a href="#cite_note-Beck-1"><span>[</span>1<span>]</span></a></sup></p>
<p>Test-driven development is related to the test-first programming concepts of <a href="/wiki/Extreme_programming" title="Extreme programming">extreme programming</a>, begun in 1999,<sup id="cite_ref-Cworld92_2-0" class="reference"><a href="#cite_note-Cworld92-2"><span>[</span>2<span>]</span></a></sup> but more recently has created more general interest in its own right.<sup id="cite_ref-Newkirk_3-0" class="reference"><a href="#cite_note-Newkirk-3"><span>[</span>3<span>]</span></a></sup></p>
<p>Programmers also apply the concept to improving and <a href="/wiki/Software_bug" title="Software bug">debugging</a> <a href="/wiki/Legacy_code" title="Legacy code">legacy code</a> developed with older techniques.<sup id="cite_ref-Feathers_4-0" class="reference"><a href="#cite_note-Feathers-4"><span>[</span>4<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Test-driven_development_cycle"><span class="tocnumber">1</span> <span class="toctext">Test-driven development cycle</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#1._Add_a_test"><span class="tocnumber">1.1</span> <span class="toctext">1. Add a test</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#2._Run_all_tests_and_see_if_the_new_one_fails"><span class="tocnumber">1.2</span> <span class="toctext">2. Run all tests and see if the new one fails</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#3._Write_some_code"><span class="tocnumber">1.3</span> <span class="toctext">3. Write some code</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#4._Run_tests"><span class="tocnumber">1.4</span> <span class="toctext">4. Run tests</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#5._Refactor_code"><span class="tocnumber">1.5</span> <span class="toctext">5. Refactor code</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Repeat"><span class="tocnumber">1.6</span> <span class="toctext">Repeat</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Development_style"><span class="tocnumber">2</span> <span class="toctext">Development style</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Best_practices"><span class="tocnumber">3</span> <span class="toctext">Best practices</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Test_structure"><span class="tocnumber">3.1</span> <span class="toctext">Test structure</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Individual_best_practices"><span class="tocnumber">3.2</span> <span class="toctext">Individual best practices</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Practices_to_avoid.2C_or_.22anti-patterns.22"><span class="tocnumber">3.3</span> <span class="toctext">Practices to avoid, or "anti-patterns"</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Benefits"><span class="tocnumber">4</span> <span class="toctext">Benefits</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Shortcomings"><span class="tocnumber">5</span> <span class="toctext">Shortcomings</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#TDD_and_ATDD"><span class="tocnumber">6</span> <span class="toctext">TDD and ATDD</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Code_visibility"><span class="tocnumber">7</span> <span class="toctext">Code visibility</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Software_for_TDD"><span class="tocnumber">8</span> <span class="toctext">Software for TDD</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#xUnit_frameworks"><span class="tocnumber">8.1</span> <span class="toctext">xUnit frameworks</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#TAP_results"><span class="tocnumber">8.2</span> <span class="toctext">TAP results</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="#Fakes.2C_mocks_and_integration_tests"><span class="tocnumber">9</span> <span class="toctext">Fakes, mocks and integration tests</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#TDD_for_complex_systems"><span class="tocnumber">10</span> <span class="toctext">TDD for complex systems</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#Designing_for_testability"><span class="tocnumber">10.1</span> <span class="toctext">Designing for testability</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Managing_tests_for_large_teams"><span class="tocnumber">10.2</span> <span class="toctext">Managing tests for large teams</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#See_also"><span class="tocnumber">11</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#References"><span class="tocnumber">12</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#External_links"><span class="tocnumber">13</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#1._Add_a_test"><span class="tocnumber">1.1</span> <span class="toctext">1. Add a test</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#2._Run_all_tests_and_see_if_the_new_one_fails"><span class="tocnumber">1.2</span> <span class="toctext">2. Run all tests and see if the new one fails</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#3._Write_some_code"><span class="tocnumber">1.3</span> <span class="toctext">3. Write some code</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#4._Run_tests"><span class="tocnumber">1.4</span> <span class="toctext">4. Run tests</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#5._Refactor_code"><span class="tocnumber">1.5</span> <span class="toctext">5. Refactor code</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Repeat"><span class="tocnumber">1.6</span> <span class="toctext">Repeat</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Test_structure"><span class="tocnumber">3.1</span> <span class="toctext">Test structure</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Individual_best_practices"><span class="tocnumber">3.2</span> <span class="toctext">Individual best practices</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Practices_to_avoid.2C_or_.22anti-patterns.22"><span class="tocnumber">3.3</span> <span class="toctext">Practices to avoid, or "anti-patterns"</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#xUnit_frameworks"><span class="tocnumber">8.1</span> <span class="toctext">xUnit frameworks</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#TAP_results"><span class="tocnumber">8.2</span> <span class="toctext">TAP results</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#Designing_for_testability"><span class="tocnumber">10.1</span> <span class="toctext">Designing for testability</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Managing_tests_for_large_teams"><span class="tocnumber">10.2</span> <span class="toctext">Managing tests for large teams</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Test-driven_development_cycle">Test-driven development cycle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=1" title="Edit section: Test-driven development cycle">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following sequence is based on the book <i><a href="/wiki/Test-Driven_Development_by_Example" title="Test-Driven Development by Example">Test-Driven Development by Example</a></i>.<sup id="cite_ref-Beck_1-1" class="reference"><a href="#cite_note-Beck-1"><span>[</span>1<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="1._Add_a_test">1. Add a test</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=2" title="Edit section: 1. Add a test">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In test-driven development, each new feature begins with writing a test. To write a test, the developer must clearly understand the feature's specification and requirements. The developer can accomplish this through <a href="/wiki/Use_case" title="Use case">use cases</a> and <a href="/wiki/User_story" title="User story">user stories</a> to cover the requirements and exception conditions, and can write the test in whatever testing framework is appropriate to the software environment. It could be a modified version of an existing test. This is a differentiating feature of test-driven development versus writing unit tests <i>after</i> the <a href="/wiki/Source_code" title="Source code">code</a> is written: it makes the developer focus on the requirements <i>before</i> writing the code, a subtle but important difference.</p>
<h3><span class="mw-headline" id="2._Run_all_tests_and_see_if_the_new_one_fails">2. Run all tests and see if the new one fails</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=3" title="Edit section: 2. Run all tests and see if the new one fails">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This validates that the <a href="/wiki/Test_harness" title="Test harness">test harness</a> is working correctly, that the new test does not mistakenly pass without requiring any new code, and that the required feature does not already exist. This step also tests the test itself, in the negative: it rules out the possibility that the new test always passes, and therefore is worthless. The new test should also fail for the expected reason. This step increases the developer's confidence that it is testing the right thing, and passes only in intended cases.</p>
<h3><span class="mw-headline" id="3._Write_some_code">3. Write some code</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=4" title="Edit section: 3. Write some code">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The next step is to write some code that causes the test to pass. The new code written at this stage is not perfect and may, for example, pass the test in an inelegant way. That is acceptable because it will be improved and honed in Step 5.</p>
<p>At this point, the only purpose of the written code is to pass the test; no further (and therefore untested) functionality should be predicted nor 'allowed for' at any stage.</p>
<h3><span class="mw-headline" id="4._Run_tests">4. Run tests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=5" title="Edit section: 4. Run tests">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If all test cases now pass, the programmer can be confident that the new code meets the test requirements, and does not break or degrade any existing features. If they do not, the new code must be adjusted until they do.</p>
<h3><span class="mw-headline" id="5._Refactor_code">5. Refactor code</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=6" title="Edit section: 5. Refactor code">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The growing code base must be <a href="/wiki/Code_refactoring" title="Code refactoring">cleaned up</a> regularly during test-driven development. New code can be moved from where it was convenient for passing a test to where it more logically belongs. <a href="/wiki/Duplicate_code" title="Duplicate code">Duplication</a> must be removed. <a href="/wiki/Object_(computer_science)" title="Object (computer science)">Object</a>, <a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">class</a>, <a href="/wiki/Modular_programming" title="Modular programming">module</a>, <a href="/wiki/Variable_(computer_science)" title="Variable (computer science)">variable</a> and <a href="/wiki/Method_(computer_programming)" title="Method (computer programming)">method</a> names should clearly represent their current purpose and use, as extra functionality is added. As features are added, method bodies can get longer and other objects larger. They benefit from being split and their parts carefully named to improve <a href="/wiki/Computer_programming#Readability_of_source_code" title="Computer programming">readability</a> and <a href="/wiki/Software_maintenance" title="Software maintenance">maintainability</a>, which will be increasingly valuable later in the <a href="/wiki/Software_lifecycle" title="Software lifecycle" class="mw-redirect">software lifecycle</a>. <a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">Inheritance hierarchies</a> may be rearranged to be more logical and helpful, and perhaps to benefit from recognised <a href="/wiki/Software_design_pattern" title="Software design pattern">design patterns</a>. There are specific and general guidelines for refactoring and for creating clean code.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup><sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> By continually re-running the test cases throughout each refactoring phase, the developer can be confident that process is not altering any existing functionality.</p>
<p>The concept of removing duplication is an important aspect of any software design. In this case, however, it also applies to the removal of any duplication between the test code and the production code—for example <a href="/wiki/Magic_number_(programming)" title="Magic number (programming)">magic numbers or strings</a> repeated in both to make the test pass in Step 3.</p>
<h3><span class="mw-headline" id="Repeat">Repeat</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=7" title="Edit section: Repeat">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Starting with another new test, the cycle is then repeated to push forward the functionality. The size of the steps should always be small, with as few as 1 to 10 edits between each test run. If new code does not rapidly satisfy a new test, or other tests fail unexpectedly, the programmer should <a href="/wiki/Undo" title="Undo">undo</a> or revert in preference to excessive <a href="/wiki/Debugging" title="Debugging">debugging</a>. <a href="/wiki/Continuous_integration" title="Continuous integration">Continuous integration</a> helps by providing revertible checkpoints. When using external libraries it is important not to make increments that are so small as to be effectively merely testing the library itself,<sup id="cite_ref-Newkirk_3-1" class="reference"><a href="#cite_note-Newkirk-3"><span>[</span>3<span>]</span></a></sup> unless there is some reason to believe that the library is buggy or is not sufficiently feature-complete to serve all the needs of the software under development.</p>
<h2><span class="mw-headline" id="Development_style">Development style</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=8" title="Edit section: Development style">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are various aspects to using test-driven development, for example the principles of "keep it simple stupid" (<a href="/wiki/KISS_principle" title="KISS principle">KISS</a>) and "<a href="/wiki/You_aren%27t_gonna_need_it" title="You aren't gonna need it">You aren't gonna need it</a>" (YAGNI). By focusing on writing only the code necessary to pass tests, designs can often be cleaner and clearer than is achieved by other methods.<sup id="cite_ref-Beck_1-2" class="reference"><a href="#cite_note-Beck-1"><span>[</span>1<span>]</span></a></sup> In <i><a href="/wiki/Test-Driven_Development_by_Example" title="Test-Driven Development by Example">Test-Driven Development by Example</a></i>, Kent Beck also suggests the principle "<a href="/wiki/Fake_it_till_you_make_it" title="Fake it till you make it">Fake it till you make it</a>".</p>
<p>To achieve some advanced design concept, such as a <a href="/wiki/Design_pattern" title="Design pattern">design pattern</a>, tests are written that generate that design. The code may remain simpler than the target pattern, but still pass all required tests. This can be unsettling at first but it allows the developer to focus only on what is important.</p>
<p>Write the tests first. The tests should be written before the functionality that is being tested. This has been claimed to have many benefits. It helps ensure that the application is written for testability, as the developers must consider how to test the application from the outset, rather than worrying about it later. It also ensures that tests for every feature get written. Additionally, writing the tests first drives a deeper and earlier understanding of the product requirements, ensures the effectiveness of the test code, and maintains a continual focus on the quality of the product.<sup id="cite_ref-Pathfinder_Solutions_7-0" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup> When writing feature-first code, there is a tendency by developers and the development organisations to push the developer on to the next feature, neglecting testing entirely. The first test might not even compile, at first, because all of the classes and methods it requires may not yet exist. Nevertheless, that first test functions as an executable specification.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup></p>
<p>First fail the test cases. The idea is to ensure that the test really works and can catch an error. Once this is shown, the underlying functionality can be implemented. This has been coined the "test-driven development mantra", known as red/green/refactor where red means <i>fail</i> and green means <i>pass</i>.</p>
<p>Test-driven development constantly repeats the steps of adding test cases that fail, passing them, and refactoring. Receiving the expected test results at each stage reinforces the programmer's mental model of the code, boosts confidence and increases productivity.</p>
<p>For TDD, a unit is most commonly defined as a class or group of related functions, often called a module. Keeping units relatively small is claimed to provide critical benefits, including:</p>
<ul>
<li>Reduced debugging effort – When test failures are detected, having smaller units aids in tracking down errors.</li>
<li>Self-documenting tests – Small test cases have improved readability and facilitate rapid understandability.<sup id="cite_ref-Pathfinder_Solutions_7-1" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup></li>
</ul>
<p>Advanced practices of test-driven development can lead to <a href="/wiki/Acceptance_test-driven_development" title="Acceptance test-driven development">Acceptance test-driven development</a> (ATDD) and <a href="/wiki/Specification_by_example" title="Specification by example">Specification by example</a> where the criteria specified by the customer are automated into acceptance tests, which then drive the traditional unit test-driven development (UTDD) process.<sup id="cite_ref-Koskela_9-0" class="reference"><a href="#cite_note-Koskela-9"><span>[</span>9<span>]</span></a></sup> This process ensures the customer has an automated mechanism to decide whether the software meets their requirements. With ATDD, the development team now has a specific target to satisfy, the acceptance tests, which keeps them continuously focused on what the customer really wants from that user story.</p>
<h2><span class="mw-headline" id="Best_practices">Best practices</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=9" title="Edit section: Best practices">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Test_structure">Test structure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=10" title="Edit section: Test structure">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Effective layout of a test case ensures all required actions are completed, improves the readability of the test case, and smooths the flow of execution. Consistent structure helps in building a self-documenting test case. A commonly applied structure for test cases has (1) setup, (2) execution, (3) validation, and (4) cleanup.</p>
<ul>
<li>Setup: Put the Unit Under Test (UUT) or the overall test system in the state needed to run the test.</li>
<li>Execution: Trigger/drive the UUT to perform the target behavior and capture all output, such as return values and output parameters. This step is usually very simple.</li>
<li>Validation: Ensure the results of the test are correct. These results may include explicit outputs captured during execution or state changes in the UUT &amp; UAT.</li>
<li>Cleanup: Restore the UUT or the overall test system to the pre-test state. This restoration permits another test to execute immediately after this one.<sup id="cite_ref-Pathfinder_Solutions_7-2" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup></li>
</ul>
<h3><span class="mw-headline" id="Individual_best_practices">Individual best practices</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=11" title="Edit section: Individual best practices">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li>Separate common set up and teardown logic into test support services utilized by the appropriate test cases.</li>
<li>Keep each <a href="/wiki/Oracle_(software_testing)" title="Oracle (software testing)">test oracle</a> focused on only the results necessary to validate its test.</li>
<li>Design time-related tests to allow tolerance for execution in non-real time operating systems. The common practice of allowing a 5-10 percent margin for late execution reduces the potential number of false negatives in test execution.</li>
<li>Treat your test code with the same respect as your production code. It also must work correctly for both positive and negative cases, last a long time, and be readable and maintainable.</li>
<li>Get together with your team and review your tests and test practices to share effective techniques and catch bad habits. It may be helpful to review this section during your discussion.<sup id="cite_ref-pathfindersolns.com_10-0" class="reference"><a href="#cite_note-pathfindersolns.com-10"><span>[</span>10<span>]</span></a></sup></li>
</ul>
<h3><span class="mw-headline" id="Practices_to_avoid.2C_or_.22anti-patterns.22">Practices to avoid, or "anti-patterns"</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=12" title='Edit section: Practices to avoid, or "anti-patterns"'>edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li>Having test cases depend on system state manipulated from previously executed test cases.</li>
<li>Dependencies between test cases. A test suite where test cases are dependent upon each other is brittle and complex. Execution order should not be presumed. Basic refactoring of the initial test cases or structure of the UUT causes a spiral of increasingly pervasive impacts in associated tests.</li>
<li>Interdependent tests. Interdependent tests can cause cascading false negatives. A failure in an early test case breaks a later test case even if no actual fault exists in the UUT, increasing defect analysis and debug efforts.</li>
<li>Testing precise execution behavior timing or performance.</li>
<li>Building “all-knowing oracles.” An oracle that inspects more than necessary is more expensive and brittle over time. This very common error is dangerous because it causes a subtle but pervasive time sink across the complex project.<sup id="cite_ref-pathfindersolns.com_10-1" class="reference"><a href="#cite_note-pathfindersolns.com-10"><span>[</span>10<span>]</span></a></sup></li>
<li>Testing implementation details.</li>
<li>Slow running tests.</li>
</ul>
<h2><span class="mw-headline" id="Benefits">Benefits</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=13" title="Edit section: Benefits">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A 2005 study found that using TDD meant writing more tests and, in turn, programmers who wrote more tests tended to be more productive.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> Hypotheses relating to code quality and a more direct correlation between TDD and productivity were inconclusive.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup></p>
<p>Programmers using pure TDD on new ("<a href="/wiki/Greenfield_project" title="Greenfield project">greenfield</a>") projects reported they only rarely felt the need to invoke a <a href="/wiki/Debugger" title="Debugger">debugger</a>. Used in conjunction with a <a href="/wiki/Version_control_system" title="Version control system" class="mw-redirect">version control system</a>, when tests fail unexpectedly, reverting the code to the last version that passed all tests may often be more productive than debugging.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>13<span>]</span></a></sup></p>
<p>Test-driven development offers more than just simple validation of correctness, but can also drive the design of a program.<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>14<span>]</span></a></sup> By focusing on the test cases first, one must imagine how the functionality is used by clients (in the first case, the test cases). So, the programmer is concerned with the interface before the implementation. This benefit is complementary to <a href="/wiki/Design_by_Contract" title="Design by Contract" class="mw-redirect">Design by Contract</a> as it approaches code through test cases rather than through mathematical assertions or preconceptions.</p>
<p>Test-driven development offers the ability to take small steps when required. It allows a programmer to focus on the task at hand as the first goal is to make the test pass. Exceptional cases and error handling are not considered initially, and tests to create these extraneous circumstances are implemented separately. Test-driven development ensures in this way that all written code is covered by at least one test. This gives the programming team, and subsequent users, a greater level of confidence in the code.</p>
<p>While it is true that more code is required with TDD than without TDD because of the unit test code, the total code implementation time could be shorter based on a model by Müller and Padberg.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>15<span>]</span></a></sup> Large numbers of tests help to limit the number of defects in the code. The early and frequent nature of the testing helps to catch defects early in the development cycle, preventing them from becoming endemic and expensive problems. Eliminating defects early in the process usually avoids lengthy and tedious debugging later in the project.</p>
<p>TDD can lead to more modularized, flexible, and extensible code. This effect often comes about because the methodology requires that the developers think of the software in terms of small units that can be written and tested independently and integrated together later. This leads to smaller, more focused classes, looser <a href="/wiki/Coupling_(computer_programming)" title="Coupling (computer programming)">coupling</a>, and cleaner interfaces. The use of the <a href="/wiki/Mock_object" title="Mock object">mock object</a> design pattern also contributes to the overall modularization of the code because this pattern requires that the code be written so that modules can be switched easily between mock versions for unit testing and "real" versions for deployment.</p>
<p>Because no more code is written than necessary to pass a failing test case, automated tests tend to cover every code path. For example, for a TDD developer to add an <code>else</code> branch to an existing <code>if</code> statement, the developer would first have to write a failing test case that motivates the branch. As a result, the automated tests resulting from TDD tend to be very thorough: they detect any unexpected changes in the code's behaviour. This detects problems that can arise where a change later in the development cycle unexpectedly alters other functionality.</p>
<p>Madeyski <sup id="cite_ref-Madeyski_16-0" class="reference"><a href="#cite_note-Madeyski-16"><span>[</span>16<span>]</span></a></sup> provided an empirical evidence (via a series of laboratory experiments with over 200 developers) regarding the superiority of the TDD practice over the classic Test-Last approach, with respect to the lower coupling between objects (CBO). The mean effect size represents a medium (but close to large) effect on the basis of meta-analysis of the performed experiments which is a substantial finding. It suggests a better modularization (i.e. a more modular design), easier reuse and testing of the developed software products due to the TDD programming practice.<sup id="cite_ref-Madeyski_16-1" class="reference"><a href="#cite_note-Madeyski-16"><span>[</span>16<span>]</span></a></sup> Madeyski also measured the effect of the TDD practice on unit tests using branch coverage (BC) and mutation score indicator (MSI),<sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>17<span>]</span></a></sup><sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>18<span>]</span></a></sup><sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span>[</span>19<span>]</span></a></sup> which are indicators of the thoroughness and the fault detection effectiveness of unit tests, respectively. The effect size of TDD on branch coverage was medium in size and therefore is considered substantive effect.<sup id="cite_ref-Madeyski_16-2" class="reference"><a href="#cite_note-Madeyski-16"><span>[</span>16<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Shortcomings">Shortcomings</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=14" title="Edit section: Shortcomings">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Test-driven development does not perform sufficient testing in situations where full functional tests are required to determine success or failure due to extensive use of unit tests.<sup id="cite_ref-20" class="reference"><a href="#cite_note-20"><span>[</span>20<span>]</span></a></sup> Examples of these are <a href="/wiki/User_interface" title="User interface">user interfaces</a>, programs that work with <a href="/wiki/Database" title="Database">databases</a>, and some that depend on specific <a href="/wiki/Computer_network" title="Computer network">network</a> configurations. TDD encourages developers to put the minimum amount of code into such modules and to maximize the logic that is in testable library code, using fakes and <a href="/wiki/Mock_object" title="Mock object">mocks</a> to represent the outside world.<sup id="cite_ref-21" class="reference"><a href="#cite_note-21"><span>[</span>21<span>]</span></a></sup></p>
<p>Management support is essential. Without the entire organization believing that test-driven development is going to improve the product, management may feel that time spent writing tests is wasted.<sup id="cite_ref-22" class="reference"><a href="#cite_note-22"><span>[</span>22<span>]</span></a></sup></p>
<p>Unit tests created in a test-driven development environment are typically created by the developer who is writing the code being tested. Therefore, the tests may share blind spots with the code: if, for example, a developer does not realize that certain input parameters must be checked, most likely neither the test nor the code will verify those parameters. Another example: if the developer misinterprets the requirements for the module he is developing, the code and the unit tests he writes will both be wrong in the same way. Therefore, the tests will pass, giving a false sense of correctness.</p>
<p>A high number of passing unit tests may bring a false sense of security, resulting in fewer additional <a href="/wiki/Software_testing" title="Software testing">software testing</a> activities, such as <a href="/wiki/Integration_testing" title="Integration testing">integration testing</a> and <a href="/wiki/Compliance_testing" title="Compliance testing" class="mw-redirect">compliance testing</a>.</p>
<p>Tests become part of the maintenance overhead of a project. Badly written tests, for example ones that include hard-coded error strings or are themselves prone to failure, are expensive to maintain. This is especially the case with <a href="/w/index.php?title=Fragile_tests&amp;action=edit&amp;redlink=1" class="new" title="Fragile tests (page does not exist)">fragile tests</a>.<sup id="cite_ref-23" class="reference"><a href="#cite_note-23"><span>[</span>23<span>]</span></a></sup> There is a risk that tests that regularly generate false failures will be ignored, so that when a real failure occurs, it may not be detected. It is possible to write tests for low and easy maintenance, for example by the reuse of error strings, and this should be a goal during the <a href="/wiki/Code_refactoring" title="Code refactoring">code refactoring</a> phase described above.</p>
<p>Writing and maintaining an excessive number of tests costs time. Also, more-flexible modules (with limited tests) might accept new requirements without the need for changing the tests. For those reasons, testing for only extreme conditions, or a small sample of data, can be easier to adjust than a set of highly detailed tests. However, developers could be warned about overtesting to avoid the excessive work, but it might require advanced skills in <a href="/wiki/Sampling_(statistics)" title="Sampling (statistics)">sampling</a> or <a href="/wiki/Factor_analysis" title="Factor analysis">factor analysis</a>.</p>
<p>The level of coverage and testing detail achieved during repeated TDD cycles cannot easily be re-created at a later date. Therefore these original, or early, tests become increasingly precious as time goes by. The tactic is to fix it early. Also, if a poor architecture, a poor design, or a poor testing strategy leads to a late change that makes dozens of existing tests fail, then it is important that they are individually fixed. Merely deleting, disabling or rashly altering them can lead to undetectable holes in the test coverage.</p>
<p>Making code callable by unit tests is not always simple. Therefore, writing unit tests to cover each part of the code, which is what TDD advocates, might make the codebase rather contorted, in effect damaging its design.<sup id="cite_ref-24" class="reference"><a href="#cite_note-24"><span>[</span>24<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="TDD_and_ATDD">TDD and ATDD</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=15" title="Edit section: TDD and ATDD">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Test-Driven Development is related to, but different from Acceptance Test-Driven Development (ATDD).<sup id="cite_ref-25" class="reference"><a href="#cite_note-25"><span>[</span>25<span>]</span></a></sup> TDD is primarily a developer’s tool to help create well-written unit of code (function, class, or module) that correctly performs a set of operations. ATDD is a communication tool between the customer, developer, and tester to ensure that the requirements are well-defined. TDD requires test automation. ATDD does not, although automation helps with regression testing. Tests used In TDD can often be derived from ATDD tests, since the code units implement some portion of a requirement. ATDD tests should be readable by the customer. TDD tests do not need to be.</p>
<h2><span class="mw-headline" id="Code_visibility">Code visibility</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=16" title="Edit section: Code visibility">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Test_suite" title="Test suite">Test suite</a> code clearly has to be able to access the code it is testing. On the other hand, normal design criteria such as <a href="/wiki/Information_hiding" title="Information hiding">information hiding</a>, encapsulation and the <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a> should not be compromised. Therefore unit test code for TDD is usually written within the same project or <a href="/wiki/Module_(programming)" title="Module (programming)" class="mw-redirect">module</a> as the code being tested.</p>
<p>In <a href="/wiki/Object_oriented_design" title="Object oriented design" class="mw-redirect">object oriented design</a> this still does not provide access to private data and methods. Therefore, extra work may be necessary for unit tests. In <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> and other languages, a developer can use <a href="/wiki/Reflection_(computer_science)" title="Reflection (computer science)" class="mw-redirect">reflection</a> to access private fields and methods.<sup id="cite_ref-26" class="reference"><a href="#cite_note-26"><span>[</span>26<span>]</span></a></sup> Alternatively, an <a href="/wiki/Inner_class" title="Inner class">inner class</a> can be used to hold the unit tests so they have visibility of the enclosing class's members and attributes. In the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a> and some other programming languages, <a href="/wiki/Partial_class" title="Partial class" class="mw-redirect">partial classes</a> may be used to expose private methods and data for the tests to access.</p>
<p>It is important that such testing hacks do not remain in the production code. In <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> and other languages, <a href="/wiki/Directive_(programming)" title="Directive (programming)">compiler directives</a> such as <code>#if DEBUG ... #endif</code> can be placed around such additional classes and indeed all other test-related code to prevent them being compiled into the released code. This means the released code is not exactly the same as what was unit tested. The regular running of fewer but more comprehensive, end-to-end, integration tests on the final release build can ensure (among other things) that no production code exists that subtly relies on aspects of the test harness.</p>
<p>There is some debate among practitioners of TDD, documented in their blogs and other writings, as to whether it is wise to test private methods and data anyway. Some argue that private members are a mere implementation detail that may change, and should be allowed to do so without breaking numbers of tests. Thus it should be sufficient to test any class through its public interface or through its subclass interface, which some languages call the "protected" interface.<sup id="cite_ref-27" class="reference"><a href="#cite_note-27"><span>[</span>27<span>]</span></a></sup> Others say that crucial aspects of functionality may be implemented in private methods and testing them directly offers advantage of smaller and more direct unit tests.<sup id="cite_ref-28" class="reference"><a href="#cite_note-28"><span>[</span>28<span>]</span></a></sup><sup id="cite_ref-29" class="reference"><a href="#cite_note-29"><span>[</span>29<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Software_for_TDD">Software for TDD</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=17" title="Edit section: Software for TDD">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are many testing frameworks and tools that are useful in TDD</p>
<h3><span class="mw-headline" id="xUnit_frameworks">xUnit frameworks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=18" title="Edit section: xUnit frameworks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Developers may use computer-assisted <a href="/wiki/List_of_unit_testing_frameworks" title="List of unit testing frameworks">testing frameworks</a>, such as <a href="/wiki/XUnit" title="XUnit">xUnit</a> created in 1998, to create and automatically run the test cases. Xunit frameworks provide assertion-style test validation capabilities and result reporting. These capabilities are critical for automation as they move the burden of execution validation from an independent post-processing activity to one that is included in the test execution. The execution framework provided by these test frameworks allows for the automatic execution of all system test cases or various subsets along with other features.<sup id="cite_ref-30" class="reference"><a href="#cite_note-30"><span>[</span>30<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="TAP_results">TAP results</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=19" title="Edit section: TAP results">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Testing frameworks may accept unit test output in the language agnostic <a href="/wiki/Test_Anything_Protocol" title="Test Anything Protocol">Test Anything Protocol</a> created in 1987.</p>
<h2><span class="mw-headline" id="Fakes.2C_mocks_and_integration_tests">Fakes, mocks and integration tests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=20" title="Edit section: Fakes, mocks and integration tests">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Unit tests are so named because they each test <i>one unit</i> of code. A complex module may have a thousand unit tests and a simple module may have only ten. The tests used for TDD should never cross process boundaries in a program, let alone network connections. Doing so introduces delays that make tests run slowly and discourage developers from running the whole suite. Introducing dependencies on external modules or data also turns <i>unit tests</i> into <i>integration tests</i>. If one module misbehaves in a chain of interrelated modules, it is not so immediately clear where to look for the cause of the failure.</p>
<p>When code under development relies on a database, a web service, or any other external process or service, enforcing a unit-testable separation is also an opportunity and a driving force to design more modular, more testable and more reusable code.<sup id="cite_ref-31" class="reference"><a href="#cite_note-31"><span>[</span>31<span>]</span></a></sup> Two steps are necessary:</p>
<ol>
<li>Whenever external access is needed in the final design, an <a href="/wiki/Interface_(computer_science)" title="Interface (computer science)" class="mw-redirect">interface</a> should be defined that describes the access available. See the <a href="/wiki/Dependency_inversion_principle" title="Dependency inversion principle">dependency inversion principle</a> for a discussion of the benefits of doing this regardless of TDD.</li>
<li>The interface should be implemented in two ways, one of which really accesses the external process, and the other of which is a <a href="/wiki/Mock_object" title="Mock object">fake or mock</a>. Fake objects need do little more than add a message such as “Person object saved” to a <a href="/wiki/Tracing_(software)" title="Tracing (software)">trace log</a>, against which a test <a href="/wiki/Assertion_(computing)" title="Assertion (computing)" class="mw-redirect">assertion</a> can be run to verify correct behaviour. Mock objects differ in that they themselves contain test assertions that can make the test fail, for example, if the person's name and other data are not as expected.</li>
</ol>
<p>Fake and mock object methods that return data, ostensibly from a data store or user, can help the test process by always returning the same, realistic data that tests can rely upon. They can also be set into predefined fault modes so that error-handling routines can be developed and reliably tested. In a fault mode, a method may return an invalid, incomplete or <a href="/wiki/Null_character" title="Null character">null</a> response, or may throw an <a href="/wiki/Exception_handling" title="Exception handling">exception</a>. Fake services other than data stores may also be useful in TDD: A fake encryption service may not, in fact, encrypt the data passed; a fake random number service may always return 1. Fake or mock implementations are examples of <a href="/wiki/Dependency_injection" title="Dependency injection">dependency injection</a>.</p>
<p>A Test Double is a test-specific capability that substitutes for a system capability, typically a class or function, that the UUT depends on. There are two times at which test doubles can be introduced into a system: link and execution. Link time substitution is when the test double is compiled into the load module, which is executed to validate testing. This approach is typically used when running in an environment other than the target environment that requires doubles for the hardware level code for compilation. The alternative to linker substitution is run-time substitution in which the real functionality is replaced during the execution of a test cases. This substitution is typically done through the reassignment of known function pointers or object replacement.</p>
<p>Test doubles are of a number of different types and varying complexities:</p>
<ul>
<li><a href="/wiki/Dummy_code" title="Dummy code" class="mw-redirect">Dummy</a> – A dummy is the simplest form of a test double. It facilitates linker time substitution by providing a default return value where required.</li>
<li><a href="/wiki/Method_stub" title="Method stub">Stub</a> – A stub adds simplistic logic to a dummy, providing different outputs.</li>
<li>Spy – A spy captures and makes available parameter and state information, publishing accessors to test code for private information allowing for more advanced state validation.</li>
<li><a href="/wiki/Mock_object" title="Mock object">Mock</a> – A mock is specified by an individual test case to validate test-specific behavior, checking parameter values and call sequencing.</li>
<li>Simulator – A simulator is a comprehensive component providing a higher-fidelity approximation of the target capability (the thing being doubled). A simulator typically requires significant additional development effort.<sup id="cite_ref-Pathfinder_Solutions_7-3" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup></li>
</ul>
<p>A corollary of such dependency injection is that the actual database or other external-access code is never tested by the TDD process itself. To avoid errors that may arise from this, other tests are needed that instantiate the test-driven code with the "real" implementations of the interfaces discussed above. These are <a href="/wiki/Integration_testing" title="Integration testing">integration tests</a> and are quite separate from the TDD unit tests. There are fewer of them, and they must be run less often than the unit tests. They can nonetheless be implemented using the same testing framework, such as <a href="/wiki/XUnit" title="XUnit">xUnit</a>.</p>
<p>Integration tests that alter any <a href="/wiki/Persistent_storage" title="Persistent storage" class="mw-redirect">persistent store</a> or database should always be designed carefully with consideration of the initial and final state of the files or database, even if any test fails. This is often achieved using some combination of the following techniques:</p>
<ul>
<li>The <code>TearDown</code> method, which is integral to many test frameworks.</li>
<li><code>try...catch...finally</code> <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a> structures where available.</li>
<li><a href="/wiki/Database_transactions" title="Database transactions" class="mw-redirect">Database transactions</a> where a transaction <a href="/wiki/Atomicity_(database_systems)" title="Atomicity (database systems)">atomically</a> includes perhaps a write, a read and a matching delete operation.</li>
<li>Taking a "snapshot" of the database before running any tests and rolling back to the snapshot after each test run. This may be automated using a framework such as <a href="/wiki/Apache_Ant" title="Apache Ant">Ant</a> or <a href="/wiki/NAnt" title="NAnt">NAnt</a> or a <a href="/wiki/Continuous_integration" title="Continuous integration">continuous integration</a> system such as <a href="/wiki/CruiseControl" title="CruiseControl">CruiseControl</a>.</li>
<li>Initialising the database to a clean state <i>before</i> tests, rather than cleaning up <i>after</i> them. This may be relevant where cleaning up may make it difficult to diagnose test failures by deleting the final state of the database before detailed diagnosis can be performed.</li>
</ul>
<h2><span class="mw-headline" id="TDD_for_complex_systems">TDD for complex systems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=21" title="Edit section: TDD for complex systems">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Exercising TDD on large, challenging systems requires a modular architecture, well-defined components with published interfaces, and disciplined system layering with maximization of platform independence. These proven practices yield increased testability and facilitate the application of build and test automation.<sup id="cite_ref-Pathfinder_Solutions_7-4" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Designing_for_testability">Designing for testability</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=22" title="Edit section: Designing for testability">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Complex systems require an architecture that meets a range of requirements. A key subset of these requirements includes support for the complete and effective testing of the system. Effective modular design yields components that share traits essential for effective TDD.</p>
<ul>
<li>High Cohesion ensures each unit provides a set of related capabilities and makes the tests of those capabilities easier to maintain.</li>
<li>Low Coupling allows each unit to be effectively tested in isolation.</li>
<li>Published Interfaces restrict Component access and serve as contact points for tests, facilitating test creation and ensuring the highest fidelity between test and production unit configuration.</li>
</ul>
<p>A key technique for building effective modular architecture is Scenario Modeling where a set of sequence charts is constructed, each one focusing on a single system-level execution scenario. The Scenario Model provides an excellent vehicle for creating the strategy of interactions between components in response to a specific stimulus. Each of these Scenario Models serves as a rich set of requirements for the services or functions that a component must provide, and it also dictates the order that these components and services interact together. Scenario modeling can greatly facilitate the construction of TDD tests for a complex system.<sup id="cite_ref-Pathfinder_Solutions_7-5" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Managing_tests_for_large_teams">Managing tests for large teams</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=23" title="Edit section: Managing tests for large teams">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a larger system the impact of poor component quality is magnified by the complexity of interactions. This magnification makes the benefits of TDD accrue even faster in the context of larger projects. However, the complexity of the total population of tests can become a problem in itself, eroding potential gains. It sounds simple, but a key initial step is to recognize that test code is also important software and should be produced and maintained with the same rigor as the production code.</p>
<p>Creating and managing the architecture of test software within a complex system is just as important as the core product architecture. Test drivers interact with the UUT, test doubles and the unit test framework.<sup id="cite_ref-Pathfinder_Solutions_7-6" class="reference"><a href="#cite_note-Pathfinder_Solutions-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=24" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Acceptance_testing" title="Acceptance testing">Acceptance testing</a></li>
<li><a href="/wiki/Behavior_driven_development" title="Behavior driven development" class="mw-redirect">Behavior driven development</a></li>
<li><a href="/wiki/Design_by_contract" title="Design by contract">Design by contract</a></li>
<li><a href="/wiki/Integration_testing" title="Integration testing">Integration testing</a></li>
<li><a href="/wiki/List_of_software_development_philosophies" title="List of software development philosophies">List of software development philosophies</a>      </li>
</ul>
<ul>
<li><a href="/wiki/List_of_unit_testing_frameworks" title="List of unit testing frameworks">List of unit testing frameworks</a></li>
<li><a href="/wiki/Mock_object" title="Mock object">Mock object</a></li>
<li><a href="/wiki/Sanity_check" title="Sanity check" class="mw-redirect">Sanity check</a>                      </li>
</ul>
<ul>
<li><a href="/wiki/Software_testing" title="Software testing">Software testing</a></li>
<li><a href="/wiki/Test_case" title="Test case">Test case</a></li>
<li><a href="/wiki/Transformation_Priority_Premise" title="Transformation Priority Premise">Transformation Priority Premise</a></li>
<li><a href="/wiki/Unit_testing" title="Unit testing">Unit testing</a></li>
<li><a href="/wiki/Continuous_test-driven_development" title="Continuous test-driven development">Continuous test-driven development</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=25" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-Beck-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-Beck_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Beck_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Beck_1-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">Beck, K. Test-Driven Development by Example, Addison Wesley - Vaseem, 2003</span></li>
<li id="cite_note-Cworld92-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-Cworld92_2-0">^</a></b></span> <span class="reference-text"><span class="citation web">Lee Copeland (December 2001). <a rel="nofollow" class="external text" href="http://www.computerworld.com/softwaretopics/software/appdev/story/0,10801,66192,00.html">"Extreme Programming"</a>. Computerworld<span class="reference-accessdate">. Retrieved January 11, 2011</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aulast=Lee+Copeland&amp;rft.au=Lee+Copeland&amp;rft.btitle=Extreme+Programming&amp;rft.date=December+2001&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.computerworld.com%2Fsoftwaretopics%2Fsoftware%2Fappdev%2Fstory%2F0%2C10801%2C66192%2C00.html&amp;rft.pub=Computerworld&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Newkirk-3"><span class="mw-cite-backlink">^ <a href="#cite_ref-Newkirk_3-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Newkirk_3-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Newkirk, JW and Vorontsov, AA. <i>Test-Driven Development in Microsoft .NET</i>, Microsoft Press, 2004.</span></li>
<li id="cite_note-Feathers-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-Feathers_4-0">^</a></b></span> <span class="reference-text">Feathers, M. Working Effectively with Legacy Code, Prentice Hall, 2004</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation book">Beck, Kent (1999). <i>XP Explained, 1st Edition</i>. Addison-Wesley Professional. p. 57. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0201616416" title="Special:BookSources/0201616416">0201616416</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.au=Beck%2C+Kent&amp;rft.aufirst=Kent&amp;rft.aulast=Beck&amp;rft.btitle=XP+Explained%2C+1st+Edition&amp;rft.date=1999&amp;rft.genre=book&amp;rft.isbn=0201616416&amp;rft.pages=57&amp;rft.pub=Addison-Wesley+Professional&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web">Ottinger and Langr, Tim and Jeff. <a rel="nofollow" class="external text" href="http://agileinaflash.blogspot.com/2009/02/simple-design.html">"Simple Design"</a><span class="reference-accessdate">. Retrieved 5 July 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Tim+and+Jeff&amp;rft.aulast=Ottinger+and+Langr&amp;rft.au=Ottinger+and+Langr%2C+Tim+and+Jeff&amp;rft.btitle=Simple+Design&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fagileinaflash.blogspot.com%2F2009%2F02%2Fsimple-design.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Pathfinder_Solutions-7"><span class="mw-cite-backlink">^ <a href="#cite_ref-Pathfinder_Solutions_7-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Pathfinder_Solutions_7-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Pathfinder_Solutions_7-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-Pathfinder_Solutions_7-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-Pathfinder_Solutions_7-4"><sup><i><b>e</b></i></sup></a> <a href="#cite_ref-Pathfinder_Solutions_7-5"><sup><i><b>f</b></i></sup></a> <a href="#cite_ref-Pathfinder_Solutions_7-6"><sup><i><b>g</b></i></sup></a></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.pathfindersolns.com/download-whitepaper/?download=EffectiveTDDforComplexEmbeddedSystems.pdf&amp;title=Effective_TDD_for_Complex_Embedded_Systems">"Effective TDD for Complex Embedded Systems Whitepaper"</a>. Pathfinder Solutions.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Effective+TDD+for+Complex+Embedded+Systems+Whitepaper&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.pathfindersolns.com%2Fdownload-whitepaper%2F%3Fdownload%3DEffectiveTDDforComplexEmbeddedSystems.pdf%26title%3DEffective_TDD_for_Complex_Embedded_Systems&amp;rft.pub=Pathfinder+Solutions&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.agilesherpa.org/agile_coach/engineering_practices/test_driven_development/">"Agile Test Driven Development"</a>. Agile Sherpa. 2010-08-03<span class="reference-accessdate">. Retrieved 2012-08-14</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Agile+Test+Driven+Development&amp;rft.date=2010-08-03&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.agilesherpa.org%2Fagile_coach%2Fengineering_practices%2Ftest_driven_development%2F&amp;rft.pub=Agile+Sherpa&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Koskela-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-Koskela_9-0">^</a></b></span> <span class="reference-text">Koskela, L. "Test Driven: TDD and Acceptance TDD for Java Developers", Manning Publications, 2007</span></li>
<li id="cite_note-pathfindersolns.com-10"><span class="mw-cite-backlink">^ <a href="#cite_ref-pathfindersolns.com_10-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-pathfindersolns.com_10-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.pathfindersolns.com/resources/industry-glossary/tdd/test-driven-development-complex-systems-overview-video/">"Test-Driven Development for Complex Systems Overview Video"</a>. Pathfinder Solutions.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Test-Driven+Development+for+Complex+Systems+Overview+Video&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.pathfindersolns.com%2Fresources%2Findustry-glossary%2Ftdd%2Ftest-driven-development-complex-systems-overview-video%2F&amp;rft.pub=Pathfinder+Solutions&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation web">Erdogmus, Hakan; Morisio, Torchiano. <a rel="nofollow" class="external text" href="http://nparc.cisti-icist.nrc-cnrc.gc.ca/npsi/ctrl?action=shwart&amp;index=an&amp;req=5763742&amp;lang=en">"On the Effectiveness of Test-first Approach to Programming"</a>. Proceedings of the IEEE Transactions on Software Engineering, 31(1). January 2005. (NRC 47445)<span class="reference-accessdate">. Retrieved 2008-01-14</span>. "We found that test-first students on average wrote more tests and, in turn, students who wrote more tests tended to be more productive."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.au=Erdogmus%2C+Hakan&amp;rft.aufirst=Hakan&amp;rft.aulast=Erdogmus&amp;rft.au=Morisio%2C+Torchiano&amp;rft.btitle=On+the+Effectiveness+of+Test-first+Approach+to+Programming&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fnparc.cisti-icist.nrc-cnrc.gc.ca%2Fnpsi%2Fctrl%3Faction%3Dshwart%26index%3Dan%26req%3D5763742%26lang%3Den&amp;rft.pub=Proceedings+of+the+IEEE+Transactions+on+Software+Engineering%2C+31%281%29.+January+2005.+%28NRC+47445%29&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation web">Proffitt, Jacob. <a rel="nofollow" class="external text" href="http://theruntime.com/blogs/jacob/archive/2008/01/22/tdd-proven-effective-or-is-it.aspx">"TDD Proven Effective! Or is it?"</a><span class="reference-accessdate">. Retrieved 2008-02-21</span>. "So TDD's relationship to quality is problematic at best. Its relationship to productivity is more interesting. I hope there's a follow-up study because the productivity numbers simply don't add up very well to me. There is an undeniable correlation between productivity and the number of tests, but that correlation is actually stronger in the non-TDD group (which had a single <a href="/wiki/Outlier" title="Outlier">outlier</a> compared to roughly half of the TDD group being outside the 95% band)."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Jacob&amp;rft.aulast=Proffitt&amp;rft.au=Proffitt%2C+Jacob&amp;rft.btitle=TDD+Proven+Effective%21+Or+is+it%3F&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Ftheruntime.com%2Fblogs%2Fjacob%2Farchive%2F2008%2F01%2F22%2Ftdd-proven-effective-or-is-it.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web">Llopis, Noel (20 February 2005). <a rel="nofollow" class="external text" href="http://gamesfromwithin.com/stepping-through-the-looking-glass-test-driven-game-development-part-1">"Stepping Through the Looking Glass: Test-Driven Game Development (Part 1)"</a>. Games from Within<span class="reference-accessdate">. Retrieved 2007-11-01</span>. "Comparing [TDD] to the non-test-driven development approach, you're replacing all the mental checking and debugger stepping with code that verifies that your program does exactly what you intended it to do."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Noel&amp;rft.aulast=Llopis&amp;rft.au=Llopis%2C+Noel&amp;rft.btitle=Stepping+Through+the+Looking+Glass%3A+Test-Driven+Game+Development+%28Part+1%29&amp;rft.date=20+February+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fgamesfromwithin.com%2Fstepping-through-the-looking-glass-test-driven-game-development-part-1&amp;rft.pub=Games+from+Within&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation book">Mayr, Herwig (2005). <i>Projekt Engineering Ingenieurmässige Softwareentwicklung in Projektgruppen</i> (2., neu bearb. Aufl. ed.). München: Fachbuchverl. Leipzig im Carl-Hanser-Verl. p. 239. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3446400702" title="Special:BookSources/978-3446400702">978-3446400702</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Herwig&amp;rft.aulast=Mayr&amp;rft.au=Mayr%2C+Herwig&amp;rft.btitle=Projekt+Engineering+Ingenieurm%C3%A4ssige+Softwareentwicklung+in+Projektgruppen&amp;rft.date=2005&amp;rft.edition=2.%2C+neu+bearb.+Aufl.&amp;rft.genre=book&amp;rft.isbn=978-3446400702&amp;rft.pages=239&amp;rft.place=M%C3%BCnchen&amp;rft.pub=Fachbuchverl.+Leipzig+im+Carl-Hanser-Verl.&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><span class="citation web">Müller, Matthias M.; Padberg, Frank. <a rel="nofollow" class="external text" href="http://www.ipd.kit.edu/KarHPFn/papers/edser03.pdf">"About the Return on Investment of Test-Driven Development"</a> (PDF). Universität Karlsruhe, Germany. p. 6<span class="reference-accessdate">. Retrieved 2012-06-14</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Matthias+M.&amp;rft.aulast=M%C3%BCller&amp;rft.au=M%C3%BCller%2C+Matthias+M.&amp;rft.au=Padberg%2C+Frank&amp;rft.btitle=About+the+Return+on+Investment+of+Test-Driven+Development&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.ipd.kit.edu%2FKarHPFn%2Fpapers%2Fedser03.pdf&amp;rft.pages=6&amp;rft.pub=Universit%C3%A4t+Karlsruhe%2C+Germany&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Madeyski-16"><span class="mw-cite-backlink">^ <a href="#cite_ref-Madeyski_16-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Madeyski_16-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Madeyski_16-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">Madeyski, L. "Test-Driven Development - An Empirical Evaluation of Agile Practice", Springer, 2010, <a href="/wiki/Special:BookSources/9783642042874" class="internal mw-magiclink-isbn">ISBN 978-3-642-04287-4</a>, pp. 1-245. DOI: 978-3-642-04288-1</span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://madeyski.e-informatyka.pl/download/Madeyski10c.pdf">The impact of Test-First programming on branch coverage and mutation score indicator of unit tests: An experiment.</a> by L. Madeyski <i>Information &amp; Software Technology 52(2): 169-184 (2010)</i></span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://madeyski.e-informatyka.pl/download/Madeyski07.pdf">On the Effects of Pair Programming on Thoroughness and Fault-Finding Effectiveness of Unit Tests</a> by L. Madeyski <i>PROFES 2007: 207-221</i></span></li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://madeyski.e-informatyka.pl/download/Madeyski08.pdf">Impact of pair programming on thoroughness and fault detection effectiveness of unit test suites.</a> by L. Madeyski <i>Software Process: Improvement and Practice 13(3): 281-295 (2008)</i></span></li>
<li id="cite_note-20"><span class="mw-cite-backlink"><b><a href="#cite_ref-20">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://dalkescientific.com/writings/diary/archive/2009/12/29/problems_with_tdd.html">"Problems with TDD"</a>. Dalkescientific.com. 2009-12-29<span class="reference-accessdate">. Retrieved 2014-03-25</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Problems+with+TDD&amp;rft.date=2009-12-29&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdalkescientific.com%2Fwritings%2Fdiary%2Farchive%2F2009%2F12%2F29%2Fproblems_with_tdd.html&amp;rft.pub=Dalkescientific.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-21"><span class="mw-cite-backlink"><b><a href="#cite_ref-21">^</a></b></span> <span class="reference-text"><span class="citation web">Hunter, Andrew (2012-10-19). <a rel="nofollow" class="external text" href="https://www.simple-talk.com/dotnet/.net-framework/are-unit-tests-overused/">"Are Unit Tests Overused?"</a>. Simple-talk.com<span class="reference-accessdate">. Retrieved 2014-03-25</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Andrew&amp;rft.au=Hunter%2C+Andrew&amp;rft.aulast=Hunter&amp;rft.btitle=Are+Unit+Tests+Overused%3F&amp;rft.date=2012-10-19&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fwww.simple-talk.com%2Fdotnet%2F.net-framework%2Fare-unit-tests-overused%2F&amp;rft.pub=Simple-talk.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-22"><span class="mw-cite-backlink"><b><a href="#cite_ref-22">^</a></b></span> <span class="reference-text"><span class="citation web">Loughran, Steve (November 6, 2006). <a rel="nofollow" class="external text" href="http://people.apache.org/~stevel/slides/testing.pdf">"Testing"</a> (PDF). HP Laboratories<span class="reference-accessdate">. Retrieved 2009-08-12</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Steve&amp;rft.aulast=Loughran&amp;rft.au=Loughran%2C+Steve&amp;rft.btitle=Testing&amp;rft.date=November+6%2C+2006&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fpeople.apache.org%2F~stevel%2Fslides%2Ftesting.pdf&amp;rft.pub=HP+Laboratories&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-23"><span class="mw-cite-backlink"><b><a href="#cite_ref-23">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://xunitpatterns.com/Fragile%20Test.html">"Fragile Tests"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Fragile+Tests&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fxunitpatterns.com%2FFragile%2520Test.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-24"><span class="mw-cite-backlink"><b><a href="#cite_ref-24">^</a></b></span> <span class="reference-text"><span class="citation web">David Heinemeier Hansson (2014-04-29). <a rel="nofollow" class="external text" href="http://david.heinemeierhansson.com/2014/test-induced-design-damage.html">"Test-induced design damage"</a><span class="reference-accessdate">. Retrieved 2014-05-22</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.au=David+Heinemeier+Hansson&amp;rft.aulast=David+Heinemeier+Hansson&amp;rft.btitle=Test-induced+design+damage&amp;rft.date=2014-04-29&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdavid.heinemeierhansson.com%2F2014%2Ftest-induced-design-damage.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-25"><span class="mw-cite-backlink"><b><a href="#cite_ref-25">^</a></b></span> <span class="reference-text"><span class="citation book"><i>Lean-Agile Acceptance Test-Driven Development: Better Software Through Collaboration</i>. Boston: Addison Wesley Professional. 2011. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0321714084" title="Special:BookSources/978-0321714084">978-0321714084</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Lean-Agile+Acceptance+Test-Driven+Development%3A+Better+Software+Through+Collaboration&amp;rft.date=2011&amp;rft.genre=book&amp;rft.isbn=978-0321714084&amp;rft.place=Boston&amp;rft.pub=Addison+Wesley+Professional&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-26"><span class="mw-cite-backlink"><b><a href="#cite_ref-26">^</a></b></span> <span class="reference-text"><span class="citation web">Burton, Ross (11/12/2003). <a rel="nofollow" class="external text" href="http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html">"Subverting Java Access Protection for Unit Testing"</a>. O'Reilly Media, Inc<span class="reference-accessdate">. Retrieved 2009-08-12</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.au=Burton%2C+Ross&amp;rft.aufirst=Ross&amp;rft.aulast=Burton&amp;rft.btitle=Subverting+Java+Access+Protection+for+Unit+Testing&amp;rft.date=11%2F12%2F2003&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.onjava.com%2Fpub%2Fa%2Fonjava%2F2003%2F11%2F12%2Freflection.html&amp;rft.pub=O%27Reilly+Media%2C+Inc.&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> <span style="font-size:100%" class="error citation-comment">Check date values in: <code style="color:inherit; border:inherit; padding:inherit;">|date=</code> (<a href="/wiki/Help:CS1_errors#bad_date" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-27"><span class="mw-cite-backlink"><b><a href="#cite_ref-27">^</a></b></span> <span class="reference-text"><span class="citation web">van Rossum, Guido; Warsaw, Barry (5 July 2001). <a rel="nofollow" class="external text" href="https://www.python.org/dev/peps/pep-0008/">"PEP 8 -- Style Guide for Python Code"</a>. Python Software Foundation<span class="reference-accessdate">. Retrieved 6 May 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Guido&amp;rft.aulast=van+Rossum&amp;rft.au=van+Rossum%2C+Guido&amp;rft.au=Warsaw%2C+Barry&amp;rft.btitle=PEP+8+--+Style+Guide+for+Python+Code&amp;rft.date=5+July+2001&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fwww.python.org%2Fdev%2Fpeps%2Fpep-0008%2F&amp;rft.pub=Python+Software+Foundation&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-28"><span class="mw-cite-backlink"><b><a href="#cite_ref-28">^</a></b></span> <span class="reference-text"><span class="citation web">Newkirk, James (7 June 2004). <a rel="nofollow" class="external text" href="http://blogs.msdn.com/jamesnewkirk/archive/2004/06/07/150361.aspx">"Testing Private Methods/Member Variables - Should you or shouldn't you"</a>. Microsoft Corporation<span class="reference-accessdate">. Retrieved 2009-08-12</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=James&amp;rft.aulast=Newkirk&amp;rft.au=Newkirk%2C+James&amp;rft.btitle=Testing+Private+Methods%2FMember+Variables+-+Should+you+or+shouldn%27t+you&amp;rft.date=7+June+2004&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fjamesnewkirk%2Farchive%2F2004%2F06%2F07%2F150361.aspx&amp;rft.pub=Microsoft+Corporation&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-29"><span class="mw-cite-backlink"><b><a href="#cite_ref-29">^</a></b></span> <span class="reference-text"><span class="citation web">Stall, Tim (1 Mar 2005). <a rel="nofollow" class="external text" href="http://www.codeproject.com/KB/cs/testnonpublicmembers.aspx">"How to Test Private and Protected methods in .NET"</a>. CodeProject<span class="reference-accessdate">. Retrieved 2009-08-12</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Tim&amp;rft.aulast=Stall&amp;rft.au=Stall%2C+Tim&amp;rft.btitle=How+to+Test+Private+and+Protected+methods+in+.NET&amp;rft.date=1+Mar+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.codeproject.com%2FKB%2Fcs%2Ftestnonpublicmembers.aspx&amp;rft.pub=CodeProject&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-30"><span class="mw-cite-backlink"><b><a href="#cite_ref-30">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.pathfindersolns.com/download-whitepaper/?download=EffectiveTDDforComplexEmbeddedSystems.pdf&amp;title=Effective_TDD_for_Complex_Embedded_Systems">"Effective TDD for Complex, Embedded Systems Whitepaper"</a>. Pathfinder Solutions.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.btitle=Effective+TDD+for+Complex%2C+Embedded+Systems+Whitepaper&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.pathfindersolns.com%2Fdownload-whitepaper%2F%3Fdownload%3DEffectiveTDDforComplexEmbeddedSystems.pdf%26title%3DEffective_TDD_for_Complex_Embedded_Systems&amp;rft.pub=Pathfinder+Solutions&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-31"><span class="mw-cite-backlink"><b><a href="#cite_ref-31">^</a></b></span> <span class="reference-text"><span class="citation book">Fowler, Martin (1999). <i>Refactoring - Improving the design of existing code</i>. Boston: Addison Wesley Longman, Inc. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-201-48567-2" title="Special:BookSources/0-201-48567-2">0-201-48567-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATest-driven+development&amp;rft.aufirst=Martin&amp;rft.au=Fowler%2C+Martin&amp;rft.aulast=Fowler&amp;rft.btitle=Refactoring+-+Improving+the+design+of+existing+code&amp;rft.date=1999&amp;rft.genre=book&amp;rft.isbn=0-201-48567-2&amp;rft.place=Boston&amp;rft.pub=Addison+Wesley+Longman%2C+Inc.&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Test-driven_development&amp;action=edit&amp;section=26" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="http://c2.com/cgi/wiki?TestDrivenDevelopment" class="extiw" title="c2:TestDrivenDevelopment">TestDrivenDevelopment</a> on WikiWikiWeb</li>
<li><a rel="nofollow" class="external text" href="http://www.eiffel.com/general/monthly_column/2004/september.html">Test or spec? Test and spec? Test from spec!</a>, by <a href="/wiki/Bertrand_Meyer" title="Bertrand Meyer">Bertrand Meyer</a> (September 2004)</li>
<li><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/ms379625(VS.80).aspx">Microsoft Visual Studio Team Test from a TDD approach</a></li>
<li><a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/magazine/cc163665.aspx">Write Maintainable Unit Tests That Will Save You Time And Tears</a></li>
<li><a rel="nofollow" class="external text" href="http://www.methodsandtools.com/archive/archive.php?id=20">Improving Application Quality Using Test-Driven Development (TDD)</a></li>
</ul>
