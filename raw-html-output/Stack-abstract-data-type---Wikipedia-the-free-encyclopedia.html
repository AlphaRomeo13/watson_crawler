<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Stack (abstract data type)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <b>stack</b> is a particular kind of <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data type</a> or <a href="/wiki/Collection_(computing)" title="Collection (computing)" class="mw-redirect">collection</a> in which the principal (or only) operations on the collection are the addition of an entity to the collection, known as <i>push</i> and removal of an entity, known as <i>pop</i>.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> The relation between the push and pop operations is such that the stack is a <a href="/wiki/LIFO_(computing)" title="LIFO (computing)">Last-In-First-Out (LIFO) data structure</a>. In a LIFO data structure, the last element added to the structure must be the first one to be removed. This is equivalent to the requirement that, considered as a <a href="/wiki/Linear_data_structure" title="Linear data structure" class="mw-redirect">linear data structure</a>, or more abstractly a sequential collection, the push and pop operations occur only at one end of the structure, referred to as the <i>top</i> of the stack. Often a <i><a href="/wiki/Peek_(data_type_operation)" title="Peek (data type operation)">peek</a></i> or <i>top</i> operation is also implemented, returning the value of the top element without removing it.</p>
<p>A stack may be implemented to have a bounded capacity. If the stack is full and does not contain enough space to accept an entity to be pushed, the stack is then considered to be in an <a href="/wiki/Stack_overflow" title="Stack overflow">overflow</a> state. The pop operation removes an item from the top of the stack. A pop either reveals previously concealed items or results in an empty stack, but, if the stack is empty, it goes into underflow state, which means no items are present in stack to be removed.</p>
<p>A stack is a <i>restricted data structure</i>, because only a small number of operations are performed on it. The nature of the pop and push operations also means that stack elements have a natural order. Elements are removed from the stack in the reverse order to the order of their addition. Therefore, the lower elements are those that have been on the stack the longest.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Abstract_definition"><span class="tocnumber">2</span> <span class="toctext">Abstract definition</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Inessential_operations"><span class="tocnumber">3</span> <span class="toctext">Inessential operations</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Software_stacks"><span class="tocnumber">4</span> <span class="toctext">Software stacks</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Implementation"><span class="tocnumber">4.1</span> <span class="toctext">Implementation</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#Array"><span class="tocnumber">4.1.1</span> <span class="toctext">Array</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Linked_list"><span class="tocnumber">4.1.2</span> <span class="toctext">Linked list</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Stacks_and_programming_languages"><span class="tocnumber">4.2</span> <span class="toctext">Stacks and programming languages</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Hardware_stacks"><span class="tocnumber">5</span> <span class="toctext">Hardware stacks</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Basic_architecture_of_a_stack"><span class="tocnumber">5.1</span> <span class="toctext">Basic architecture of a stack</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Hardware_support"><span class="tocnumber">5.2</span> <span class="toctext">Hardware support</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#Stack_in_main_memory"><span class="tocnumber">5.2.1</span> <span class="toctext">Stack in main memory</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Stack_in_registers_or_dedicated_memory"><span class="tocnumber">5.2.2</span> <span class="toctext">Stack in registers or dedicated memory</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Applications"><span class="tocnumber">6</span> <span class="toctext">Applications</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Expression_evaluation_and_syntax_parsing"><span class="tocnumber">6.1</span> <span class="toctext">Expression evaluation and syntax parsing</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Backtracking"><span class="tocnumber">6.2</span> <span class="toctext">Backtracking</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Runtime_memory_management"><span class="tocnumber">6.3</span> <span class="toctext">Runtime memory management</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18"><a href="#Security"><span class="tocnumber">7</span> <span class="toctext">Security</span></a></li>
<li class="toclevel-1 tocsection-19"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#Further_reading"><span class="tocnumber">10</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#External_links"><span class="tocnumber">11</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Implementation"><span class="tocnumber">4.1</span> <span class="toctext">Implementation</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#Array"><span class="tocnumber">4.1.1</span> <span class="toctext">Array</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Linked_list"><span class="tocnumber">4.1.2</span> <span class="toctext">Linked list</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Stacks_and_programming_languages"><span class="tocnumber">4.2</span> <span class="toctext">Stacks and programming languages</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#Array"><span class="tocnumber">4.1.1</span> <span class="toctext">Array</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Linked_list"><span class="tocnumber">4.1.2</span> <span class="toctext">Linked list</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Basic_architecture_of_a_stack"><span class="tocnumber">5.1</span> <span class="toctext">Basic architecture of a stack</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Hardware_support"><span class="tocnumber">5.2</span> <span class="toctext">Hardware support</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#Stack_in_main_memory"><span class="tocnumber">5.2.1</span> <span class="toctext">Stack in main memory</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Stack_in_registers_or_dedicated_memory"><span class="tocnumber">5.2.2</span> <span class="toctext">Stack in registers or dedicated memory</span></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#Stack_in_main_memory"><span class="tocnumber">5.2.1</span> <span class="toctext">Stack in main memory</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Stack_in_registers_or_dedicated_memory"><span class="tocnumber">5.2.2</span> <span class="toctext">Stack in registers or dedicated memory</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Expression_evaluation_and_syntax_parsing"><span class="tocnumber">6.1</span> <span class="toctext">Expression evaluation and syntax parsing</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Backtracking"><span class="tocnumber">6.2</span> <span class="toctext">Backtracking</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Runtime_memory_management"><span class="tocnumber">6.3</span> <span class="toctext">Runtime memory management</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The stack was first proposed in 1946, in the computer design of <a href="/wiki/Alan_M._Turing" title="Alan M. Turing" class="mw-redirect">Alan M. Turing</a> (who used the terms "bury" and "unbury") as a means of calling and returning from subroutines.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2014)">citation needed</span></a></i>]</sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text near this tag may need clarification or removal of jargon. (February 2013)">clarification needed</span></a></i>]</sup> Subroutines had already been implemented in <a href="/wiki/Konrad_Zuse" title="Konrad Zuse">Konrad Zuse</a>'s <a href="/wiki/Z4_(computer)" title="Z4 (computer)">Z4</a> in 1945. <a href="/wiki/Klaus_Samelson" title="Klaus Samelson">Klaus Samelson</a> and <a href="/wiki/Friedrich_L._Bauer" title="Friedrich L. Bauer">Friedrich L. Bauer</a> of <a href="/wiki/Technical_University_Munich" title="Technical University Munich" class="mw-redirect">Technical University Munich</a> proposed the idea in 1955 and filed a patent in 1957.<sup id="cite_ref-patent_3-0" class="reference"><a href="#cite_note-patent-3"><span>[</span>3<span>]</span></a></sup> The same concept was developed, independently, by the Australian <a href="/wiki/Charles_Leonard_Hamblin" title="Charles Leonard Hamblin">Charles Leonard Hamblin</a> in the first half of 1957.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Abstract_definition">Abstract definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=2" title="Edit section: Abstract definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A stack is a basic <a href="/wiki/Computer_science" title="Computer science">computer science</a> <a href="/wiki/Data_structure" title="Data structure">data structure</a> and can be defined in an abstract, implementation-free manner, or it can be generally defined as a linear list of items in which all additions and deletion are restricted to one end that is Top.</p>
<p>This is a VDM (<i><a href="/wiki/Vienna_Development_Method" title="Vienna Development Method">Vienna Development Method</a></i>) description of a stack:<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p>Function signatures:</p>
<p>WHATSON? 9738e0e9-63c1-477f-b3b6-29ed39c31d4a</p>
<pre>
  init: -&gt; Stack
  push: N x Stack -&gt; Stack
  top: Stack -&gt; (N U ERROR)
  pop: Stack -&gt; Stack
  isempty: Stack -&gt; Boolean
</pre>
<p>(where N indicates an element (natural numbers in this case), and U indicates set union)</p>
<p>Semantics:</p>
<p>WHATSON? 4ae52ed5-e795-43f4-9d00-38384cb881ef</p>
<pre>
  top(init()) = ERROR
  top(push(i,s)) = i
  pop(init()) = init()
  pop(push(i, s)) = s
  isempty(init()) = true
  isempty(push(i, s)) = false
</pre>
<h2><span class="mw-headline" id="Inessential_operations">Inessential operations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=3" title="Edit section: Inessential operations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In many implementations, a stack has more operations than "push" and "pop". An example is "top of stack", or "<a href="/wiki/Peek_(data_type_operation)" title="Peek (data type operation)">peek</a>", which observes the top-most element <i>without</i> removing it from the stack.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> Since this can be done with a "pop" and a "push" with the same data, it is not essential. An underflow condition can occur in the "stack top" operation if the stack is empty, the same as "pop". Also, implementations often have a function which just returns whether the stack is empty.</p>
<h2><span class="mw-headline" id="Software_stacks">Software stacks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=4" title="Edit section: Software stacks">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=5" title="Edit section: Implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In most <a href="/wiki/High_level_language" title="High level language" class="mw-redirect">high level languages</a>, a stack can be easily implemented either through an <a href="/wiki/Array_data_structure" title="Array data structure">array</a> or a <a href="/wiki/Linked_list" title="Linked list">linked list</a>. What identifies the data structure as a stack in either case is not the implementation but the interface: the user is only allowed to pop or push items onto the array or linked list, with few other helper operations. The following will demonstrate both implementations, using C.</p>
<h4><span class="mw-headline" id="Array">Array</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=6" title="Edit section: Array">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The <b>array implementation</b> aims to create an array where the first element (usually at the zero-offset) is the bottom. That is, <code>array[0]</code> is the first element pushed onto the stack and the last element popped off. The program must keep track of the size, or the length of the stack. The stack itself can therefore be effectively implemented as a two-element structure in C:</p>
<p>WHATSON? 4cd0c05b-91b6-4586-905b-a13103835a40</p>
<pre class="de1">
<span class="kw4">typedef</span> <span class="kw4">struct</span> <span class="br0">{</span>
    <span class="kw4">size_t</span> size<span class="sy0">;</span>
    <span class="kw4">int</span> items<span class="br0">[</span>STACKSIZE<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span> STACK<span class="sy0">;</span>
</pre>
<p>The <code>push()</code> operation is used both to initialize the stack, and to store values to it. It is responsible for inserting (copying) the value into the <code>ps-&gt;items[]</code> array and for incrementing the element counter (<code>ps-&gt;size</code>). In a responsible C implementation, it is also necessary to check whether the array is already full to prevent an <a href="/wiki/Buffer_overflow" title="Buffer overflow">overrun</a>.</p>
<p>WHATSON? d82881fe-10bc-4f68-ac36-db058857a904</p>
<pre class="de1">
<span class="kw4">void</span> push<span class="br0">(</span>STACK <span class="sy0">*</span>ps<span class="sy0">,</span> <span class="kw4">int</span> x<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>ps<span class="sy0">-&gt;</span>size <span class="sy0">==</span> STACKSIZE<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw3">fputs</span><span class="br0">(</span><span class="st0">"Error: stack overflow<span class="es1">\n</span>"</span><span class="sy0">,</span> stderr<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw3">abort</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw1">else</span>
        ps<span class="sy0">-&gt;</span>items<span class="br0">[</span>ps<span class="sy0">-&gt;</span>size<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> x<span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>The <code>pop()</code> operation is responsible for removing a value from the stack, and decrementing the value of <code>ps-&gt;size</code>. A responsible C implementation will also need to check that the array is not already empty.</p>
<p>WHATSON? 4291332a-0154-41de-8325-a683c778e8d3</p>
<pre class="de1">
<span class="kw4">int</span> pop<span class="br0">(</span>STACK <span class="sy0">*</span>ps<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>ps<span class="sy0">-&gt;</span>size <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span><span class="br0">{</span>
        <span class="kw3">fputs</span><span class="br0">(</span><span class="st0">"Error: stack underflow<span class="es1">\n</span>"</span><span class="sy0">,</span> stderr<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw3">abort</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw1">else</span>
        <span class="kw1">return</span> ps<span class="sy0">-&gt;</span>items<span class="br0">[</span><span class="sy0">--</span>ps<span class="sy0">-&gt;</span>size<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
</pre>
<p>If we use a <a href="/wiki/Dynamic_array" title="Dynamic array">dynamic array</a>, then we can implement a stack that can grow or shrink as much as needed. The size of the stack is simply the size of the dynamic array. A dynamic array is a very efficient implementation of a stack, since adding items to or removing items from the end of a dynamic array is amortized O(1) time.</p>
<h4><span class="mw-headline" id="Linked_list">Linked list</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=7" title="Edit section: Linked list">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The <b>linked-list</b> implementation is equally simple and straightforward. In fact, a simple <a href="/wiki/Singly_linked_list" title="Singly linked list" class="mw-redirect">singly linked list</a> is sufficient to implement a stack—it only requires that the head node or element can be removed, or popped, and a node can only be inserted by becoming the new head node.</p>
<p>Unlike the array implementation, our structure typedef corresponds not to the entire stack structure, but to a single node:</p>
<p>WHATSON? f8cf9375-9dde-48c5-9814-8ff2be549ba8</p>
<pre class="de1">
<span class="kw4">typedef</span> <span class="kw4">struct</span> stack <span class="br0">{</span>
    <span class="kw4">int</span> data<span class="sy0">;</span>
    <span class="kw4">struct</span> stack <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span> STACK<span class="sy0">;</span>
</pre>
<p>Such a node is identical to a typical singly linked list node, at least to those that are implemented in C.</p>
<p>The <code>push()</code> operation both initializes an empty stack, and adds a new node to a non-empty one. It works by receiving a data value to push onto the stack, along with a target stack, creating a new node by allocating memory for it, and then inserting it into a linked list as the new head:</p>
<p>WHATSON? 765ee7de-c3cd-4fc2-bc43-d4576468f20e</p>
<pre class="de1">
<span class="kw4">void</span> push<span class="br0">(</span>STACK <span class="sy0">**</span>head<span class="sy0">,</span> <span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
    STACK <span class="sy0">*</span>node <span class="sy0">=</span> <span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span>STACK<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>  <span class="coMULTI">/* create a new node */</span>
 
    <span class="kw1">if</span> <span class="br0">(</span>node <span class="sy0">==</span> NULL<span class="br0">)</span><span class="br0">{</span>
        <span class="kw3">fputs</span><span class="br0">(</span><span class="st0">"Error: no space available for node<span class="es1">\n</span>"</span><span class="sy0">,</span> stderr<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw3">abort</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>                                      <span class="coMULTI">/* initialize node */</span>
        node<span class="sy0">-&gt;</span>data <span class="sy0">=</span> value<span class="sy0">;</span>
        node<span class="sy0">-&gt;</span>next <span class="sy0">=</span> empty<span class="br0">(</span><span class="sy0">*</span>head<span class="br0">)</span> <span class="sy0">?</span> NULL <span class="sy0">:</span> <span class="sy0">*</span>head<span class="sy0">;</span> <span class="coMULTI">/* insert new head if any */</span>
        <span class="sy0">*</span>head <span class="sy0">=</span> node<span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
</pre>
<p>A <code>pop()</code> operation removes the head from the linked list, and assigns the pointer to the head to the previous second node. It checks whether the list is empty before popping from it:</p>
<p>WHATSON? fb21f270-42c1-4a40-93a5-adf8a63e7bc0</p>
<pre class="de1">
<span class="kw4">int</span> pop<span class="br0">(</span>STACK <span class="sy0">**</span>head<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>empty<span class="br0">(</span><span class="sy0">*</span>head<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>                          <span class="coMULTI">/* stack is empty */</span>
       <span class="kw3">fputs</span><span class="br0">(</span><span class="st0">"Error: stack underflow<span class="es1">\n</span>"</span><span class="sy0">,</span> stderr<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw3">abort</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>                                     <span class="co1">//pop a node</span>
        STACK <span class="sy0">*</span>top <span class="sy0">=</span> <span class="sy0">*</span>head<span class="sy0">;</span>
        <span class="kw4">int</span> value <span class="sy0">=</span> top<span class="sy0">-&gt;</span>data<span class="sy0">;</span>
        <span class="sy0">*</span>head <span class="sy0">=</span> top<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
        <span class="kw3">free</span><span class="br0">(</span>top<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">return</span> value<span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
</pre>
<h3><span class="mw-headline" id="Stacks_and_programming_languages">Stacks and programming languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=8" title="Edit section: Stacks and programming languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some languages, like Perl, <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">LISP</a> and <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, do not call for stack implementations, since <b>push</b> and <b>pop</b> functions are available for any list. All <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>-like languages (such as <a href="/wiki/PostScript" title="PostScript">Adobe PostScript</a>) are also designed around language-defined stacks that are directly visible to and manipulated by the programmer. Examples from <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>:</p>
<p>WHATSON? 94645ea0-5c27-49e6-b2ff-f3b22fb66e49</p>
<pre class="de1">
<span class="br0">(</span><span class="kw1">setf</span> <span class="kw1">list</span> <span class="br0">(</span><span class="kw1">list</span> 'a 'b 'c<span class="br0">)</span><span class="br0">)</span>
<span class="co1">;; ⇒ (A B C)</span>
<span class="br0">(</span>pop <span class="kw1">list</span><span class="br0">)</span>
<span class="co1">;; ⇒ A</span>
<span class="kw1">list</span>
<span class="co1">;; ⇒ (B C)</span>
<span class="br0">(</span>push 'new <span class="kw1">list</span><span class="br0">)</span>
<span class="co1">;; ⇒ (NEW B C)</span>
</pre>
<p>C++'s <a href="/wiki/Standard_Template_Library" title="Standard Template Library">Standard Template Library</a> provides a "<code>stack</code>" templated class which is restricted to only push/pop operations. Java's library contains a <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Stack</a></code> class that is a specialization of <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/Vector.html">Vector</a></code>---this could be considered a design flaw, since the inherited get() method from <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/Vector.html">Vector</a></code> ignores the LIFO constraint of the <code><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Stack</a></code>. PHP has an <a rel="nofollow" class="external text" href="http://www.php.net/manual/en/class.splstack.php">SplStack</a> class.</p>
<h2><span class="mw-headline" id="Hardware_stacks">Hardware stacks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=9" title="Edit section: Hardware stacks">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A common use of stacks at the architecture level is as a means of allocating and accessing memory.</p>
<h3><span class="mw-headline" id="Basic_architecture_of_a_stack">Basic architecture of a stack</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=10" title="Edit section: Basic architecture of a stack">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A typical stack is an area of computer memory with a fixed origin and a variable size. Initially the size of the stack is zero. A <i>stack pointer,</i> usually in the form of a hardware register, points to the most recently referenced location on the stack; when the stack has a size of zero, the stack pointer points to the origin of the stack.</p>
<p>The two operations applicable to all stacks are:</p>
<ul>
<li>a <i>push</i> operation, in which a data item is placed at the location pointed to by the stack pointer, and the address in the stack pointer is adjusted by the size of the data item;</li>
<li>a <i>pop</i> or <i>pull</i> operation: a data item at the current location pointed to by the stack pointer is removed, and the stack pointer is adjusted by the size of the data item.</li>
</ul>
<p>There are many variations on the basic principle of stack operations. Every stack has a fixed location in memory at which it begins. As data items are added to the stack, the stack pointer is displaced to indicate the current extent of the stack, which expands away from the origin.</p>
<p>Stack pointers may point to the origin of a stack or to a limited range of addresses either above or below the origin (depending on the direction in which the stack grows); however, the stack pointer cannot cross the origin of the stack. In other words, if the origin of the stack is at address 1000 and the stack grows downwards (towards addresses 999, 998, and so on), the stack pointer must never be incremented beyond 1000 (to 1001, 1002, etc.). If a pop operation on the stack causes the stack pointer to move past the origin of the stack, a <i>stack underflow</i> occurs. If a push operation causes the stack pointer to increment or decrement beyond the maximum extent of the stack, a <i>stack overflow</i> occurs.</p>
<p>Some environments that rely heavily on stacks may provide additional operations, for example:</p>
<ul>
<li><i>Duplicate</i>: the top item is popped, and then pushed again (twice), so that an additional copy of the former top item is now on top, with the original below it.</li>
<li><i>Peek</i>: the topmost item is inspected (or returned), but the stack pointer is not changed, and the stack size does not change (meaning that the item remains on the stack). This is also called <b>top</b> operation in many articles.</li>
<li><i>Swap</i> or <i>exchange</i>: the two topmost items on the stack exchange places.</li>
<li><i>Rotate (or Roll)</i>: the <i>n</i> topmost items are moved on the stack in a rotating fashion. For example, if <i>n</i>=3, items 1, 2, and 3 on the stack are moved to positions 2, 3, and 1 on the stack, respectively. Many variants of this operation are possible, with the most common being called <i>left rotate</i> and <i>right rotate.</i></li>
</ul>
<p>Stacks are often visualized growing from the bottom up (like real-world stacks). They may also be visualized growing from left to right, so that "topmost" becomes "rightmost", or even growing from top to bottom. The important feature is that the top of the stack is in a fixed position. The image above and to the right is an example of a top to bottom growth visualization: the top (28) is the stack 'bottom', since the stack 'top' is where items are pushed or popped from. Sometimes stacks are also visualized metaphorically, such as coin holders or <a href="/wiki/Pez" title="Pez">Pez</a> dispensers.</p>
<p>A <i>right rotate</i> will move the first element to the third position, the second to the first and the third to the second. Here are two equivalent visualizations of this process:</p>
<p>WHATSON? 98e5f8a2-aeeb-45b4-803c-a1129ba83eae</p>
<pre>
apple                         banana
banana    ===right rotate==&gt;  cucumber
cucumber                      apple
</pre>
<p>WHATSON? 73baa5aa-3cdd-440b-adaf-22debd65ecd6</p>
<pre>
cucumber                      apple
banana    ===left rotate==&gt;   cucumber
apple                         banana
</pre>
<p>A stack is usually represented in computers by a block of memory cells, with the "bottom" at a fixed location, and the stack pointer holding the address of the current "top" cell in the stack. The top and bottom terminology are used irrespective of whether the stack actually grows towards lower memory addresses or towards higher memory addresses.</p>
<p>Pushing an item on to the stack adjusts the stack pointer by the size of the item (either decrementing or incrementing, depending on the direction in which the stack grows in memory), pointing it to the next cell, and copies the new top item to the stack area. Depending again on the exact implementation, at the end of a push operation, the stack pointer may point to the next unused location in the stack, or it may point to the topmost item in the stack. If the stack points to the current topmost item, the stack pointer will be updated before a new item is pushed onto the stack; if it points to the next available location in the stack, it will be updated <i>after</i> the new item is pushed onto the stack.</p>
<p>Popping the stack is simply the inverse of pushing. The topmost item in the stack is removed and the stack pointer is updated, in the opposite order of that used in the push operation.</p>
<h3><span class="mw-headline" id="Hardware_support">Hardware support</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=11" title="Edit section: Hardware support">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Stack_in_main_memory">Stack in main memory</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=12" title="Edit section: Stack in main memory">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Most <a href="/wiki/Central_processing_unit" title="Central processing unit">CPUs</a> have registers that can be used as stack pointers. Processor families like the <a href="/wiki/X86" title="X86">x86</a>, <a href="/wiki/Z80" title="Z80" class="mw-redirect">Z80</a>, <a href="/wiki/6502" title="6502" class="mw-redirect">6502</a>, and many others have special instructions that implicitly use a dedicated (hardware) stack pointer to conserve opcode space. Some processors, like the <a href="/wiki/PDP-11" title="PDP-11">PDP-11</a> and the <a href="/wiki/68000" title="68000" class="mw-redirect">68000</a>, also have special addressing modes for implementation of stacks, typically with a semi-dedicated stack pointer as well (such as A7 in the 68000). However, in most processors, several different registers may be used as additional stack pointers as needed (whether updated via addressing modes or via add/sub instructions).</p>
<h4><span class="mw-headline" id="Stack_in_registers_or_dedicated_memory">Stack in registers or dedicated memory</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=13" title="Edit section: Stack in registers or dedicated memory">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The <a href="/wiki/X87" title="X87">x87</a> <a href="/wiki/Floating_point" title="Floating point">floating point</a> architecture is an example of a set of registers organised as a stack where direct access to individual registers (relative the current top) is also possible. As with stack-based machines in general, having the top-of-stack as an implicit argument allows for a small <a href="/wiki/Machine_code" title="Machine code">machine code</a> footprint with a good usage of <a href="/wiki/Bus_(computing)" title="Bus (computing)">bus</a> <a href="/wiki/Bandwidth_(computing)" title="Bandwidth (computing)">bandwidth</a> and <a href="/wiki/Cache_memory" title="Cache memory" class="mw-redirect">code caches</a>, but it also prevents some types of optimizations possible on processors permitting <a href="/wiki/Random_access" title="Random access">random access</a> to the <a href="/wiki/Register_file" title="Register file">register file</a> for all (two or three) operands. A stack structure also makes <a href="/wiki/Superscalar" title="Superscalar">superscalar</a> implementations with <a href="/wiki/Register_renaming" title="Register renaming">register renaming</a> (for <a href="/wiki/Speculative_execution" title="Speculative execution">speculative execution</a>) somewhat more complex to implement, although it is still feasible, as exemplified by modern <a href="/wiki/X87" title="X87">x87</a> implementations.</p>
<p><a href="/wiki/Sun_SPARC" title="Sun SPARC" class="mw-redirect">Sun SPARC</a>, <a href="/wiki/AMD_Am29000" title="AMD Am29000">AMD Am29000</a>, and <a href="/wiki/Intel_i960" title="Intel i960">Intel i960</a> are all examples of architectures using <a href="/wiki/Register_window" title="Register window">register windows</a> within a register-stack as another strategy to avoid the use of slow main memory for function arguments and return values.</p>
<p>There are also a number of small microprocessors that implements a stack directly in hardware and some <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a> have a fixed-depth stack that is not directly accessible. Examples are the <a href="/wiki/PIC_microcontroller" title="PIC microcontroller">PIC microcontrollers</a>, the <a href="/w/index.php?title=Computer_Cowboys&amp;action=edit&amp;redlink=1" class="new" title="Computer Cowboys (page does not exist)">Computer Cowboys</a> <a href="/w/index.php?title=MuP21&amp;action=edit&amp;redlink=1" class="new" title="MuP21 (page does not exist)">MuP21</a>, the <a href="/wiki/Harris_RTX" title="Harris RTX" class="mw-redirect">Harris RTX</a> line, and the <a href="/w/index.php?title=Novix&amp;action=edit&amp;redlink=1" class="new" title="Novix (page does not exist)">Novix</a> <a href="/w/index.php?title=NC4016&amp;action=edit&amp;redlink=1" class="new" title="NC4016 (page does not exist)">NC4016</a>. Many stack-based microprocessors were used to implement the programming language <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a> at the <a href="/wiki/Microcode" title="Microcode">microcode</a> level. Stacks were also used as a basis of a number of mainframes and mini computers. Such machines were called <a href="/wiki/Stack_machine" title="Stack machine">stack machines</a>, the most famous being the <a href="/wiki/Burroughs_large_systems" title="Burroughs large systems">Burroughs B5000</a>.</p>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=14" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Stacks are present everyday life, from the books in a library, to the blank sheets of paper in a printer tray. All these applications follow the <i>Last In First Out</i> (LIFO) logic, which means that (for example) a book is added on top of a pile of books, while removing a book from a pile also takes the book on top of a pile.</p>
<p>Below are a few applications of stacks in computing.</p>
<h3><span class="mw-headline" id="Expression_evaluation_and_syntax_parsing">Expression evaluation and syntax parsing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=15" title="Edit section: Expression evaluation and syntax parsing">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Calculators employing <a href="/wiki/Reverse_Polish_notation" title="Reverse Polish notation">reverse Polish notation</a> use a stack structure to hold values. Expressions can be represented in prefix, postfix or infix notations and conversion from one form to another may be accomplished using a stack. Many compilers use a stack for parsing the syntax of expressions, program blocks etc. before translating into low level code. Most programming languages are <a href="/wiki/Context-free_grammar" title="Context-free grammar">context-free languages</a>, allowing them to be parsed with stack based machines.</p>
<h3><span class="mw-headline" id="Backtracking">Backtracking</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=16" title="Edit section: Backtracking">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Another important application of stacks is <a href="/wiki/Backtracking" title="Backtracking">backtracking</a>. Consider a simple example of finding the correct path in a maze. There are a series of points, from the starting point to the destination. We start from one point. To reach the final destination, there are several paths. Suppose we choose a random path. After following a certain path, we realise that the path we have chosen is wrong. So we need to find a way by which we can return to the beginning of that path. This can be done with the use of stacks. With the help of stacks, we remember the point where we have reached. This is done by pushing that point into the stack. In case we end up on the wrong path, we can pop the last point from the stack and thus return to the last point and continue our quest to find the right path. This is called backtracking.</p>
<h3><span class="mw-headline" id="Runtime_memory_management">Runtime memory management</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=17" title="Edit section: Runtime memory management">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A number of <a href="/wiki/Programming_language" title="Programming language">programming languages</a> are <a href="/wiki/Stack-oriented_programming_language" title="Stack-oriented programming language">stack-oriented</a>, meaning they define most basic operations (adding two numbers, printing a character) as taking their arguments from the stack, and placing any return values back on the stack. For example, <a href="/wiki/PostScript" title="PostScript">PostScript</a> has a return stack and an operand stack, and also has a graphics state stack and a dictionary stack. Many <a href="/wiki/Virtual_machine" title="Virtual machine">virtual machines</a> are also stack-oriented, including the <a href="/wiki/P-code_machine" title="P-code machine">p-code machine</a> and the <a href="/wiki/Java_Virtual_Machine" title="Java Virtual Machine" class="mw-redirect">Java Virtual Machine</a>.</p>
<p>Almost all <a href="/wiki/Calling_convention" title="Calling convention">calling conventions</a> – computer runtime memory environments – use a special stack (the "<a href="/wiki/Call_stack" title="Call stack">call stack</a>") to hold information about procedure/function calling and nesting in order to switch to the context of the called function and restore to the caller function when the calling finishes. The functions follow a runtime protocol between caller and callee to save arguments and return value on the stack. Stacks are an important way of supporting nested or <a href="/wiki/Recursion" title="Recursion">recursive</a> function calls. This type of stack is used implicitly by the compiler to support CALL and RETURN statements (or their equivalents) and is not manipulated directly by the programmer.</p>
<p>Some programming languages use the stack to store data that is local to a procedure. Space for local data items is allocated from the stack when the procedure is entered, and is deallocated when the procedure exits. The <a href="/wiki/C_(programming_language)" title="C (programming language)">C programming language</a> is typically implemented in this way. Using the same stack for both data and procedure calls has important security implications (see below) of which a programmer must be aware in order to avoid introducing serious security bugs into a program.</p>
<h2><span class="mw-headline" id="Security">Security</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=18" title="Edit section: Security">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some computing environments use stacks in ways that may make them vulnerable to security breaches and attacks. Programmers working in such environments must take special care to avoid the pitfalls of these implementations.</p>
<p>For example, some programming languages use a common stack to store both data local to a called procedure and the linking information that allows the procedure to return to its caller. This means that the program moves data into and out of the same stack that contains critical return addresses for the procedure calls. If data is moved to the wrong location on the stack, or an oversized data item is moved to a stack location that is not large enough to contain it, return information for procedure calls may be corrupted, causing the program to fail.</p>
<p>Malicious parties may attempt a <a href="/wiki/Stack_smashing" title="Stack smashing" class="mw-redirect">stack smashing</a> attack that takes advantage of this type of implementation by providing oversized data input to a program that does not check the length of input. Such a program may copy the data in its entirety to a location on the stack, and in so doing it may change the return addresses for procedures that have called it. An attacker can experiment to find a specific type of data that can be provided to such a program such that the return address of the current procedure is reset to point to an area within the stack itself (and within the data provided by the attacker), which in turn contains instructions that carry out unauthorized operations.</p>
<p>This type of attack is a variation on the <a href="/wiki/Buffer_overflow" title="Buffer overflow">buffer overflow</a> attack and is an extremely frequent source of security breaches in software, mainly because some of the most popular compilers use a shared stack for both data and procedure calls, and do not verify the length of data items. Frequently programmers do not write code to verify the size of data items, either, and when an oversized or undersized data item is copied to the stack, a security breach may occur.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=19" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/List_of_data_structures" title="List of data structures">List of data structures</a></li>
<li><a href="/wiki/Queue_(abstract_data_type)" title="Queue (abstract data type)">Queue</a></li>
<li><a href="/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queue</a></li>
<li><a href="/wiki/Call_stack" title="Call stack">Call stack</a></li>
<li><a href="/wiki/Stack-based_memory_allocation" title="Stack-based memory allocation">Stack-based memory allocation</a></li>
<li><a href="/wiki/Stack_machine" title="Stack machine">Stack machine</a></li>
<li><a href="/wiki/Stack_overflow" title="Stack overflow">Stack overflow</a></li>
<li><a href="/wiki/Stack-oriented_programming_language" title="Stack-oriented programming language">Stack-oriented programming language</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=20" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.cs.duke.edu/csed/ap/subset/doc/ap/Stack.html">"Interface Stack"</a>. Duke University<span class="reference-accessdate">. Retrieved Feb 7, 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AStack+%28abstract+data+type%29&amp;rft.btitle=Interface+Stack&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.duke.edu%2Fcsed%2Fap%2Fsubset%2Fdoc%2Fap%2FStack.html&amp;rft.pub=Duke+University&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://www.cprogramming.com/tutorial/computersciencetheory/stack.html">http://www.cprogramming.com/tutorial/computersciencetheory/stack.html</a> cprogramming.com</span></li>
<li id="cite_note-patent-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-patent_3-0">^</a></b></span> <span class="reference-text"><span class="citation journal">Dr. Friedrich Ludwig Bauer and Dr. Klaus Samelson (30 March 1957). <a rel="nofollow" class="external text" href="http://v3.espacenet.com/origdoc?DB=EPODOC&amp;IDX=DE1094019&amp;F=0&amp;QPN=DE1094019">"Verfahren zur automatischen Verarbeitung von kodierten Daten und Rechenmaschine zur Ausübung des Verfahrens"</a> (in German). Germany, Munich: Deutsches Patentamt<span class="reference-accessdate">. Retrieved 2010-10-01</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AStack+%28abstract+data+type%29&amp;rft.au=Dr.+Friedrich+Ludwig+Bauer+and+Dr.+Klaus+Samelson&amp;rft.aulast=Dr.+Friedrich+Ludwig+Bauer+and+Dr.+Klaus+Samelson&amp;rft.btitle=Verfahren+zur+automatischen+Verarbeitung+von+kodierten+Daten+und+Rechenmaschine+zur+Aus%C3%BCbung+des+Verfahrens&amp;rft.date=30+March+1957&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fv3.espacenet.com%2Forigdoc%3FDB%3DEPODOC%26IDX%3DDE1094019%26F%3D0%26QPN%3DDE1094019&amp;rft.place=Germany%2C+Munich&amp;rft.pub=Deutsches+Patentamt&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">C. L. Hamblin, "An Addressless Coding Scheme based on Mathematical Notation", N.S.W University of Technology, May 1957 (typescript)</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Jones: "Systematic Software Development Using VDM"</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Horowitz, Ellis: "Fundamentals of Data Structures in Pascal", page 67. Computer Science Press, 1984</span></li>
</ol>
<ul>
<li><a rel="nofollow" class="external text" href="http://goodsoft.org.ua/en/data_struct/stack.html">Stack implementation on goodsoft.org.ua</a></li>
</ul>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=21" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>. <i>The Art of Computer Programming</i>, Volume 1: <i>Fundamental Algorithms</i>, Third Edition.Addison-Wesley, 1997. <a href="/wiki/Special:BookSources/0201896834" class="internal mw-magiclink-isbn">ISBN 0-201-89683-4</a>. Section 2.2.1: Stacks, Queues, and Deques, pp. 238–243.</li>
<li><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw-Hill, 2001. <a href="/wiki/Special:BookSources/0262032937" class="internal mw-magiclink-isbn">ISBN 0-262-03293-7</a>. Section 10.1: Stacks and queues, pp. 200–204.</li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Stack_(abstract_data_type)&amp;action=edit&amp;section=22" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://scanftree.com/Data_Structure/Application-of-stack">Stacks and its Applications</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ece.cmu.edu/~koopman/stack_computers/index.html">Stack Machines - the new wave</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.utah.edu/~regehr/stacktool">Bounding stack depth</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.ucla.edu/~palsberg/paper/sas03.pdf">Stack Size Analysis for Interrupt-driven Programs</a> (322 KB)</li>
<li>Paul E. Black, <a rel="nofollow" class="external text" href="http://www.nist.gov/dads/HTML/boundedstack.html">Bounded stack</a> at the <a href="/wiki/National_Institute_of_Standards_and_Technology" title="National Institute of Standards and Technology">NIST</a> <a href="/wiki/Dictionary_of_Algorithms_and_Data_Structures" title="Dictionary of Algorithms and Data Structures">Dictionary of Algorithms and Data Structures</a>.</li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_structures" title="Template:Data structures"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_structures" title="Template talk:Data structures"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_structures&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Collection_(abstract_data_type)" title="Collection (abstract data type)">Collection</a></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Container</a></li>
</ul>
<ul>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Double-ended_priority_queue" title="Double-ended priority queue">Double-ended priority queue</a></li>
<li><a href="/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queue</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Map</a></li>
<li><a href="/wiki/Multimap" title="Multimap">Multimap</a></li>
<li><a href="/wiki/Priority_queue" title="Priority queue">Priority queue</a></li>
<li><a href="/wiki/Queue_(abstract_data_type)" title="Queue (abstract data type)">Queue</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a>
<ul>
<li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">multiset</a></li>
</ul>
</li>
<li><a href="/wiki/Disjoint-set_data_structure" title="Disjoint-set data structure">Disjoint Sets</a></li>
<li><strong class="selflink">Stack</strong></li>
</ul>
<ul>
<li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">multiset</a></li>
</ul>
<ul>
<li><a href="/wiki/Bit_array" title="Bit array">Bit array</a></li>
<li><a href="/wiki/Circular_buffer" title="Circular buffer">Circular buffer</a></li>
<li><a href="/wiki/Dynamic_array" title="Dynamic array">Dynamic array</a></li>
<li><a href="/wiki/Hash_table" title="Hash table">Hash table</a></li>
<li><a href="/wiki/Hashed_array_tree" title="Hashed array tree">Hashed array tree</a></li>
<li><a href="/wiki/Sparse_array" title="Sparse array">Sparse array</a></li>
</ul>
<ul>
<li><a href="/wiki/Association_list" title="Association list">Association list</a></li>
<li><a href="/wiki/Linked_list" title="Linked list">Linked list</a></li>
<li><a href="/wiki/Skip_list" title="Skip list">Skip list</a></li>
<li><a href="/wiki/Unrolled_linked_list" title="Unrolled linked list">Unrolled linked list</a></li>
<li><a href="/wiki/XOR_linked_list" title="XOR linked list">XOR linked list</a></li>
</ul>
<ul>
<li><a href="/wiki/B-tree" title="B-tree">B-tree</a></li>
<li><a href="/wiki/Binary_search_tree" title="Binary search tree">Binary search tree</a>
<ul>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">red-black</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">splay</a></li>
</ul>
</li>
<li><a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">Heap</a>
<ul>
<li><a href="/wiki/Binary_heap" title="Binary heap">binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">binomial</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
</ul>
</li>
<li><a href="/wiki/R-tree" title="R-tree">R-tree</a>
<ul>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert</a></li>
</ul>
</li>
<li><a href="/wiki/Trie" title="Trie">Trie</a>
<ul>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">red-black</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">splay</a></li>
</ul>
<ul>
<li><a href="/wiki/Binary_heap" title="Binary heap">binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">binomial</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
</ul>
<ul>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert</a></li>
</ul>
<ul>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li>
</ul>
<ul>
<li><a href="/wiki/Binary_decision_diagram" title="Binary decision diagram">Binary decision diagram</a></li>
<li><a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">Directed acyclic graph</a></li>
<li><a href="/wiki/Directed_acyclic_word_graph" title="Directed acyclic word graph">Directed acyclic word graph</a></li>
</ul>
<ul>
<li><a href="/wiki/List_of_data_structures" title="List of data structures">List of data structures</a></li>
</ul>
