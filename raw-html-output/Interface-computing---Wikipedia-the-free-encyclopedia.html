<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Interface (computing)</span></h1>
<p>In <a href="/wiki/Computing" title="Computing">computing</a>, an <b>interface</b> is a shared boundary across which two separate components of a <a href="/wiki/Computer_system" title="Computer system" class="mw-redirect">computer system</a> exchange information. The exchange can be between <a href="/wiki/Software" title="Software">software</a>, <a href="/wiki/Computer_hardware" title="Computer hardware">computer hardware</a>, <a href="/wiki/Peripheral" title="Peripheral">peripheral</a> devices, humans and combinations of these. Some computer hardware devices such as a <a href="/wiki/Touchscreen" title="Touchscreen">touchscreen</a> can send and receive data through the interface, while others such as a mouse, microphone or joystick are one way only.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Hardware_interfaces"><span class="tocnumber">1</span> <span class="toctext">Hardware interfaces</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Software_interfaces"><span class="tocnumber">2</span> <span class="toctext">Software interfaces</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Software_interfaces_in_practice"><span class="tocnumber">2.1</span> <span class="toctext">Software interfaces in practice</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Software_interfaces_in_object-oriented_languages"><span class="tocnumber">2.2</span> <span class="toctext">Software interfaces in object-oriented languages</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Programming_to_the_interface"><span class="tocnumber">2.3</span> <span class="toctext">Programming to the interface</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Software_interfaces_in_practice"><span class="tocnumber">2.1</span> <span class="toctext">Software interfaces in practice</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Software_interfaces_in_object-oriented_languages"><span class="tocnumber">2.2</span> <span class="toctext">Software interfaces in object-oriented languages</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Programming_to_the_interface"><span class="tocnumber">2.3</span> <span class="toctext">Programming to the interface</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Hardware_interfaces">Hardware interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=1" title="Edit section: Hardware interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Hardware interfaces exist in many of the components such as the various <a href="/wiki/Bus_(computing)" title="Bus (computing)">buses</a>, <a href="/wiki/Computer_data_storage" title="Computer data storage">storage devices</a>, other <a href="/wiki/I/O" title="I/O" class="mw-redirect">I/O</a> devices, etc. A hardware interface is described by the mechanical, electrical and logical signals at the interface and the protocol for sequencing them (sometimes called signaling).<sup id="cite_ref-87Blaauw_2-0" class="reference"><a href="#cite_note-87Blaauw-2"><span>[</span>2<span>]</span></a></sup> A standard interface, such as <a href="/wiki/SCSI" title="SCSI">SCSI</a>, decouples the design and introduction of computing hardware, such as <a href="/wiki/I/O" title="I/O" class="mw-redirect">I/O</a> devices, from the design and introduction of other components of a computing system, thereby allowing users and manufacturers great flexibility in the implementation of computing systems.<sup id="cite_ref-87Blaauw_2-1" class="reference"><a href="#cite_note-87Blaauw-2"><span>[</span>2<span>]</span></a></sup> Hardware interfaces can be <a href="/wiki/Parallel_communication" title="Parallel communication">parallel</a> with several electrical connections carrying parts of the data simultaneously, or <a href="/wiki/Serial_communication" title="Serial communication">serial</a> where data is sent one <a href="/wiki/Bit" title="Bit">bit</a> at a time.</p>
<h2><span class="mw-headline" id="Software_interfaces">Software interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=2" title="Edit section: Software interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A software interface may refer to a wide range of different types of interface at different "levels": an operating system may interface with pieces of hardware. <a href="/wiki/Application_software" title="Application software">Applications</a> or <a href="/wiki/Computer_program" title="Computer program">programs</a> running on the operating system may need to interact via <a href="/wiki/Stream_(computing)" title="Stream (computing)">streams</a>, and in <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object oriented programs</a>, objects within an application may need to interact via <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">methods</a>.</p>
<h3><span class="mw-headline" id="Software_interfaces_in_practice">Software interfaces in practice</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=3" title="Edit section: Software interfaces in practice">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A key principle of design is to prohibit access to all resources by default, allowing access only through well-defined entry points, i.e. interfaces.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> Software interfaces provide access to computer resources (such as memory, CPU, storage, etc.) of the underlying computer system; direct access (i.e. not through well designed interfaces) to such resources by software can have major ramifications—sometimes disastrous ones—for functionality and stability.</p>
<p>Interfaces between software components can provide: <a href="/wiki/Constant_(computer_science)" title="Constant (computer science)" class="mw-redirect">constants</a>, <a href="/wiki/Data_type" title="Data type">data types</a>, types of <a href="/wiki/Subroutine" title="Subroutine">procedures</a>, <a href="/wiki/Exception_handling" title="Exception handling">exception</a> specifications and <a href="/wiki/Method_signature" title="Method signature" class="mw-redirect">method signatures</a>. Sometimes, public <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variables</a> are also defined as part of an interface.</p>
<p>The interface of a software module <i>A</i> is deliberately defined separately from the <i><a href="/wiki/Implementation#Computer_science" title="Implementation">implementation</a></i> of that module. The latter contains the actual code of the procedures and methods described in the interface, as well as other "private" variables, procedures, etc. Another software module <i>B</i>, for example the <a href="/wiki/Client_(computing)" title="Client (computing)">client</a> to <i>A</i>, that interacts with <i>A</i> is forced to do so <i>only</i> through the published interface. One practical advantage of this arrangement is that replacing the implementation of <i>A</i> by another implementation of the same interface should not cause <i>B</i> to fail—how <i>A</i> internally meets the requirements of the interface is not relevant to <i>B</i>, which <a href="/wiki/Separation_of_concerns" title="Separation of concerns">is only concerned</a> with the specifications of the interface. (See also <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>.)</p>
<h3><span class="mw-headline" id="Software_interfaces_in_object-oriented_languages">Software interfaces in object-oriented languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=4" title="Edit section: Software interfaces in object-oriented languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/Object-oriented" title="Object-oriented" class="mw-redirect">object-oriented</a> languages, the term <i>interface</i> is often used to define an <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract type</a> that contains no data or code, but defines behaviors as <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> signatures. A <a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a> having code and data for all the methods corresponding to that interface is said to <i>implement</i> that interface.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> Furthermore, a class can implement multiple interfaces, and hence can <i>be</i> of different types at the same time.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p>An interface is hence a <a href="/wiki/Data_type" title="Data type">type</a> definition; anywhere an object can be exchanged (for example, in a <a href="/wiki/Function_(computer_science)" title="Function (computer science)" class="mw-redirect">function</a> or <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> call) the <i>type</i> of the object to be exchanged can be defined in terms of its interface rather than specifying a particular <a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a>. This means that any class that implements that interface can be used. For example, a <a href="/wiki/Skeleton_(computer_programming)" title="Skeleton (computer programming)">dummy implementation</a> may be used to allow development to progress before the final implementation is available. In another case, a <a href="/wiki/Test-driven_development#Fakes.2C_mocks_and_integration_tests" title="Test-driven development">fake or mock</a> implementation may be substituted during testing. Such <a href="/wiki/Method_stub" title="Method stub">stub</a> implementations are replaced by real code later in the development process.</p>
<p>Usually a method defined in an interface cannot be used directly; it must be implemented by non-abstract code that will run when it is actually invoked. An interface called "<tt><a href="/wiki/Stack_(data_structure)" title="Stack (data structure)" class="mw-redirect">Stack</a></tt>" might define two methods: <code>push()</code> and <code>pop()</code>. It can be implemented in different ways, for example, <tt>FastStack</tt> and <tt>GenericStack</tt>—the first being fast, working with a stack of fixed size, and the second using a data structure that can be resized, but at the cost of somewhat lower speed.</p>
<p>An interface may define only a single method; for example, the <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> language defines the interface <tt>Readable</tt> that has the single <code>read()</code> method. Various implementations are used for different purposes, including <tt>BufferedReader</tt>, <tt>FileReader</tt>, <tt>InputStreamReader</tt>, <tt>PipedReader</tt>, and <tt>StringReader</tt>. <a href="/wiki/Marker_interface_pattern" title="Marker interface pattern">Marker interfaces</a> like <span class="mw-geshi java source-java"><span class="kw3">Serializable</span></span> contain no methods at all.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Programming_to_the_interface">Programming to the interface</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=5" title="Edit section: Programming to the interface">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The use of interfaces allows a programming style called <i>programming to the interface</i>. The idea behind this is to base programming logic on the interfaces of the objects used, rather than on internal implementation details. Programming to the interface reduces dependency on implementation specifics and makes code more reusable.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> It gives the programmer the ability to later change the behavior of the system by simply swapping the object used with another implementing the same interface.</p>
<p>Pushing this idea to the extreme, <a href="/wiki/Inversion_of_control" title="Inversion of control">inversion of control</a> leaves the <i>context</i> to inject the code with the specific implementations of the interface that will be used to perform the work.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Abstraction_inversion" title="Abstraction inversion">Abstraction inversion</a></li>
<li><a href="/wiki/Application_binary_interface" title="Application binary interface">Application binary interface</a></li>
<li><a href="/wiki/Application_programming_interface" title="Application programming interface">Application programming interface</a></li>
<li><a href="/wiki/Business_Interoperability_Interface" title="Business Interoperability Interface" class="mw-redirect">Business Interoperability Interface</a></li>
<li><a href="/wiki/Computer_bus" title="Computer bus" class="mw-redirect">Computer bus</a></li>
<li><a href="/wiki/Implementation_(computer_science)" title="Implementation (computer science)" class="mw-redirect">Implementation (computer science)</a></li>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Inheritance_semantics" title="Inheritance semantics" class="mw-redirect">Inheritance semantics</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular programming</a></li>
<li><a href="/wiki/Software_componentry" title="Software componentry" class="mw-redirect">Software componentry</a></li>
<li><a href="/wiki/User_interface" title="User interface">User interface</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation encyclopaedia"><i>IEEE 100 - The Authoritative Dictionary Of IEEE Standards Terms</i>. NYC, NY, USA: IEEE Press. 2000. pp. 574–575. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-7381-2601-2" title="Special:BookSources/0-7381-2601-2">0-7381-2601-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.btitle=IEEE+100+-+The+Authoritative+Dictionary+Of+IEEE+Standards+Terms&amp;rft.date=2000&amp;rft.genre=book&amp;rft.isbn=0-7381-2601-2&amp;rft.pages=574-575&amp;rft.place=NYC%2C+NY%2C+USA&amp;rft.pub=IEEE+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-87Blaauw-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-87Blaauw_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-87Blaauw_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span id="CITEREFBlaauwBrooks.2C_Jr.1997" class="citation">Blaauw, Gerritt A.; Brooks, Jr., Frederick P. (1997), "Chapter 8.6, Device Interfaces", <i>Computer Architecture-Concepts and Evolution</i>, Addison-Wesley, pp. 489–493, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-201-10557-8" title="Special:BookSources/0-201-10557-8">0-201-10557-8</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=Computer+Architecture-Concepts+and+Evolution&amp;rft.au=Blaauw%2C+Gerritt+A.&amp;rft.au=Brooks%2C+Jr.%2C+Frederick+P.&amp;rft.aufirst=Gerritt+A.&amp;rft.aulast=Blaauw&amp;rft.btitle=Chapter+8.6%2C+Device+Interfaces&amp;rft.date=1997&amp;rft.genre=bookitem&amp;rft.isbn=0-201-10557-8&amp;rft.pages=489-493&amp;rft.pub=Addison-Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> See also: <span id="CITEREFPattersonHennessey2005" class="citation">Patterson, David A.; Hennessey, John L. (2005), "Chapter 8.5, Interfacing I/O Devices to the Processor, Memory and Operating System", <i>Computer Organization and Design - The Hardware/Software Interface, Third Edition</i>, Morgan Kaufmann, pp. 588–596, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/1-55860-604-1" title="Special:BookSources/1-55860-604-1">1-55860-604-1</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=Computer+Organization+and+Design+-+The+Hardware%2FSoftware+Interface%2C+Third+Edition&amp;rft.aufirst=David+A.&amp;rft.au=Hennessey%2C+John+L.&amp;rft.aulast=Patterson&amp;rft.au=Patterson%2C+David+A.&amp;rft.btitle=Chapter+8.5%2C+Interfacing+I%2FO+Devices+to+the+Processor%2C+Memory+and+Operating+System&amp;rft.date=2005&amp;rft.genre=bookitem&amp;rft.isbn=1-55860-604-1&amp;rft.pages=588-596&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web">Bill Venners (2005-06-06). <a rel="nofollow" class="external text" href="http://www.artima.com/lejava/articles/designprinciples.html">"Leading-Edge Java: Design Principles from Design Patterns: Program to an interface, not an implementation - A Conversation with Erich Gamma, Part III"</a>. <a rel="nofollow" class="external free" href="http://www.artima.com/index.jsp">http://www.artima.com/index.jsp</a>: artima developer<span class="reference-accessdate">. Retrieved 2011-08-03</span>. "Once you depend on interfaces only, you're decoupled from the implementation. That means the implementation can vary, and that's a healthy dependency relationship. For example, for testing purposes you can replace a heavy database implementation with a lighter-weight mock implementation. Fortunately, with today's refactoring support you no longer have to come up with an interface up front. You can distill an interface from a concrete class once you have the full insights into a problem. The intended interface is just one 'extract interface' refactoring away. ..."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.au=Bill+Venners&amp;rft.aulast=Bill+Venners&amp;rft.btitle=Leading-Edge+Java%3A+Design+Principles+from+Design+Patterns%3A+Program+to+an+interface%2C+not+an+implementation+-+A+Conversation+with+Erich+Gamma%2C+Part+III&amp;rft.date=2005-06-06&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.artima.com%2Flejava%2Farticles%2Fdesignprinciples.html&amp;rft.place=http%3A%2F%2Fwww.artima.com%2Findex.jsp&amp;rft.pub=artima+developer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/tutorial/java/concepts/interface.html">"What Is an Interface"</a>. <i>The Java Tutorials</i>. Oracle<span class="reference-accessdate">. Retrieved 2012-05-01</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=What+Is+an+Interface&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fjava%2Fconcepts%2Finterface.html&amp;rft.jtitle=The+Java+Tutorials&amp;rft.pub=Oracle&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">"Interfaces"</a>. <i>The Java Tutorials</i>. Oracle<span class="reference-accessdate">. Retrieved 2012-05-01</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=Interfaces&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fjava%2FIandI%2Fcreateinterface.html&amp;rft.jtitle=The+Java+Tutorials&amp;rft.pub=Oracle&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/javase/7/docs/api/java/io/Serializable.html">"Performance improvement techniques in Serialization"</a>. <a rel="nofollow" class="external free" href="http://www.precisejava.com/">http://www.precisejava.com/</a>: Precise Java<span class="reference-accessdate">. Retrieved 2011-08-04</span>. "We will talk initially about Serializable interface. This is a marker interface and does not have any methods."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.btitle=Performance+improvement+techniques+in+Serialization&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fjavase%2F7%2Fdocs%2Fapi%2Fjava%2Fio%2FSerializable.html&amp;rft.place=http%3A%2F%2Fwww.precisejava.com%2F&amp;rft.pub=Precise+Java&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation book">Gamma; Helm; Johnson; Vlissides (1995). <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>. Addison Wesley. pp. 17–18.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.au=Gamma&amp;rft.au=Helm&amp;rft.au=Johnson&amp;rft.aulast=Gamma&amp;rft.au=Vlissides&amp;rft.btitle=Design+Patterns%3A+Elements+of+Reusable+Object-Oriented+Software&amp;rft.date=1995&amp;rft.genre=book&amp;rft.pages=17-18&amp;rft.pub=Addison+Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Interface (computing)</span></h1>
<p>In <a href="/wiki/Computing" title="Computing">computing</a>, an <b>interface</b> is a shared boundary across which two separate components of a <a href="/wiki/Computer_system" title="Computer system" class="mw-redirect">computer system</a> exchange information. The exchange can be between <a href="/wiki/Software" title="Software">software</a>, <a href="/wiki/Computer_hardware" title="Computer hardware">computer hardware</a>, <a href="/wiki/Peripheral" title="Peripheral">peripheral</a> devices, humans and combinations of these. Some computer hardware devices such as a <a href="/wiki/Touchscreen" title="Touchscreen">touchscreen</a> can send and receive data through the interface, while others such as a mouse, microphone or joystick are one way only.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Hardware_interfaces"><span class="tocnumber">1</span> <span class="toctext">Hardware interfaces</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Software_interfaces"><span class="tocnumber">2</span> <span class="toctext">Software interfaces</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Software_interfaces_in_practice"><span class="tocnumber">2.1</span> <span class="toctext">Software interfaces in practice</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Software_interfaces_in_object-oriented_languages"><span class="tocnumber">2.2</span> <span class="toctext">Software interfaces in object-oriented languages</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Programming_to_the_interface"><span class="tocnumber">2.3</span> <span class="toctext">Programming to the interface</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Software_interfaces_in_practice"><span class="tocnumber">2.1</span> <span class="toctext">Software interfaces in practice</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Software_interfaces_in_object-oriented_languages"><span class="tocnumber">2.2</span> <span class="toctext">Software interfaces in object-oriented languages</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Programming_to_the_interface"><span class="tocnumber">2.3</span> <span class="toctext">Programming to the interface</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Hardware_interfaces">Hardware interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=1" title="Edit section: Hardware interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Hardware interfaces exist in many of the components such as the various <a href="/wiki/Bus_(computing)" title="Bus (computing)">buses</a>, <a href="/wiki/Computer_data_storage" title="Computer data storage">storage devices</a>, other <a href="/wiki/I/O" title="I/O" class="mw-redirect">I/O</a> devices, etc. A hardware interface is described by the mechanical, electrical and logical signals at the interface and the protocol for sequencing them (sometimes called signaling).<sup id="cite_ref-87Blaauw_2-0" class="reference"><a href="#cite_note-87Blaauw-2"><span>[</span>2<span>]</span></a></sup> A standard interface, such as <a href="/wiki/SCSI" title="SCSI">SCSI</a>, decouples the design and introduction of computing hardware, such as <a href="/wiki/I/O" title="I/O" class="mw-redirect">I/O</a> devices, from the design and introduction of other components of a computing system, thereby allowing users and manufacturers great flexibility in the implementation of computing systems.<sup id="cite_ref-87Blaauw_2-1" class="reference"><a href="#cite_note-87Blaauw-2"><span>[</span>2<span>]</span></a></sup> Hardware interfaces can be <a href="/wiki/Parallel_communication" title="Parallel communication">parallel</a> with several electrical connections carrying parts of the data simultaneously, or <a href="/wiki/Serial_communication" title="Serial communication">serial</a> where data is sent one <a href="/wiki/Bit" title="Bit">bit</a> at a time.</p>
<h2><span class="mw-headline" id="Software_interfaces">Software interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=2" title="Edit section: Software interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A software interface may refer to a wide range of different types of interface at different "levels": an operating system may interface with pieces of hardware. <a href="/wiki/Application_software" title="Application software">Applications</a> or <a href="/wiki/Computer_program" title="Computer program">programs</a> running on the operating system may need to interact via <a href="/wiki/Stream_(computing)" title="Stream (computing)">streams</a>, and in <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object oriented programs</a>, objects within an application may need to interact via <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">methods</a>.</p>
<h3><span class="mw-headline" id="Software_interfaces_in_practice">Software interfaces in practice</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=3" title="Edit section: Software interfaces in practice">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A key principle of design is to prohibit access to all resources by default, allowing access only through well-defined entry points, i.e. interfaces.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> Software interfaces provide access to computer resources (such as memory, CPU, storage, etc.) of the underlying computer system; direct access (i.e. not through well designed interfaces) to such resources by software can have major ramifications—sometimes disastrous ones—for functionality and stability.</p>
<p>Interfaces between software components can provide: <a href="/wiki/Constant_(computer_science)" title="Constant (computer science)" class="mw-redirect">constants</a>, <a href="/wiki/Data_type" title="Data type">data types</a>, types of <a href="/wiki/Subroutine" title="Subroutine">procedures</a>, <a href="/wiki/Exception_handling" title="Exception handling">exception</a> specifications and <a href="/wiki/Method_signature" title="Method signature" class="mw-redirect">method signatures</a>. Sometimes, public <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variables</a> are also defined as part of an interface.</p>
<p>The interface of a software module <i>A</i> is deliberately defined separately from the <i><a href="/wiki/Implementation#Computer_science" title="Implementation">implementation</a></i> of that module. The latter contains the actual code of the procedures and methods described in the interface, as well as other "private" variables, procedures, etc. Another software module <i>B</i>, for example the <a href="/wiki/Client_(computing)" title="Client (computing)">client</a> to <i>A</i>, that interacts with <i>A</i> is forced to do so <i>only</i> through the published interface. One practical advantage of this arrangement is that replacing the implementation of <i>A</i> by another implementation of the same interface should not cause <i>B</i> to fail—how <i>A</i> internally meets the requirements of the interface is not relevant to <i>B</i>, which <a href="/wiki/Separation_of_concerns" title="Separation of concerns">is only concerned</a> with the specifications of the interface. (See also <a href="/wiki/Liskov_substitution_principle" title="Liskov substitution principle">Liskov substitution principle</a>.)</p>
<h3><span class="mw-headline" id="Software_interfaces_in_object-oriented_languages">Software interfaces in object-oriented languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=4" title="Edit section: Software interfaces in object-oriented languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In <a href="/wiki/Object-oriented" title="Object-oriented" class="mw-redirect">object-oriented</a> languages, the term <i>interface</i> is often used to define an <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract type</a> that contains no data or code, but defines behaviors as <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> signatures. A <a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a> having code and data for all the methods corresponding to that interface is said to <i>implement</i> that interface.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> Furthermore, a class can implement multiple interfaces, and hence can <i>be</i> of different types at the same time.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p>An interface is hence a <a href="/wiki/Data_type" title="Data type">type</a> definition; anywhere an object can be exchanged (for example, in a <a href="/wiki/Function_(computer_science)" title="Function (computer science)" class="mw-redirect">function</a> or <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> call) the <i>type</i> of the object to be exchanged can be defined in terms of its interface rather than specifying a particular <a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a>. This means that any class that implements that interface can be used. For example, a <a href="/wiki/Skeleton_(computer_programming)" title="Skeleton (computer programming)">dummy implementation</a> may be used to allow development to progress before the final implementation is available. In another case, a <a href="/wiki/Test-driven_development#Fakes.2C_mocks_and_integration_tests" title="Test-driven development">fake or mock</a> implementation may be substituted during testing. Such <a href="/wiki/Method_stub" title="Method stub">stub</a> implementations are replaced by real code later in the development process.</p>
<p>Usually a method defined in an interface cannot be used directly; it must be implemented by non-abstract code that will run when it is actually invoked. An interface called "<tt><a href="/wiki/Stack_(data_structure)" title="Stack (data structure)" class="mw-redirect">Stack</a></tt>" might define two methods: <code>push()</code> and <code>pop()</code>. It can be implemented in different ways, for example, <tt>FastStack</tt> and <tt>GenericStack</tt>—the first being fast, working with a stack of fixed size, and the second using a data structure that can be resized, but at the cost of somewhat lower speed.</p>
<p>An interface may define only a single method; for example, the <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> language defines the interface <tt>Readable</tt> that has the single <code>read()</code> method. Various implementations are used for different purposes, including <tt>BufferedReader</tt>, <tt>FileReader</tt>, <tt>InputStreamReader</tt>, <tt>PipedReader</tt>, and <tt>StringReader</tt>. <a href="/wiki/Marker_interface_pattern" title="Marker interface pattern">Marker interfaces</a> like <span class="mw-geshi java source-java"><span class="kw3">Serializable</span></span> contain no methods at all.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Programming_to_the_interface">Programming to the interface</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=5" title="Edit section: Programming to the interface">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The use of interfaces allows a programming style called <i>programming to the interface</i>. The idea behind this is to base programming logic on the interfaces of the objects used, rather than on internal implementation details. Programming to the interface reduces dependency on implementation specifics and makes code more reusable.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> It gives the programmer the ability to later change the behavior of the system by simply swapping the object used with another implementing the same interface.</p>
<p>Pushing this idea to the extreme, <a href="/wiki/Inversion_of_control" title="Inversion of control">inversion of control</a> leaves the <i>context</i> to inject the code with the specific implementations of the interface that will be used to perform the work.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Abstraction_inversion" title="Abstraction inversion">Abstraction inversion</a></li>
<li><a href="/wiki/Application_binary_interface" title="Application binary interface">Application binary interface</a></li>
<li><a href="/wiki/Application_programming_interface" title="Application programming interface">Application programming interface</a></li>
<li><a href="/wiki/Business_Interoperability_Interface" title="Business Interoperability Interface" class="mw-redirect">Business Interoperability Interface</a></li>
<li><a href="/wiki/Computer_bus" title="Computer bus" class="mw-redirect">Computer bus</a></li>
<li><a href="/wiki/Implementation_(computer_science)" title="Implementation (computer science)" class="mw-redirect">Implementation (computer science)</a></li>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Inheritance_semantics" title="Inheritance semantics" class="mw-redirect">Inheritance semantics</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular programming</a></li>
<li><a href="/wiki/Software_componentry" title="Software componentry" class="mw-redirect">Software componentry</a></li>
<li><a href="/wiki/User_interface" title="User interface">User interface</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Interface_(computing)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation encyclopaedia"><i>IEEE 100 - The Authoritative Dictionary Of IEEE Standards Terms</i>. NYC, NY, USA: IEEE Press. 2000. pp. 574–575. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-7381-2601-2" title="Special:BookSources/0-7381-2601-2">0-7381-2601-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.btitle=IEEE+100+-+The+Authoritative+Dictionary+Of+IEEE+Standards+Terms&amp;rft.date=2000&amp;rft.genre=book&amp;rft.isbn=0-7381-2601-2&amp;rft.pages=574-575&amp;rft.place=NYC%2C+NY%2C+USA&amp;rft.pub=IEEE+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-87Blaauw-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-87Blaauw_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-87Blaauw_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span id="CITEREFBlaauwBrooks.2C_Jr.1997" class="citation">Blaauw, Gerritt A.; Brooks, Jr., Frederick P. (1997), "Chapter 8.6, Device Interfaces", <i>Computer Architecture-Concepts and Evolution</i>, Addison-Wesley, pp. 489–493, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-201-10557-8" title="Special:BookSources/0-201-10557-8">0-201-10557-8</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=Computer+Architecture-Concepts+and+Evolution&amp;rft.au=Blaauw%2C+Gerritt+A.&amp;rft.au=Brooks%2C+Jr.%2C+Frederick+P.&amp;rft.aufirst=Gerritt+A.&amp;rft.aulast=Blaauw&amp;rft.btitle=Chapter+8.6%2C+Device+Interfaces&amp;rft.date=1997&amp;rft.genre=bookitem&amp;rft.isbn=0-201-10557-8&amp;rft.pages=489-493&amp;rft.pub=Addison-Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> See also: <span id="CITEREFPattersonHennessey2005" class="citation">Patterson, David A.; Hennessey, John L. (2005), "Chapter 8.5, Interfacing I/O Devices to the Processor, Memory and Operating System", <i>Computer Organization and Design - The Hardware/Software Interface, Third Edition</i>, Morgan Kaufmann, pp. 588–596, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/1-55860-604-1" title="Special:BookSources/1-55860-604-1">1-55860-604-1</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=Computer+Organization+and+Design+-+The+Hardware%2FSoftware+Interface%2C+Third+Edition&amp;rft.aufirst=David+A.&amp;rft.au=Hennessey%2C+John+L.&amp;rft.aulast=Patterson&amp;rft.au=Patterson%2C+David+A.&amp;rft.btitle=Chapter+8.5%2C+Interfacing+I%2FO+Devices+to+the+Processor%2C+Memory+and+Operating+System&amp;rft.date=2005&amp;rft.genre=bookitem&amp;rft.isbn=1-55860-604-1&amp;rft.pages=588-596&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web">Bill Venners (2005-06-06). <a rel="nofollow" class="external text" href="http://www.artima.com/lejava/articles/designprinciples.html">"Leading-Edge Java: Design Principles from Design Patterns: Program to an interface, not an implementation - A Conversation with Erich Gamma, Part III"</a>. <a rel="nofollow" class="external free" href="http://www.artima.com/index.jsp">http://www.artima.com/index.jsp</a>: artima developer<span class="reference-accessdate">. Retrieved 2011-08-03</span>. "Once you depend on interfaces only, you're decoupled from the implementation. That means the implementation can vary, and that's a healthy dependency relationship. For example, for testing purposes you can replace a heavy database implementation with a lighter-weight mock implementation. Fortunately, with today's refactoring support you no longer have to come up with an interface up front. You can distill an interface from a concrete class once you have the full insights into a problem. The intended interface is just one 'extract interface' refactoring away. ..."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.au=Bill+Venners&amp;rft.aulast=Bill+Venners&amp;rft.btitle=Leading-Edge+Java%3A+Design+Principles+from+Design+Patterns%3A+Program+to+an+interface%2C+not+an+implementation+-+A+Conversation+with+Erich+Gamma%2C+Part+III&amp;rft.date=2005-06-06&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.artima.com%2Flejava%2Farticles%2Fdesignprinciples.html&amp;rft.place=http%3A%2F%2Fwww.artima.com%2Findex.jsp&amp;rft.pub=artima+developer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/tutorial/java/concepts/interface.html">"What Is an Interface"</a>. <i>The Java Tutorials</i>. Oracle<span class="reference-accessdate">. Retrieved 2012-05-01</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=What+Is+an+Interface&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fjava%2Fconcepts%2Finterface.html&amp;rft.jtitle=The+Java+Tutorials&amp;rft.pub=Oracle&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">"Interfaces"</a>. <i>The Java Tutorials</i>. Oracle<span class="reference-accessdate">. Retrieved 2012-05-01</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.atitle=Interfaces&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fjava%2FIandI%2Fcreateinterface.html&amp;rft.jtitle=The+Java+Tutorials&amp;rft.pub=Oracle&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://download.oracle.com/javase/7/docs/api/java/io/Serializable.html">"Performance improvement techniques in Serialization"</a>. <a rel="nofollow" class="external free" href="http://www.precisejava.com/">http://www.precisejava.com/</a>: Precise Java<span class="reference-accessdate">. Retrieved 2011-08-04</span>. "We will talk initially about Serializable interface. This is a marker interface and does not have any methods."</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.btitle=Performance+improvement+techniques+in+Serialization&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdownload.oracle.com%2Fjavase%2F7%2Fdocs%2Fapi%2Fjava%2Fio%2FSerializable.html&amp;rft.place=http%3A%2F%2Fwww.precisejava.com%2F&amp;rft.pub=Precise+Java&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation book">Gamma; Helm; Johnson; Vlissides (1995). <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>. Addison Wesley. pp. 17–18.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInterface+%28computing%29&amp;rft.au=Gamma&amp;rft.au=Helm&amp;rft.au=Johnson&amp;rft.aulast=Gamma&amp;rft.au=Vlissides&amp;rft.btitle=Design+Patterns%3A+Elements+of+Reusable+Object-Oriented+Software&amp;rft.date=1995&amp;rft.genre=book&amp;rft.pages=17-18&amp;rft.pub=Addison+Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
