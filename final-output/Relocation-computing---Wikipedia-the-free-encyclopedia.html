<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Relocation-computing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Relocation (computing)</h1>
<p><b>Relocation</b> is the process of assigning load addresses to various parts of a program and adjusting the code and data in the program to reflect the assigned addresses. A linker usually performs relocation in conjunction with <b>symbol resolution</b>, the process of searching files and libraries to replace symbolic references or names of libraries with actual usable addresses in memory before running a program.</p>
<p>Relocation is typically done by the linker at link time, but it can also be done at run time by a relocating loader, or by the running program itself. Some architectures avoid relocation entirely by deferring address assignment to run time; this is known as zero address arithmetic.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Relocation procedure</li>
<li>2 Relocation table
<ul>
<li>2.1 16-bit Windows</li>
<li>2.2 32-bit Windows</li>
<li>2.3 64-bit Windows</li>
<li>2.4 Unix-like systems</li>
</ul>
</li>
<li>3 Example</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<ul>
<li>2.1 16-bit Windows</li>
<li>2.2 32-bit Windows</li>
<li>2.3 64-bit Windows</li>
<li>2.4 Unix-like systems</li>
</ul>
<p></p>
<h2>Relocation procedure</h2>
<p>Relocation is typically done in two steps:</p>
<ol>
<li>Each object file has various sections like code, data, .bss etc. To combine all the objects to a single executable, the linker merges all sections of similar type into a single section of that type. The linker then assigns run time addresses to each section and each symbol. At this point, the code (functions) and data (global variables) will have unique run time addresses.</li>
<li>Each section refers to one or more symbols which should be modified so that they point to the correct run time addresses based on information stored in a <b>relocation table</b> in the object file.</li>
</ol>
<h2>Relocation table</h2>
<p>The relocation table is a list of pointers created by the compiler or assembler and stored in the object or executable file. Each entry in the table, or "fixup", is a pointer to an address in the object code that must be changed when the loader relocates the program. Fixups are designed to support relocation of the program as a complete unit. In some cases, each fixup in the table is itself relative to a base address of zero, so the fixups themselves must be changed as the loader moves through the table.</p>
<p>In some architectures a fixup that crosses certain boundaries (such as a segment boundary) or that is not aligned on a word boundary is illegal and flagged as an error by the linker.</p>
<h3>16-bit Windows</h3>
<p>Far pointers (32-bit pointers with segment:offset, used to address 20-bit 640 KB memory space available to DOS programs), which point to code or data within an DOS executable (EXE) do not have absolute segments, because the actual address of code/data depends on where the program is loaded in memory and this is not known until the program is loaded.</p>
<p>Instead, segments are relative values in the DOS EXE file. These segments need to be corrected, when the executable has been loaded into memory. The EXE loader uses a relocation table to find the segments which need to be adjusted.</p>
<h3>32-bit Windows</h3>
<p>With 32-bit Windows operating systems it is not mandatory to provide relocation tables for EXE files, since they are the first image loaded into the virtual address space and thus will be loaded at their preferred base address.</p>
<p>For both DLLs and for EXEs which opt into Address Space Layout Randomisation - an exploit mitigation technique introduced with Windows Vista, relocation tables once again become mandatory because of the possibility that the binary may be dynamically moved before being executed, even though they are still the first thing loaded in the virtual address space.</p>
<h3>64-bit Windows</h3>
<p>When running native 64-bit binaries on Windows Vista and above, ASLR (Address Space Layout Randomization) is mandatory, and thus relocation sections cannot be omitted by the compiler.</p>
<h3>Unix-like systems</h3>
<p>The ELF executable format and SO shared library format used by most Unix-like systems allows several types of relocation to be defined.</p>
<h2>Example</h2>
<p>The following example uses Donald Knuth's MIX architecture and MIXAL assembly language. The principles are the same for any architecture, though the details will change.</p>
<ul>
<li>(A) Program <i>SUBR</i> is compiled to produce object file(B), shown as both machine code and assembler. The compiler may start the compiled code at an arbitrary location, often location zero as shown. Location 13 contains the machine code for the jump instruction to statement <i>ST</i> in location 5.</li>
<li>(C) If <i>SUBR</i> is later linked with other code it may be stored at a location other than zero. In this example the linker places it at location 120. The address in the jump instruction, which is now at location 133, must be <b>relocated</b> to point to the new location of the code for statement <i>ST</i>, now 125. [1 61 shown in the instruction is the MIX machine code representation of 125].</li>
<li>(D) When the program is loaded into memory to run it may be loaded at some location other than the one assigned by the linker. This example shows <i>SUBR</i> now at location 300. The address in the jump instruction, now at 313, needs to be relocated again so that it points to the updated location of <i>ST</i>, 305. [4 49 is the MIX machine representation of 305].</li>
</ul>
<p><img alt="Relocation example.tif" src="//upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Relocation_example.tif/lossy-page1-334px-Relocation_example.tif.jpg" width="334" height="435" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Relocation_example.tif/lossy-page1-501px-Relocation_example.tif.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Relocation_example.tif/lossy-page1-668px-Relocation_example.tif.jpg 2x" data-file-width="1275" data-file-height="1660"></p>
<h2>See also</h2>
<ul>
<li>Linker (computing)</li>
<li>Library (computing)</li>
<li>Object file</li>
<li>Prebinding</li>
<li>Static library</li>
<li>Self-relocation</li>
<li>Position-independent code</li>
<li>Rebasing</li>
</ul>
</body>
</html>