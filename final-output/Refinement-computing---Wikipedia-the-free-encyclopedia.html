<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Refinement-computing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Refinement (computing)</h1>
<ul>
<li>metadata</li>
<li>data mapping</li>
<li>data transformation</li>
<li>model transformation</li>
</ul>
<ul>
<li>ATL</li>
<li>AWK</li>
<li>MOFM2T</li>
<li>QVT</li>
<li>TXL</li>
<li>XML languages</li>
</ul>
<ul>
<li>identity</li>
<li>synthesis</li>
<li>refinement</li>
</ul>
<ul>
<li>data migration</li>
<li>data conversion</li>
<li>ETL</li>
<li>program transformation</li>
</ul>
<ul>
<li>Data warehouse</li>
<li>Software engineering</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Refinement</b> is a generic term of computer science that encompasses various approaches for producing correct computer programs and simplifying existing programs to enable their formal verification.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Program refinement</li>
<li>2 Data refinement</li>
<li>3 Refinement calculus</li>
<li>4 Refinement types</li>
<li>5 References</li>
</ul>
<p></p>
<h2>Program refinement</h2>
<p>In formal methods, <b>program refinement</b> is the verifiable transformation of an <i>abstract</i> (high-level) formal specification into a <i>concrete</i> (low-level) executable program. <i>Stepwise refinement</i> allows this process to be done in stages. Logically, refinement normally involves implication, but there can be additional complications.</p>
<h2>Data refinement</h2>
<p><b>Data refinement</b> is used to convert an abstract data model (in terms of sets for example) into implementable data structures (such as arrays). <i>Operation refinement</i> converts a specification of an operation on a system into an implementable program (e.g., a procedure). The postcondition can be strengthened and/or the precondition weakened in this process. This reduces any nondeterminism in the specification, typically to a completely deterministic implementation.</p>
<p>For example, <i>x</i> ∈ {1,2,3} (where <i>x</i> is the value of the variable <i>x</i> after an operation) could be refined to <i>x</i> ∈ {1,2}, then <i>x</i> ∈ {1}, and implemented as <i>x</i> := 1. Implementations of <i>x</i> := 2 and <i>x</i> := 3 would be equally acceptable in this case, using a different route for the refinement. However, we must be careful not to refine to <i>x</i> ∈ {} (equivalent to <i>false</i>) since this is unimplementable; it is impossible to select a member from the empty set.</p>
<p>The term reification is also sometimes used (coined by Cliff Jones). Retrenchment is an alternative technique when formal refinement is not possible. The opposite of refinement is abstraction.</p>
<h2>Refinement calculus</h2>
<p>Refinement calculus is a formal system (inspired from Hoare logic) that promotes program refinement. The FermaT Transformation System is an industrial-strength implementation of refinement. The B-Method is also a formal method that extends refinement calculus with a component language: it has been used in industrial developments.</p>
<h2>Refinement types</h2>
<p>In type theory, a <b>refinement type</b> is a type endowed with a predicate which is assumed to hold for any element of the refined type. Refinement types can express preconditions when used as function arguments or postconditions when used as return types: for instance, the type of a function which accepts natural numbers and returns natural numbers greater than 5 may be written as <img class="mwe-math-fallback-image-inline tex" alt="f: \mathbb{N} \rarr \{n: \mathbb{N} | n &gt; 5\}" src="//upload.wikimedia.org/math/7/0/d/70dd0f5bd955752e2a818c7f9df1769c.png">. Refinement types are thus related to behavioral subtyping.</p>
</body>
</html>