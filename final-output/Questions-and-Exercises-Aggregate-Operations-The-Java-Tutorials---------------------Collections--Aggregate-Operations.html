<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Questions-and-Exercises-Aggregate-Operations-The-Java-Tutorials---------------------Collections--Aggregate-Operations.html</title></head>
<body>
<h1>Questions and Exercises: Aggregate Operations</h1>
<h2>Questions</h2>
<ol>
  <li>A sequence of aggregate operations is known as a ___ .</li>
  <li>Each pipeline contains zero or more ___ operations.</li>
  <li>Each pipeline ends with a ___ operation.</li>
  <li>What kind of operation produces another stream as its output?</li>
  <li>Describe one way in which the <code>forEach</code> aggregate operation differs from the enhanced 
<code>for</code> statement
 or iterators.</li>
  <li>True or False: A stream is similar to a collection in that it 
 is a data structure that stores elements.</li>
  <li>Identify the intermediate and terminal operations in this code:
<div class="codeblock"><pre>
double average = roster
    .stream()
    .filter(p -&gt; p.getGender() == Person.Sex.MALE)
    .mapToInt(Person::getAge)
    .average()
    .getAsDouble();
</pre></div>
</li>
<li>The code 
<code>
p -&gt; p.getGender() == Person.Sex.MALE
</code>
 is an example of what?</li>
<li>
The code
<code>
Person::getAge
</code>
is an example of what?
</li>
<li>
Terminal operations that combine the contents of a stream and return one value
are known as what?
</li>

<li>
Name one important difference between the <code>Stream.reduce</code> method 
and the <code>Stream.collect</code> method.
</li>

<li>
If you wanted to process a stream of names, extract the male names, and 
store them in a new <code>List</code>, would <code>Stream.reduce</code> or 
<code>Stream.collect</code> be the 
most appropriate operation to use?
</li>

<li>
True or False: Aggregate operations make it possible to
implement parallelism with non-thread-safe collections.
</li>

<li>
Streams are always serial unless otherwise specified. How 
 do you request that a stream be processed in parallel?
</li>

</ol>
<p>WHATSON? f706b680-236f-48ad-9c35-100c7b2f8142</p>
<pre>
double average = roster
    .stream()
    .filter(p -&gt; p.getGender() == Person.Sex.MALE)
    .mapToInt(Person::getAge)
    .average()
    .getAsDouble();
</pre>
<h2>Exercises</h2>
<ol>
 <li>
Write the following enhanced <code>for</code> statement as a 
pipeline with lambda expressions. Hint: Use the
<code>filter</code> intermediate operation and the <code>forEach</code> terminal 
operation.
<br>
<div class="codeblock"><pre>
for (Person p : roster) {
    if (p.getGender() == Person.Sex.MALE) {
        System.out.println(p.getName());
    }
}
</pre></div>



 </li>

<li>Convert the following code into a new implementation that 
uses lambda expressions and aggregate operations instead of nested
<code>for</code> loops. Hint: Make a pipeline that invokes the <code>filter</code>, <code>sorted</code>, and 
<code>collect</code>
operations, in that order. 

<div class="codeblock"><pre>
List&lt;Album&gt; favs = new ArrayList&lt;&gt;();
for (Album a : albums) {
    boolean hasFavorite = false;
    for (Track t : a.tracks) {
        if (t.rating &gt;= 4) {
            hasFavorite = true;
            break;
        }
    }
    if (hasFavorite)
        favs.add(a);
}
Collections.sort(favs, new Comparator&lt;Album&gt;() {
                           public int compare(Album a1, Album a2) {
                               return a1.name.compareTo(a2.name);
                           }});
</pre></div>
</li>
</ol>
<p>WHATSON? 1fe0d074-a7fe-4a14-a909-c94899753272</p>
<pre>
for (Person p : roster) {
    if (p.getGender() == Person.Sex.MALE) {
        System.out.println(p.getName());
    }
}
</pre>
<p>WHATSON? 781e9edf-bab0-4f27-b6b3-399c27931fa4</p>
<pre>
List&lt;Album&gt; favs = new ArrayList&lt;&gt;();
for (Album a : albums) {
    boolean hasFavorite = false;
    for (Track t : a.tracks) {
        if (t.rating &gt;= 4) {
            hasFavorite = true;
            break;
        }
    }
    if (hasFavorite)
        favs.add(a);
}
Collections.sort(favs, new Comparator&lt;Album&gt;() {
                           public int compare(Album a1, Album a2) {
                               return a1.name.compareTo(a2.name);
                           }});
</pre>
<p>
Check your answers.</p>
</body>
</html>