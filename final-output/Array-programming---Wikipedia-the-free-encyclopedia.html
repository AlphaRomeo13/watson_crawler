<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Array-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Array programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li><strong class="selflink">Array</strong></li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li><strong class="selflink">Array</strong></li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computer science, <b>array programming languages</b> (also known as <b>vector</b> or <b>multidimensional</b> languages) generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays.</p>
<p>Array programming primitives concisely express broad ideas about data manipulation. The level of conciseness can be dramatic in certain cases: it is not uncommon to find array programming language one-liners that require more than a couple of pages of Java code.</p>
<p>Modern programming languages that support array programming are commonly used in scientific and engineering settings; these include MATLAB, TK Solver (as Lists), Octave, R, and the NumPy extension to Python. In these languages, an operation that operates on entire arrays can be called a <b>vectorized</b> operation, regardless of whether it is executed on a vector processor or not.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Concepts</li>
<li>2 Uses</li>
<li>3 Languages
<ul>
<li>3.1 Scalar languages</li>
<li>3.2 Array languages
<ul>
<li>3.2.1 Ada</li>
<li>3.2.2 BASIC</li>
<li>3.2.3 MATLAB</li>
</ul>
</li>
</ul>
</li>
<li>4 Mathematical reasoning and language notation</li>
<li>5 Third party libraries</li>
<li>6 See also</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>3.1 Scalar languages</li>
<li>3.2 Array languages
<ul>
<li>3.2.1 Ada</li>
<li>3.2.2 BASIC</li>
<li>3.2.3 MATLAB</li>
</ul>
</li>
</ul>
<ul>
<li>3.2.1 Ada</li>
<li>3.2.2 BASIC</li>
<li>3.2.3 MATLAB</li>
</ul>
<p></p>
<h2>Concepts</h2>
<p>The fundamental idea behind array programming is that operations apply at once to an entire set of values. This makes it a high-level programming model as it allows the programmer to think and operate on whole aggregates of data, without having to resort to explicit loops of individual scalar operations.</p>
<p>Iverson described the rationale behind array programming (actually referring to APL) as follows:</p>
<p>most programming languages are decidedly inferior to mathematical notation and are little used as tools of thought in ways that would be considered significant by, say, an applied mathematician. [...]</p>
<p>The thesis [...] is that the advantages of executability and universality found in programming languages can be effectively combined, in a single coherent language, with the advantages offered by mathematical notation. [...] it is important to distinguish the difficulty of describing and of learning a piece of notation from the difficulty of mastering its implications. For example, learning the rules for computing a matrix product is easy, but a mastery of its implications (such as its associativity, its distributivity over addition, and its ability to represent linear functions and geometric operations) is a different and much more difficult matter.</p>
<p>Indeed, the very suggestiveness of a notation may make it seem harder to learn because of the many properties it suggests for explorations.</p>
<p>[...] Users of computers and programming languages are often concerned primarily with the efficiency of execution of algorithms, and might, therefore, summarily dismiss many of the algorithms presented here. Such dismissal would be short-sighted, since a clear statement of an algorithm can usually be used as a basis from which one may easily derive more efficient algorithm.</p>
<p>The basis behind array programming and thinking is to find and exploit the properties of data where individual elements are similar and/or adjacent. Unlike object orientation which implicitly breaks down data to its constituent parts (or scalar quantities), array orientation looks to group data and apply a uniform handling.</p>
<p>Function rank is an important concept to array programming languages in general, by analogy to tensor rank in mathematics: functions that operate on data may be classified by the number of dimensions they act on. Ordinary multiplication, for example, is a scalar ranked function because it operates on zero-dimensional data (individual numbers). The cross product operation is an example of a vector rank function because it operates on vectors, not scalars. Matrix multiplication is an example of a 2-rank function, because it operates on 2-dimensional objects (matrices). Collapse operators reduce the dimensionality of an input data array by one or more dimensions. For example, summing over elements collapses the input array by 1 dimension.</p>
<h2>Uses</h2>
<p>Array programming is very well suited to implicit parallelization; a topic of much research nowadays. Further, Intel and compatible CPUs developed and produced after 1997 contained various instruction set extensions, starting from MMX and continuing through SSSE3 and 3DNow!, which include rudimentary SIMD array capabilities. Array processing is distinct from parallel processing in that one physical processor performs operations on a group of items simultaneously while parallel processing aims to split a larger problem into smaller ones (MIMD) to be solved piecemeal by numerous processors. Processors with two or more cores are increasingly common today.</p>
<h2>Languages</h2>
<p>The canonical examples of array programming languages are APL, J, and Fortran. Others include: D, A+, IDL, K, Q, Mathematica, MATLAB, MOLSF, NumPy, GNU Octave, PDL, R, S-Lang, SAC, Nial and ZPL.</p>
<h3>Scalar languages</h3>
<p>In scalar languages like C, and Pascal, etc. operations apply only to single values, so <i>a</i>+<i>b</i> expresses the addition of two numbers. In such languages adding two arrays requires indexing and looping, which is tedious and error prone.</p>
<p>WHATSON? df6d2fa0-bc7d-4518-badc-986e18541cbd</p>
<pre>
for (i = 0; i &lt; n; i++)
    for (j = 0; j &lt; n; j++)
        a[i][j] += b[i][j];
</pre>
<h3>Array languages</h3>
<p>In array languages, operations are generalized to apply to both scalars and arrays. Thus, <i>a</i>+<i>b</i> expresses the sum of two scalars if <i>a</i> and <i>b</i> are scalars, or the sum of two arrays if they are arrays.</p>
<p>An array language simplifies programming but may come at a cost known as the <i>abstraction penalty</i>. Because the additions are performed in isolation to the rest of the coding, it may not produce the optimally most efficient code (for example if additions of other elements of the same array are subsequently encountered during the same execution, causing unnecessary repeated lookups). Even the most sophisticated optimizing compiler would have an extremely hard time amalgamating two or more apparently disparate functions which might appear in different program sections or sub-routines (yet this would be entirely obvious to a programmer who would naturally try to ensure the sums were aggregated on the same 'pass' of the array to minimize overhead).</p>
<h4>Ada</h4>
<p>The previous C code would become the following in the Ada language, which supports array-programming syntax.</p>
<p>WHATSON? 67dabc55-3520-41b4-b513-42117f415366</p>
<pre>
 A := A + B;
</pre>
<h4>BASIC</h4>
<p>The Dartmouth BASIC had MAT statements for matrix and array manipulation already in its third edition (1966).</p>
<p>WHATSON? 2187a507-1f5d-4e8f-bca7-071804c30f05</p>
<pre>
DIM A(4),B(4),C(4)
MAT A = 1
MAT B = 2*A
MAT C = A + B
MAT PRINT A,B,C
</pre>
<h4>MATLAB</h4>
<p>The implementation in MATLAB language allows the same economy allowed by using the Ada language.</p>
<p>WHATSON? 75ea6cb2-bbfb-49c6-9b96-088de2bb13ae</p>
<pre>
A = A + B;
</pre>
<p>A variant of the MATLAB language is the GNU Octave language, which extends the original language also with augmented assignments:</p>
<p>WHATSON? 400e0bc7-660d-4f2b-be6b-9838338ad182</p>
<pre>
A += B;
</pre>
<p>Both MATLAB and GNU Octave natively support linear algebra operations such as matrix multiplication, matrix inversion, the numerical solution of system of linear equations even using the Moore–Penrose pseudoinverse.</p>
<p>The Nial example of the inner product of two arrays can be implemented using the native matrix multiplication operator, If <code>a</code> is a row vector of size [1 n] and <code>b</code> is a corresponding column vector of size [n 1].</p>
<p>WHATSON? ac4dbbdd-09ef-4cf3-ab8b-94ab243d2777</p>
<pre>
a * b;
</pre>
<p>The inner product between two matrices having the same number of elements can be implemented with the auxiliary operator <code>(:)</code> which reshape a given matrix to be a column vector, and the transpose operator <code>'</code>:</p>
<p>WHATSON? 5078343d-5d56-46cd-947b-2391cabe84a6</p>
<pre>
A(:)' * B(:);
</pre>
<h2>Mathematical reasoning and language notation</h2>
<p>The matrix left-division operator concisely expresses some semantic properties of matrices. As in the scalar equivalent, if the (determinant of the) coefficient (matrix) <code>A</code> is not null then it is possible to solve the (vectorial) equation <code>A * x = b</code> by left-multiplying both sides by the inverse of <code>A</code>: <code>A</code> (in both MATLAB and GNU Octave languages: <code>A^-1</code>). The following mathematical statements hold when <code>A</code> is a full rank square matrix:</p>
<p>where <code>==</code> is the equivalence relational operator. The previous statements are also valid MATLAB expressions if the third one is executed before the others (numerical comparisons may be false because of round-off errors).</p>
<p>If the system is overdetermined - so that <code>A</code> has more rows than columns - the pseudoinverse <code>A</code> (in MATLAB and GNU Octave languages: <code>pinv(A)</code>) can replace the inverse <code>A</code>, as follows:</p>
<p>However, these solutions are neither the most concise ones (e.g. still remains the need to notationally differentiate overdetermined systems) nor the most computationally efficient. The latter point is easy to understand when considering again the scalar equivalent <code>a * x = b</code>, for which the solution <code>x = a^-1 * b</code> would require two operations instead of the more efficient <code>x = b / a</code>. The problem is that generally matrix multiplications are not commutative as the extension of the scalar solution to the matrix case would require:</p>
<p>The MATLAB language introduces the left-division operator <code>\</code> to maintain the essential part of the analogy with the scalar case, therefore simplifying the mathematical reasoning and preserving the conciseness:</p>
<p>This is not only an example of terse array programming from the coding point of view but also from the computational efficiency perspective, which in several array programming languages benefits from quite efficient linear algebra libraries such as ATLAS or LAPACK.</p>
<p>Returning to the previous quotation of Iverson, the rationale behind it should now be evident:</p>
<p>it is important to distinguish the difficulty of describing and of learning a piece of notation from the difficulty of mastering its implications. For example, learning the rules for computing a matrix product is easy, but a mastery of its implications (such as its associativity, its distributivity over addition, and its ability to represent linear functions and geometric operations) is a different and much more difficult matter.</p>
<p>Indeed, the very suggestiveness of a notation may make it seem harder to learn because of the many properties it suggests for explorations.</p>
<h2>Third party libraries</h2>
<p>The use of specialized and efficient libraries to provide more terse abstractions is also common in other programming languages. In C++ several linear algebra libraries exploit the language ability to overload operators. It is interesting to notice that in some case a very terse abstraction in those languages is explicitly influenced by the array programming paradigm, as the Armadillo and Blitz++ libraries do.</p>
<h2>See also</h2>
<ul>
<li>Array slicing</li>
</ul>
</body>
</html>