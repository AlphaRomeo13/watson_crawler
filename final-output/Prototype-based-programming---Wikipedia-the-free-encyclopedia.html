<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Prototype-based-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Prototype-based programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li><strong class="selflink">Prototype-based</strong></li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li><strong class="selflink">Prototype-based</strong></li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li><strong class="selflink">Prototype-based</strong></li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Prototype-based programming</b> is a style of object-oriented programming in which behaviour reuse (known as inheritance) is performed via a process of cloning existing objects that serve as prototypes. This model can also be known as <i>prototypal</i>, <i>prototype-oriented,</i> <i>classless</i>, or <i>instance-based</i> programming. Delegation is the language feature that supports prototype-based programming.</p>
<p>A fruit bowl serves as one example. A "fruit" object would represent the properties and functionality of fruit in general. A "banana" object would be cloned from the "fruit" object, and would also be extended to include general properties specific to bananas. Each individual "banana" object would be cloned from the generic "banana" object.</p>
<p>The first prototype-oriented programming language was Self, developed by David Ungar and Randall Smith in the mid-1980s to research topics in object-oriented language design. Since the late 1990s, the classless paradigm has grown increasingly popular. Some current prototype-oriented languages are JavaScript (and other ECMAScript implementations, JScript and Flash's ActionScript 1.0), Lua, Cecil, NewtonScript, Io, MOO, REBOL, and Lisaac.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Design and implementation</li>
<li>2 Object construction</li>
<li>3 Delegation</li>
<li>4 Concatenation</li>
<li>5 Criticism</li>
<li>6 Languages supporting prototype-based programming</li>
<li>7 References</li>
<li>8 Further reading</li>
<li>9 See also</li>
</ul>
<p></p>
<h2>Design and implementation</h2>
<p>Prototypal inheritance in JavaScript is described by Douglas Crockford as: <i>you make prototype objects, and then ... make new instances. Objects are mutable in JavaScript, so we can augment the new instances, giving them new fields and methods. These can then act as prototypes for even newer objects. We don't need classes to make lots of similar objects....Objects inherit from objects. What could be more object oriented than that?</i>.</p>
<p>Advocates of prototype-based programming argue that it encourages the programmer to focus on the behavior of some set of examples and only later worry about classifying these objects into archetypal objects that are later used in a fashion similar to classes. Many prototype-based systems encourage the alteration of prototypes during run-time, whereas only very few class-based object-oriented systems (such as the dynamic object-oriented system, Common Lisp, Dylan, Smalltalk, Objective-C, Python, Perl, or Ruby) allow classes to be altered during the execution of a program.</p>
<p>Almost all prototype-based systems are based on interpreted and dynamically typed languages. Systems based on statically typed languages are technically feasible, however. The Omega language discussed in <i>Prototype-Based Programming</i> is an example of such a system, though according to Omega's website even Omega is not exclusively static, but rather its "compiler may choose to use static binding where this is possible and may improve the efficiency of a program."</p>
<h2>Object construction</h2>
<p>In prototype-based languages there are no explicit classes and objects inherit directly from other objects with which they are linked through a property, often called <code>prototype</code> as in the case of JavaScript. There are two methods of constructing new objects: <i>ex nihilo</i> ("from nothing") object creation or through <i>cloning</i> an existing object. The former is supported through some form of object literal, declarations where objects can be defined at runtime through special syntax such as <code>{...}</code> and passed directly to a variable. While most systems support a variety of cloning, <i>ex nihilo</i> object creation is not as prominent.</p>
<p>In class-based languages, a new instance is constructed through a class's constructor function, a special function that reserves a block of memory for the object's members (properties and methods) and returns a reference to that block. An optional set of constructor arguments can be passed to the function and are usually held in properties. The resulting instance will inherit all the methods and properties that were defined in the class, which acts as a kind of template from which similar typed objects can be constructed.</p>
<p>Systems that support <i>ex nihilo</i> object creation allow new objects to be created from scratch without cloning from an existing prototype. Such systems provide a special syntax for specifying the properties and behaviors of new objects without referencing existing objects. In many prototype languages there exists a root object, often called <i>Object</i>, which is set as the default prototype for all other objects created in run-time and which carries commonly needed methods such as a <code>toString()</code> function to return a description of the object as a string. One useful aspect of <i>ex nihilo</i> object creation is to ensure that a new object's slot (properties and methods) names do not have namespace conflicts with the top-level <i>Object</i> object. (In the Mozilla JavaScript implementation, one can do this by setting a newly constructed object's <i>__proto__</i> property to null.)</p>
<p><i>Cloning</i> refers to a process whereby a new object is constructed by copying the behavior of an existing object (its prototype). The new object then carries all the qualities of the original. From this point on, the new object can be modified. In some systems the resulting child object maintains an explicit link (via <i>delegation</i> or <i>resemblance</i>) to its prototype, and changes in the prototype cause corresponding changes to be apparent in its clone. Other systems, such as the Forth-like programming language Kevo, do not propagate change from the prototype in this fashion, and instead follow a more <i>concatenative</i> model where changes in cloned objects do not automatically propagate across descendants.</p>
<p>WHATSON? 06cd7d37-8d99-4d81-bdd3-c99b3565382d</p>
<pre>
// Example of true prototypical inheritance style 
// in JavaScript.
 
// "ex nihilo" object creation using the literal 
// object notation {}.
var foo = {name: "foo", one: 1, two: 2};
 
// Another "ex nihilo" object.
var bar = {two: "two", three: 3};
 
// Gecko and Webkit JavaScript engines can directly 
// manipulate the internal prototype link.
// For the sake of simplicity, let us pretend 
// that the following line works regardless of the 
// engine used:
bar.__proto__ = foo; // foo is now the prototype of bar.
 
// If we try to access foo's properties from bar 
// from now on, we'll succeed. 
bar.one // Resolves to 1.
 
// The child object's properties are also accessible.
bar.three // Resolves to 3.
 
// Own properties shadow prototype properties
bar.two; // Resolves to "two"
foo.name; // unaffected, resolves to "foo"
bar.name; // Resolves to "foo"
</pre>
<p>This example in JS 1.8.5 + ( see http://kangax.github.com/es5-compat-table/ )</p>
<p>WHATSON? d76aad3b-c3b1-4e38-a12d-d3fe397296ee</p>
<pre>
var foo = {one: 1, two: 2};
 
// bar.[[prototype]] = foo
var bar = Object.create( foo );
 
bar.three = 3;
 
bar.one; // 1
bar.two; // 2
bar.three; // 3
</pre>
<h2>Delegation</h2>
<p>In prototype-based languages that use <i>delegation</i>, the language runtime is capable of dispatching the correct method or finding the right piece of data simply by following a series of delegation pointers (from object to its prototype) until a match is found. All that is required to establish this behavior-sharing between objects is the delegation pointer. Unlike the relationship between class and instance in class-based object-oriented languages, the relationship between the prototype and its offshoots does not require that the child object have a memory or structural similarity to the prototype beyond this link. As such, the child object can continue to be modified and amended over time without rearranging the structure of its associated prototype as in class-based systems. It is also important to note that not only data but also methods can be added or changed. For this reason, some prototype-based languages refer to both data and methods as "slots" or "members".</p>
<h2>Concatenation</h2>
<p>Under pure prototyping, which is also referred to as <i>concatenative</i> prototyping, and is exemplified in the Kevo language, there are no visible pointers or links to the original prototype from which an object is cloned. The prototype (parent) object is copied rather than linked to. As a result, changes to the prototype will not be reflected in cloned objects.</p>
<p>The main conceptual difference under this arrangement is that changes made to a prototype object are not automatically propagated to clones. This may be seen as an advantage or disadvantage. (However, Kevo does provide additional primitives for publishing changes across sets of objects based on their similarity — so-called <i>family resemblances</i> — rather than through taxonomic origin, as is typical in the delegation model.) It is also sometimes claimed that delegation-based prototyping has an additional disadvantage in that changes to a child object may affect the later operation of the parent. However, this problem is not inherent to the delegation-based model and does not exist in delegation-based languages such as JavaScript, which ensure that changes to a child object are always recorded in the child object itself and never in parents (i.e. the child's value shadows the parent's value rather than changing the parent's value).</p>
<p>In simplistic implementations, concatenative prototyping will have faster member lookup than delegation-based prototyping (because there is no need to follow the chain of parent objects), but will conversely use more memory (because all slots are copied, rather than there being a single slot pointing to the parent object). More sophisticated implementations can avoid these problems, however, although trade-offs between speed and memory are required. For example, systems with concatenative prototyping can use a copy-on-write implementation to allow for behind-the-scenes data sharing — and such an approach is indeed followed by Kevo. Conversely, systems with delegation-based prototyping can use caching to speed up data lookup.</p>
<h2>Criticism</h2>
<p>Advocates of class-based object models who criticize prototype-based systems often have concerns similar to the concerns that proponents of static type systems for programming languages have of dynamic type systems (see datatype). Usually, such concerns involve: correctness, safety, predictability, efficiency and programmer unfamiliarity.</p>
<p>On the first three points, classes are often seen as analogous to types (in most statically typed object-oriented languages they serve that role) and are proposed to provide contractual guarantees to their instances, and to users of their instances, that they will behave in some given fashion.</p>
<p>Regarding efficiency, declaring classes simplifies many compiler optimizations that allow developing efficient method and instance-variable lookup. For the Self language, much development time was spent on developing, compiling, and interpreting techniques to improve the performance of prototype-based systems versus class-based systems.</p>
<p>A common criticism made against prototype-based languages is that the community of software developers is unfamiliar with them, despite the popularity and market permeation of JavaScript. This knowledge level of prototype-based systems seems to be increasing with the proliferation of JavaScript frameworks and the complex use of JavaScript as the Web matures.</p>
<h2>Languages supporting prototype-based programming</h2>
<ul>
<li>Actor-Based Concurrent Language (ABCL): ABCL/1, ABCL/R, ABCL/R2, ABCL/c+</li>
<li>Agora</li>
<li>Cecil</li>
<li>Cel</li>
<li>ColdC</li>
<li>ECMAScript
<ul>
<li>ActionScript 1.0, used by Adobe Flash and Adobe Flex</li>
<li>E4X</li>
<li>JavaScript</li>
<li>JScript</li>
</ul>
</li>
<li>Falcon</li>
<li>Io</li>
<li>Ioke</li>
<li>Lisaac</li>
<li>Logtalk</li>
<li>LPC</li>
<li>Lua</li>
<li>MOO</li>
<li>Neko</li>
<li>NewtonScript</li>
<li>Obliq</li>
<li>Object Lisp</li>
<li>Omega</li>
<li>OpenLaszlo</li>
<li>Pauscal</li>
<li>Perl, with the Class::Prototyped module</li>
<li>Python with prototype.py.</li>
<li>R, with the proto package</li>
<li>REBOL</li>
<li>Ruby</li>
<li>Self</li>
<li>Seph</li>
<li>SmartFrog</li>
<li>TADS</li>
<li>Tcl with snit extension</li>
</ul>
<ul>
<li>ActionScript 1.0, used by Adobe Flash and Adobe Flex</li>
<li>E4X</li>
<li>JavaScript</li>
<li>JScript</li>
</ul>
</body>
</html>