<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Anti-unification-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Anti-unification (computer science)</h1>
<p><b>Anti-unification</b> is the process of constructing a generalization common to two given symbolic expressions. As in unification, several <b>frameworks</b> are distinguished depending on which expressions (also called terms) are allowed, and which expressions are considered equal. If variables representing functions are allowed in an expression, the process is called <b>higher-order anti-unification</b>, otherwise <b>first-order anti-unification</b>. If the generalization is required to have an instance literally equal to each input expression, the process is called <b>syntactical anti-unification</b>, otherwise <b>E-anti-unification</b>, or <b>anti-unification modulo theory</b>.</p>
<p>An anti-unification algorithm should compute for given expressions a <b>complete</b>, and <b>minimal</b> generalization set, that is, a set covering all generalizations, and containing no redundant members, respectively. Depending on the framework, a complete and minimal generalization set may have one, finitely many, or possibly infinitely many members, or may not exist at all; it cannot be empty, since a trivial generalization exists in any case. For first-order syntactical anti-unification, Plotkin gave an algorithm that computes a complete and minimal singleton generalization set containing the so-called <b>least general generalization (lgg)</b>.</p>
<p>Anti-unification should not be confused with <i>dis-unification</i>. The latter means the process of solving systems of inequations, that is of finding values for the variables such that all given inequations are satisfied. This task is quite different from finding generalizations.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Prerequisites
<ul>
<li>1.1 First-order term</li>
<li>1.2 Higher-order term</li>
<li>1.3 Substitution</li>
<li>1.4 Generalization, specialization</li>
<li>1.5 Anti-unification problem, generalization set</li>
</ul>
</li>
<li>2 First-order syntactical anti-unification</li>
<li>3 First-order anti-unification modulo theory
<ul>
<li>3.1 Equational theories</li>
<li>3.2 First-order sorted anti-unification</li>
<li>3.3 Applications</li>
<li>3.4 Anti-unification of trees and linguistic applications</li>
</ul>
</li>
<li>4 Higher-order anti-unification</li>
<li>5 Notes</li>
<li>6 References</li>
</ul>
<ul>
<li>1.1 First-order term</li>
<li>1.2 Higher-order term</li>
<li>1.3 Substitution</li>
<li>1.4 Generalization, specialization</li>
<li>1.5 Anti-unification problem, generalization set</li>
</ul>
<ul>
<li>3.1 Equational theories</li>
<li>3.2 First-order sorted anti-unification</li>
<li>3.3 Applications</li>
<li>3.4 Anti-unification of trees and linguistic applications</li>
</ul>
<p></p>
<h2>Prerequisites</h2>
<p>Formally, an anti-unification approach presupposes</p>
<ul>
<li>An infinite set <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> of <b>variables</b>. For higher-order anti-unification, it is convenient to choose <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> disjoint from the set of lambda-term bound variables.</li>
<li>A set <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> of <b>terms</b> such that <img class="mwe-math-fallback-image-inline tex" alt="V \subseteq T" src="//upload.wikimedia.org/math/e/8/4/e8433fe6280a3b452dc07fe0dc6868cc.png">. For first-order and higher-order anti-unification, <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> is usually the set of first-order terms (terms built from variable and function symbols) and lambda terms (terms containing some higher-order variables), respectively.</li>
<li>An <b>equivalence relation</b> <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> on <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png">, indicating which terms are considered equal. For higher-order anti-unification, usually <img class="mwe-math-fallback-image-inline tex" alt="t \equiv u" src="//upload.wikimedia.org/math/d/a/6/da6b2240463cc4373f8463812e95722c.png"> if <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> and <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> are alpha equivalent. For first-order E-anti-unification, <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> reflects the background knowledge about certain function symbols; for example, if <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> is considered commutative, <img class="mwe-math-fallback-image-inline tex" alt="t \equiv u" src="//upload.wikimedia.org/math/d/a/6/da6b2240463cc4373f8463812e95722c.png"> if <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> results from <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> by swapping the arguments of <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> at some (possibly all) occurrences. If there is no background knowledge at all, then only literally, or syntactically, identical terms are considered equal.</li>
</ul>
<h3>First-order term</h3>
<p>Given a set <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> of variable symbols, a set <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> of constant symbols and sets <img class="mwe-math-fallback-image-inline tex" alt="F_n" src="//upload.wikimedia.org/math/3/c/5/3c55419967d78bff97d6a021132c947d.png"> of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-ary function symbols, also called operator symbols, for each natural number <img class="mwe-math-fallback-image-inline tex" alt="n \geq 1" src="//upload.wikimedia.org/math/f/e/3/fe37f48a6bb040c06c5e7ccaac63bc66.png">, the set of (unsorted first-order) terms <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> is recursively defined to be the smallest set with the following properties:</p>
<ul>
<li>every variable symbol is a term: <img class="mwe-math-fallback-image-inline tex" alt="V \subseteq T" src="//upload.wikimedia.org/math/e/8/4/e8433fe6280a3b452dc07fe0dc6868cc.png">,</li>
<li>every constant symbol is a term: <img class="mwe-math-fallback-image-inline tex" alt="C \subseteq T" src="//upload.wikimedia.org/math/c/d/e/cde56411715abd0105223384e50de7c7.png">,</li>
<li>from every <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> terms <img class="mwe-math-fallback-image-inline tex" alt="t_1,\ldots,t_n" src="//upload.wikimedia.org/math/9/9/8/998c7812117644c3d8f9e87da532300d.png">, and every <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-ary function symbol <img class="mwe-math-fallback-image-inline tex" alt="f \in F_n" src="//upload.wikimedia.org/math/2/e/6/2e6e8a954ca1de44559a6f813fd13ccb.png">, a larger term <img class="mwe-math-fallback-image-inline tex" alt="f(t_1,\ldots,t_n)" src="//upload.wikimedia.org/math/e/0/2/e0206846dd6f69f84a6f52dd0f0544b2.png"> can be built.</li>
</ul>
<p>For example, if <img class="mwe-math-fallback-image-inline tex" alt="x \in V" src="//upload.wikimedia.org/math/7/3/1/7311eadac874d3eb683dd147ce424084.png"> is a variable symbol, <img class="mwe-math-fallback-image-inline tex" alt="1 \in C" src="//upload.wikimedia.org/math/b/7/a/b7aad2384200fe272c634ff58688cf01.png"> is a constant symbol, and <img class="mwe-math-fallback-image-inline tex" alt="\textit{add} \in F_2" src="//upload.wikimedia.org/math/7/1/4/71456f843864f3a1a831e0ec7aebde4d.png"> is a binary function symbol, then <img class="mwe-math-fallback-image-inline tex" alt="x \in T" src="//upload.wikimedia.org/math/b/a/5/ba502c7721edfbe0fa14168da84b4f95.png">, <img class="mwe-math-fallback-image-inline tex" alt="1 \in T" src="//upload.wikimedia.org/math/3/5/3/353f48c338d1f96af2b05f044a95f14f.png">, and (hence) <img class="mwe-math-fallback-image-inline tex" alt="add(x,1) \in T" src="//upload.wikimedia.org/math/1/5/e/15e841f5ac6c07d88cbc558df3e308d2.png"> by the first, second, and third term building rule, respectively. The latter term is usually written as <img class="mwe-math-fallback-image-inline tex" alt="x+1" src="//upload.wikimedia.org/math/c/f/2/cf267a0bc414e4ea2681d6bd522a8992.png">, using Infix notation and the more common operator symbol <img class="mwe-math-fallback-image-inline tex" alt="+" src="//upload.wikimedia.org/math/2/6/b/26b17225b626fb9238849fd60eabdf60.png"> for convenience.</p>
<h3>Higher-order term</h3>
<h3>Substitution</h3>
<p>A <b>substitution</b> is a mapping <img class="mwe-math-fallback-image-inline tex" alt="\sigma: V \longrightarrow T" src="//upload.wikimedia.org/math/5/7/d/57d1f0704273c8a61ab942ea4e37a47d.png"> from variables to terms; the notation <img class="mwe-math-fallback-image-inline tex" alt="\{x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \}" src="//upload.wikimedia.org/math/0/b/0/0b028006fb797692255f3923a8d6cdb2.png"> refers to a substitution mapping each variable <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> to the term <img class="mwe-math-fallback-image-inline tex" alt="t_i" src="//upload.wikimedia.org/math/a/5/7/a578f93d86a9111f5900e4681f14ce16.png">, for <img class="mwe-math-fallback-image-inline tex" alt="i=1,\ldots,k" src="//upload.wikimedia.org/math/5/7/4/57419b7c2597864a08a6bb014d96f34e.png">, and every other variable to itself. <b>Applying</b> that substitution to a term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is written in postfix notation as <img class="mwe-math-fallback-image-inline tex" alt="t \{x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \}" src="//upload.wikimedia.org/math/e/f/f/eff0b6db0294cee1b73f7a5765e1afc7.png">; it means to (simultaneously) replace every occurrence of each variable <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> in the term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> by <img class="mwe-math-fallback-image-inline tex" alt="t_i" src="//upload.wikimedia.org/math/a/5/7/a578f93d86a9111f5900e4681f14ce16.png">. The result <img class="mwe-math-fallback-image-inline tex" alt="t \sigma" src="//upload.wikimedia.org/math/a/c/4/ac47b6b7b9231b57db987c4864aac0ba.png"> of applying a substitution <img class="mwe-math-fallback-image-inline tex" alt="\sigma" src="//upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png"> to a term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is called an <b>instance</b> of that term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">. As a first-order example, applying the substitution <img class="mwe-math-fallback-image-inline tex" alt="\{x \mapsto h(a,y), z \mapsto b\}" src="//upload.wikimedia.org/math/8/8/6/886c35117f6ba2cda6537803434348bb.png"> to the term</p>
<h3>Generalization, specialization</h3>
<p>If a term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> has an instance equivalent to a term <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png">, that is, if <img class="mwe-math-fallback-image-inline tex" alt="t \sigma \equiv u" src="//upload.wikimedia.org/math/3/7/c/37cdd6fdf283db60e78bff7fd80b783c.png"> for some substitution <img class="mwe-math-fallback-image-inline tex" alt="\sigma" src="//upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png">, then <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is called <b>more general</b> than <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png">, and <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> is called <b>more special</b> than, or <b>subsumed</b> by, <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">. For example, <img class="mwe-math-fallback-image-inline tex" alt="x \oplus a" src="//upload.wikimedia.org/math/1/b/0/1b0fad102859ccccd829cce737e7d04e.png"> is more general than <img class="mwe-math-fallback-image-inline tex" alt="a \oplus b" src="//upload.wikimedia.org/math/c/5/3/c53e6aad986d493168c51853f8c5a0cf.png"> if <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> is commutative, since then <img class="mwe-math-fallback-image-inline tex" alt="(x \oplus a)\{x \mapsto b\} = b \oplus a \equiv a \oplus b" src="//upload.wikimedia.org/math/c/a/d/cad33a5fd4db345d936bd337e4687d65.png">.</p>
<p>If <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> is literal (syntactic) identity of terms, a term may be both more general and more special than another one only if both terms differ just in their variable names, not in their syntactic structure; such terms are called <b>variants</b>, or <b>renamings</b> of each other. For example, <img class="mwe-math-fallback-image-inline tex" alt="f(x_1,a,g(z_1),y_1)" src="//upload.wikimedia.org/math/6/d/9/6d9c6b5135b370893e3bd1623cd13593.png"> is a variant of <img class="mwe-math-fallback-image-inline tex" alt="f(x_2,a,g(z_2),y_2)" src="//upload.wikimedia.org/math/f/0/2/f023ff11390b5b9b626792465740d8d0.png">, since <img class="mwe-math-fallback-image-inline tex" alt="f(x_1,a,g(z_1),y_1) \{ x_1 \mapsto x_2, y_2 \mapsto y_2, z_1 \mapsto z_2\} = f(x_2,a,g(z_2),y_2)" src="//upload.wikimedia.org/math/f/e/c/feca855b3011424b56defea31bad3d65.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(x_2,a,g(z_2),y_2) \{x_1 \mapsto x_1, y_2 \mapsto y_1, z_2 \mapsto z_1\} = f(x_1,a,g(z_1),y_1)" src="//upload.wikimedia.org/math/f/1/2/f126065786ae534a3b5370ac531a4208.png">. However, <img class="mwe-math-fallback-image-inline tex" alt="f(x_1,a,g(z_1),y_1)" src="//upload.wikimedia.org/math/6/d/9/6d9c6b5135b370893e3bd1623cd13593.png"> is <i>not</i> a variant of <img class="mwe-math-fallback-image-inline tex" alt="f(x_2,a,g(x_2),x_2)" src="//upload.wikimedia.org/math/8/2/f/82f544077b272980e2763171ac188821.png">, since no substitution can transform the latter term into the former one. The latter term is therefor properly more special than the former one.</p>
<p>A substitution <img class="mwe-math-fallback-image-inline tex" alt="\sigma" src="//upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png"> is <b>more special</b> than, or <b>subsumed</b> by, a substitution <img class="mwe-math-fallback-image-inline tex" alt="\tau" src="//upload.wikimedia.org/math/8/1/a/81a69207104f00baaabd6f84cafd15a0.png"> if <img class="mwe-math-fallback-image-inline tex" alt="x \sigma" src="//upload.wikimedia.org/math/5/5/2/5520cb31db22446da765eed2126329ac.png"> is more special than <img class="mwe-math-fallback-image-inline tex" alt="x \tau" src="//upload.wikimedia.org/math/2/1/9/2192ee74eb9c04cecbb49e805ffaa809.png"> for each variable <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png">. For example, <img class="mwe-math-fallback-image-inline tex" alt="\{ x \mapsto f(u), y \mapsto f(f(u)) \}" src="//upload.wikimedia.org/math/e/4/5/e4581fd8ebed374000ce723d3cd04875.png"> is more special than <img class="mwe-math-fallback-image-inline tex" alt="\{ x \mapsto z, y \mapsto f(z) \}" src="//upload.wikimedia.org/math/9/1/c/91ce7e1f93870e1439e6ac0ed74e76b1.png">, since <img class="mwe-math-fallback-image-inline tex" alt="f(u)" src="//upload.wikimedia.org/math/f/2/c/f2c157202779c9a3de64999d015a2095.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(f(u)) " src="//upload.wikimedia.org/math/4/4/d/44d22bb02ba9debf29b8ca8791238d7e.png"> is more special than <img class="mwe-math-fallback-image-inline tex" alt="z" src="//upload.wikimedia.org/math/f/b/a/fbade9e36a3f36d3d676c1b808451dd7.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(z)" src="//upload.wikimedia.org/math/b/2/3/b23d8bcdb490736c53d5b677455a8cd2.png">, respectively.</p>
<h3>Anti-unification problem, generalization set</h3>
<p>An <b>anti-unification problem</b> is a pair <img class="mwe-math-fallback-image-inline tex" alt="\langle t_1, t_2 \rangle" src="//upload.wikimedia.org/math/2/5/4/2549edeccbed7fb1be308fbfcab9245b.png"> of terms. A term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is a common <b>generalization</b>, or <b>anti-unifier</b>, of <img class="mwe-math-fallback-image-inline tex" alt="t_1" src="//upload.wikimedia.org/math/7/3/6/7363212f8e5a9d7ace25c6991a33c6fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_2" src="//upload.wikimedia.org/math/9/7/4/974cb705b0c744f1855953c1086337df.png"> if <img class="mwe-math-fallback-image-inline tex" alt="t \sigma_1 \equiv t_1" src="//upload.wikimedia.org/math/4/a/6/4a684dfcc6d3957a6020801b202d3ad1.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t \sigma_2 \equiv t_2" src="//upload.wikimedia.org/math/5/4/0/540bc9e376a12a49b241d90fb11dc6fb.png"> for some substitutions <img class="mwe-math-fallback-image-inline tex" alt="\sigma_1, \sigma_2" src="//upload.wikimedia.org/math/c/3/d/c3d32e1872fcf054c549010f1a258f69.png">. For a given anti-unification problem, a set <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> of anti-unifiers is called <b>complete</b> if each generalization subsumes some term <img class="mwe-math-fallback-image-inline tex" alt="t \in S" src="//upload.wikimedia.org/math/5/9/1/5918191b19cc9305f145c76355763a8e.png">; the set <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> is called <b>minimal</b> if none of its members subsumes another one.</p>
<h2>First-order syntactical anti-unification</h2>
<p>The framework of first-order syntactical anti-unification is based on <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> being the set of <i>first-order terms</i> (over some given set <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> of variables, <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> of constants and <img class="mwe-math-fallback-image-inline tex" alt="F_n" src="//upload.wikimedia.org/math/3/c/5/3c55419967d78bff97d6a021132c947d.png"> of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-ary function symbols) and on <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> being <i>syntactic equality</i>. In this framework, each anti-unification problem <img class="mwe-math-fallback-image-inline tex" alt="\langle t_1, t_2 \rangle" src="//upload.wikimedia.org/math/2/5/4/2549edeccbed7fb1be308fbfcab9245b.png"> has a complete, and obviously minimal, singleton solution set <img class="mwe-math-fallback-image-inline tex" alt="\{t\}" src="//upload.wikimedia.org/math/6/c/d/6cdef036f26cfd308612361942a3a770.png">. Its member <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is called the <b>least general generalization (lgg)</b> of the problem, it has an instance syntactically equal to <img class="mwe-math-fallback-image-inline tex" alt="t_1" src="//upload.wikimedia.org/math/7/3/6/7363212f8e5a9d7ace25c6991a33c6fe.png"> and another one syntactically equal to <img class="mwe-math-fallback-image-inline tex" alt="t_2" src="//upload.wikimedia.org/math/9/7/4/974cb705b0c744f1855953c1086337df.png">. Any common generalization of <img class="mwe-math-fallback-image-inline tex" alt="t_1" src="//upload.wikimedia.org/math/7/3/6/7363212f8e5a9d7ace25c6991a33c6fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_2" src="//upload.wikimedia.org/math/9/7/4/974cb705b0c744f1855953c1086337df.png"> subsumes <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">. The lgg is unique up to variants: if <img class="mwe-math-fallback-image-inline tex" alt="S_1" src="//upload.wikimedia.org/math/8/d/c/8dc4eef060814e559aff4c5fac3f51fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="S_2" src="//upload.wikimedia.org/math/9/7/a/97a6ae0695c4b2723ff5c8bccdb1e735.png"> are both complete and minimal solution sets of the same syntactical anti-unification problem, then <img class="mwe-math-fallback-image-inline tex" alt="S_1 = \{ s_1\}" src="//upload.wikimedia.org/math/2/7/2/2728067055d55145adbffbcb5bf5b038.png"> and <img class="mwe-math-fallback-image-inline tex" alt="S_2 = \{ s_2 \}" src="//upload.wikimedia.org/math/a/9/3/a939be32be1e88c6af09f7432a76e878.png"> for some terms <img class="mwe-math-fallback-image-inline tex" alt="s_1" src="//upload.wikimedia.org/math/0/3/2/032e388e2ab0ba83dd40c91e1f8d9c2f.png"> and <img class="mwe-math-fallback-image-inline tex" alt="s_2" src="//upload.wikimedia.org/math/3/3/6/336ac411515fbb2b61ec71e6bf2fba27.png">, that are renamings of each other.</p>
<p>Plotkin has given an algorithm to compute the lgg of two given terms. It presupposes an injective mapping <img class="mwe-math-fallback-image-inline tex" alt="\phi: T \times T \longrightarrow V" src="//upload.wikimedia.org/math/d/6/9/d69dd6a42db672c4f510675326bb34fe.png">, that is, a mapping assigning each pair <img class="mwe-math-fallback-image-inline tex" alt="s,t" src="//upload.wikimedia.org/math/c/f/a/cfa32cfac3b0f2875f94c90cee520677.png"> of terms an own variable <img class="mwe-math-fallback-image-inline tex" alt="\phi(s,t)" src="//upload.wikimedia.org/math/0/a/0/0a0127324d053ee5b20f18e21046450d.png">, such that no two pairs share the same variable.  The algorithm consists of two rules:</p>
<p>For example, <img class="mwe-math-fallback-image-inline tex" alt="(0*0) \sqcup (4*4) \rightsquigarrow (0 \sqcup 4)*(0 \sqcup 4) \rightsquigarrow \phi(0,4) * \phi(0,4) \rightsquigarrow x*x" src="//upload.wikimedia.org/math/d/5/6/d56473955dca97b327e5027ef68f00f9.png">; this least general generalization reflects the common property of both inputs of being square numbers.</p>
<p>Plotkin used his algorithm to compute the "relative least general generalization (rlgg)" of two clause sets in first-order logic, which was the basis of the Golem approach to inductive logic programming.</p>
<h2>First-order anti-unification modulo theory</h2>
<ul>
<li>Jacobson, Erik (Jun 1991), <i>Unification and Anti-Unification</i>, Technical Report </li>
<li>Østvold, Bjarte M. (Apr 2004), <i>A Functional Reconstruction of Anti-Unification</i>, NR Note, DART/04/04, Norwegian Computing Center </li>
<li>Boytcheva, Svetla; Markov, Zdravko (2002). "An Algorithm for Inducing Least Generalization Under Relative Implication". </li>
<li>Kutsia, Temur; Levy, Jordi; Villaret, Mateu (2014). "Anti-Unification for Unranked Terms and Hedges". <i>Journal of Automated Reasoning</i> (Springer) <b>52</b> (2): 155–190. doi:10.1007/s10817-013-9285-6.  Software.</li>
</ul>
<h3>Equational theories</h3>
<ul>
<li>One associative and commutative operation: Pottier, Loic (Feb 1989), <i>Algorithms des completion et generalisation en logic du premier ordre</i> ; Pottier, Loic (1989), <i>Generalisation de termes en theorie equationelle – Cas associatif-commutatif</i>, INRIA Report <b>1056</b>, INRIA </li>
<li>Commutative theories: Baader, Franz (1991). "Unification, Weak Unification, Upper Bound, Lower Bound, and Generalization Problems". "Proc. 4th Conf. on Rewriting Techniques and Applications (RTA)". LNCS <b>488</b>. Springer. pp. 86–91. </li>
<li>Free monoids: Biere, A. (1993), <i>Normalisierung, Unifikation und Antiunifikation in Freien Monoiden</i>, Univ. Karlsruhe, Germany </li>
<li>Regular congruence classes: Heinz, Birgit (Dec 1995), <i>Anti-Unifikation modulo Gleichungstheorie und deren Anwendung zur Lemmagenerierung</i>, GMD Berichte <b>261</b>, TU Berlin, ISBN 3-486-23873-6 ; Burghardt, Jochen (2005). "E-Generalization Using Grammars". <i>Artificial Intelligence Journal</i> (Elsevier) <b>165</b> (1): 1–35. doi:10.1016/j.artint.2005.01.008. </li>
<li>A-, C-, AC-, ACU-theories with ordered sorts: Alpuente, Maria; Escobar, Santiago; Espert, Javier; Meseguer, Jose (2014). "A modular order-sorted equational generalization algorithm". <i>Information and Computation</i> (Elsevier). </li>
</ul>
<h3>First-order sorted anti-unification</h3>
<ul>
<li>Taxonomic sorts: Frisch, Alan M.; Page, David (1990). "Generalisation with Taxonomic Information". <i>AAAI</i>: 755–761. ; Frisch, Alan M.; Page Jr., C. David (1991). "Generalizing Atoms in Constraint Logic". "Proc. Conf. on Knowledge Representation". ; Frisch, A.M.; Page, C.D. (1995). "Building Theories into Instantiation". In Mellish, C.S. "Proc. 14th IJCAI". Morgan Kaufmann. pp. 1210–1216. </li>
<li>Feature terms: Plaza, E. (1995). "Cases as Terms: A Feature Term Approach to the Structured Representation of Cases". "Proc. 1st International Conference on Case-Based Reasoning (ICCBR)". LNCS <b>1010</b>. Springer. pp. 265–276. ISSN 0302-9743. </li>
<li>Idestam-Almquist, Peter (Jun 1993). "Generalization under Implication by Recursive Anti-Unification". "Proc. 10th Conf. on Machine Learning". Morgan Kaufmann. pp. 151–158. </li>
<li>Fischer, Cornelia (May 1994), <i>PAntUDE – An Anti-Unification Algorithm for Expressing Refined Generalizations</i>, Research Report, TM-94-04, DFKI </li>
<li>A-, C-, AC-, ACU-theories with ordered sorts: see above</li>
</ul>
<h3>Applications</h3>
<ul>
<li>Program analysis: Bulychev, Peter; Minea, Marius (2008). "Duplicate Code Detection Using Anti-Unification". ; Bulychev, Peter E.; Kostylev, Egor V.; Zakharov, Vladimir A. (2009). "Anti-Unification Algorithms and their Applications in Program Analysis". </li>
<li>Code factoring: Cottrell, Rylan (Sep 2008), <i>Semi-automating Small-Scale Source Code Reuse via Structural Correspondence</i>, Univ. Calgary </li>
<li>Induction proving: Heinz, Birgit (1994), <i>Lemma Discovery by Anti-Unification of Regular Sorts</i>, Technical Report, 94-21, TU Berlin </li>
<li>Information Extraction: Thomas, Bernd (1999). "Anti-Unification Based Learning of T-Wrappers for Information Extraction". <i>AAAI Technical Report</i>. WS-99-11: 15–20. </li>
<li>Case-based reasoning: Armengol, Eva; Plaza, Enric (2005). "Using Symbolic Descriptions to Explain Similarity on CBR". </li>
</ul>
<h3>Anti-unification of trees and linguistic applications</h3>
<ul>
<li>Parse trees for sentences can be subject to least general generalization to derive a maximal common sub-parse trees for language learning. There are applications in search and text classification.</li>
<li>Parse thickets for paragraphs as graphs can be subject to least general generalization.</li>
<li>Operation of generalization commutes with the operation of transition from syntactic (parse trees) to semantic (symbolic expressions) level. The latter can then be subject to conventional anti-unification.</li>
</ul>
<h2>Higher-order anti-unification</h2>
<ul>
<li>Calculus of constructions: Pfenning, Frank (Jul 1991). "Unification and Anti-Unification in the Calculus of Constructions". "Proc. 6th LICS". Springer. pp. 74–85. </li>
<li>Simply-typed lambda calculus (Input: Terms in the eta-long beta-normal form. Output: higher-order patterns): Baumgartner, Alexander; Kutsia, Temur; Levy, Jordi; Villaret, Mateu (Jun 2013). A Variant of Higher-Order Anti-Unification. Proc. RTA 2013. Vol. 21 of LIPIcs. Schloss Dagstuhl, 113-127. Software.</li>
<li>Restricted Higher-Order: Wagner, Ulrich (Apr 2002), <i>Combinatorically Restricted Higher Order Anti-Unification</i>, TU Berlin ; Schmidt, Martin (Sep 2010), <i>Restricted Higher-Order Anti-Unification for Heuristic-Driven Theory Projection</i>, PICS-Report, 31-2010, Univ. Osnabrück, Germany, ISSN 1610-5389 </li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Complete generalization sets always exist, but it may be the case that every complete generalization set is non-minimal.</li>
<li><b>^</b> Comon referred in 1986 to inequation-solving as "anti-unification", which nowadays has become quite unusual. Comon, Hubert (1986). "Sufficient Completeness, Term Rewriting Systems and 'Anti-Unification'". "Proc. 8th International Conference on Automated Deduction". LNCS <b>230</b>. Springer. pp. 128–140. </li>
<li><b>^</b> E.g. <img class="mwe-math-fallback-image-inline tex" alt=" a \oplus (b \oplus f(x)) \equiv a \oplus (f(x) \oplus b) \equiv (b \oplus f(x)) \oplus a \equiv (f(x) \oplus b) \oplus a" src="//upload.wikimedia.org/math/d/b/e/dbe8bbe8ba01ecdcd892c8dd8eaaeab9.png"></li>
<li><b>^</b> From a theoretical viewpoint, such a mapping exists, since both <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> and <img class="mwe-math-fallback-image-inline tex" alt="T \times T" src="//upload.wikimedia.org/math/a/0/e/a0e8151da4d8c9d29908305f11749c4d.png"> are countably infinite sets; for practical purposes, <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> can be built up as needed, remembering assigned mappings <img class="mwe-math-fallback-image-inline tex" alt="\langle s,t,\phi(s,t) \rangle" src="//upload.wikimedia.org/math/3/0/a/30a537a6786e84a59c61261c8f1d292e.png"> in a hash table.</li>
</ol>
</body>
</html>