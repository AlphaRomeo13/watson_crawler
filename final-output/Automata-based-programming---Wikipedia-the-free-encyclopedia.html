<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Automata-based-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Automata-based programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li><strong class="selflink">Automata-based</strong></li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Automata-based programming</b> is a programming paradigm in which the program or its part is thought of as a model of a finite state machine (FSM) or any other (often more complicated) formal automaton (see automata theory). Sometimes a potentially-infinite set of possible states is introduced, and such a set can have a complicated structure, not just an enumeration.</p>
<p><b>FSM-based programming</b> is generally the same, but, formally speaking, doesn't cover all possible variants as FSM stands for finite state machine and <b>automata-based programming</b> doesn't necessarily employ FSMs in the strict sense.</p>
<p>The following properties are key indicators for automata-based programming:</p>
<ol>
<li>The time period of the program's execution is clearly separated down to the <i>steps of the automaton</i>. Each of the <i>steps</i> is effectively an execution of a code section (same for all the steps), which has a single entry point. Such a section can be a function or other routine, or just a cycle body. The step section might be divided down to subsection to be executed depending on different states, although this is not necessary.</li>
<li>Any communication between the steps is only possible via the explicitly noted set of variables named <i>the state</i>. Between any two steps, the program (or its part created using the automata-based technique) can <b>not</b> have implicit components of its state, such as local (stack) variables' values, return addresses, the current instruction pointer etc. That is, the state of the whole program, taken at any two moments of entering the step of the automaton, can only differ in the values of the variables being considered as the state of the automaton.</li>
</ol>
<p>The whole execution of the automata-based code is a (possibly explicit) cycle of the automaton's steps.</p>
<p>Another reason to use the notion of <b>automata-based programming</b> is that the programmer's style of thinking about the program in this technique is very similar to the style of thinking used to solve math-related tasks using Turing machine, Markov algorithm etc.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Example
<ul>
<li>1.1 Traditional (imperative) program in C</li>
<li>1.2 Automata-based style program</li>
<li>1.3 A separate function for the automation step</li>
<li>1.4 Explicit state transition table</li>
<li>1.5 Automation and Automata
<ul>
<li>1.5.1 Example Program</li>
<li>1.5.2 Automation &amp; Events</li>
</ul>
</li>
<li>1.6 Using object-oriented capabilities</li>
</ul>
</li>
<li>2 Applications</li>
<li>3 History</li>
<li>4 Compared against imperative and procedural programming</li>
<li>5 Object-oriented programming relationship</li>
<li>6 See also</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>1.1 Traditional (imperative) program in C</li>
<li>1.2 Automata-based style program</li>
<li>1.3 A separate function for the automation step</li>
<li>1.4 Explicit state transition table</li>
<li>1.5 Automation and Automata
<ul>
<li>1.5.1 Example Program</li>
<li>1.5.2 Automation &amp; Events</li>
</ul>
</li>
<li>1.6 Using object-oriented capabilities</li>
</ul>
<ul>
<li>1.5.1 Example Program</li>
<li>1.5.2 Automation &amp; Events</li>
</ul>
<p></p>
<h2>Example</h2>
<p>Consider a program in C that reads a text from <i>standard input stream</i>, line by line, and prints the first word of each line. It is clear we need first to read and skip the leading spaces, if any, then read characters of the first word and print them until the word ends, and then read and skip all the remaining characters until the end-of-line character is encountered. Upon reaching the end of line character (regardless of the stage), we restart the algorithm from the beginning, and upon encountering the <i>end of file</i> condition (regardless of the stage), we terminate the program.</p>
<h3>Traditional (imperative) program in C</h3>
<p>The program which solves the example task in traditional (imperative) style can look something like this:</p>
<p>WHATSON? 24e25be8-6b74-4c15-8e24-507f1fcf8bf0</p>
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    int c;
    do {
        c = getchar();
        while(c == ' ')
            c = getchar();
        while(c != EOF &amp;&amp; c != ' ' &amp;&amp; c != '\n') {
            putchar(c);
            c = getchar();
        }
        putchar('\n');
        while(c != EOF &amp;&amp; c != '\n')
            c = getchar();
    } while(c != EOF);
    return 0;
}
</pre>
<h3>Automata-based style program</h3>
<p>The same task can be solved by thinking in terms of finite state machines. Note that line parsing has three stages: skipping the leading spaces, printing the word and skipping the trailing characters. Let's call them <b>states</b> <code>before</code>, <code>inside</code> and <code>after</code>. The program may now look like this:</p>
<p>WHATSON? 29d87a87-03a2-41b0-928c-f1666027c625</p>
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    enum states {
        before, inside, after
    } state;
    int c;
    state = before;
    while((c = getchar()) != EOF) {
        switch(state) {
            case before:
                if(c == '\n') {
                    putchar('\n');
                } else
                if(c != ' ') {
                    putchar(c);
                    state = inside;
                }
                break;
            case inside:
                switch(c) {
                    case ' ':  state = after; break;
                    case '\n':
                        putchar('\n');
                        state = before;
                        break;
                    default:   putchar(c);
                }
                break;
            case after:
                if(c == '\n') {
                    putchar('\n');
                    state = before;
                }
        }
    }
    return 0;
}
</pre>
<p>Although the code now looks longer, it has at least one significant advantage: there's only one <i>reading</i> (that is, call to the <code>getchar()</code> function) instruction in the program. Besides that, there's only one loop instead of the four the previous versions had.</p>
<p>In this program, the body of the <code>while</code> loop is the <b>automaton step</b>, and the loop itself is the <i>cycle of the automaton's work</i>.</p>
<p>The program implements (models) the work of a <i>finite state machine</i> shown on the picture. The <b>N</b> denotes the end of line character, the <b>S</b> denotes spaces, and the <b>A</b> stands for all the other characters. The automaton follows exactly one <i>arrow</i> on each step depending on the current state and the encountered character. Some state switches are accompanied with printing the character; such arrows are marked with asterisks.</p>
<p>It is not absolutely necessary to divide the code down to separate handlers for each unique state. Furthermore, in some cases the very notion of the <i>state</i> can be composed of several variables' values, so that it could be impossible to handle each possible state explicitly. In the discussed program it is possible to reduce the code length by noticing that the actions taken in response to the end of line character are the same for all the possible states. The following program is equal to the previous one but is a bit shorter:</p>
<p>WHATSON? f2067b02-a486-47f9-b3c8-ef4ab64c9d25</p>
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    enum states {
        before, inside, after
    } state;
    int c;
    state = before;
    while((c = getchar()) != EOF) {
        if(c == '\n') {
            putchar('\n');
            state = before;
        } else
        switch(state) {
            case before:
                if(c != ' ') {
                    putchar(c);
                    state = inside;
                }
                break;
            case inside:
                if(c == ' ') {
                    state = after;
                } else {
                    putchar(c);
                }
                break;
            case after:
                break;
        }
    }
    return 0;
}
</pre>
<h3>A separate function for the automation step</h3>
<p>The most important property of the previous program is that the automaton step code section is clearly localized. With a separate function for it, we can better demonstrate this property:</p>
<p>WHATSON? 8e5dfd8f-fd18-4083-aae7-352263506e28</p>
<pre>
#include &lt;stdio.h&gt;
enum states { before, inside, after };
void step(enum states *state, int c)
{
    if(c == '\n') {
        putchar('\n');
        *state = before;
    } else
    switch(*state) {
        case before:
            if(c != ' ') {
                putchar(c);
                *state = inside;
            }
            break;
        case inside:
            if(c == ' ') {
                *state = after;
            } else {
                putchar(c);
            }
            break;
        case after:
            break;
    }
} 
int main(void)
{
    int c;
    enum states state = before;
    while((c = getchar()) != EOF) {
        step(&amp;state, c);
    }
    return 0;
}
</pre>
<p>This example clearly demonstrates the basic properties of automata-based code:</p>
<ol>
<li>time periods of automaton step executions may not overlap</li>
<li>the only information passed from the previous step to the next is the explicitly specified <i>automaton state</i></li>
</ol>
<h3>Explicit state transition table</h3>
<p>A finite automaton can be defined by an explicit state transition table. Generally speaking, an automata-based program code can naturally reflect this approach. In the program below there's an array named <code>the_table</code>, which defines the table. The rows of the table stand for three <i>states</i>, while columns reflect the input characters (first for spaces, second for the end of line character, and the last is for all the other characters).</p>
<p>For every possible combination, the table contains the new state number and the flag, which determines whether the automaton must print the symbol. In a real life task, this could be more complicated; e.g., the table could contain pointers to functions to be called on every possible combination of conditions.</p>
<p>WHATSON? 5048eb4e-5345-48c4-8d4c-8cd8c5a73d6e</p>
<pre>
#include &lt;stdio.h&gt;
enum states { before = 0, inside = 1, after = 2 };
struct branch {
    unsigned char new_state:2;
    unsigned char should_putchar:1;
};
struct branch the_table[3][3] = {
                 /* ' '         '\n'        others */
    /* before */ { {before,0}, {before,1}, {inside,1} },
    /* inside */ { {after, 0}, {before,1}, {inside,1} },
    /* after  */ { {after, 0}, {before,1}, {after, 0} }
};
void step(enum states *state, int c)
{
    int idx2 = (c == ' ') ? 0 : (c == '\n') ? 1 : 2;
    struct branch *b = &amp; the_table[*state][idx2];
    *state = (enum states)(b-&gt;new_state);
    if(b-&gt;should_putchar) putchar(c);
}
</pre>
<h3>Automation and Automata</h3>
<p>Automata-based programming indeed closely matches the programming needs found in the field of automation.</p>
<p>A production cycle is commonly modelled as:</p>
<ul>
<li>A sequence of stages stepping according to input data (from captors).</li>
<li>A set of actions performed depending on the current stage.</li>
</ul>
<p>Various dedicated programming languages allow expressing such a model in more or less sophisticated ways.</p>
<h4>Example Program</h4>
<p>The example presented above could be expressed according to this view like in the following program. Here pseudo-code uses such conventions:</p>
<ul>
<li>'set' and 'reset' respectively activate &amp; inactivate a logic variable (here a stage)</li>
<li>':' is assignment, '=' is equality test</li>
</ul>
<p>WHATSON? ac347d4d-5d74-4389-a926-6b2582cc93f9</p>
<pre>
SPC : ' '
EOL : '\n'
 
states : (before, inside, after, end)
 
setState(c) {
    if c=EOF then set end
    if before and (c!=SPC and c!=EOL) then set inside
    if inside and (c=SPC or c=EOL) then set after
    if after and c=EOL then set before
}
 
doAction(c) {
    if inside then write(c)
    else if c=EOL then write(c)
}
 
cycle {
    set before
    loop {
        c : readCharacter
        setState(c)
        doAction(c)
    }
    until end
}
</pre>
<p>The separation of routines expressing cycle progression on one side, and actual action on the other (matching input &amp; output) allows clearer and simpler code.</p>
<h4>Automation &amp; Events</h4>
<p>In the field of automation, stepping from step to step depends on input data coming from the machine itself. This is represented in the program by reading characters from a text. In reality, those data inform about position, speed, temperature, etc. of critical elements of a machine.</p>
<p>Like in GUI programming, <b>changes</b> in the machine state can thus be considered as events causing the passage from a state to another, until the final one is reached. The combination of possible states can generate a wide variety of events, thus defining a more complex production cycle. As a consequence, cycles are usually far to be simple linear sequences. There are commonly parallel branches running together and alternatives selected according to different events, schematically represented below:</p>
<p>WHATSON? 4b003a35-ec83-44df-955b-4e77dea08c45</p>
<pre>
   s:stage   c:condition
   
   s1
   |
   |-c2
   |
   s2
   |
   ----------
   |        |
   |-c31    |-c32
   |        |
  s31       s32
   |        |
   |-c41    |-c42
   |        |
   ----------
   |
   s4
</pre>
<h3>Using object-oriented capabilities</h3>
<p>If the implementation language supports object-oriented programming, a simple refactoring is to encapsulate the automaton into an object, thus hiding its implementation details. For example, an object-oriented version in C++ of the same program is below. A more sophisticated refactoring could employ the State pattern.</p>
<p>WHATSON? 53adde11-4275-4976-8914-b0a04389331f</p>
<pre>
#include &lt;stdio.h&gt;
class StateMachine {
    enum states { before = 0, inside = 1, after = 2 } state;
    struct branch {
        enum states new_state:2;
        int should_putchar:1;
    };
    static struct branch the_table[3][3];
public:
    StateMachine() : state(before) {}
    void FeedChar(int c) {
        int idx2 = (c == ' ') ? 0 : (c == '\n') ? 1 : 2;
        struct branch *b = &amp; the_table[state][idx2];
        state = b-&gt;new_state;
        if(b-&gt;should_putchar) putchar(c);
    }
};
struct StateMachine::branch StateMachine::the_table[3][3] = {
                 /* ' '         '\n'        others */
    /* before */ { {before,0}, {before,1}, {inside,1} },
    /* inside */ { {after, 0}, {before,1}, {inside,1} },
    /* after  */ { {after, 0}, {before,1}, {after, 0} }
};
int main(void)
{
    int c;
    StateMachine machine;
    while((c = getchar()) != EOF)
        machine.FeedChar(c);
    return 0;
}
</pre>
<p>Note: To minimize changes not directly related to the subject of the article, the input/output functions from the standard library of C are being used. Note the use of the ternary operator, which could also be implemented as if-else.</p>
<h2>Applications</h2>
<p>Automata-based programming is widely used in lexical and syntactic analyses.</p>
<p>Besides that, thinking in terms of automata (that is, breaking the execution process down to <i>automaton steps</i> and passing information from step to step through the explicit <i>state</i>) is necessary for event-driven programming as the only alternative to using parallel processes or threads.</p>
<p>The notions of states and state machines are often used in the field of formal specification. For instance, UML-based software architecture development uses state diagrams to specify the behaviour of the program. Also various communication protocols are often specified using the explicit notion of <i>state</i> (see, e.g., RFC 793).</p>
<p>Thinking in terms of automata (steps and states) can also be used to describe semantics of some programming languages. For example, the execution of a program written in the Refal language is described as a sequence of <i>steps</i> of a so-called abstract Refal machine; the state of the machine is a <i>view</i> (an arbitrary Refal expression without variables).</p>
<p>Continuations in the Scheme language require thinking in terms of steps and states, although Scheme itself is in no way automata-related (it is recursive). To make it possible the call/cc feature to work, implementation needs to be able to catch a whole state of the executing program, which is only possible when there's no implicit part in the state. Such a <i>caught state</i> is the very thing called <i>continuation</i>, and it can be considered as the <i>state</i> of a (relatively complicated) automaton. The step of the automaton is deducing the next continuation from the previous one, and the execution process is the cycle of such steps.</p>
<p>Alexander Ollongren in his book explains the so-called <i>Vienna method</i> of programming languages semantics description which is fully based on formal automata.</p>
<p>The STAT system [1] is a good example of using the automata-based approach; this system, besides other features, includes an embedded language called <i>STATL</i> which is purely automata-oriented.</p>
<h2>History</h2>
<p>Automata-based techniques were used widely in the domains where there are algorithms based on automata theory, such as formal language analyses.</p>
<p>One of the early papers on this is by Johnson et al., 1968.</p>
<p>One of the earliest mentions of automata-based programming as a general technique is found in the paper by Peter Naur, 1963. The author calls the technique <i>Turing machine approach</i>, however no real Turing machine is given in the paper; instead, the technique based on states and steps is described.</p>
<h2>Compared against imperative and procedural programming</h2>
<p>The notion of state is not exclusive property of automata-based programming. Generally speaking, <i>state</i> (or program state) appears during execution of any computer program, as a combination of all information that can change during the execution. For instance, a <i>state</i> of a traditional imperative program consists of</p>
<ol>
<li>values of all variables and the information stored within dynamic memory</li>
<li>values stored in registers</li>
<li>stack contents (including local variables' values and return addresses)</li>
<li>current value of the instruction pointer</li>
</ol>
<p>These can be divided to the <b>explicit</b> part (such as values stored in variables) and the <b>implicit</b> part (return addresses and the instruction pointer).</p>
<p>Having said this, an automata-based program can be considered as a special case of an imperative program, in which implicit part of the state is minimized. The state of the whole program taken at the two distinct moments of entering the <i>step</i> code section can differ in the automaton state only. This simplifies the analysis of the program.</p>
<h2>Object-oriented programming relationship</h2>
<p>In the theory of object-oriented programming an <b>object</b> is said to have an internal <i>state</i> and is capable of <i>receiving messages</i>, <i>responding</i> to them, <i>sending</i> messages to other objects and changing the internal state during message handling. In more practical terminology, <i>to call an object's method</i> is considered the same as <i>to send a message to the object</i>.</p>
<p>Thus, on the one hand, objects from object-oriented programming can be considered as automata (or models of automata) whose <i>state</i> is the combination of internal fields, and one or more methods are considered to be the <i>step</i>. Such methods must not call each other nor themselves, neither directly nor indirectly, otherwise the object can not be considered to be implemented in an automata-based manner.</p>
<p>On the other hand, it is obvious that <i>object</i> is good for implementing a model of an automaton. When the automata-based approach is used within an object-oriented language, an automaton model is usually implemented by a class, the <i>state</i> is represented with internal (private) fields of the class, and the <i>step</i> is implemented as a method; such a method is usually the only non-constant public method of the class (besides constructors and destructors). Other public methods could query the state but don't change it. All the secondary methods (such as particular state handlers) are usually hidden within the private part of the class.</p>
<h2>See also</h2>
<ul>
<li>Nondeterministic programming</li>
<li>State pattern</li>
<li>Esterel, an automata-based language</li>
<li>Umple, a tool to add automata to Java and C++</li>
</ul>
</body>
</html>