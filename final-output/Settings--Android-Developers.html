<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Settings--Android-Developers.html</title></head>
<body>
<h1>Settings</h1>
<h2>In this document</h2>
<ol>
  <li>Overview
    <ol>
      <li>Preferences</li>
    </ol>
  </li>
  <li>Defining Preferences in XML
    <ol>
      <li>Creating setting groups</li>
      <li>Using intents</li>
    </ol>
  </li>
  <li>Creating a Preference Activity</li>
  <li>Using Preference Fragments</li>
  <li>Setting Default Values</li>
  <li>Using Preference Headers
    <ol>
      <li>Creating the headers file</li>
      <li>Displaying the headers</li>
      <li>Supporting older versions with preference headers</li>
    </ol>
  </li>
  <li>Reading Preferences
    <ol>
      <li>Listening for preference changes</li>
    </ol>
  </li>
  <li>Managing Network Usage</li>
  <li>Building a Custom Preference
    <ol>
      <li>Specifying the user interface</li>
      <li>Saving the setting's value</li>
      <li>Initializing the current value</li>
      <li>Providing a default value</li>
      <li>Saving and restoring the Preference's state</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Preferences</li>
    </ol>
<ol>
      <li>Creating setting groups</li>
      <li>Using intents</li>
    </ol>
<ol>
      <li>Creating the headers file</li>
      <li>Displaying the headers</li>
      <li>Supporting older versions with preference headers</li>
    </ol>
<ol>
      <li>Listening for preference changes</li>
    </ol>
<ol>
      <li>Specifying the user interface</li>
      <li>Saving the setting's value</li>
      <li>Initializing the current value</li>
      <li>Providing a default value</li>
      <li>Saving and restoring the Preference's state</li>
    </ol>
<h2>Key classes</h2>
<ol>
  <li><code>Preference</code></li>
  <li><code>PreferenceActivity</code></li>
  <li><code>PreferenceFragment</code></li>
</ol>
<h2>See also</h2>
<ol>
  <li>Settings design guide</li>
</ol>
<p>Applications often include settings that allow users to modify app features and behaviors. For
example, some apps allow users to specify whether notifications are enabled or specify how often the
application syncs data with the cloud.</p>
<p>If you want to provide settings for your app, you should use
Android's <code>Preference</code> APIs to build an interface that's consistent with
the user experience in other Android apps (including the system settings). This document describes
how to build your app settings using <code>Preference</code> APIs.</p>
<p><strong>Settings Design</strong></p>
<p>For information about how to design your settings, read the Settings design guide.</p>
<p><strong>Figure 1.</strong> Screenshots from the Android Messaging app's
settings. Selecting an item defined by a <code>Preference</code> 
opens an interface to change the setting.</p>
<h2>Overview</h2>
<p>Instead of using <code>View</code> objects to build the user interface, settings are
built using various subclasses of the <code>Preference</code> class that you
declare in an XML file.</p>
<p>A <code>Preference</code> object is the building block for a single
setting. Each <code>Preference</code> appears as an item in a list and provides the
appropriate UI for users to modify the setting. For example, a <code>CheckBoxPreference</code> creates a list item that shows a checkbox, and a <code>ListPreference</code> creates an item that opens a dialog with a list of choices.</p>
<p>Each <code>Preference</code> you add has a corresponding key-value pair that
the system uses to save the setting in a default <code>SharedPreferences</code>
file for your app's settings. When the user changes a setting, the system updates the corresponding
value in the <code>SharedPreferences</code> file for you. The only time you should
directly interact with the associated <code>SharedPreferences</code> file is when you
need to read the value in order to determine your app's behavior based on the user's setting.</p>
<p>The value saved in <code>SharedPreferences</code> for each setting can be one of the
following data types:</p>
<ul>
  <li>Boolean</li>
  <li>Float</li>
  <li>Int</li>
  <li>Long</li>
  <li>String</li>
  <li>String <code>Set</code></li>
</ul>
<p>Because your app's settings UI is built using <code>Preference</code> objects
instead of
<code>View</code> objects, you need to use a specialized <code>Activity</code> or
<code>Fragment</code> subclass to display the list settings:</p>
<ul>
  <li>If your app supports versions of Android older than 3.0 (API level 10 and lower), you must
build the activity as an extension of the <code>PreferenceActivity</code> class.</li>
  <li>On Android 3.0 and later, you should instead use a traditional <code>Activity</code>
that hosts a <code>PreferenceFragment</code> that displays your app settings.
However, you can also use <code>PreferenceActivity</code> to create a two-pane layout
for large screens when you have multiple groups of settings.</li>
</ul>
<p>How to set up your <code>PreferenceActivity</code> and instances of <code>PreferenceFragment</code> is discussed in the sections about Creating a Preference Activity and Using
Preference Fragments.</p>
<h3>Preferences</h3>
<p>Every setting for your app is represented by a specific subclass of the <code>Preference</code> class. Each subclass includes a set of core properties that allow you
to specify things such as a title for the setting and the default value. Each subclass also provides
its own specialized properties and user interface. For instance, figure 1 shows a screenshot from
the Messaging app's settings. Each list item in the settings screen is backed by a different <code>Preference</code> object.</p>
<p>A few of the most common preferences are:</p>
<p>See the <code>Preference</code> class for a list of all other subclasses and their
corresponding properties.</p>
<p>Of course, the built-in classes don't accommodate every need and your application might require
something more specialized. For example, the platform currently does not provide a <code>Preference</code> class for picking a number or a date. So you might need to define
your own <code>Preference</code> subclass. For help doing so, see the section about Building a Custom Preference.</p>
<h2>Defining Preferences in XML</h2>
<p>Although you can instantiate new <code>Preference</code> objects at runtime, you
should define your list of settings in XML with a hierarchy of <code>Preference</code>
objects. Using an XML file to define your collection of settings is preferred because the file
provides an easy-to-read structure that's simple to update. Also, your app's settings are
generally pre-determined, although you can still modify the collection at runtime.</p>
<p>Each <code>Preference</code> subclass can be declared with an XML element that
matches the class name, such as <code>&lt;CheckBoxPreference&gt;</code>.</p>
<p>You must save the XML file in the <code>res/xml/</code> directory. Although you can name the file
anything you want, it's traditionally named <code>preferences.xml</code>. You usually need only one file,
because branches in the hierarchy (that open their own list of settings) are declared using nested
instances of <code>PreferenceScreen</code>.</p>
<p><strong>Note:</strong> If you want to create a multi-pane layout for your
settings, then you need separate XML files for each fragment.</p>
<p>The root node for the XML file must be a <code>&lt;PreferenceScreen&gt;</code> element. Within this element is where you add each <code>Preference</code>. Each child you add within the
<code>&lt;PreferenceScreen&gt;</code> element appears as a single
item in the list of settings.</p>
<p>For example:</p>
<p>WHATSON? 49a7ff1b-86fc-4c68-9e60-44a5fa8b2ef9</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;CheckBoxPreference
        android:key="pref_sync"
        android:title="@string/pref_sync"
        android:summary="@string/pref_sync_summ"
        android:defaultValue="true" /&gt;
    &lt;ListPreference
        android:dependency="pref_sync"
        android:key="pref_syncConnectionType"
        android:title="@string/pref_syncConnectionType"
        android:dialogTitle="@string/pref_syncConnectionType"
        android:entries="@array/pref_syncConnectionTypes_entries"
        android:entryValues="@array/pref_syncConnectionTypes_values"
        android:defaultValue="@string/pref_syncConnectionTypes_default" /&gt;
&lt;/PreferenceScreen&gt;
</pre>
<p>In this example, there's a <code>CheckBoxPreference</code> and a <code>ListPreference</code>. Both items include the following three attributes:</p>
<p>The only instances in which this attribute is <em>not required</em> is when the preference is a
<code>PreferenceCategory</code> or <code>PreferenceScreen</code>, or the
preference specifies an <code>Intent</code> to invoke (with an <code>&lt;intent&gt;</code> element) or a <code>Fragment</code> to display (with an <code>android:fragment</code> attribute).</p>
<p>For information about all other supported attributes, see the <code>Preference</code> (and respective subclass) documentation.</p>
<p><strong>Figure 2.</strong> Setting categories
    with titles. <br><b>1.</b> The category is specified by the <code>&lt;PreferenceCategory&gt;</code> element. <br><b>2.</b> The title is
specified with the <code>android:title</code> attribute.</p>
<p>When your list of settings exceeds about 10 items, you might want to add titles to
define groups of settings or display those groups in a
separate screen. These options are described in the following sections.</p>
<h3>Creating setting groups</h3>
<p>If you present a list of 10 or more settings, users
may have difficulty scanning, comprehending, and processing them. You can remedy this by
dividing some or all of the settings into groups, effectively turning one long list into multiple
shorter lists. A group of related settings can be presented in one of two ways:</p>
<ul>
  <li>Using titles</li>
  <li>Using subscreens</li>
</ul>
<p>You can use one or both of these grouping techniques to organize your app's settings. When
deciding which to use and how to divide your settings, you should follow the guidelines in Android
Design's Settings guide.</p>
<h4>Using titles</h4>
<p>If you want to provide dividers with headings between groups of settings (as shown in figure 2),
place each group of <code>Preference</code> objects inside a <code>PreferenceCategory</code>.</p>
<p>For example:</p>
<p>WHATSON? c3dd4031-a32f-49a4-907b-d20b7bf57b86</p>
<pre>
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;PreferenceCategory 
        android:title="@string/pref_sms_storage_title"
        android:key="pref_key_storage_settings"&gt;
        &lt;CheckBoxPreference
            android:key="pref_key_auto_delete"
            android:summary="@string/pref_summary_auto_delete"
            android:title="@string/pref_title_auto_delete"
            android:defaultValue="false"... /&gt;
        &lt;Preference 
            android:key="pref_key_sms_delete_limit"
            android:dependency="pref_key_auto_delete"
            android:summary="@string/pref_summary_delete_limit"
            android:title="@string/pref_title_sms_delete"... /&gt;
        &lt;Preference 
            android:key="pref_key_mms_delete_limit"
            android:dependency="pref_key_auto_delete"
            android:summary="@string/pref_summary_delete_limit"
            android:title="@string/pref_title_mms_delete" ... /&gt;
    &lt;/PreferenceCategory&gt;
    ...
&lt;/PreferenceScreen&gt;
</pre>
<h4>Using subscreens</h4>
<p>If you want to place groups of settings into a subscreen (as shown in figure 3), place the group
of <code>Preference</code> objects inside a <code>PreferenceScreen</code>.</p>
<p><strong>Figure 3.</strong> Setting subscreens. The <code>&lt;PreferenceScreen&gt;</code> element
creates an item that, when selected, opens a separate list to display the nested settings.</p>
<p>For example:</p>
<p>WHATSON? fb89be85-00fa-43ea-8d5d-db748e05b1ad</p>
<pre>
&lt;PreferenceScreen  xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;!-- opens a subscreen of settings --&gt;
    &lt;PreferenceScreen
        android:key="button_voicemail_category_key"
        android:title="@string/voicemail"
        android:persistent="false"&gt;
        &lt;ListPreference
            android:key="button_voicemail_provider_key"
            android:title="@string/voicemail_provider" ... /&gt;
        &lt;!-- opens another nested subscreen --&gt;
        &lt;PreferenceScreen
            android:key="button_voicemail_setting_key"
            android:title="@string/voicemail_settings"
            android:persistent="false"&gt;
            ...
        &lt;/PreferenceScreen&gt;
        &lt;RingtonePreference
            android:key="button_voicemail_ringtone_key"
            android:title="@string/voicemail_ringtone_title"
            android:ringtoneType="notification" ... /&gt;
        ...
    &lt;/PreferenceScreen&gt;
    ...
&lt;/PreferenceScreen&gt;
</pre>
<h3>Using intents</h3>
<p>In some cases, you might want a preference item to open a different activity instead of a
settings screen, such as a web browser to view a web page. To invoke an <code>Intent</code> when the user selects a preference item, add an <code>&lt;intent&gt;</code>
element as a child of the corresponding <code>&lt;Preference&gt;</code> element.</p>
<p>For example, here's how you can use a preference item to open a web page:</p>
<p>WHATSON? ffc7c051-5c64-4b01-8fd5-e54a1b7f1817</p>
<pre>
&lt;Preference android:title="@string/prefs_web_page" &gt;
    &lt;intent android:action="android.intent.action.VIEW"
            android:data="http://www.example.com" /&gt;
&lt;/Preference&gt;
</pre>
<p>You can create both implicit and explicit intents using the following attributes:</p>
<h2>Creating a Preference Activity</h2>
<p>To display your settings in an activity, extend the <code>PreferenceActivity</code> class. This is an extension of the traditional <code>Activity</code> class that displays a list of settings based on a hierarchy of <code>Preference</code> objects. The <code>PreferenceActivity</code>
automatically persists the settings associated with each <code>Preference</code> when the user makes a change.</p>
<p><strong>Note:</strong> If you're developing your application for Android 3.0 and
higher, you should instead use <code>PreferenceFragment</code>. Go to the next
section about Using Preference Fragments.</p>
<p>The most important thing to remember is that you do not load a layout of views during the <code>onCreate()</code> callback. Instead, you call <code>addPreferencesFromResource()</code> to
add the preferences you've declared in an XML file to the activity. For example, here's the bare
minimum code required for a functional <code>PreferenceActivity</code>:</p>
<p>WHATSON? c1fa8de7-26f1-475e-a6a5-6894472e1efe</p>
<pre>
public class SettingsActivity extends PreferenceActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        addPreferencesFromResource(R.xml.preferences);
    }
}
</pre>
<p>This is actually enough code for some apps, because as soon as the user modifies a preference,
the system saves the changes to a default <code>SharedPreferences</code> file that your
other application components can read when you need to check the user's settings. Many apps,
however, require a little more code in order to listen for changes that occur to the preferences.
For information about listening to changes in the <code>SharedPreferences</code> file,
see the section about Reading Preferences.</p>
<h2>Using Preference Fragments</h2>
<p>If you're developing for Android 3.0 (API level 11) and higher, you should use a <code>PreferenceFragment</code> to display your list of <code>Preference</code>
objects. You can add a <code>PreferenceFragment</code> to any activity—you don't
need to use <code>PreferenceActivity</code>.</p>
<p>Fragments provide a more
flexible architecture for your application, compared to using activities alone, no matter what kind
of activity you're building. As such, we suggest you use <code>PreferenceFragment</code> to control the display of your settings instead of <code>PreferenceActivity</code> when possible.</p>
<p>Your implementation of <code>PreferenceFragment</code> can be as simple as
defining the <code>onCreate()</code> method to load a
preferences file with <code>addPreferencesFromResource()</code>. For example:</p>
<p>WHATSON? 43f5926d-3f5d-4cf4-818e-7d3c98f95625</p>
<pre>
public static class SettingsFragment extends PreferenceFragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource(R.xml.preferences);
    }
    ...
}
</pre>
<p>You can then add this fragment to an <code>Activity</code> just as you would for any other
<code>Fragment</code>. For example:</p>
<p>WHATSON? 74a515c5-3a3d-4c1e-a122-281ff7103ce6</p>
<pre>
public class SettingsActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Display the fragment as the main content.
        getFragmentManager().beginTransaction()
                .replace(android.R.id.content, new SettingsFragment())
                .commit();
    }
}
</pre>
<p><strong>Note:</strong> A <code>PreferenceFragment</code> doesn't have
a its own <code>Context</code> object. If you need a <code>Context</code>
object, you can call <code>getActivity()</code>. However, be careful to call
<code>getActivity()</code> only when the fragment is attached to an activity. When
the fragment is not yet attached, or was detached during the end of its lifecycle, <code>getActivity()</code> will return null.</p>
<h2>Setting Default Values</h2>
<p>The preferences you create probably define some important behaviors for your application, so it's
necessary that you initialize the associated <code>SharedPreferences</code> file with
default values for each <code>Preference</code> when the user first opens your
application.</p>
<p>The first thing you must do is specify a default value for each <code>Preference</code>
object in your XML file using the <code>android:defaultValue</code> attribute. The value can be any data
type that is appropriate for the corresponding <code>Preference</code> object. For
example:</p>
<p>WHATSON? 8a536c4c-6a67-4c30-9190-93182c16fbfd</p>
<pre>
&lt;!-- default value is a boolean --&gt;
&lt;CheckBoxPreference
    android:defaultValue="true"
    ... /&gt;

&lt;!-- default value is a string --&gt;
&lt;ListPreference
    android:defaultValue="@string/pref_syncConnectionTypes_default"
    ... /&gt;
</pre>
<p>Then, from the <code>onCreate()</code> method in your application's main
activity—and in any other activity through which the user may enter your application for the
first time—call <code>setDefaultValues()</code>:</p>
<p>WHATSON? 62b96ca7-f1c4-491b-9426-9d884d4a3d18</p>
<pre>
PreferenceManager.setDefaultValues(this, R.xml.advanced_preferences, false);
</pre>
<p>Calling this during <code>onCreate()</code> ensures that your
application is properly initialized with default settings, which your application might need to
read in order to determine some behaviors (such as whether to download data while on a
cellular network).</p>
<p>This method takes three arguments:</p>
<ul>
  <li>Your application <code>Context</code>.</li>
  <li>The resource ID for the preference XML file for which you want to set the default values.</li>
  <li>A boolean indicating whether the default values should be set more than once.
<p>When <code>false</code>, the system sets the default values only if this method has never been
called in the past (or the <code>KEY_HAS_SET_DEFAULT_VALUES</code>
in the default value shared preferences file is false).</p></li>
</ul>
<p>When <code>false</code>, the system sets the default values only if this method has never been
called in the past (or the <code>KEY_HAS_SET_DEFAULT_VALUES</code>
in the default value shared preferences file is false).</p>
<p>As long as you set the third argument to <code>false</code>, you can safely call this method
every time your activity starts without overriding the user's saved preferences by resetting them to
the defaults. However, if you set it to <code>true</code>, you will override any previous
values with the defaults.</p>
<h2>Using Preference Headers</h2>
<p>In rare cases, you might want to design your settings such that the first screen
displays only a list of subscreens (such as in the system Settings app,
as shown in figures 4 and 5). When you're developing such a design for Android 3.0 and higher, you
should use a new "headers" feature in Android 3.0, instead of building subscreens with nested
<code>PreferenceScreen</code> elements.</p>
<p>To build your settings with headers, you need to:</p>
<ol>
  <li>Separate each group of settings into separate instances of <code>PreferenceFragment</code>. That is, each group of settings needs a separate XML
file.</li>
  <li>Create an XML headers file that lists each settings group and declares which fragment
contains the corresponding list of settings.</li>
  <li>Extend the <code>PreferenceActivity</code> class to host your settings.</li>
  <li>Implement the <code>onBuildHeaders()</code> callback to specify the
headers file.</li>
</ol>
<p>A great benefit to using this design is that <code>PreferenceActivity</code>
automatically presents the two-pane layout shown in figure 4 when running on large screens.</p>
<p>Even if your application supports versions of Android older than 3.0, you can build your
application to use <code>PreferenceFragment</code> for a two-pane presentation on
newer devices while still supporting a traditional multi-screen hierarchy on older
devices (see the section about Supporting older versions with
preference headers).</p>
<p><strong>Figure 4.</strong> Two-pane layout with headers. <br><b>1.</b> The
headers are defined with an XML headers file. <br><b>2.</b> Each group of settings is defined by a
<code>PreferenceFragment</code> that's specified by a <code>&lt;header&gt;</code> element in
the headers file.</p>
<p><strong>Figure 5.</strong> A handset device with setting headers. When an
item is selected, the associated <code>PreferenceFragment</code> replaces the
headers.</p>
<h3>Creating the headers file</h3>
<p>Each group of settings in your list of headers is specified by a single <code>&lt;header&gt;</code>
element inside a root <code>&lt;preference-headers&gt;</code> element. For example:</p>
<p>WHATSON? a6ac03bc-a54c-4eb3-9cab-2285a5458c4c</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;preference-headers xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsActivity$SettingsFragmentOne"
        android:title="@string/prefs_category_one"
        android:summary="@string/prefs_summ_category_one" /&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsActivity$SettingsFragmentTwo"
        android:title="@string/prefs_category_two"
        android:summary="@string/prefs_summ_category_two" &gt;
        &lt;!-- key/value pairs can be included as arguments for the fragment. --&gt;
        &lt;extra android:name="someKey" android:value="someHeaderValue" /&gt;
    &lt;/header&gt;
&lt;/preference-headers&gt;
</pre>
<p>With the <code>android:fragment</code> attribute, each header declares an instance of <code>PreferenceFragment</code> that should open when the user selects the header.</p>
<p>The <code>&lt;extras&gt;</code> element allows you to pass key-value pairs to the fragment in a <code>Bundle</code>. The fragment can retrieve the arguments by calling <code>getArguments()</code>. You might pass arguments to the fragment for a variety of
reasons, but one good reason is to reuse the same subclass of <code>PreferenceFragment</code> for each group and use the argument to specify which
preferences XML file the fragment should load.</p>
<p>For example, here's a fragment that can be reused for multiple settings groups, when each
header defines an <code>&lt;extra&gt;</code> argument with the <code>"settings"</code> key:</p>
<p>WHATSON? 9bd00e9e-6a2c-427a-8e31-d0abc698313a</p>
<pre>
public static class SettingsFragment extends PreferenceFragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String settings = getArguments().getString("settings");
        if ("notifications".equals(settings)) {
            addPreferencesFromResource(R.xml.settings_wifi);
        } else if ("sync".equals(settings)) {
            addPreferencesFromResource(R.xml.settings_sync);
        }
    }
}
</pre>
<h3>Displaying the headers</h3>
<p>To display the preference headers, you must implement the <code>onBuildHeaders()</code> callback method and call
<code>loadHeadersFromResource()</code>. For example:</p>
<p>WHATSON? 3cef6a0b-7d20-4c46-8ac3-4295eabc1cba</p>
<pre>
public class SettingsActivity extends PreferenceActivity {
    @Override
    public void onBuildHeaders(List&lt;Header&gt; target) {
        loadHeadersFromResource(R.xml.preference_headers, target);
    }
}
</pre>
<p>When the user selects an item from the list of headers, the system opens the associated <code>PreferenceFragment</code>.</p>
<p><strong>Note:</strong> When using preference headers, your subclass of <code>PreferenceActivity</code> doesn't need to implement the <code>onCreate()</code> method, because the only required
task for the activity is to load the headers.</p>
<h3>Supporting older versions with preference headers</h3>
<p>If your application supports versions of Android older than 3.0, you can still use headers to
provide a two-pane layout when running on Android 3.0 and higher. All you need to do is create an
additional preferences XML file that uses basic <code>&lt;Preference&gt;</code> elements that behave like the header items (to be used by the older Android
versions).</p>
<p>Instead of opening a new <code>PreferenceScreen</code>, however, each of the <code>&lt;Preference&gt;</code> elements sends an <code>Intent</code> to
the <code>PreferenceActivity</code> that specifies which preference XML file to
load.</p>
<p>For example, here's an XML file for preference headers that is used on Android 3.0
and higher (<code>res/xml/preference_headers.xml</code>):</p>
<p>WHATSON? 37fef4d6-df33-4e2b-9f4c-7df67af69262</p>
<pre>
&lt;preference-headers xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsFragmentOne"
        android:title="@string/prefs_category_one"
        android:summary="@string/prefs_summ_category_one" /&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsFragmentTwo"
        android:title="@string/prefs_category_two"
        android:summary="@string/prefs_summ_category_two" /&gt;
&lt;/preference-headers&gt;
</pre>
<p>And here is a preference file that provides the same headers for versions older than
Android 3.0 (<code>res/xml/preference_headers_legacy.xml</code>):</p>
<p>WHATSON? a7d414fb-66a9-47b1-bdc0-e890a47d5287</p>
<pre>
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;Preference 
        android:title="@string/prefs_category_one"
        android:summary="@string/prefs_summ_category_one"  &gt;
        &lt;intent 
            android:targetPackage="com.example.prefs"
            android:targetClass="com.example.prefs.SettingsActivity"
            android:action="com.example.prefs.PREFS_ONE" /&gt;
    &lt;/Preference&gt;
    &lt;Preference 
        android:title="@string/prefs_category_two"
        android:summary="@string/prefs_summ_category_two" &gt;
        &lt;intent 
            android:targetPackage="com.example.prefs"
            android:targetClass="com.example.prefs.SettingsActivity"
            android:action="com.example.prefs.PREFS_TWO" /&gt;
    &lt;/Preference&gt;
&lt;/PreferenceScreen&gt;
</pre>
<p>Because support for <code>&lt;preference-headers&gt;</code> was added in Android 3.0, the system calls
<code>onBuildHeaders()</code> in your <code>PreferenceActivity</code> only when running on Androd 3.0 or higher. In order to load
the "legacy" headers file (<code>preference_headers_legacy.xml</code>), you must check the Android
version and, if the version is older than Android 3.0 (<code>HONEYCOMB</code>), call <code>addPreferencesFromResource()</code> to
load the legacy header file. For example:</p>
<p>WHATSON? 8593dd03-1892-4af7-9ff6-be9cdddd542d</p>
<pre>
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ...

    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        // Load the legacy preferences headers
        addPreferencesFromResource(R.xml.preference_headers_legacy);
    }
}

// Called only on Honeycomb and later
@Override
public void onBuildHeaders(List&lt;Header&gt; target) {
   loadHeadersFromResource(R.xml.preference_headers, target);
}
</pre>
<p>The only thing left to do is handle the <code>Intent</code> that's passed into the
activity to identify which preference file to load. So retrieve the intent's action and compare it
to known action strings that you've used in the preference XML's <code>&lt;intent&gt;</code> tags:</p>
<p>WHATSON? 4c193b18-a0d5-4a20-9ba1-4460dd5d5ce5</p>
<pre>
final static String ACTION_PREFS_ONE = "com.example.prefs.PREFS_ONE";
...

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    String action = getIntent().getAction();
    if (action != null &amp;&amp; action.equals(ACTION_PREFS_ONE)) {
        addPreferencesFromResource(R.xml.preferences);
    }
    ...

    else if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        // Load the legacy preferences headers
        addPreferencesFromResource(R.xml.preference_headers_legacy);
    }
}
</pre>
<p>Beware that consecutive calls to <code>addPreferencesFromResource()</code> will
stack all the preferences in a single list, so be sure that it's only called once by chaining the
conditions with else-if statements.</p>
<h2>Reading Preferences</h2>
<p>By default, all your app's preferences are saved to a file that's accessible from anywhere
within your application by calling the static method <code>PreferenceManager.getDefaultSharedPreferences()</code>. This returns the <code>SharedPreferences</code> object containing all the key-value pairs that are associated
with the <code>Preference</code> objects used in your <code>PreferenceActivity</code>.</p>
<p>For example, here's how you can read one of the preference values from any other activity in your
application:</p>
<p>WHATSON? 3e912aa2-2c55-4105-8579-a45cf0159ef9</p>
<pre>
SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
String syncConnPref = sharedPref.getString(SettingsActivity.KEY_PREF_SYNC_CONN, "");
</pre>
<h3>Listening for preference changes</h3>
<p>There are several reasons you might want to be notified as soon as the use changes one of the
preferences. In order to receive a callback when a change happens to any one of the preferences,
implement the <code>SharedPreference.OnSharedPreferenceChangeListener</code> interface and register the listener for the
<code>SharedPreferences</code> object by calling <code>registerOnSharedPreferenceChangeListener()</code>.</p>
<p>The interface has only one callback method, <code>onSharedPreferenceChanged()</code>, and you might find it easiest to implement the interface as a part of
your activity. For example:</p>
<p>WHATSON? f91c9309-98e2-441a-b8f6-d9a2a72d792a</p>
<pre>
public class SettingsActivity extends PreferenceActivity
                              implements OnSharedPreferenceChangeListener {
    public static final String KEY_PREF_SYNC_CONN = "pref_syncConnectionType";
    ...

    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
        String key) {
        if (key.equals(KEY_PREF_SYNC_CONN)) {
            Preference connectionPref = findPreference(key);
            // Set summary to be the user-description for the selected value
            connectionPref.setSummary(sharedPreferences.getString(key, ""));
        }
    }
}
</pre>
<p>In this example, the method checks whether the changed setting is for a known preference key. It
calls <code>findPreference()</code> to get the
<code>Preference</code> object that was changed so it can modify the item's
summary to be a description of the user's selection. That is, when the setting is a <code>ListPreference</code> or other multiple choice setting, you should call <code>setSummary()</code> when the setting changes to display the
current status (such as the Sleep setting shown in figure 5).</p>
<p><strong>Note:</strong> As described in the Android Design document about Settings, we recommend that you update the
summary for a <code>ListPreference</code> each time the user changes the preference in
order to describe the current setting.</p>
<p>For proper lifecycle management in the activity, we recommend that you register and unregister
your <code>SharedPreferences.OnSharedPreferenceChangeListener</code> during the <code>onResume()</code> and <code>onPause()</code> callbacks, respectively:</p>
<p>WHATSON? df4a09ed-3d49-4d91-8114-4fc4837ba0f7</p>
<pre>
@Override
protected void onResume() {
    super.onResume();
    getPreferenceScreen().getSharedPreferences()
            .registerOnSharedPreferenceChangeListener(this);
}

@Override
protected void onPause() {
    super.onPause();
    getPreferenceScreen().getSharedPreferences()
            .unregisterOnSharedPreferenceChangeListener(this);
}
</pre>
<p><strong>Caution:</strong> When you call <code>registerOnSharedPreferenceChangeListener()</code>, the preference manager does not
currently store a strong reference to the listener. You must store a strong
reference to the listener, or it will be susceptible to garbage collection. We
recommend you keep a reference to the listener in the instance data of an object
that will exist as long as you need the listener.</p>
<p>For example, in the following code, the caller does not keep a reference to
the listener. As a result, the listener will be subject to garbage collection,
and it will fail at some indeterminate time in the future:</p>
<p>WHATSON? e5731869-089e-49e8-910e-f51ff6ec9c7b</p>
<pre>
prefs.registerOnSharedPreferenceChangeListener(
  // Bad! The listener is subject to garbage collection!
  new SharedPreferences.OnSharedPreferenceChangeListener() {
  public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
    // listener implementation
  }
});
</pre>
<p>Instead, store a reference to the listener in an instance data field of an
object that will exist as long as the listener is needed:</p>
<p>WHATSON? c664d859-d329-4614-81ab-2efd003db0b9</p>
<pre>
SharedPreferences.OnSharedPreferenceChangeListener listener =
    new SharedPreferences.OnSharedPreferenceChangeListener() {
  public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
    // listener implementation
  }
};
prefs.registerOnSharedPreferenceChangeListener(listener);
</pre>
<h2>Managing Network Usage</h2>
<p>Beginning with Android 4.0, the system's Settings application allows users to see how much
network data their applications are using while in the foreground and background. Users can then
disable the use of background data for individual apps. In order to avoid users disabling your app's
access to data from the background, you should use the data connection efficiently and allow
users to refine your app's data usage through your application settings.</p>
<p>

</p>
<p>For example, you might allow the user to control how often your app syncs data, whether your app
performs uploads/downloads only when on Wi-Fi, whether your app uses data while roaming, etc. With
these controls available to them, users are much less likely to disable your app's access to data
when they approach the limits they set in the system Settings, because they can instead precisely
control how much data your app uses.</p>
<p>Once you've added the necessary preferences in your <code>PreferenceActivity</code>
to control your app's data habits, you should add an intent filter for <code>ACTION_MANAGE_NETWORK_USAGE</code> in your manifest file. For example:</p>
<p>WHATSON? 7737fbde-af44-4ba0-bfde-5b7eeeb22a25</p>
<pre>
&lt;activity android:name="SettingsActivity" ... &gt;
    &lt;intent-filter&gt;
       &lt;action android:name="android.intent.action.MANAGE_NETWORK_USAGE" /&gt;
       &lt;category android:name="android.intent.category.DEFAULT" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p>This intent filter indicates to the system that this is the activity that controls your
application's data usage. Thus, when the user inspects how much data your app is using from the
system's Settings app, a <em>View application settings</em> button is available that launches your
<code>PreferenceActivity</code> so the user can refine how much data your app
uses.</p>
<h2>Building a Custom Preference</h2>
<p>The Android framework includes a variety of <code>Preference</code> subclasses that
allow you to build a UI for several different types of settings.
However, you might discover a setting you need for which there’s no built-in solution, such as a
number picker or date picker. In such a case, you’ll need to create a custom preference by extending
the <code>Preference</code> class or one of the other subclasses.</p>
<p>When you extend the <code>Preference</code> class, there are a few important
things you need to do:</p>
<ul>
  <li>Specify the user interface that appears when the user selects the settings.</li>
  <li>Save the setting's value when appropriate.</li>
  <li>Initialize the <code>Preference</code> with the current (or default) value
when it comes into view.</li>
  <li>Provide the default value when requested by the system.</li>
  <li>If the <code>Preference</code> provides its own UI (such as a dialog), save
and restore the state to handle lifecycle changes (such as when the user rotates the screen).</li>
</ul>
<p>The following sections describe how to accomplish each of these tasks.</p>
<h3>Specifying the user interface</h3>
<p>If you directly extend the <code>Preference</code> class, you need to implement
<code>onClick()</code> to define the action that occurs when the user
selects the item. However, most custom settings extend <code>DialogPreference</code> to
show a dialog, which simplifies the procedure. When you extend <code>DialogPreference</code>, you must call <code>setDialogLayoutResourcs()</code> during in the
class constructor to specify the layout for the dialog.</p>
<p>For example, here's the constructor for a custom <code>DialogPreference</code> that declares the layout and specifies the text for the
default positive and negative dialog buttons:</p>
<p>WHATSON? 6acc999f-a4cf-4c29-abdc-dbe55c533206</p>
<pre>
public class NumberPickerPreference extends DialogPreference {
    public NumberPickerPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        
        setDialogLayoutResource(R.layout.numberpicker_dialog);
        setPositiveButtonText(android.R.string.ok);
        setNegativeButtonText(android.R.string.cancel);
        
        setDialogIcon(null);
    }
    ...
}
</pre>
<h3>Saving the setting's value</h3>
<p>You can save a value for the setting at any time by calling one of the <code>Preference</code> class's <code>persist*()</code> methods, such as <code>persistInt()</code> if the setting's value is an integer or
<code>persistBoolean()</code> to save a boolean.</p>
<p><strong>Note:</strong> Each <code>Preference</code> can save only one
data type, so you must use the <code>persist*()</code> method appropriate for the data type used by your
custom <code>Preference</code>.</p>
<p>When you choose to persist the setting can depend on which <code>Preference</code> class you extend. If you extend <code>DialogPreference</code>, then you should persist the value only when the dialog
closes due to a positive result (the user selects the "OK" button).</p>
<p>When a <code>DialogPreference</code> closes, the system calls the <code>onDialogClosed()</code> method. The method includes a
boolean argument that specifies whether the user result is "positive"—if the value is
<code>true</code>, then the user selected the positive button and you should save the new value. For
example:</p>
<p>WHATSON? 3b4922d8-951e-42ab-b11b-7805296c2eb5</p>
<pre>
@Override
protected void onDialogClosed(boolean positiveResult) {
    // When the user selects "OK", persist the new value
    if (positiveResult) {
        persistInt(mNewValue);
    }
}
</pre>
<p>In this example, <code>mNewValue</code> is a class member that holds the setting's current
value. Calling <code>persistInt()</code> saves the value to
the <code>SharedPreferences</code> file (automatically using the key that's
specified in the XML file for this <code>Preference</code>).</p>
<h3>Initializing the current value</h3>
<p>When the system adds your <code>Preference</code> to the screen, it
calls <code>onSetInitialValue()</code> to notify
you whether the setting has a persisted value. If there is no persisted value, this call provides
you the default value.</p>
<p>The <code>onSetInitialValue()</code> method passes
a boolean, <code>restorePersistedValue</code>, to indicate whether a value has already been persisted
for the setting. If it is <code>true</code>, then you should retrieve the persisted value by calling
one of the <code>Preference</code> class's <code>getPersisted*()</code> methods, such as <code>getPersistedInt()</code> for an integer value. You'll
usually want to retrieve the persisted value so you can properly update the UI to reflect the
previously saved value.</p>
<p>If <code>restorePersistedValue</code> is <code>false</code>, then you
should use the default value that is passed in the second argument.</p>
<p>WHATSON? fbf91f37-ce3d-4cf5-9044-7b786bf7b10f</p>
<pre>
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    if (restorePersistedValue) {
        // Restore existing state
        mCurrentValue = this.getPersistedInt(DEFAULT_VALUE);
    } else {
        // Set default state from the XML attribute
        mCurrentValue = (Integer) defaultValue;
        persistInt(mCurrentValue);
    }
}
</pre>
<p>Each <code>getPersisted*()</code> method takes an argument that specifies the
default value to use in case there is actually no persisted value or the key does not exist. In
the example above, a local constant is used to specify the default value in case <code>getPersistedInt()</code> can't return a persisted value.</p>
<p><strong>Caution:</strong> You <strong>cannot</strong> use the
<code>defaultValue</code> as the default value in the <code>getPersisted*()</code> method, because
its value is always null when <code>restorePersistedValue</code> is <code>true</code>.</p>
<h3>Providing a default value</h3>
<p>If the instance of your <code>Preference</code> class specifies a default value
(with the <code>android:defaultValue</code> attribute), then the
system calls <code>onGetDefaultValue()</code> when it instantiates the object in order to retrieve the value. You must
implement this method in order for the system to save the default value in the <code>SharedPreferences</code>. For example:</p>
<p>WHATSON? 62e1817a-e12c-49b5-bed4-92be69d8e84c</p>
<pre>
@Override
protected Object onGetDefaultValue(TypedArray a, int index) {
    return a.getInteger(index, DEFAULT_VALUE);
}
</pre>
<p>The method arguments provide everything you need: the array of attributes and the index
position of the <code>android:defaultValue</code>, which you must retrieve. The reason you must
implement this method to extract the default value from the attribute is because you must specify
a local default value for the attribute in case the value is undefined.</p>
<h3>Saving and restoring the Preference's state</h3>
<p>Just like a <code>View</code> in a layout, your <code>Preference</code>
subclass is responsible for saving and restoring its state in case the activity or fragment is
restarted (such as when the user rotates the screen). To properly save and
restore the state of your <code>Preference</code> class, you must implement the
lifecycle callback methods <code>onSaveInstanceState()</code> and <code>onRestoreInstanceState()</code>.</p>
<p>The state of your <code>Preference</code> is defined by an object that implements
the <code>Parcelable</code> interface. The Android framework provides such an object for you
as a starting point to define your state object: the <code>Preference.BaseSavedState</code> class.</p>
<p>To define how your <code>Preference</code> class saves its state, you should
extend the <code>Preference.BaseSavedState</code> class. You need to override just
 a few methods and define the <code>CREATOR</code>
object.</p>
<p>For most apps, you can copy the following implementation and simply change the lines that
handle the <code>value</code> if your <code>Preference</code> subclass saves a data
type other than an integer.</p>
<p>WHATSON? 2cf121f2-142d-49f7-a025-44755bf2aad7</p>
<pre>
private static class SavedState extends BaseSavedState {
    // Member that holds the setting's value
    // Change this data type to match the type saved by your Preference
    int value;

    public SavedState(Parcelable superState) {
        super(superState);
    }

    public SavedState(Parcel source) {
        super(source);
        // Get the current preference's value
        value = source.readInt();  // Change this to read the appropriate data type
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        super.writeToParcel(dest, flags);
        // Write the preference's value
        dest.writeInt(value);  // Change this to write the appropriate data type
    }

    // Standard creator object using an instance of this class
    public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =
            new Parcelable.Creator&lt;SavedState&gt;() {

        public SavedState createFromParcel(Parcel in) {
            return new SavedState(in);
        }

        public SavedState[] newArray(int size) {
            return new SavedState[size];
        }
    };
}
</pre>
<p>With the above implementation of <code>Preference.BaseSavedState</code> added
to your app (usually as a subclass of your <code>Preference</code> subclass), you
then need to implement the <code>onSaveInstanceState()</code> and <code>onRestoreInstanceState()</code> methods for your
<code>Preference</code> subclass.</p>
<p>For example:</p>
<p>WHATSON? 5c76d100-fdcf-4720-97b9-b1d3da825e88</p>
<pre>
@Override
protected Parcelable onSaveInstanceState() {
    final Parcelable superState = super.onSaveInstanceState();
    // Check whether this Preference is persistent (continually saved)
    if (isPersistent()) {
        // No need to save instance state since it's persistent,
        // use superclass state
        return superState;
    }

    // Create instance of custom BaseSavedState
    final SavedState myState = new SavedState(superState);
    // Set the state's value with the class member that holds current
    // setting value
    myState.value = mNewValue;
    return myState;
}

@Override
protected void onRestoreInstanceState(Parcelable state) {
    // Check whether we saved the state in onSaveInstanceState
    if (state == null || !state.getClass().equals(SavedState.class)) {
        // Didn't save the state, so call superclass
        super.onRestoreInstanceState(state);
        return;
    }

    // Cast state to custom BaseSavedState and pass to superclass
    SavedState myState = (SavedState) state;
    super.onRestoreInstanceState(myState.getSuperState());
    
    // Set this Preference's widget to reflect the restored state
    mNumberPicker.setValue(myState.value);
}
</pre>
<h1>Settings</h1>
<h2>In this document</h2>
<ol>
  <li>Overview
    <ol>
      <li>Preferences</li>
    </ol>
  </li>
  <li>Defining Preferences in XML
    <ol>
      <li>Creating setting groups</li>
      <li>Using intents</li>
    </ol>
  </li>
  <li>Creating a Preference Activity</li>
  <li>Using Preference Fragments</li>
  <li>Setting Default Values</li>
  <li>Using Preference Headers
    <ol>
      <li>Creating the headers file</li>
      <li>Displaying the headers</li>
      <li>Supporting older versions with preference headers</li>
    </ol>
  </li>
  <li>Reading Preferences
    <ol>
      <li>Listening for preference changes</li>
    </ol>
  </li>
  <li>Managing Network Usage</li>
  <li>Building a Custom Preference
    <ol>
      <li>Specifying the user interface</li>
      <li>Saving the setting's value</li>
      <li>Initializing the current value</li>
      <li>Providing a default value</li>
      <li>Saving and restoring the Preference's state</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Preferences</li>
    </ol>
<ol>
      <li>Creating setting groups</li>
      <li>Using intents</li>
    </ol>
<ol>
      <li>Creating the headers file</li>
      <li>Displaying the headers</li>
      <li>Supporting older versions with preference headers</li>
    </ol>
<ol>
      <li>Listening for preference changes</li>
    </ol>
<ol>
      <li>Specifying the user interface</li>
      <li>Saving the setting's value</li>
      <li>Initializing the current value</li>
      <li>Providing a default value</li>
      <li>Saving and restoring the Preference's state</li>
    </ol>
<h2>Key classes</h2>
<ol>
  <li><code>Preference</code></li>
  <li><code>PreferenceActivity</code></li>
  <li><code>PreferenceFragment</code></li>
</ol>
<h2>See also</h2>
<ol>
  <li>Settings design guide</li>
</ol>
<p>Applications often include settings that allow users to modify app features and behaviors. For
example, some apps allow users to specify whether notifications are enabled or specify how often the
application syncs data with the cloud.</p>
<p>If you want to provide settings for your app, you should use
Android's <code>Preference</code> APIs to build an interface that's consistent with
the user experience in other Android apps (including the system settings). This document describes
how to build your app settings using <code>Preference</code> APIs.</p>
<p><strong>Settings Design</strong></p>
<p>For information about how to design your settings, read the Settings design guide.</p>
<p><strong>Figure 1.</strong> Screenshots from the Android Messaging app's
settings. Selecting an item defined by a <code>Preference</code> 
opens an interface to change the setting.</p>
<h2>Overview</h2>
<p>Instead of using <code>View</code> objects to build the user interface, settings are
built using various subclasses of the <code>Preference</code> class that you
declare in an XML file.</p>
<p>A <code>Preference</code> object is the building block for a single
setting. Each <code>Preference</code> appears as an item in a list and provides the
appropriate UI for users to modify the setting. For example, a <code>CheckBoxPreference</code> creates a list item that shows a checkbox, and a <code>ListPreference</code> creates an item that opens a dialog with a list of choices.</p>
<p>Each <code>Preference</code> you add has a corresponding key-value pair that
the system uses to save the setting in a default <code>SharedPreferences</code>
file for your app's settings. When the user changes a setting, the system updates the corresponding
value in the <code>SharedPreferences</code> file for you. The only time you should
directly interact with the associated <code>SharedPreferences</code> file is when you
need to read the value in order to determine your app's behavior based on the user's setting.</p>
<p>The value saved in <code>SharedPreferences</code> for each setting can be one of the
following data types:</p>
<ul>
  <li>Boolean</li>
  <li>Float</li>
  <li>Int</li>
  <li>Long</li>
  <li>String</li>
  <li>String <code>Set</code></li>
</ul>
<p>Because your app's settings UI is built using <code>Preference</code> objects
instead of
<code>View</code> objects, you need to use a specialized <code>Activity</code> or
<code>Fragment</code> subclass to display the list settings:</p>
<ul>
  <li>If your app supports versions of Android older than 3.0 (API level 10 and lower), you must
build the activity as an extension of the <code>PreferenceActivity</code> class.</li>
  <li>On Android 3.0 and later, you should instead use a traditional <code>Activity</code>
that hosts a <code>PreferenceFragment</code> that displays your app settings.
However, you can also use <code>PreferenceActivity</code> to create a two-pane layout
for large screens when you have multiple groups of settings.</li>
</ul>
<p>How to set up your <code>PreferenceActivity</code> and instances of <code>PreferenceFragment</code> is discussed in the sections about Creating a Preference Activity and Using
Preference Fragments.</p>
<h3>Preferences</h3>
<p>Every setting for your app is represented by a specific subclass of the <code>Preference</code> class. Each subclass includes a set of core properties that allow you
to specify things such as a title for the setting and the default value. Each subclass also provides
its own specialized properties and user interface. For instance, figure 1 shows a screenshot from
the Messaging app's settings. Each list item in the settings screen is backed by a different <code>Preference</code> object.</p>
<p>A few of the most common preferences are:</p>
<p>See the <code>Preference</code> class for a list of all other subclasses and their
corresponding properties.</p>
<p>Of course, the built-in classes don't accommodate every need and your application might require
something more specialized. For example, the platform currently does not provide a <code>Preference</code> class for picking a number or a date. So you might need to define
your own <code>Preference</code> subclass. For help doing so, see the section about Building a Custom Preference.</p>
<h2>Defining Preferences in XML</h2>
<p>Although you can instantiate new <code>Preference</code> objects at runtime, you
should define your list of settings in XML with a hierarchy of <code>Preference</code>
objects. Using an XML file to define your collection of settings is preferred because the file
provides an easy-to-read structure that's simple to update. Also, your app's settings are
generally pre-determined, although you can still modify the collection at runtime.</p>
<p>Each <code>Preference</code> subclass can be declared with an XML element that
matches the class name, such as <code>&lt;CheckBoxPreference&gt;</code>.</p>
<p>You must save the XML file in the <code>res/xml/</code> directory. Although you can name the file
anything you want, it's traditionally named <code>preferences.xml</code>. You usually need only one file,
because branches in the hierarchy (that open their own list of settings) are declared using nested
instances of <code>PreferenceScreen</code>.</p>
<p><strong>Note:</strong> If you want to create a multi-pane layout for your
settings, then you need separate XML files for each fragment.</p>
<p>The root node for the XML file must be a <code>&lt;PreferenceScreen&gt;</code> element. Within this element is where you add each <code>Preference</code>. Each child you add within the
<code>&lt;PreferenceScreen&gt;</code> element appears as a single
item in the list of settings.</p>
<p>For example:</p>
<p>WHATSON? ee8d72d7-6ff5-446d-867c-4a2e5f7513c4</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;CheckBoxPreference
        android:key="pref_sync"
        android:title="@string/pref_sync"
        android:summary="@string/pref_sync_summ"
        android:defaultValue="true" /&gt;
    &lt;ListPreference
        android:dependency="pref_sync"
        android:key="pref_syncConnectionType"
        android:title="@string/pref_syncConnectionType"
        android:dialogTitle="@string/pref_syncConnectionType"
        android:entries="@array/pref_syncConnectionTypes_entries"
        android:entryValues="@array/pref_syncConnectionTypes_values"
        android:defaultValue="@string/pref_syncConnectionTypes_default" /&gt;
&lt;/PreferenceScreen&gt;
</pre>
<p>In this example, there's a <code>CheckBoxPreference</code> and a <code>ListPreference</code>. Both items include the following three attributes:</p>
<p>The only instances in which this attribute is <em>not required</em> is when the preference is a
<code>PreferenceCategory</code> or <code>PreferenceScreen</code>, or the
preference specifies an <code>Intent</code> to invoke (with an <code>&lt;intent&gt;</code> element) or a <code>Fragment</code> to display (with an <code>android:fragment</code> attribute).</p>
<p>For information about all other supported attributes, see the <code>Preference</code> (and respective subclass) documentation.</p>
<p><strong>Figure 2.</strong> Setting categories
    with titles. <br><b>1.</b> The category is specified by the <code>&lt;PreferenceCategory&gt;</code> element. <br><b>2.</b> The title is
specified with the <code>android:title</code> attribute.</p>
<p>When your list of settings exceeds about 10 items, you might want to add titles to
define groups of settings or display those groups in a
separate screen. These options are described in the following sections.</p>
<h3>Creating setting groups</h3>
<p>If you present a list of 10 or more settings, users
may have difficulty scanning, comprehending, and processing them. You can remedy this by
dividing some or all of the settings into groups, effectively turning one long list into multiple
shorter lists. A group of related settings can be presented in one of two ways:</p>
<ul>
  <li>Using titles</li>
  <li>Using subscreens</li>
</ul>
<p>You can use one or both of these grouping techniques to organize your app's settings. When
deciding which to use and how to divide your settings, you should follow the guidelines in Android
Design's Settings guide.</p>
<h4>Using titles</h4>
<p>If you want to provide dividers with headings between groups of settings (as shown in figure 2),
place each group of <code>Preference</code> objects inside a <code>PreferenceCategory</code>.</p>
<p>For example:</p>
<p>WHATSON? 81f7233b-af9a-4571-bf89-c6bb2e57c2b6</p>
<pre>
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;PreferenceCategory 
        android:title="@string/pref_sms_storage_title"
        android:key="pref_key_storage_settings"&gt;
        &lt;CheckBoxPreference
            android:key="pref_key_auto_delete"
            android:summary="@string/pref_summary_auto_delete"
            android:title="@string/pref_title_auto_delete"
            android:defaultValue="false"... /&gt;
        &lt;Preference 
            android:key="pref_key_sms_delete_limit"
            android:dependency="pref_key_auto_delete"
            android:summary="@string/pref_summary_delete_limit"
            android:title="@string/pref_title_sms_delete"... /&gt;
        &lt;Preference 
            android:key="pref_key_mms_delete_limit"
            android:dependency="pref_key_auto_delete"
            android:summary="@string/pref_summary_delete_limit"
            android:title="@string/pref_title_mms_delete" ... /&gt;
    &lt;/PreferenceCategory&gt;
    ...
&lt;/PreferenceScreen&gt;
</pre>
<h4>Using subscreens</h4>
<p>If you want to place groups of settings into a subscreen (as shown in figure 3), place the group
of <code>Preference</code> objects inside a <code>PreferenceScreen</code>.</p>
<p><strong>Figure 3.</strong> Setting subscreens. The <code>&lt;PreferenceScreen&gt;</code> element
creates an item that, when selected, opens a separate list to display the nested settings.</p>
<p>For example:</p>
<p>WHATSON? 906ec57c-ca80-475f-bd7d-1e0eb5c14f39</p>
<pre>
&lt;PreferenceScreen  xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;!-- opens a subscreen of settings --&gt;
    &lt;PreferenceScreen
        android:key="button_voicemail_category_key"
        android:title="@string/voicemail"
        android:persistent="false"&gt;
        &lt;ListPreference
            android:key="button_voicemail_provider_key"
            android:title="@string/voicemail_provider" ... /&gt;
        &lt;!-- opens another nested subscreen --&gt;
        &lt;PreferenceScreen
            android:key="button_voicemail_setting_key"
            android:title="@string/voicemail_settings"
            android:persistent="false"&gt;
            ...
        &lt;/PreferenceScreen&gt;
        &lt;RingtonePreference
            android:key="button_voicemail_ringtone_key"
            android:title="@string/voicemail_ringtone_title"
            android:ringtoneType="notification" ... /&gt;
        ...
    &lt;/PreferenceScreen&gt;
    ...
&lt;/PreferenceScreen&gt;
</pre>
<h3>Using intents</h3>
<p>In some cases, you might want a preference item to open a different activity instead of a
settings screen, such as a web browser to view a web page. To invoke an <code>Intent</code> when the user selects a preference item, add an <code>&lt;intent&gt;</code>
element as a child of the corresponding <code>&lt;Preference&gt;</code> element.</p>
<p>For example, here's how you can use a preference item to open a web page:</p>
<p>WHATSON? 0e11f567-ec8f-44cf-be5b-186e566f08da</p>
<pre>
&lt;Preference android:title="@string/prefs_web_page" &gt;
    &lt;intent android:action="android.intent.action.VIEW"
            android:data="http://www.example.com" /&gt;
&lt;/Preference&gt;
</pre>
<p>You can create both implicit and explicit intents using the following attributes:</p>
<h2>Creating a Preference Activity</h2>
<p>To display your settings in an activity, extend the <code>PreferenceActivity</code> class. This is an extension of the traditional <code>Activity</code> class that displays a list of settings based on a hierarchy of <code>Preference</code> objects. The <code>PreferenceActivity</code>
automatically persists the settings associated with each <code>Preference</code> when the user makes a change.</p>
<p><strong>Note:</strong> If you're developing your application for Android 3.0 and
higher, you should instead use <code>PreferenceFragment</code>. Go to the next
section about Using Preference Fragments.</p>
<p>The most important thing to remember is that you do not load a layout of views during the <code>onCreate()</code> callback. Instead, you call <code>addPreferencesFromResource()</code> to
add the preferences you've declared in an XML file to the activity. For example, here's the bare
minimum code required for a functional <code>PreferenceActivity</code>:</p>
<p>WHATSON? 24f713ac-6fd1-448b-9ebd-e2cf7d233821</p>
<pre>
public class SettingsActivity extends PreferenceActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        addPreferencesFromResource(R.xml.preferences);
    }
}
</pre>
<p>This is actually enough code for some apps, because as soon as the user modifies a preference,
the system saves the changes to a default <code>SharedPreferences</code> file that your
other application components can read when you need to check the user's settings. Many apps,
however, require a little more code in order to listen for changes that occur to the preferences.
For information about listening to changes in the <code>SharedPreferences</code> file,
see the section about Reading Preferences.</p>
<h2>Using Preference Fragments</h2>
<p>If you're developing for Android 3.0 (API level 11) and higher, you should use a <code>PreferenceFragment</code> to display your list of <code>Preference</code>
objects. You can add a <code>PreferenceFragment</code> to any activity—you don't
need to use <code>PreferenceActivity</code>.</p>
<p>Fragments provide a more
flexible architecture for your application, compared to using activities alone, no matter what kind
of activity you're building. As such, we suggest you use <code>PreferenceFragment</code> to control the display of your settings instead of <code>PreferenceActivity</code> when possible.</p>
<p>Your implementation of <code>PreferenceFragment</code> can be as simple as
defining the <code>onCreate()</code> method to load a
preferences file with <code>addPreferencesFromResource()</code>. For example:</p>
<p>WHATSON? 7b0eb2b6-56a6-43a5-b7dd-50fbee68ee8b</p>
<pre>
public static class SettingsFragment extends PreferenceFragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource(R.xml.preferences);
    }
    ...
}
</pre>
<p>You can then add this fragment to an <code>Activity</code> just as you would for any other
<code>Fragment</code>. For example:</p>
<p>WHATSON? dddea5fc-f208-4d8e-b585-90da205e402b</p>
<pre>
public class SettingsActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Display the fragment as the main content.
        getFragmentManager().beginTransaction()
                .replace(android.R.id.content, new SettingsFragment())
                .commit();
    }
}
</pre>
<p><strong>Note:</strong> A <code>PreferenceFragment</code> doesn't have
a its own <code>Context</code> object. If you need a <code>Context</code>
object, you can call <code>getActivity()</code>. However, be careful to call
<code>getActivity()</code> only when the fragment is attached to an activity. When
the fragment is not yet attached, or was detached during the end of its lifecycle, <code>getActivity()</code> will return null.</p>
<h2>Setting Default Values</h2>
<p>The preferences you create probably define some important behaviors for your application, so it's
necessary that you initialize the associated <code>SharedPreferences</code> file with
default values for each <code>Preference</code> when the user first opens your
application.</p>
<p>The first thing you must do is specify a default value for each <code>Preference</code>
object in your XML file using the <code>android:defaultValue</code> attribute. The value can be any data
type that is appropriate for the corresponding <code>Preference</code> object. For
example:</p>
<p>WHATSON? d950092c-15a2-403b-83cd-9f4945fc8bb5</p>
<pre>
&lt;!-- default value is a boolean --&gt;
&lt;CheckBoxPreference
    android:defaultValue="true"
    ... /&gt;

&lt;!-- default value is a string --&gt;
&lt;ListPreference
    android:defaultValue="@string/pref_syncConnectionTypes_default"
    ... /&gt;
</pre>
<p>Then, from the <code>onCreate()</code> method in your application's main
activity—and in any other activity through which the user may enter your application for the
first time—call <code>setDefaultValues()</code>:</p>
<p>WHATSON? bd9a33ce-d7ff-40f4-8500-6be1c5370041</p>
<pre>
PreferenceManager.setDefaultValues(this, R.xml.advanced_preferences, false);
</pre>
<p>Calling this during <code>onCreate()</code> ensures that your
application is properly initialized with default settings, which your application might need to
read in order to determine some behaviors (such as whether to download data while on a
cellular network).</p>
<p>This method takes three arguments:</p>
<ul>
  <li>Your application <code>Context</code>.</li>
  <li>The resource ID for the preference XML file for which you want to set the default values.</li>
  <li>A boolean indicating whether the default values should be set more than once.
<p>When <code>false</code>, the system sets the default values only if this method has never been
called in the past (or the <code>KEY_HAS_SET_DEFAULT_VALUES</code>
in the default value shared preferences file is false).</p></li>
</ul>
<p>When <code>false</code>, the system sets the default values only if this method has never been
called in the past (or the <code>KEY_HAS_SET_DEFAULT_VALUES</code>
in the default value shared preferences file is false).</p>
<p>As long as you set the third argument to <code>false</code>, you can safely call this method
every time your activity starts without overriding the user's saved preferences by resetting them to
the defaults. However, if you set it to <code>true</code>, you will override any previous
values with the defaults.</p>
<h2>Using Preference Headers</h2>
<p>In rare cases, you might want to design your settings such that the first screen
displays only a list of subscreens (such as in the system Settings app,
as shown in figures 4 and 5). When you're developing such a design for Android 3.0 and higher, you
should use a new "headers" feature in Android 3.0, instead of building subscreens with nested
<code>PreferenceScreen</code> elements.</p>
<p>To build your settings with headers, you need to:</p>
<ol>
  <li>Separate each group of settings into separate instances of <code>PreferenceFragment</code>. That is, each group of settings needs a separate XML
file.</li>
  <li>Create an XML headers file that lists each settings group and declares which fragment
contains the corresponding list of settings.</li>
  <li>Extend the <code>PreferenceActivity</code> class to host your settings.</li>
  <li>Implement the <code>onBuildHeaders()</code> callback to specify the
headers file.</li>
</ol>
<p>A great benefit to using this design is that <code>PreferenceActivity</code>
automatically presents the two-pane layout shown in figure 4 when running on large screens.</p>
<p>Even if your application supports versions of Android older than 3.0, you can build your
application to use <code>PreferenceFragment</code> for a two-pane presentation on
newer devices while still supporting a traditional multi-screen hierarchy on older
devices (see the section about Supporting older versions with
preference headers).</p>
<p><strong>Figure 4.</strong> Two-pane layout with headers. <br><b>1.</b> The
headers are defined with an XML headers file. <br><b>2.</b> Each group of settings is defined by a
<code>PreferenceFragment</code> that's specified by a <code>&lt;header&gt;</code> element in
the headers file.</p>
<p><strong>Figure 5.</strong> A handset device with setting headers. When an
item is selected, the associated <code>PreferenceFragment</code> replaces the
headers.</p>
<h3>Creating the headers file</h3>
<p>Each group of settings in your list of headers is specified by a single <code>&lt;header&gt;</code>
element inside a root <code>&lt;preference-headers&gt;</code> element. For example:</p>
<p>WHATSON? 17c1d9de-1369-47f0-93f0-ecb9634ab5d0</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;preference-headers xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsActivity$SettingsFragmentOne"
        android:title="@string/prefs_category_one"
        android:summary="@string/prefs_summ_category_one" /&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsActivity$SettingsFragmentTwo"
        android:title="@string/prefs_category_two"
        android:summary="@string/prefs_summ_category_two" &gt;
        &lt;!-- key/value pairs can be included as arguments for the fragment. --&gt;
        &lt;extra android:name="someKey" android:value="someHeaderValue" /&gt;
    &lt;/header&gt;
&lt;/preference-headers&gt;
</pre>
<p>With the <code>android:fragment</code> attribute, each header declares an instance of <code>PreferenceFragment</code> that should open when the user selects the header.</p>
<p>The <code>&lt;extras&gt;</code> element allows you to pass key-value pairs to the fragment in a <code>Bundle</code>. The fragment can retrieve the arguments by calling <code>getArguments()</code>. You might pass arguments to the fragment for a variety of
reasons, but one good reason is to reuse the same subclass of <code>PreferenceFragment</code> for each group and use the argument to specify which
preferences XML file the fragment should load.</p>
<p>For example, here's a fragment that can be reused for multiple settings groups, when each
header defines an <code>&lt;extra&gt;</code> argument with the <code>"settings"</code> key:</p>
<p>WHATSON? 8cc3c7b8-e12a-4eb8-9ce6-5f0691ee7a9d</p>
<pre>
public static class SettingsFragment extends PreferenceFragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String settings = getArguments().getString("settings");
        if ("notifications".equals(settings)) {
            addPreferencesFromResource(R.xml.settings_wifi);
        } else if ("sync".equals(settings)) {
            addPreferencesFromResource(R.xml.settings_sync);
        }
    }
}
</pre>
<h3>Displaying the headers</h3>
<p>To display the preference headers, you must implement the <code>onBuildHeaders()</code> callback method and call
<code>loadHeadersFromResource()</code>. For example:</p>
<p>WHATSON? 31ebc820-1664-4e88-acb2-ff7e14e164e1</p>
<pre>
public class SettingsActivity extends PreferenceActivity {
    @Override
    public void onBuildHeaders(List&lt;Header&gt; target) {
        loadHeadersFromResource(R.xml.preference_headers, target);
    }
}
</pre>
<p>When the user selects an item from the list of headers, the system opens the associated <code>PreferenceFragment</code>.</p>
<p><strong>Note:</strong> When using preference headers, your subclass of <code>PreferenceActivity</code> doesn't need to implement the <code>onCreate()</code> method, because the only required
task for the activity is to load the headers.</p>
<h3>Supporting older versions with preference headers</h3>
<p>If your application supports versions of Android older than 3.0, you can still use headers to
provide a two-pane layout when running on Android 3.0 and higher. All you need to do is create an
additional preferences XML file that uses basic <code>&lt;Preference&gt;</code> elements that behave like the header items (to be used by the older Android
versions).</p>
<p>Instead of opening a new <code>PreferenceScreen</code>, however, each of the <code>&lt;Preference&gt;</code> elements sends an <code>Intent</code> to
the <code>PreferenceActivity</code> that specifies which preference XML file to
load.</p>
<p>For example, here's an XML file for preference headers that is used on Android 3.0
and higher (<code>res/xml/preference_headers.xml</code>):</p>
<p>WHATSON? 2a52c6d4-5fa3-4eb1-944f-c5713be4583d</p>
<pre>
&lt;preference-headers xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsFragmentOne"
        android:title="@string/prefs_category_one"
        android:summary="@string/prefs_summ_category_one" /&gt;
    &lt;header 
        android:fragment="com.example.prefs.SettingsFragmentTwo"
        android:title="@string/prefs_category_two"
        android:summary="@string/prefs_summ_category_two" /&gt;
&lt;/preference-headers&gt;
</pre>
<p>And here is a preference file that provides the same headers for versions older than
Android 3.0 (<code>res/xml/preference_headers_legacy.xml</code>):</p>
<p>WHATSON? 8160226d-e76e-426f-b722-4aedc1097f23</p>
<pre>
&lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;Preference 
        android:title="@string/prefs_category_one"
        android:summary="@string/prefs_summ_category_one"  &gt;
        &lt;intent 
            android:targetPackage="com.example.prefs"
            android:targetClass="com.example.prefs.SettingsActivity"
            android:action="com.example.prefs.PREFS_ONE" /&gt;
    &lt;/Preference&gt;
    &lt;Preference 
        android:title="@string/prefs_category_two"
        android:summary="@string/prefs_summ_category_two" &gt;
        &lt;intent 
            android:targetPackage="com.example.prefs"
            android:targetClass="com.example.prefs.SettingsActivity"
            android:action="com.example.prefs.PREFS_TWO" /&gt;
    &lt;/Preference&gt;
&lt;/PreferenceScreen&gt;
</pre>
<p>Because support for <code>&lt;preference-headers&gt;</code> was added in Android 3.0, the system calls
<code>onBuildHeaders()</code> in your <code>PreferenceActivity</code> only when running on Androd 3.0 or higher. In order to load
the "legacy" headers file (<code>preference_headers_legacy.xml</code>), you must check the Android
version and, if the version is older than Android 3.0 (<code>HONEYCOMB</code>), call <code>addPreferencesFromResource()</code> to
load the legacy header file. For example:</p>
<p>WHATSON? e8af5b94-b784-47d5-ad60-d16b5e95197c</p>
<pre>
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ...

    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        // Load the legacy preferences headers
        addPreferencesFromResource(R.xml.preference_headers_legacy);
    }
}

// Called only on Honeycomb and later
@Override
public void onBuildHeaders(List&lt;Header&gt; target) {
   loadHeadersFromResource(R.xml.preference_headers, target);
}
</pre>
<p>The only thing left to do is handle the <code>Intent</code> that's passed into the
activity to identify which preference file to load. So retrieve the intent's action and compare it
to known action strings that you've used in the preference XML's <code>&lt;intent&gt;</code> tags:</p>
<p>WHATSON? b1f72b12-6dc3-4cf5-b88f-6cdfc76a88ff</p>
<pre>
final static String ACTION_PREFS_ONE = "com.example.prefs.PREFS_ONE";
...

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    String action = getIntent().getAction();
    if (action != null &amp;&amp; action.equals(ACTION_PREFS_ONE)) {
        addPreferencesFromResource(R.xml.preferences);
    }
    ...

    else if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        // Load the legacy preferences headers
        addPreferencesFromResource(R.xml.preference_headers_legacy);
    }
}
</pre>
<p>Beware that consecutive calls to <code>addPreferencesFromResource()</code> will
stack all the preferences in a single list, so be sure that it's only called once by chaining the
conditions with else-if statements.</p>
<h2>Reading Preferences</h2>
<p>By default, all your app's preferences are saved to a file that's accessible from anywhere
within your application by calling the static method <code>PreferenceManager.getDefaultSharedPreferences()</code>. This returns the <code>SharedPreferences</code> object containing all the key-value pairs that are associated
with the <code>Preference</code> objects used in your <code>PreferenceActivity</code>.</p>
<p>For example, here's how you can read one of the preference values from any other activity in your
application:</p>
<p>WHATSON? 12e95cd8-f723-4ae8-ac3d-6c8158ee37cd</p>
<pre>
SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
String syncConnPref = sharedPref.getString(SettingsActivity.KEY_PREF_SYNC_CONN, "");
</pre>
<h3>Listening for preference changes</h3>
<p>There are several reasons you might want to be notified as soon as the use changes one of the
preferences. In order to receive a callback when a change happens to any one of the preferences,
implement the <code>SharedPreference.OnSharedPreferenceChangeListener</code> interface and register the listener for the
<code>SharedPreferences</code> object by calling <code>registerOnSharedPreferenceChangeListener()</code>.</p>
<p>The interface has only one callback method, <code>onSharedPreferenceChanged()</code>, and you might find it easiest to implement the interface as a part of
your activity. For example:</p>
<p>WHATSON? f94140de-5ae7-400c-aa61-2a9f7f8e34bd</p>
<pre>
public class SettingsActivity extends PreferenceActivity
                              implements OnSharedPreferenceChangeListener {
    public static final String KEY_PREF_SYNC_CONN = "pref_syncConnectionType";
    ...

    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
        String key) {
        if (key.equals(KEY_PREF_SYNC_CONN)) {
            Preference connectionPref = findPreference(key);
            // Set summary to be the user-description for the selected value
            connectionPref.setSummary(sharedPreferences.getString(key, ""));
        }
    }
}
</pre>
<p>In this example, the method checks whether the changed setting is for a known preference key. It
calls <code>findPreference()</code> to get the
<code>Preference</code> object that was changed so it can modify the item's
summary to be a description of the user's selection. That is, when the setting is a <code>ListPreference</code> or other multiple choice setting, you should call <code>setSummary()</code> when the setting changes to display the
current status (such as the Sleep setting shown in figure 5).</p>
<p><strong>Note:</strong> As described in the Android Design document about Settings, we recommend that you update the
summary for a <code>ListPreference</code> each time the user changes the preference in
order to describe the current setting.</p>
<p>For proper lifecycle management in the activity, we recommend that you register and unregister
your <code>SharedPreferences.OnSharedPreferenceChangeListener</code> during the <code>onResume()</code> and <code>onPause()</code> callbacks, respectively:</p>
<p>WHATSON? df338697-28e9-40b8-9475-6b0bad275387</p>
<pre>
@Override
protected void onResume() {
    super.onResume();
    getPreferenceScreen().getSharedPreferences()
            .registerOnSharedPreferenceChangeListener(this);
}

@Override
protected void onPause() {
    super.onPause();
    getPreferenceScreen().getSharedPreferences()
            .unregisterOnSharedPreferenceChangeListener(this);
}
</pre>
<p><strong>Caution:</strong> When you call <code>registerOnSharedPreferenceChangeListener()</code>, the preference manager does not
currently store a strong reference to the listener. You must store a strong
reference to the listener, or it will be susceptible to garbage collection. We
recommend you keep a reference to the listener in the instance data of an object
that will exist as long as you need the listener.</p>
<p>For example, in the following code, the caller does not keep a reference to
the listener. As a result, the listener will be subject to garbage collection,
and it will fail at some indeterminate time in the future:</p>
<p>WHATSON? db7a024b-6c6e-447a-9351-4ae9decf005c</p>
<pre>
prefs.registerOnSharedPreferenceChangeListener(
  // Bad! The listener is subject to garbage collection!
  new SharedPreferences.OnSharedPreferenceChangeListener() {
  public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
    // listener implementation
  }
});
</pre>
<p>Instead, store a reference to the listener in an instance data field of an
object that will exist as long as the listener is needed:</p>
<p>WHATSON? 9511c3a4-66e8-4a68-b21b-bde31b2925c8</p>
<pre>
SharedPreferences.OnSharedPreferenceChangeListener listener =
    new SharedPreferences.OnSharedPreferenceChangeListener() {
  public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
    // listener implementation
  }
};
prefs.registerOnSharedPreferenceChangeListener(listener);
</pre>
<h2>Managing Network Usage</h2>
<p>Beginning with Android 4.0, the system's Settings application allows users to see how much
network data their applications are using while in the foreground and background. Users can then
disable the use of background data for individual apps. In order to avoid users disabling your app's
access to data from the background, you should use the data connection efficiently and allow
users to refine your app's data usage through your application settings.</p>
<p>

</p>
<p>For example, you might allow the user to control how often your app syncs data, whether your app
performs uploads/downloads only when on Wi-Fi, whether your app uses data while roaming, etc. With
these controls available to them, users are much less likely to disable your app's access to data
when they approach the limits they set in the system Settings, because they can instead precisely
control how much data your app uses.</p>
<p>Once you've added the necessary preferences in your <code>PreferenceActivity</code>
to control your app's data habits, you should add an intent filter for <code>ACTION_MANAGE_NETWORK_USAGE</code> in your manifest file. For example:</p>
<p>WHATSON? d4d5574e-b927-4a81-9060-81d69f41e121</p>
<pre>
&lt;activity android:name="SettingsActivity" ... &gt;
    &lt;intent-filter&gt;
       &lt;action android:name="android.intent.action.MANAGE_NETWORK_USAGE" /&gt;
       &lt;category android:name="android.intent.category.DEFAULT" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p>This intent filter indicates to the system that this is the activity that controls your
application's data usage. Thus, when the user inspects how much data your app is using from the
system's Settings app, a <em>View application settings</em> button is available that launches your
<code>PreferenceActivity</code> so the user can refine how much data your app
uses.</p>
<h2>Building a Custom Preference</h2>
<p>The Android framework includes a variety of <code>Preference</code> subclasses that
allow you to build a UI for several different types of settings.
However, you might discover a setting you need for which there’s no built-in solution, such as a
number picker or date picker. In such a case, you’ll need to create a custom preference by extending
the <code>Preference</code> class or one of the other subclasses.</p>
<p>When you extend the <code>Preference</code> class, there are a few important
things you need to do:</p>
<ul>
  <li>Specify the user interface that appears when the user selects the settings.</li>
  <li>Save the setting's value when appropriate.</li>
  <li>Initialize the <code>Preference</code> with the current (or default) value
when it comes into view.</li>
  <li>Provide the default value when requested by the system.</li>
  <li>If the <code>Preference</code> provides its own UI (such as a dialog), save
and restore the state to handle lifecycle changes (such as when the user rotates the screen).</li>
</ul>
<p>The following sections describe how to accomplish each of these tasks.</p>
<h3>Specifying the user interface</h3>
<p>If you directly extend the <code>Preference</code> class, you need to implement
<code>onClick()</code> to define the action that occurs when the user
selects the item. However, most custom settings extend <code>DialogPreference</code> to
show a dialog, which simplifies the procedure. When you extend <code>DialogPreference</code>, you must call <code>setDialogLayoutResourcs()</code> during in the
class constructor to specify the layout for the dialog.</p>
<p>For example, here's the constructor for a custom <code>DialogPreference</code> that declares the layout and specifies the text for the
default positive and negative dialog buttons:</p>
<p>WHATSON? db843e0a-0a6f-4ad8-9c9e-85fc5a7edeb8</p>
<pre>
public class NumberPickerPreference extends DialogPreference {
    public NumberPickerPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        
        setDialogLayoutResource(R.layout.numberpicker_dialog);
        setPositiveButtonText(android.R.string.ok);
        setNegativeButtonText(android.R.string.cancel);
        
        setDialogIcon(null);
    }
    ...
}
</pre>
<h3>Saving the setting's value</h3>
<p>You can save a value for the setting at any time by calling one of the <code>Preference</code> class's <code>persist*()</code> methods, such as <code>persistInt()</code> if the setting's value is an integer or
<code>persistBoolean()</code> to save a boolean.</p>
<p><strong>Note:</strong> Each <code>Preference</code> can save only one
data type, so you must use the <code>persist*()</code> method appropriate for the data type used by your
custom <code>Preference</code>.</p>
<p>When you choose to persist the setting can depend on which <code>Preference</code> class you extend. If you extend <code>DialogPreference</code>, then you should persist the value only when the dialog
closes due to a positive result (the user selects the "OK" button).</p>
<p>When a <code>DialogPreference</code> closes, the system calls the <code>onDialogClosed()</code> method. The method includes a
boolean argument that specifies whether the user result is "positive"—if the value is
<code>true</code>, then the user selected the positive button and you should save the new value. For
example:</p>
<p>WHATSON? eae17a8a-572b-42ce-9c2a-99e6dec95e3c</p>
<pre>
@Override
protected void onDialogClosed(boolean positiveResult) {
    // When the user selects "OK", persist the new value
    if (positiveResult) {
        persistInt(mNewValue);
    }
}
</pre>
<p>In this example, <code>mNewValue</code> is a class member that holds the setting's current
value. Calling <code>persistInt()</code> saves the value to
the <code>SharedPreferences</code> file (automatically using the key that's
specified in the XML file for this <code>Preference</code>).</p>
<h3>Initializing the current value</h3>
<p>When the system adds your <code>Preference</code> to the screen, it
calls <code>onSetInitialValue()</code> to notify
you whether the setting has a persisted value. If there is no persisted value, this call provides
you the default value.</p>
<p>The <code>onSetInitialValue()</code> method passes
a boolean, <code>restorePersistedValue</code>, to indicate whether a value has already been persisted
for the setting. If it is <code>true</code>, then you should retrieve the persisted value by calling
one of the <code>Preference</code> class's <code>getPersisted*()</code> methods, such as <code>getPersistedInt()</code> for an integer value. You'll
usually want to retrieve the persisted value so you can properly update the UI to reflect the
previously saved value.</p>
<p>If <code>restorePersistedValue</code> is <code>false</code>, then you
should use the default value that is passed in the second argument.</p>
<p>WHATSON? 3acc838b-2d44-41d3-b51f-4cf004bbcff4</p>
<pre>
@Override
protected void onSetInitialValue(boolean restorePersistedValue, Object defaultValue) {
    if (restorePersistedValue) {
        // Restore existing state
        mCurrentValue = this.getPersistedInt(DEFAULT_VALUE);
    } else {
        // Set default state from the XML attribute
        mCurrentValue = (Integer) defaultValue;
        persistInt(mCurrentValue);
    }
}
</pre>
<p>Each <code>getPersisted*()</code> method takes an argument that specifies the
default value to use in case there is actually no persisted value or the key does not exist. In
the example above, a local constant is used to specify the default value in case <code>getPersistedInt()</code> can't return a persisted value.</p>
<p><strong>Caution:</strong> You <strong>cannot</strong> use the
<code>defaultValue</code> as the default value in the <code>getPersisted*()</code> method, because
its value is always null when <code>restorePersistedValue</code> is <code>true</code>.</p>
<h3>Providing a default value</h3>
<p>If the instance of your <code>Preference</code> class specifies a default value
(with the <code>android:defaultValue</code> attribute), then the
system calls <code>onGetDefaultValue()</code> when it instantiates the object in order to retrieve the value. You must
implement this method in order for the system to save the default value in the <code>SharedPreferences</code>. For example:</p>
<p>WHATSON? 7ea7a42e-5175-43e0-870f-ae5e166b2e98</p>
<pre>
@Override
protected Object onGetDefaultValue(TypedArray a, int index) {
    return a.getInteger(index, DEFAULT_VALUE);
}
</pre>
<p>The method arguments provide everything you need: the array of attributes and the index
position of the <code>android:defaultValue</code>, which you must retrieve. The reason you must
implement this method to extract the default value from the attribute is because you must specify
a local default value for the attribute in case the value is undefined.</p>
<h3>Saving and restoring the Preference's state</h3>
<p>Just like a <code>View</code> in a layout, your <code>Preference</code>
subclass is responsible for saving and restoring its state in case the activity or fragment is
restarted (such as when the user rotates the screen). To properly save and
restore the state of your <code>Preference</code> class, you must implement the
lifecycle callback methods <code>onSaveInstanceState()</code> and <code>onRestoreInstanceState()</code>.</p>
<p>The state of your <code>Preference</code> is defined by an object that implements
the <code>Parcelable</code> interface. The Android framework provides such an object for you
as a starting point to define your state object: the <code>Preference.BaseSavedState</code> class.</p>
<p>To define how your <code>Preference</code> class saves its state, you should
extend the <code>Preference.BaseSavedState</code> class. You need to override just
 a few methods and define the <code>CREATOR</code>
object.</p>
<p>For most apps, you can copy the following implementation and simply change the lines that
handle the <code>value</code> if your <code>Preference</code> subclass saves a data
type other than an integer.</p>
<p>WHATSON? b2650f7e-2fd1-40b1-8d59-0b4170a721fe</p>
<pre>
private static class SavedState extends BaseSavedState {
    // Member that holds the setting's value
    // Change this data type to match the type saved by your Preference
    int value;

    public SavedState(Parcelable superState) {
        super(superState);
    }

    public SavedState(Parcel source) {
        super(source);
        // Get the current preference's value
        value = source.readInt();  // Change this to read the appropriate data type
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        super.writeToParcel(dest, flags);
        // Write the preference's value
        dest.writeInt(value);  // Change this to write the appropriate data type
    }

    // Standard creator object using an instance of this class
    public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =
            new Parcelable.Creator&lt;SavedState&gt;() {

        public SavedState createFromParcel(Parcel in) {
            return new SavedState(in);
        }

        public SavedState[] newArray(int size) {
            return new SavedState[size];
        }
    };
}
</pre>
<p>With the above implementation of <code>Preference.BaseSavedState</code> added
to your app (usually as a subclass of your <code>Preference</code> subclass), you
then need to implement the <code>onSaveInstanceState()</code> and <code>onRestoreInstanceState()</code> methods for your
<code>Preference</code> subclass.</p>
<p>For example:</p>
<p>WHATSON? 95c2762b-1593-4e53-b7df-78064d6f672f</p>
<pre>
@Override
protected Parcelable onSaveInstanceState() {
    final Parcelable superState = super.onSaveInstanceState();
    // Check whether this Preference is persistent (continually saved)
    if (isPersistent()) {
        // No need to save instance state since it's persistent,
        // use superclass state
        return superState;
    }

    // Create instance of custom BaseSavedState
    final SavedState myState = new SavedState(superState);
    // Set the state's value with the class member that holds current
    // setting value
    myState.value = mNewValue;
    return myState;
}

@Override
protected void onRestoreInstanceState(Parcelable state) {
    // Check whether we saved the state in onSaveInstanceState
    if (state == null || !state.getClass().equals(SavedState.class)) {
        // Didn't save the state, so call superclass
        super.onRestoreInstanceState(state);
        return;
    }

    // Cast state to custom BaseSavedState and pass to superclass
    SavedState myState = (SavedState) state;
    super.onRestoreInstanceState(myState.getSuperState());
    
    // Set this Preference's widget to reflect the restored state
    mNumberPicker.setValue(myState.value);
}
</pre>
</body>
</html>