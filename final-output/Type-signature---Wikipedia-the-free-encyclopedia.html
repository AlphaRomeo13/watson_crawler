<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Type-signature---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Type signature</h1>
<p>In computer science, a <b>type signature</b> or <b>type annotation</b> defines the inputs and outputs for a function, subroutine or method. A type signature includes at least the function name and the number of its arguments. In some programming languages, it may also specify the function's return type, the types of its arguments, or errors it may pass back.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Examples
<ul>
<li>1.1 C/C++</li>
<li>1.2 Erlang</li>
<li>1.3 Haskell</li>
<li>1.4 Java</li>
</ul>
</li>
<li>2 Signature</li>
<li>3 Method signature</li>
<li>4 Examples
<ul>
<li>4.1 C/C++</li>
<li>4.2 C#</li>
<li>4.3 Java</li>
<li>4.4 Objective-C</li>
</ul>
</li>
<li>5 References</li>
</ul>
<ul>
<li>1.1 C/C++</li>
<li>1.2 Erlang</li>
<li>1.3 Haskell</li>
<li>1.4 Java</li>
</ul>
<ul>
<li>4.1 C/C++</li>
<li>4.2 C#</li>
<li>4.3 Java</li>
<li>4.4 Objective-C</li>
</ul>
<p></p>
<h2>Examples</h2>
<h3>C/C++</h3>
<p>In C and C++, the type signature is declared by what is commonly known as a function prototype. In C/C++, a function declaration reflects its use; for example, a function pointer that would be invoked as:</p>
<p>WHATSON? 6b9448e5-b513-4a58-aee9-d9a289d6ff47</p>
<pre>
char c;
double d;
int retVal = (*fPtr)(c, d);
</pre>
<p>has the signature:</p>
<p>WHATSON? 6279c147-da72-403a-ac31-12a677bdfbc7</p>
<pre>
(int) (char, double);
</pre>
<h3>Erlang</h3>
<p>In Erlang, type signatures may be optionally declared, as:</p>
<p>WHATSON? 81df09c0-6f42-4c49-800b-73b3318ddc8e</p>
<pre>
-spec(function_name(type1(), type2(), ...) -&gt; out_type()).
</pre>
<p>For example:</p>
<p>WHATSON? 5995fad7-6c43-4004-81cd-718e353ae535</p>
<pre>
-spec(is_even(number()) -&gt; boolean()).
</pre>
<h3>Haskell</h3>
<p>A type signature in the Haskell programming language is generally written in the following format:</p>
<p>WHATSON? d14944e7-7734-4859-8b29-5ac5d3f2d90f</p>
<pre>
functionName :: arg1Type -&gt; arg2Type -&gt; ... -&gt; argNType
</pre>
<p>Notice that the type of the result can be regarded as everything past the first supplied argument. This is a consequence of currying, which is made possible by Haskell's support for first-class functions; this function requires two inputs where one argument supplied and the function is "curried" to produce a function for the argument not supplied. Thus calling f(x), where f :: a -&gt; b -&gt; c, yields a new function f2 :: b -&gt; c that can be called f2(b) to produce c.</p>
<p>The actual type specifications can consist of an actual type, such as Integer, or a general type variable that is used in parametric polymorphic functions, such as a, or b, or anyType. So we can write something like: functionName :: a -&gt; a -&gt; ... -&gt; a</p>
<p>Since Haskell supports higher-order functions, functions can be passed as arguments. This is written as: functionName :: (a -&gt; a) -&gt; a</p>
<p>This function takes in a function with type signature a -&gt; a and returns data of type a out.</p>
<h3>Java</h3>
<p>In the Java virtual machine, <i>internal type signatures</i> are used to identify methods and classes at the level of the virtual machine code.</p>
<p>Example: The method String String.substring(int, int) is represented as Ljava/lang/String/substring(II)Ljava/lang/String;. The signature of <code>main()</code> method looks like this:</p>
<p>WHATSON? 88e04d3a-7010-43c1-ae0c-4f4bcd59e2e1</p>
<pre>
public static void main(String args[])
</pre>
<p>The method signature for the <code>main()</code> method contains three modifiers:</p>
<ul>
<li><code>public</code> indicates that the <code>main()</code> method can be called by any object.</li>
<li><code>static</code> indicates that the <code>main()</code> method is a class method.</li>
<li><code>void</code> indicates that the <code>main()</code> method has no return value.</li>
</ul>
<h2>Signature</h2>
<p>A function signature consists of the function prototype. It specifies the general information about a function like the name, scope and parameters. Many programming languages use name mangling in order to pass along more semantic information from the compilers to the linkers. In addition to mangling, there is an excess of information in a function signature (stored internally to most compilers) which is not readily available, but may be accessed.</p>
<p>Understanding the notion of a function signature is an important concept for all computer science studies.</p>
<ul>
<li>Modern object orientation techniques make use of interfaces, which are essentially templates made from function signatures.</li>
<li>C/C++ uses function overloading with various signatures.</li>
</ul>
<p>The practice of multiple inheritance requires consideration of the function signatures to avoid unpredictable results.</p>
<p>Computer science theory, and the concept of polymorphism in particular, make much use of the concept of function signature.</p>
<p>In the C programming language signature is roughly equivalent to its prototype definition.</p>
<p>The term "signature" may carry other meanings in computer science. For example:</p>
<ul>
<li>File signatures can identify or verify the content of a file.</li>
<li>Database signatures can identify or verify the schema or a version of a database.</li>
<li>In the ML family of programming languages, "signature" is used as a keyword referring to a construct of the module system that plays the role of an interface.</li>
</ul>
<h2>Method signature</h2>
<p>In computer programming, especially object-oriented programming, a method is commonly identified by its unique <b>method signature</b>, which usually includes the method name, and the number, types and order of its parameters. A method signature is the smallest type of a method.</p>
<h2>Examples</h2>
<h3>C/C++</h3>
<p>In C/C++, the method signature is the method name and the number and type of its parameters, but it is possible to have a last parameter that consists of an array of values:</p>
<p>WHATSON? 09226100-b043-4e5b-9d11-b0b08b67536c</p>
<pre>
int printf(const char*, ... );
</pre>
<p>Manipulation of these parameters can be done by using the routines in the standard library header &lt;stdarg.h&gt;.</p>
<h3>C#</h3>
<p>Similar to the C syntax, C# sees as the method signature its name and the number and type of its parameters, where the last parameter may be an array of values:</p>
<p>WHATSON? d8f28160-dcbc-49c6-becb-eb0315e435b7</p>
<pre>
void Add(out int sum, params int[] value);
[...]
Add(out sum, 3, 5, 7, 11, -1);  // sum == 25
</pre>
<h3>Java</h3>
<p>In the Java programming language, a method signature is the method name and the number and type of its parameters. Return types and thrown exceptions are not considered to be a part of the method signature.</p>
<p>WHATSON? 606f4652-d951-477a-ad36-947d1df79203</p>
<pre>
methodName(parameters) {...};
</pre>
<p>For example, the following two methods have distinct signatures:</p>
<p>WHATSON? 01c32452-cbd8-4739-8a77-f4376f1ed26a</p>
<pre>
doSomething(int y);
doSomething(String y);
</pre>
<p>The following three methods do have the same signatures and are considered the same, as only the return value differs. The name of the parameter is not part of the method signature and is ignored by the compiler for checking method uniqueness.</p>
<p>WHATSON? 555a4f11-534c-4c4a-b8d0-5dfeb95f094d</p>
<pre>
int doSomething(int y) 
String doSomething(int x)
int doSomething(int z) throws java.lang.Exception
</pre>
<h3>Objective-C</h3>
<p>In the Objective-C programming language, method signatures for an object are declared in the interface header file. For example,</p>
<p>WHATSON? 47ab07f1-1f78-42ea-a471-57a201aa0a38</p>
<pre>
- (id)initWithInt:(int)value;
</pre>
<p>defines a method initWithInt that returns a general object (an id) and takes one integer argument. Objective-C only requires a type in a signature to be explicit when the type is not id; this signature is equivalent:</p>
<p>WHATSON? a92902ed-4d1c-42b6-a26a-47618fa9030e</p>
<pre>
- initWithInt:(int)value;
</pre>
</body>
</html>