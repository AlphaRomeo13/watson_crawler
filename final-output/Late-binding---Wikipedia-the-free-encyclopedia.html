<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Late-binding---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Late binding</h1>
<p><b>Late binding</b>, or <b>dynamic binding</b>, is a computer programming mechanism in which the method being called upon an object is looked up by name at runtime.</p>
<p>With early binding, or static binding, the compilation phase fixes all types of variables and expressions. This is usually stored in the compiled program as an offset in a virtual method table ("v-table") and is very efficient. With late binding the compiler does not have enough information to verify the method even exists, let alone bind to its particular slot on the v-table. Instead the method is looked up by name at runtime.</p>
<p>The primary advantage of using late binding in Component Object Model (COM) programming is that it does not require the compiler to reference the libraries that contain the object at compile time. This makes the compilation process more resistant to version conflicts, in which the class's v-table may be accidentally modified. (This is not a concern in JIT-compiled platforms such as .NET or Java, because the v-table is created at runtime by the virtual machine against the libraries as they are being loaded into the running application.)</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Late binding implementations
<ul>
<li>2.1 Late binding in dynamically-typed languages</li>
<li>2.2 Late binding in C++</li>
<li>2.3 Late binding in COM languages</li>
<li>2.4 Late binding in .NET</li>
<li>2.5 Late binding in Java</li>
<li>2.6 Early vs. late binding in PL/SQL and Ada</li>
</ul>
</li>
<li>3 Criticism</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<ul>
<li>2.1 Late binding in dynamically-typed languages</li>
<li>2.2 Late binding in C++</li>
<li>2.3 Late binding in COM languages</li>
<li>2.4 Late binding in .NET</li>
<li>2.5 Late binding in Java</li>
<li>2.6 Early vs. late binding in PL/SQL and Ada</li>
</ul>
<p></p>
<h2>History</h2>
<p>The term "late binding" dates back to at least the 1960s, where it can be found in <i>Communications of the ACM</i>. The term was widely used to describe languages such as LISP, though usually with negative connotations about performance.</p>
<p>In the 1980s Smalltalk popularized object-oriented programming (OOP) and with it late binding. Dr. Alan Kay once said, "OOP to me means only messaging, local retention, and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them."</p>
<p>In the early to mid-1990s, Microsoft heavily promoted its COM standard as a binary interface between different OOP programming languages. COM programming equally promoted early and late binding, with many languages supporting both at the syntax level.</p>
<p>In 2000, Alex Martelli coined the term "duck typing" to refer to the same concept, but with a different emphasis. While late binding generally focuses on implementation details, duck typing focuses on the ability to ignore types and concentrate on the methods an object currently has.</p>
<h2>Late binding implementations</h2>
<h3>Late binding in dynamically-typed languages</h3>
<p>In most dynamically-typed languages, the list of methods on an object can be altered at runtime. For this reason most or all method calls on a dynamically-typed language are done exclusively via a late binding. These languages may not even have v-tables and instead store the methods in a dictionary.</p>
<h3>Late binding in C++</h3>
<p>In C++, late binding (also called "dynamic binding") is normally made happen by prepending the <i>virtual</i> keyword to a method. C++ will then create a so-called virtual table, which is a look-up table for functions that from now on will always be consulted on each function call. You may find further information about this type of late binding under the related article of dynamic dispatch; however, it must be noted that even in textbooks the "late binding" term <i>is</i> used in favor of "dynamic dispatch".</p>
<h3>Late binding in COM languages</h3>
<p>In COM programming a late-bound method call is performed using the IDispatch interface. Some COM-based languages such as Visual Basic 6 have syntactical support for calling this interface. This is done by defining the variable's type as Object. Others such as C++ require that you explicitly call GetIDsOfNames to look up a method and Invoke to call it.</p>
<h3>Late binding in .NET</h3>
<p>Like COM and Java, the Common Language Runtime provides reflection APIs that make late binding calls possible. The use of these calls varies by language (C# and Visual Basic).</p>
<p>Prior to version 4, C# only allowed late binding via the appropriate reflection API. A different API would be needed for each of .NET, COM, and DLR objects. With C# 4, the language gained the "dynamic" pseudo-type. This would be used in place of the Object type to indicate that late binding is desired. The specific late binding mechanism needed is determined at runtime using the Dynamic Language Runtime as a starting point.</p>
<p>Visual Basic uses them whenever the variable is of type Object and the compiler directive "Option Strict Off" is in force. This is the default setting for a new VB project. Prior to version 9, only .NET and COM objects could be late bound. With VB 10, this has been extended to DLR-based objects.</p>
<h3>Late binding in Java</h3>
<p>There are three definitions for late binding in Java.</p>
<p>Early documents on Java discussed how classes were not linked together at compile time. While types are statically checked at compile time, different implementations for classes could be swapped out just prior to runtime simply by overwriting the class file. As long as the new class definition had the same class and method names, the code would still work. In this sense it is similar to the traditional definition of late binding.</p>
<p>Currently, it is popular to use the term late binding in Java programming as a synonym for dynamic dispatch. Specifically, this refers to Java's single dispatch mechanism used with virtual methods.</p>
<p>Finally, Java can use late binding using its reflection APIs and type introspection much in the same way it is done in COM and .NET programming. Generally speaking those who only program in Java do not call this late binding. Likewise the use of "duck typing" techniques is frowned upon in Java programming, with abstract interfaces used instead.</p>
<p>It should be noted that Oracle, the current owner of Java, has been known to use the term late binding in the "duck typing" sense when discussing both Java and other languages in the same documentation.</p>
<h3>Early vs. late binding in PL/SQL and Ada</h3>
<p>When using early binding between Ada and a database-stored procedure, a timestamp is checked to verify that the stored procedure has not changed since the code was compiled. This allows for faster executions and prevents the application from running against the wrong version of a stored procedure.</p>
<p>When using late binding the timestamp check is not performed, and the stored procedure is executed via an anonymous PL/SQL block. While this can be slower, it removes the need to recompile all of the client applications when a stored procedure changes.</p>
<p>This distinction appears to be unique to PL/SQL and Ada. Other languages that can call PL/SQL procedures, as well as other database engines, only use late binding.</p>
<h2>Criticism</h2>
<p>Late binding has poorer performance than an early bound method call. Under most implementations the correct method address must be looked up by name with each call, requiring relatively expensive dictionary search and possibly overload resolution logic.</p>
<p>Late binding necessarily prevents the use of static type checking. When making a late bound call, the compiler has to assume that the method exists. This means a simple spelling error can cause a runtime error to be thrown. The exact exception varies by language, but it is usually named something like "Method Not Found" or "Method Missing".</p>
<p>Late binding prevents many forms of static analysis needed by an integrated development environment (IDE). For example, an IDE's "go to definition" feature cannot be used on a late-bound call, because the IDE has no way to know which class the call may refer to. Another problem is that the lack of typing information prevents the creation of dependency graphs. However, other programming methods such as abstract interfaces can result in the same problems.</p>
<p>Using late binding in medium or large software projects often makes them harder to maintain and troubleshoot. For example, a function called during runtime might not obtain a required lock, and tracing that down can be quite challenging and time-consuming.</p>
<h2>See also</h2>
<ul>
<li>Late linking</li>
<li>Dynamic linking</li>
<li>Dynamic dispatch</li>
<li>Name binding</li>
</ul>
</body>
</html>