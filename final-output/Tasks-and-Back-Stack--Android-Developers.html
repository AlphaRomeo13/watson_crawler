<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tasks-and-Back-Stack--Android-Developers.html</title></head>
<body>
<h1>Tasks and Back Stack</h1>
<h2>In this document</h2>
<ol>
<li>Saving Activity State</li>
<li>Managing Tasks
  <ol>
    <li>Defining launch modes</li>
    <li>Handling affinities</li>
    <li>Clearing the back stack</li>
    <li>Starting a task</li>
  </ol>
</li>
</ol>
<ol>
    <li>Defining launch modes</li>
    <li>Handling affinities</li>
    <li>Clearing the back stack</li>
    <li>Starting a task</li>
  </ol>
<h2>Articles</h2>
<ol>
  <li>
  Multitasking the Android Way</li>
</ol>
<h2>See also</h2>
<ol>
  <li>Android Design:
Navigation</li>
  <li><code>&lt;activity&gt;</code> manifest
element</li>
  <li>Overview Screen</li>
</ol>
<p>An application usually contains multiple activities. Each activity
should be designed around a specific kind of action the user can perform and can start other
activities. For example, an email application might have one activity to show a list of new messages.
When the user selects a message, a new activity opens to view that message.</p>
<p>An activity can even start activities that exist in other applications on the device. For
example, if your application wants to send an email message, you can define an intent to perform a
"send" action and include some data, such as an email address and a message. An activity from another
application that declares itself to handle this kind of intent then opens. In this case, the intent
is to send an email, so an email application's "compose" activity starts (if multiple activities
support the same intent, then the system lets the user select which one to use). When the email is
sent, your activity resumes and it seems as if the email activity was part of your application. Even
though the activities may be from different applications, Android maintains this seamless user
experience by keeping both activities in the same <em>task</em>.</p>
<p>A task is a collection of activities that users interact with
when performing a certain job. The activities are arranged in a stack (the <em>back stack</em>), in
the order in which each activity is opened.</p>
<p>The device Home screen is the starting place for most tasks. When the user touches an icon in the
application
launcher (or a shortcut on the Home screen), that application's task comes to the foreground. If no
task exists for the application (the application has not been used recently), then a new task
is created and the "main" activity for that application opens as the root activity in the stack.</p>
<p>When the current activity starts another, the new activity is pushed on the top of the stack and
takes focus. The previous activity remains in the stack, but is stopped. When an activity
stops, the system retains the current state of its user interface. When the user presses the
<em>Back</em>
button, the current activity is popped from the top of the stack (the activity is destroyed) and the
previous activity resumes (the previous state of its UI is restored). Activities in the stack are
never rearranged, only pushed and popped from the stack—pushed onto the stack when started by
the current activity and popped off when the user leaves it using the <em>Back</em> button. As such,
the back
stack operates as a "last in, first out" object structure. Figure 1 visualizes
this behavior with a timeline showing the progress between activities along with the current back
stack at each point in time.</p>
<p><strong>Figure 1.</strong> A representation of how each new activity in a
task adds an item to the back stack. When the user presses the <em>Back</em> button, the current
activity is
destroyed and the previous activity resumes.</p>
<p>If the user continues to press <em>Back</em>, then each activity in the stack is popped off to
reveal the
previous one, until the user returns to the Home screen (or to whichever activity was running when
the task began). When all activities are removed from the stack, the task no longer exists.</p>
<p><strong>Figure 2.</strong> Two tasks: Task B receives user interaction
in the foreground, while Task A is in the background, waiting to be resumed.</p>
<p><strong>Figure 3.</strong> A single activity is instantiated multiple times.</p>
<p>A task is a cohesive unit that can move to the "background" when users begin a new task or go
to the Home screen, via the <em>Home</em> button. While in the background, all the activities in the
task are
stopped, but the back stack for the task remains intact—the task has simply lost focus while
another task takes place, as shown in figure 2. A task can then return to the "foreground" so users
can pick up where they left off. Suppose, for example, that the current task (Task A) has three
activities in its stack—two under the current activity. The user presses the <em>Home</em>
button, then
starts a new application from the application launcher. When the Home screen appears, Task A goes
into the background. When the new application starts, the system starts a task for that application
(Task B) with its own stack of activities. After interacting with
that application, the user returns Home again and selects the application that originally
started Task A. Now, Task A comes to the
foreground—all three activities in its stack are intact and the activity at the top of the
stack resumes. At
this point, the user can also switch back to Task B by going Home and selecting the application icon
that started that task (or by selecting the app's task from the
overview screen).
This is an example of multitasking on Android.</p>
<p><strong>Note:</strong> Multiple tasks can be held in the background at once.
However, if the user is running many background tasks at the same time, the system might begin
destroying background activities in order to recover memory, causing the activity states to be lost.
See the following section about Activity state.</p>
<p>Because the activities in the back stack are never rearranged, if your application allows
users to start a particular activity from more than one activity, a new instance of
that activity is created and pushed onto the stack (rather than bringing any previous instance of
the activity to the top). As such, one activity in your application might be instantiated multiple
times (even from different tasks), as shown in figure 3. As such, if the user navigates backward
using the <em>Back</em> button, each instance of the activity is revealed in the order they were
opened (each
with their own UI state). However, you can modify this behavior if you do not want an activity to be
instantiated more than once. How to do so is discussed in the later section about Managing Tasks.</p>
<p>To summarize the default behavior for activities and tasks:</p>
<ul>
  <li>When Activity A starts Activity B, Activity A is stopped, but the system retains its state
(such as scroll position and text entered into forms).
If the user presses the <em>Back</em> button while in Activity B, Activity A resumes with its state
restored.</li>
  <li>When the user leaves a task by pressing the <em>Home</em> button, the current activity is
stopped and
its task goes into the background. The system retains the state of every activity in the task. If
the user later resumes the task by selecting the launcher icon that began the task, the task comes
to the foreground and resumes the activity at the top of the stack.</li>
  <li>If the user presses the <em>Back</em> button, the current activity is popped from the stack
and
destroyed. The previous activity in the stack is resumed. When an activity is destroyed, the system
<em>does not</em> retain the activity's state.</li>
  <li>Activities can be instantiated multiple times, even from other tasks.</li>
</ul>
<p><strong>Navigation Design</strong></p>
<p>For more about how app navigation works on Android, read Android Design's Navigation guide.</p>
<h2>Saving Activity State</h2>
<p>As discussed above, the system's default behavior preserves the state of an activity when it is
stopped. This way, when users navigate back to a previous activity, its user interface appears
the way they left it. However, you can—and <strong>should</strong>—proactively retain
the state of your activities using callback methods, in case the activity is destroyed and must
be recreated.</p>
<p>When the system stops one of your activities (such as when a new activity starts or the task
moves to the background), the system might destroy that activity completely if it needs to recover
system memory. When this happens, information about the activity state is lost. If this happens, the
system still
knows that the activity has a place in the back stack, but when the activity is brought to the
top of the stack the system must recreate it (rather than resume it). In order to
avoid losing the user's work, you should proactively retain it by implementing the
<code>onSaveInstanceState()</code> callback
methods in your activity.</p>
<p>For more information about how to save your activity state, see the Activities
document.</p>
<h2>Managing Tasks</h2>
<p>The way Android manages tasks and the back stack, as described above—by placing all
activities started in succession in the same task and in a "last in, first out" stack—works
great for most applications and you shouldn't have to worry about how your activities are associated
with tasks or how they exist in the back stack. However, you might decide that you want to interrupt
the normal behavior. Perhaps you want an activity in your application to begin a new task when it is
started (instead of being placed within the current task); or, when you start an activity, you want
to bring forward an existing instance of it (instead of creating a new
instance on top of the back stack); or, you want your back stack to be cleared of all
activities except for the root activity when the user leaves the task.</p>
<p>You can do these things and more, with attributes in the
<code>&lt;activity&gt;</code>
manifest element and with flags in the intent that you pass to
<code>startActivity()</code>.</p>
<p>In this regard, the principal 
<code>&lt;activity&gt;</code> attributes you can use are:</p>
<ul>
  <li>
  <code>taskAffinity</code></li>
  <li>
  <code>launchMode</code></li>
  <li>
  <code>allowTaskReparenting</code></li>
  <li>
  <code>clearTaskOnLaunch</code></li>
  <li>
  <code>alwaysRetainTaskState</code></li>
  <li>
  <code>finishOnTaskLaunch</code></li>
</ul>
<p>And the principal intent flags you can use are:</p>
<ul>
  <li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
  <li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
  <li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ul>
<p>In the following sections, you'll see how you can use these manifest attributes and intent
flags to define how activities are associated with tasks and how they behave in the back stack.</p>
<p>Also, discussed separately are the considerations for how tasks and activites may be represented
and managed in the overview screen. See Overview Screen
for more information. Normally you should allow the system to define how your task and
activities are represented in the overview screen, and you don't need to modify this behavior.</p>
<p><strong>Caution:</strong> Most applications should not interrupt the default
behavior for activities and tasks. If you determine that it's necessary for your activity to modify
the default behaviors, use caution and be sure to test the usability of the activity during
launch and when navigating back to it from other activities and tasks with the <em>Back</em> button.
Be sure to test for navigation behaviors that might conflict with the user's expected behavior.</p>
<h3>Defining launch modes</h3>
<p>Launch modes allow you to define how a new instance of an activity is associated with the
current task. You can define different launch modes in two ways:</p>
<ul>
  <li>Using the manifest file
    <p>When you declare an activity in your manifest file, you can specify how the activity
should associate with tasks when it starts.</p></li>
  <li>Using Intent flags
    <p>When you call <code>startActivity()</code>,
you can include a flag in the <code>Intent</code> that declares how (or
whether) the new activity should associate with the current task.</p></li>
</ul>
<p>When you declare an activity in your manifest file, you can specify how the activity
should associate with tasks when it starts.</p>
<p>When you call <code>startActivity()</code>,
you can include a flag in the <code>Intent</code> that declares how (or
whether) the new activity should associate with the current task.</p>
<p>As such, if Activity A starts Activity B, Activity B can define in its manifest how it
should associate with the current task (if at all) and Activity A can also request how Activity
B should associate with current task. If both activities define how Activity B
should associate with a task, then Activity A's request (as defined in the intent) is honored
over Activity B's request (as defined in its manifest).</p>
<p><strong>Note:</strong> Some launch modes available for the manifest file
are not available as flags for an intent and, likewise, some launch modes available as flags
for an intent cannot be defined in the manifest.</p>
<h4>Using the manifest file</h4>
<p>When declaring an activity in your manifest file, you can specify how the activity should
associate with a task using the <code>&lt;activity&gt;</code>
element's <code>launchMode</code> attribute.</p>
<p>The <code>launchMode</code> attribute specifies an instruction on how the activity should be launched into a
task. There are four different launch modes you can assign to the
<code>launchMode</code>
attribute:</p>
<p>For example, suppose a task's back stack consists of root activity A with activities B, C,
and D on top (the stack is A-B-C-D; D is on top). An intent arrives for an activity of type D.
If D has the default <code>"standard"</code> launch mode, a new instance of the class is launched and the
stack becomes A-B-C-D-D. However, if D's launch mode is <code>"singleTop"</code>, the existing instance
of D receives the intent through <code>onNewIntent()</code>, because it's at the top of the stack—the
stack remains A-B-C-D. However, if an intent arrives for an activity of type B, then a new
instance of B is added to the stack, even if its launch mode is <code>"singleTop"</code>.</p>
<p><strong>Note:</strong> When a new instance of an activity is created,
the user can press the <em>Back</em> button to return to the previous activity. But when an existing
instance of
an activity handles a new intent, the user cannot press the <em>Back</em> button to return to the
state of
the activity before the new intent arrived in <code>onNewIntent()</code>.</p>
<p><strong>Note:</strong> Although the activity starts in a new task, the
<em>Back</em> button still returns the user to the previous activity.</p>
<p>As another example, the Android Browser application declares that the web browser activity should
always open in its own task—by specifying the <code>singleTask</code> launch mode in the <code>&lt;activity&gt;</code> element.
This means that if your application issues an
intent to open the Android Browser, its activity is <em>not</em> placed in the same
task as your application. Instead, either a new task starts for the Browser or, if the Browser
already has a task running in the background, that task is brought forward to handle the new
intent.</p>
<p>Regardless of whether an activity starts in a new task or in the same task as the activity that
started it, the <em>Back</em> button always takes the user to the previous activity. However, if you
start an activity that specifies the <code>singleTask</code> launch mode, then if an instance of
that activity exists in a background task, that whole task is brought to the foreground. At this
point, the back stack now includes all activities from the task brought forward, at the top of the
stack. Figure 4 illustrates this type of scenario.</p>
<p><strong>Figure 4.</strong> A representation of how an activity with
launch mode "singleTask" is added to the back stack. If the activity is already a part of a
background task with its own back stack, then the entire back stack also comes
forward, on top of the current task.</p>
<p>For more information about using launch modes in the manifest file, see the
<code>&lt;activity&gt;</code>
element documentation, where the <code>launchMode</code> attribute and the accepted values are
discussed more.</p>
<p><strong>Note:</strong> The behaviors that you specify for your activity with the <code>launchMode</code> attribute
can be overridden by flags included with the intent that start your activity, as discussed in the
next section.</p>
<h4>Using Intent flags</h4>
<p>When starting an activity, you can modify the default association of an activity to its task
by including flags in the intent that you deliver to <code>startActivity()</code>. The flags you can use to modify the
default behavior are:</p>
<p>
  </p>
<p>This produces the same behavior as the <code>"singleTask"</code> <code>launchMode</code> value,
discussed in the previous section.</p>
<p>This produces the same behavior as the <code>"singleTop"</code> <code>launchMode</code> value,
discussed in the previous section.</p>
<p>There is no value for the <code>launchMode</code>
attribute that produces this behavior.</p>
<p><code>FLAG_ACTIVITY_CLEAR_TOP</code> is most often used in conjunction with
    <code>FLAG_ACTIVITY_NEW_TASK</code>.
When used together, these flags are a way of locating an existing activity
in another task and putting it in a position where it can respond to the intent. </p>
<p><strong>Note:</strong> If the launch mode of the designated activity is
    <code>"standard"</code>,
it too is removed from the stack and a new instance is launched in its place to handle
the incoming intent.  That's because a new instance is always created for a new intent when the
launch mode is <code>"standard"</code>. </p>
<h3>Handling affinities</h3>
<p>The <em>affinity</em> indicates which task an activity prefers to belong to. By default, all the
activities from the same application have an affinity for each other. So, by default, all
activities in the same application prefer to be in the same task. However, you can modify
the default affinity for an activity. Activities defined in
different applications can share an affinity, or activities defined in the same application can be
assigned different task affinities.</p>
<p>You can modify the affinity for any given activity with the <code>taskAffinity</code> attribute
of the <code>&lt;activity&gt;</code>
element.</p>
<p>The <code>taskAffinity</code>
attribute takes a string value, which must be unique from the default package name
declared in the 
<code>&lt;manifest&gt;</code>
 element, because the system uses that name to identify the default task
affinity for the application.</p>
<p>The affinity comes into play in two circumstances:</p>
<ul>
  <li>When the intent that launches an activity contains the
  <code>FLAG_ACTIVITY_NEW_TASK</code>
  flag.

<p>A new activity is, by default, launched into the task of the activity
that called <code>startActivity()</code>. It's pushed onto the same
back stack as the caller.  However, if the intent passed to
<code>startActivity()</code>
contains the <code>FLAG_ACTIVITY_NEW_TASK</code>
flag, the system looks for a different task to house the new activity. Often, it's a new task.
However, it doesn't have to be.  If there's already an existing task with the same affinity as the
new activity, the activity is launched into that task.  If not, it begins a new task.</p>

<p>If this flag causes an activity to begin a new task and the user presses the <em>Home</em> button
to leave
it, there must be some way for the user to navigate back to the task. Some entities (such as the
notification manager) always start activities in an external task, never as part of their own, so
they always put <code>FLAG_ACTIVITY_NEW_TASK</code> in the intents they pass to
<code>startActivity()</code>.
If you have an activity that can be invoked by
an external entity that might use this flag, take care that the user has a independent way to get
back to the task that's started, such as with a launcher icon (the root activity of the task
has a <code>CATEGORY_LAUNCHER</code> intent filter; see the Starting a task section below).</p>
</li>

  <li>When an activity has its 
<code>allowTaskReparenting</code> attribute set to <code>"true"</code>.
  <p>In this case, the activity can move from the task it starts to the task it has an affinity
for, when that task comes to the foreground.</p>
  <p>For example, suppose that an activity that reports weather conditions in selected cities is
defined as part of a travel application.  It has the same affinity as other activities in the same
application (the default application affinity) and it allows re-parenting with this attribute.
When one of your activities starts the weather reporter activity, it initially belongs to the same
task as your activity. However, when the travel application's task comes to the foreground, the
weather reporter activity is reassigned to that task and displayed within it.</p>
</li>
</ul>
<p>A new activity is, by default, launched into the task of the activity
that called <code>startActivity()</code>. It's pushed onto the same
back stack as the caller.  However, if the intent passed to
<code>startActivity()</code>
contains the <code>FLAG_ACTIVITY_NEW_TASK</code>
flag, the system looks for a different task to house the new activity. Often, it's a new task.
However, it doesn't have to be.  If there's already an existing task with the same affinity as the
new activity, the activity is launched into that task.  If not, it begins a new task.</p>
<p>If this flag causes an activity to begin a new task and the user presses the <em>Home</em> button
to leave
it, there must be some way for the user to navigate back to the task. Some entities (such as the
notification manager) always start activities in an external task, never as part of their own, so
they always put <code>FLAG_ACTIVITY_NEW_TASK</code> in the intents they pass to
<code>startActivity()</code>.
If you have an activity that can be invoked by
an external entity that might use this flag, take care that the user has a independent way to get
back to the task that's started, such as with a launcher icon (the root activity of the task
has a <code>CATEGORY_LAUNCHER</code> intent filter; see the Starting a task section below).</p>
<p>In this case, the activity can move from the task it starts to the task it has an affinity
for, when that task comes to the foreground.</p>
<p>For example, suppose that an activity that reports weather conditions in selected cities is
defined as part of a travel application.  It has the same affinity as other activities in the same
application (the default application affinity) and it allows re-parenting with this attribute.
When one of your activities starts the weather reporter activity, it initially belongs to the same
task as your activity. However, when the travel application's task comes to the foreground, the
weather reporter activity is reassigned to that task and displayed within it.</p>
<p><strong>Tip:</strong> If an <code>.apk</code> file contains more than one "application"
from the user's point of view, you probably want to use the <code>taskAffinity</code>
attribute to assign different affinities to the activities associated with each "application".</p>
<h3>Clearing the back stack</h3>
<p>If the user leaves a task for a long time, the system clears the task of all activities except
the root activity.  When the user returns to the task again, only the root activity is restored.
The system behaves this way, because, after an extended amount of time, users likely have abandoned
what they were doing before and are returning to the task to begin something new. </p>
<p>There are some activity attributes that you can use to modify this behavior: </p>
<h3>Starting a task</h3>
<p>You can set up an activity as the entry point for a task by giving it an intent filter with
<code>"android.intent.action.MAIN"</code> as the specified action and
<code>"android.intent.category.LAUNCHER"</code>
as the specified category. For example:</p>
<p>WHATSON? 8ac9b287-1dd9-4d25-84b2-e6a04059338e</p>
<pre>
&lt;activity ... &gt;
    &lt;intent-filter ... &gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
    ...
&lt;/activity&gt;
</pre>
<p>An intent filter of this kind causes an icon and label for the
activity to be displayed in the application launcher, giving users a way to launch the activity and
to return to the task that it creates any time after it has been launched.
</p>
<p>This second ability is important: Users must be able to leave a task and then come back to it
later using this activity launcher. For this reason, the two launch
modes that mark activities as always initiating a task, <code>"singleTask"</code> and
<code>"singleInstance"</code>, should be used only when the activity has an
<code>ACTION_MAIN</code>
and a <code>CATEGORY_LAUNCHER</code> filter. Imagine, for example, what could
happen if the filter is missing: An intent launches a <code>"singleTask"</code> activity, initiating a
new task, and the user spends some time working in that task. The user then presses the <em>Home</em>
button. The task is now sent to the background and is not visible. Now the user has no way to return
to the task, because it is not represented in the application launcher.</p>
<p>For those cases where you don't want the user to be able to return to an activity, set the
<code>&lt;activity&gt;</code>
element's
<code>finishOnTaskLaunch</code>
to <code>"true"</code> (see Clearing the stack).</p>
<p>Further information about how tasks and activites are represented and managed in
the overview screen is available in 
Overview Screen.</p>
<h1>Tasks and Back Stack</h1>
<h2>In this document</h2>
<ol>
<li>Saving Activity State</li>
<li>Managing Tasks
  <ol>
    <li>Defining launch modes</li>
    <li>Handling affinities</li>
    <li>Clearing the back stack</li>
    <li>Starting a task</li>
  </ol>
</li>
</ol>
<ol>
    <li>Defining launch modes</li>
    <li>Handling affinities</li>
    <li>Clearing the back stack</li>
    <li>Starting a task</li>
  </ol>
<h2>Articles</h2>
<ol>
  <li>
  Multitasking the Android Way</li>
</ol>
<h2>See also</h2>
<ol>
  <li>Android Design:
Navigation</li>
  <li><code>&lt;activity&gt;</code> manifest
element</li>
  <li>Overview Screen</li>
</ol>
<p>An application usually contains multiple activities. Each activity
should be designed around a specific kind of action the user can perform and can start other
activities. For example, an email application might have one activity to show a list of new messages.
When the user selects a message, a new activity opens to view that message.</p>
<p>An activity can even start activities that exist in other applications on the device. For
example, if your application wants to send an email message, you can define an intent to perform a
"send" action and include some data, such as an email address and a message. An activity from another
application that declares itself to handle this kind of intent then opens. In this case, the intent
is to send an email, so an email application's "compose" activity starts (if multiple activities
support the same intent, then the system lets the user select which one to use). When the email is
sent, your activity resumes and it seems as if the email activity was part of your application. Even
though the activities may be from different applications, Android maintains this seamless user
experience by keeping both activities in the same <em>task</em>.</p>
<p>A task is a collection of activities that users interact with
when performing a certain job. The activities are arranged in a stack (the <em>back stack</em>), in
the order in which each activity is opened.</p>
<p>The device Home screen is the starting place for most tasks. When the user touches an icon in the
application
launcher (or a shortcut on the Home screen), that application's task comes to the foreground. If no
task exists for the application (the application has not been used recently), then a new task
is created and the "main" activity for that application opens as the root activity in the stack.</p>
<p>When the current activity starts another, the new activity is pushed on the top of the stack and
takes focus. The previous activity remains in the stack, but is stopped. When an activity
stops, the system retains the current state of its user interface. When the user presses the
<em>Back</em>
button, the current activity is popped from the top of the stack (the activity is destroyed) and the
previous activity resumes (the previous state of its UI is restored). Activities in the stack are
never rearranged, only pushed and popped from the stack—pushed onto the stack when started by
the current activity and popped off when the user leaves it using the <em>Back</em> button. As such,
the back
stack operates as a "last in, first out" object structure. Figure 1 visualizes
this behavior with a timeline showing the progress between activities along with the current back
stack at each point in time.</p>
<p><strong>Figure 1.</strong> A representation of how each new activity in a
task adds an item to the back stack. When the user presses the <em>Back</em> button, the current
activity is
destroyed and the previous activity resumes.</p>
<p>If the user continues to press <em>Back</em>, then each activity in the stack is popped off to
reveal the
previous one, until the user returns to the Home screen (or to whichever activity was running when
the task began). When all activities are removed from the stack, the task no longer exists.</p>
<p><strong>Figure 2.</strong> Two tasks: Task B receives user interaction
in the foreground, while Task A is in the background, waiting to be resumed.</p>
<p><strong>Figure 3.</strong> A single activity is instantiated multiple times.</p>
<p>A task is a cohesive unit that can move to the "background" when users begin a new task or go
to the Home screen, via the <em>Home</em> button. While in the background, all the activities in the
task are
stopped, but the back stack for the task remains intact—the task has simply lost focus while
another task takes place, as shown in figure 2. A task can then return to the "foreground" so users
can pick up where they left off. Suppose, for example, that the current task (Task A) has three
activities in its stack—two under the current activity. The user presses the <em>Home</em>
button, then
starts a new application from the application launcher. When the Home screen appears, Task A goes
into the background. When the new application starts, the system starts a task for that application
(Task B) with its own stack of activities. After interacting with
that application, the user returns Home again and selects the application that originally
started Task A. Now, Task A comes to the
foreground—all three activities in its stack are intact and the activity at the top of the
stack resumes. At
this point, the user can also switch back to Task B by going Home and selecting the application icon
that started that task (or by selecting the app's task from the
overview screen).
This is an example of multitasking on Android.</p>
<p><strong>Note:</strong> Multiple tasks can be held in the background at once.
However, if the user is running many background tasks at the same time, the system might begin
destroying background activities in order to recover memory, causing the activity states to be lost.
See the following section about Activity state.</p>
<p>Because the activities in the back stack are never rearranged, if your application allows
users to start a particular activity from more than one activity, a new instance of
that activity is created and pushed onto the stack (rather than bringing any previous instance of
the activity to the top). As such, one activity in your application might be instantiated multiple
times (even from different tasks), as shown in figure 3. As such, if the user navigates backward
using the <em>Back</em> button, each instance of the activity is revealed in the order they were
opened (each
with their own UI state). However, you can modify this behavior if you do not want an activity to be
instantiated more than once. How to do so is discussed in the later section about Managing Tasks.</p>
<p>To summarize the default behavior for activities and tasks:</p>
<ul>
  <li>When Activity A starts Activity B, Activity A is stopped, but the system retains its state
(such as scroll position and text entered into forms).
If the user presses the <em>Back</em> button while in Activity B, Activity A resumes with its state
restored.</li>
  <li>When the user leaves a task by pressing the <em>Home</em> button, the current activity is
stopped and
its task goes into the background. The system retains the state of every activity in the task. If
the user later resumes the task by selecting the launcher icon that began the task, the task comes
to the foreground and resumes the activity at the top of the stack.</li>
  <li>If the user presses the <em>Back</em> button, the current activity is popped from the stack
and
destroyed. The previous activity in the stack is resumed. When an activity is destroyed, the system
<em>does not</em> retain the activity's state.</li>
  <li>Activities can be instantiated multiple times, even from other tasks.</li>
</ul>
<p><strong>Navigation Design</strong></p>
<p>For more about how app navigation works on Android, read Android Design's Navigation guide.</p>
<h2>Saving Activity State</h2>
<p>As discussed above, the system's default behavior preserves the state of an activity when it is
stopped. This way, when users navigate back to a previous activity, its user interface appears
the way they left it. However, you can—and <strong>should</strong>—proactively retain
the state of your activities using callback methods, in case the activity is destroyed and must
be recreated.</p>
<p>When the system stops one of your activities (such as when a new activity starts or the task
moves to the background), the system might destroy that activity completely if it needs to recover
system memory. When this happens, information about the activity state is lost. If this happens, the
system still
knows that the activity has a place in the back stack, but when the activity is brought to the
top of the stack the system must recreate it (rather than resume it). In order to
avoid losing the user's work, you should proactively retain it by implementing the
<code>onSaveInstanceState()</code> callback
methods in your activity.</p>
<p>For more information about how to save your activity state, see the Activities
document.</p>
<h2>Managing Tasks</h2>
<p>The way Android manages tasks and the back stack, as described above—by placing all
activities started in succession in the same task and in a "last in, first out" stack—works
great for most applications and you shouldn't have to worry about how your activities are associated
with tasks or how they exist in the back stack. However, you might decide that you want to interrupt
the normal behavior. Perhaps you want an activity in your application to begin a new task when it is
started (instead of being placed within the current task); or, when you start an activity, you want
to bring forward an existing instance of it (instead of creating a new
instance on top of the back stack); or, you want your back stack to be cleared of all
activities except for the root activity when the user leaves the task.</p>
<p>You can do these things and more, with attributes in the
<code>&lt;activity&gt;</code>
manifest element and with flags in the intent that you pass to
<code>startActivity()</code>.</p>
<p>In this regard, the principal 
<code>&lt;activity&gt;</code> attributes you can use are:</p>
<ul>
  <li>
  <code>taskAffinity</code></li>
  <li>
  <code>launchMode</code></li>
  <li>
  <code>allowTaskReparenting</code></li>
  <li>
  <code>clearTaskOnLaunch</code></li>
  <li>
  <code>alwaysRetainTaskState</code></li>
  <li>
  <code>finishOnTaskLaunch</code></li>
</ul>
<p>And the principal intent flags you can use are:</p>
<ul>
  <li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
  <li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
  <li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ul>
<p>In the following sections, you'll see how you can use these manifest attributes and intent
flags to define how activities are associated with tasks and how they behave in the back stack.</p>
<p>Also, discussed separately are the considerations for how tasks and activites may be represented
and managed in the overview screen. See Overview Screen
for more information. Normally you should allow the system to define how your task and
activities are represented in the overview screen, and you don't need to modify this behavior.</p>
<p><strong>Caution:</strong> Most applications should not interrupt the default
behavior for activities and tasks. If you determine that it's necessary for your activity to modify
the default behaviors, use caution and be sure to test the usability of the activity during
launch and when navigating back to it from other activities and tasks with the <em>Back</em> button.
Be sure to test for navigation behaviors that might conflict with the user's expected behavior.</p>
<h3>Defining launch modes</h3>
<p>Launch modes allow you to define how a new instance of an activity is associated with the
current task. You can define different launch modes in two ways:</p>
<ul>
  <li>Using the manifest file
    <p>When you declare an activity in your manifest file, you can specify how the activity
should associate with tasks when it starts.</p></li>
  <li>Using Intent flags
    <p>When you call <code>startActivity()</code>,
you can include a flag in the <code>Intent</code> that declares how (or
whether) the new activity should associate with the current task.</p></li>
</ul>
<p>When you declare an activity in your manifest file, you can specify how the activity
should associate with tasks when it starts.</p>
<p>When you call <code>startActivity()</code>,
you can include a flag in the <code>Intent</code> that declares how (or
whether) the new activity should associate with the current task.</p>
<p>As such, if Activity A starts Activity B, Activity B can define in its manifest how it
should associate with the current task (if at all) and Activity A can also request how Activity
B should associate with current task. If both activities define how Activity B
should associate with a task, then Activity A's request (as defined in the intent) is honored
over Activity B's request (as defined in its manifest).</p>
<p><strong>Note:</strong> Some launch modes available for the manifest file
are not available as flags for an intent and, likewise, some launch modes available as flags
for an intent cannot be defined in the manifest.</p>
<h4>Using the manifest file</h4>
<p>When declaring an activity in your manifest file, you can specify how the activity should
associate with a task using the <code>&lt;activity&gt;</code>
element's <code>launchMode</code> attribute.</p>
<p>The <code>launchMode</code> attribute specifies an instruction on how the activity should be launched into a
task. There are four different launch modes you can assign to the
<code>launchMode</code>
attribute:</p>
<p>For example, suppose a task's back stack consists of root activity A with activities B, C,
and D on top (the stack is A-B-C-D; D is on top). An intent arrives for an activity of type D.
If D has the default <code>"standard"</code> launch mode, a new instance of the class is launched and the
stack becomes A-B-C-D-D. However, if D's launch mode is <code>"singleTop"</code>, the existing instance
of D receives the intent through <code>onNewIntent()</code>, because it's at the top of the stack—the
stack remains A-B-C-D. However, if an intent arrives for an activity of type B, then a new
instance of B is added to the stack, even if its launch mode is <code>"singleTop"</code>.</p>
<p><strong>Note:</strong> When a new instance of an activity is created,
the user can press the <em>Back</em> button to return to the previous activity. But when an existing
instance of
an activity handles a new intent, the user cannot press the <em>Back</em> button to return to the
state of
the activity before the new intent arrived in <code>onNewIntent()</code>.</p>
<p><strong>Note:</strong> Although the activity starts in a new task, the
<em>Back</em> button still returns the user to the previous activity.</p>
<p>As another example, the Android Browser application declares that the web browser activity should
always open in its own task—by specifying the <code>singleTask</code> launch mode in the <code>&lt;activity&gt;</code> element.
This means that if your application issues an
intent to open the Android Browser, its activity is <em>not</em> placed in the same
task as your application. Instead, either a new task starts for the Browser or, if the Browser
already has a task running in the background, that task is brought forward to handle the new
intent.</p>
<p>Regardless of whether an activity starts in a new task or in the same task as the activity that
started it, the <em>Back</em> button always takes the user to the previous activity. However, if you
start an activity that specifies the <code>singleTask</code> launch mode, then if an instance of
that activity exists in a background task, that whole task is brought to the foreground. At this
point, the back stack now includes all activities from the task brought forward, at the top of the
stack. Figure 4 illustrates this type of scenario.</p>
<p><strong>Figure 4.</strong> A representation of how an activity with
launch mode "singleTask" is added to the back stack. If the activity is already a part of a
background task with its own back stack, then the entire back stack also comes
forward, on top of the current task.</p>
<p>For more information about using launch modes in the manifest file, see the
<code>&lt;activity&gt;</code>
element documentation, where the <code>launchMode</code> attribute and the accepted values are
discussed more.</p>
<p><strong>Note:</strong> The behaviors that you specify for your activity with the <code>launchMode</code> attribute
can be overridden by flags included with the intent that start your activity, as discussed in the
next section.</p>
<h4>Using Intent flags</h4>
<p>When starting an activity, you can modify the default association of an activity to its task
by including flags in the intent that you deliver to <code>startActivity()</code>. The flags you can use to modify the
default behavior are:</p>
<p>
  </p>
<p>This produces the same behavior as the <code>"singleTask"</code> <code>launchMode</code> value,
discussed in the previous section.</p>
<p>This produces the same behavior as the <code>"singleTop"</code> <code>launchMode</code> value,
discussed in the previous section.</p>
<p>There is no value for the <code>launchMode</code>
attribute that produces this behavior.</p>
<p><code>FLAG_ACTIVITY_CLEAR_TOP</code> is most often used in conjunction with
    <code>FLAG_ACTIVITY_NEW_TASK</code>.
When used together, these flags are a way of locating an existing activity
in another task and putting it in a position where it can respond to the intent. </p>
<p><strong>Note:</strong> If the launch mode of the designated activity is
    <code>"standard"</code>,
it too is removed from the stack and a new instance is launched in its place to handle
the incoming intent.  That's because a new instance is always created for a new intent when the
launch mode is <code>"standard"</code>. </p>
<h3>Handling affinities</h3>
<p>The <em>affinity</em> indicates which task an activity prefers to belong to. By default, all the
activities from the same application have an affinity for each other. So, by default, all
activities in the same application prefer to be in the same task. However, you can modify
the default affinity for an activity. Activities defined in
different applications can share an affinity, or activities defined in the same application can be
assigned different task affinities.</p>
<p>You can modify the affinity for any given activity with the <code>taskAffinity</code> attribute
of the <code>&lt;activity&gt;</code>
element.</p>
<p>The <code>taskAffinity</code>
attribute takes a string value, which must be unique from the default package name
declared in the 
<code>&lt;manifest&gt;</code>
 element, because the system uses that name to identify the default task
affinity for the application.</p>
<p>The affinity comes into play in two circumstances:</p>
<ul>
  <li>When the intent that launches an activity contains the
  <code>FLAG_ACTIVITY_NEW_TASK</code>
  flag.

<p>A new activity is, by default, launched into the task of the activity
that called <code>startActivity()</code>. It's pushed onto the same
back stack as the caller.  However, if the intent passed to
<code>startActivity()</code>
contains the <code>FLAG_ACTIVITY_NEW_TASK</code>
flag, the system looks for a different task to house the new activity. Often, it's a new task.
However, it doesn't have to be.  If there's already an existing task with the same affinity as the
new activity, the activity is launched into that task.  If not, it begins a new task.</p>

<p>If this flag causes an activity to begin a new task and the user presses the <em>Home</em> button
to leave
it, there must be some way for the user to navigate back to the task. Some entities (such as the
notification manager) always start activities in an external task, never as part of their own, so
they always put <code>FLAG_ACTIVITY_NEW_TASK</code> in the intents they pass to
<code>startActivity()</code>.
If you have an activity that can be invoked by
an external entity that might use this flag, take care that the user has a independent way to get
back to the task that's started, such as with a launcher icon (the root activity of the task
has a <code>CATEGORY_LAUNCHER</code> intent filter; see the Starting a task section below).</p>
</li>

  <li>When an activity has its 
<code>allowTaskReparenting</code> attribute set to <code>"true"</code>.
  <p>In this case, the activity can move from the task it starts to the task it has an affinity
for, when that task comes to the foreground.</p>
  <p>For example, suppose that an activity that reports weather conditions in selected cities is
defined as part of a travel application.  It has the same affinity as other activities in the same
application (the default application affinity) and it allows re-parenting with this attribute.
When one of your activities starts the weather reporter activity, it initially belongs to the same
task as your activity. However, when the travel application's task comes to the foreground, the
weather reporter activity is reassigned to that task and displayed within it.</p>
</li>
</ul>
<p>A new activity is, by default, launched into the task of the activity
that called <code>startActivity()</code>. It's pushed onto the same
back stack as the caller.  However, if the intent passed to
<code>startActivity()</code>
contains the <code>FLAG_ACTIVITY_NEW_TASK</code>
flag, the system looks for a different task to house the new activity. Often, it's a new task.
However, it doesn't have to be.  If there's already an existing task with the same affinity as the
new activity, the activity is launched into that task.  If not, it begins a new task.</p>
<p>If this flag causes an activity to begin a new task and the user presses the <em>Home</em> button
to leave
it, there must be some way for the user to navigate back to the task. Some entities (such as the
notification manager) always start activities in an external task, never as part of their own, so
they always put <code>FLAG_ACTIVITY_NEW_TASK</code> in the intents they pass to
<code>startActivity()</code>.
If you have an activity that can be invoked by
an external entity that might use this flag, take care that the user has a independent way to get
back to the task that's started, such as with a launcher icon (the root activity of the task
has a <code>CATEGORY_LAUNCHER</code> intent filter; see the Starting a task section below).</p>
<p>In this case, the activity can move from the task it starts to the task it has an affinity
for, when that task comes to the foreground.</p>
<p>For example, suppose that an activity that reports weather conditions in selected cities is
defined as part of a travel application.  It has the same affinity as other activities in the same
application (the default application affinity) and it allows re-parenting with this attribute.
When one of your activities starts the weather reporter activity, it initially belongs to the same
task as your activity. However, when the travel application's task comes to the foreground, the
weather reporter activity is reassigned to that task and displayed within it.</p>
<p><strong>Tip:</strong> If an <code>.apk</code> file contains more than one "application"
from the user's point of view, you probably want to use the <code>taskAffinity</code>
attribute to assign different affinities to the activities associated with each "application".</p>
<h3>Clearing the back stack</h3>
<p>If the user leaves a task for a long time, the system clears the task of all activities except
the root activity.  When the user returns to the task again, only the root activity is restored.
The system behaves this way, because, after an extended amount of time, users likely have abandoned
what they were doing before and are returning to the task to begin something new. </p>
<p>There are some activity attributes that you can use to modify this behavior: </p>
<h3>Starting a task</h3>
<p>You can set up an activity as the entry point for a task by giving it an intent filter with
<code>"android.intent.action.MAIN"</code> as the specified action and
<code>"android.intent.category.LAUNCHER"</code>
as the specified category. For example:</p>
<p>WHATSON? c4d3acfd-86f6-441e-bc26-f9987933d799</p>
<pre>
&lt;activity ... &gt;
    &lt;intent-filter ... &gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
    ...
&lt;/activity&gt;
</pre>
<p>An intent filter of this kind causes an icon and label for the
activity to be displayed in the application launcher, giving users a way to launch the activity and
to return to the task that it creates any time after it has been launched.
</p>
<p>This second ability is important: Users must be able to leave a task and then come back to it
later using this activity launcher. For this reason, the two launch
modes that mark activities as always initiating a task, <code>"singleTask"</code> and
<code>"singleInstance"</code>, should be used only when the activity has an
<code>ACTION_MAIN</code>
and a <code>CATEGORY_LAUNCHER</code> filter. Imagine, for example, what could
happen if the filter is missing: An intent launches a <code>"singleTask"</code> activity, initiating a
new task, and the user spends some time working in that task. The user then presses the <em>Home</em>
button. The task is now sent to the background and is not visible. Now the user has no way to return
to the task, because it is not represented in the application launcher.</p>
<p>For those cases where you don't want the user to be able to return to an activity, set the
<code>&lt;activity&gt;</code>
element's
<code>finishOnTaskLaunch</code>
to <code>"true"</code> (see Clearing the stack).</p>
<p>Further information about how tasks and activites are represented and managed in
the overview screen is available in 
Overview Screen.</p>
</body>
</html>