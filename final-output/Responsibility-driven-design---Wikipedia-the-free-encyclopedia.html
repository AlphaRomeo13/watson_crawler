<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Responsibility-driven-design---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Responsibility-driven design</h1>
<p><b>Responsibility-driven design</b> is a design technique in object-oriented programming. It was proposed by Rebecca Wirfs-Brock and Brian Wilkerson, who defined it as follows:</p>
<p>Responsibility-driven design is inspired by the client/server model. It focuses on the contract by asking:</p>
<ul>
<li>What actions is this object responsible for?</li>
<li>What information does this object share?</li>
</ul>
<p>Responsibility-driven design is in direct contrast with data-driven design, which promotes defining the behavior of a class along the data that it holds. Data-driven design is not the same as data-driven programming, which is concerned with using data to determine control flow not class design.</p>
<p>The client/server model they refer to assumes that a software client and a software server exchange information based on a contract that both parties commit to adhere to. The client may only make the requests specified, the server must answer them. Thus, responsibility-driven design tries to avoid dealing with details, such as the way in which requests are carried out, by instead only specifying the intent of a certain request. The benefit is increased encapsulation, since the specification of the exact way in which a request is carried out is private to the server.</p>
<p>To further the encapsulation of the server, Wirfs-Brock and Wilkerson call for language features that limit outside influence to the behavior of a class. They demand that visibility of members and functions should be finely grained, such as in Eiffel. Even finer control of the visibility of even classes is available in the Newspeak programming language.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Building blocks
<ul>
<li>1.1 Objects</li>
<li>1.2 Roles</li>
</ul>
</li>
<li>2 Control style
<ul>
<li>2.1 Centralized control style</li>
<li>2.2 Clustered control style</li>
<li>2.3 Delegated control style</li>
<li>2.4 Dispersed control style</li>
<li>2.5 Preferred control style</li>
</ul>
</li>
<li>3 Conflict with the Law of Demeter</li>
<li>4 References</li>
<li>5 Bibliography</li>
</ul>
<ul>
<li>1.1 Objects</li>
<li>1.2 Roles</li>
</ul>
<ul>
<li>2.1 Centralized control style</li>
<li>2.2 Clustered control style</li>
<li>2.3 Delegated control style</li>
<li>2.4 Dispersed control style</li>
<li>2.5 Preferred control style</li>
</ul>
<p></p>
<h2>Building blocks</h2>
<p>In their book <i>Object Design: Roles, Responsibilities and Collaborations</i>, the authors describe the following building blocks that make up responsibility-driven design.</p>
<ul>
<li>Application : A software application is referred to as a set of interacting objects</li>
<li>Candidates : Candidates or candidate objects are key concepts in the form of objects described on CRC cards. They serve as initial inventions in the process of object design.</li>
<li>Collaborations : A collaboration is defined as an interaction of objects or roles (or both).</li>
<li>CRC Cards : CRC stands for Candidates, Responsibilities, Collaborators. They are index cards used in early design for recording candidates. These cards are split up into an unlined and a lined side.
<ul>
<li>Content of lined side : On this side the candidate's name, its responsibilities and its collaborators are recorded.</li>
<li>Content of unlined side : On this side the candidate's name, its purpose in the application, stereotype roles and anything worthwhile such as the names of roles in patterns it participates in are recorded.</li>
</ul>
</li>
<li>Hot Spots : Hot Spots are points in the application where variations occur. They are recorded using Hot Spot Cards.</li>
<li>Hot Spot Cards : Hot Spot Cards are used for recording variations, so called hot spots. They are similarly to CRC cards low-level tools in the form of index cards. These cards consist of:
<ul>
<li>Hot Spot Name</li>
<li>General description of the variation</li>
<li>At least two specific examples where the variation occurs</li>
</ul>
</li>
</ul>
<ul>
<li>Content of lined side : On this side the candidate's name, its responsibilities and its collaborators are recorded.</li>
<li>Content of unlined side : On this side the candidate's name, its purpose in the application, stereotype roles and anything worthwhile such as the names of roles in patterns it participates in are recorded.</li>
</ul>
<ul>
<li>Hot Spot Name</li>
<li>General description of the variation</li>
<li>At least two specific examples where the variation occurs</li>
</ul>
<h3>Objects</h3>
<p>Objects are described as things that have machinelike behaviors that can be plugged together to work in concert. These objects play well-defined roles and encapsulate scripted responses and information.</p>
<ul>
<li>Object Neighborhoods : Another term for subsystem. It is a logical grouping of collaborators.</li>
<li>Responsibilities : A responsibility is an obligation to perform a task or know information. These are further categorized according to their usage scenario.</li>
<li>Public Responsibilities : Public responsibilities are the responsibilities an object offers as services to others and the information it provides to others.</li>
<li>Private Responsibilities : Private responsibilities are the actions an object takes in support of public responsibilities</li>
</ul>
<ul>
<li>Subresponsibilities : These responsibilities come into existence whenever a large or complicated responsibility is split up into smaller ones. They are further categorized by what they do.
<ul>
<li>Subordinate Responsibilities : These are the major steps of the subresponsibility.</li>
<li>Sequencing Responsibility : This responsibility refers to the sequencing of the execution of subordinate responsibilities.</li>
</ul>
</li>
</ul>
<ul>
<li>Subordinate Responsibilities : These are the major steps of the subresponsibility.</li>
<li>Sequencing Responsibility : This responsibility refers to the sequencing of the execution of subordinate responsibilities.</li>
</ul>
<h3>Roles</h3>
<p>A role is a set of related responsibilities. They can be implemented as classes and interfaces. Interfaces, however, are the preferred implementation as they increase flexibility by hiding the concrete class which ultimately does the work.</p>
<ul>
<li>Role Stereotypes : Role stereotypes are simplified roles that come with predefined responsibilities. There are several categories.</li>
<li>Controller : Objects implementing this role make decisions and closely direct the action of other objects.</li>
<li>Coordinator : This role reacts to events by delegating tasks to others.</li>
</ul>
<ul>
<li>Information Holder : Information holders know and provide information.
<ul>
<li>Information Provider : A slight variation of an information holder is the information provider, which takes a more active role in managing and maintaining information. This distinction can be used if a designer needs to get more specific.</li>
</ul>
</li>
</ul>
<ul>
<li>Information Provider : A slight variation of an information holder is the information provider, which takes a more active role in managing and maintaining information. This distinction can be used if a designer needs to get more specific.</li>
</ul>
<ul>
<li>Interfacer : This role transforms information and requests between distinct parts of an application. It is further divided into more specific roles.
<ul>
<li>External Interfacer : These interfacers communicate with other applications than your own. They are mainly used for encapsulating non-object-oriented APIs and do not collaborate a lot.</li>
<li>Internal Interfacer : Also called intersystem interfacers. These interfacers act as a bridge between object neighborhoods.</li>
<li>User Interfacer : These interfacers communicate with users by responding to events generated in the UI and then passing them on to more appropriate objects.</li>
</ul>
</li>
</ul>
<ul>
<li>External Interfacer : These interfacers communicate with other applications than your own. They are mainly used for encapsulating non-object-oriented APIs and do not collaborate a lot.</li>
<li>Internal Interfacer : Also called intersystem interfacers. These interfacers act as a bridge between object neighborhoods.</li>
<li>User Interfacer : These interfacers communicate with users by responding to events generated in the UI and then passing them on to more appropriate objects.</li>
</ul>
<ul>
<li>Service Provider : This role performs work and offers computing services.</li>
<li>Structurer : This role maintains relationships between objects and information about those relationships.</li>
</ul>
<h2>Control style</h2>
<p>An important part in the responsibility-driven design process is the distribution of control responsibilities that results in developing a control style.</p>
<ul>
<li>Concept of Control : Control styles rely heavily on the concept of control. Therefore it makes sense to properly define the term. It is defined as decision making and selection of paths through an application.</li>
<li>Control Centers : An important aspect of developing a control style is the invention of so called control centers. These are places where objects charged with controlling and coordinating reside.</li>
<li>Control Style Variations : A control style comes in three distinct variations. These are not precise definitions though since a control style can be said to be more centralized or delegated than another.</li>
</ul>
<h3>Centralized control style</h3>
<p>This control style inflicts a procedural paradigm on the structure of the application and places major-decision making responsibilities in only a few objects.</p>
<ul>
<li>Application logic is in one place.</li>
</ul>
<ul>
<li>Control logic can get overly complex</li>
<li>Controllers can become dependent on information holders' contents</li>
<li>Objects can become coupled indirectly through the actions of their controller</li>
<li>The only interesting work is done in the controller</li>
</ul>
<p>When decisions to be made are few, simple, and related to a single task.</p>
<h3>Clustered control style</h3>
<p>This control style is a variation of the centralized control style wherein control is factored among a group of objects whose actions are coordinated. The main difference between a clustered and delegated control style is that in a clustered control style, the decision making objects are located within a control center whereas in a delegated control style they are mostly outside.</p>
<ul>
<li>Application logic is in one place.</li>
</ul>
<ul>
<li>Control logic can get overly complex</li>
<li>Controllers can become dependent on information holders' contents</li>
<li>Objects can become coupled indirectly through the actions of their controller</li>
<li>The only interesting work is done in the controller</li>
</ul>
<p>When decisions to be made are few, simple, and related to a single task.</p>
<h3>Delegated control style</h3>
<p>A delegated control style lies in between a centralized and dispersed control style. It passes some of the decision making and much of the action to objects surrounding a control center. Each neighboring object has a significant role to play.</p>
<ul>
<li>It is easy to find out how something works since only few objects are involved</li>
<li>It is reusable because each object is largely capable of fulfilling its own responsibilities</li>
<li>System functions can be used in relative isolation since they are organized into pools of responsibilities</li>
<li>Delegating coordinators tend to know about fewer objects than dominating controllers</li>
<li>Dialogs are higher-level</li>
<li>Changes typically affect fewer objects</li>
<li>It is easier to divide design work among team members</li>
</ul>
<ul>
<li>Too much distribution of responsibility can lead to weak objects and weak collaborations</li>
</ul>
<p>When one wants to delegate work to objects that are more specialized.</p>
<h3>Dispersed control style</h3>
<p>A dispersed control style does not contain any control centers. The logic is spread across the entire population of objects, keeping each object small and building in as few dependencies among them as possible.</p>
<ul>
<li>None</li>
</ul>
<ul>
<li>When you want to find out how something works, you must trace the sequence of requests for services across many objects</li>
<li>Not very reusable because no single object contributes much</li>
</ul>
<p>Never.</p>
<h3>Preferred control style</h3>
<p>The inventors of responsibility-driven design recommend using a delegated control style because no one object knows or does too much.</p>
<h2>Conflict with the Law of Demeter</h2>
<p>According to Wirfs-Brock and Wilkerson, there is a conflict between the Law of Demeter and responsibility-driven design. The law says that messages can be sent only to the following: message argument, instance variable, new objects, and global variables. Therefore, sending a message to the result of a previous message send isn't allowed. However, "returned values are part of the client/server contract. There need be no correlation between the structure of an object and the object returned by the message."</p>
</body>
</html>