<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Fragments--Android-Developers.html</title></head>
<body>
<h1>Fragments</h1>
<h2>In this document</h2>
<ol>
    <li>Design Philosophy</li>
    <li>Creating a Fragment
      <ol>
        <li>Adding a user interface</li>
        <li>Adding a fragment to an activity</li>
      </ol>
    </li>
    <li>Managing Fragments</li>
    <li>Performing Fragment Transactions</li>
    <li>Communicating with the Activity
      <ol>
        <li>Creating event callbacks to the activity</li>
        <li>Adding items to the Action Bar</li>
      </ol>
    </li>
    <li>Handling the Fragment Lifecycle
      <ol>
        <li>Coordinating with the activity lifecycle</li>
      </ol>
    </li>
    <li>Example</li>
  </ol>
<ol>
        <li>Adding a user interface</li>
        <li>Adding a fragment to an activity</li>
      </ol>
<ol>
        <li>Creating event callbacks to the activity</li>
        <li>Adding items to the Action Bar</li>
      </ol>
<ol>
        <li>Coordinating with the activity lifecycle</li>
      </ol>
<h2>Key classes</h2>
<ol>
    <li><code>Fragment</code></li>
    <li><code>FragmentManager</code></li>
    <li><code>FragmentTransaction</code></li>
  </ol>
<h2>See also</h2>
<ol>
    <li>Building a Dynamic UI with Fragments</li>
    <li>Supporting Tablets
and Handsets</li>
  </ol>
<p>A <code>Fragment</code> represents a behavior or a portion of user interface in an
<code>Activity</code>. You can combine multiple fragments in a single activity to build a
multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a
modular section of an activity, which has its own lifecycle, receives its own input events, and
which you can add or remove while the activity is running (sort of like a "sub activity" that
you can reuse in different activities).</p>
<p>A fragment must always be embedded in an activity and the fragment's lifecycle is directly
affected by the host activity's lifecycle. For example, when the activity is paused, so are all
fragments in it, and when the activity is destroyed, so are all fragments. However, while an
activity is running (it is in the <em>resumed</em> lifecycle state), you can
manipulate each fragment independently, such as add or remove them. When you perform such a
fragment transaction, you can also add it to a back stack that's managed by the
activity—each back stack entry in the activity is a record of the fragment transaction that
occurred. The back stack allows the user to reverse a fragment transaction (navigate backwards),
by pressing the <em>Back</em> button.</p>
<p>When you add a fragment as a part of your activity layout, it lives in a <code>ViewGroup</code> inside the activity's view hierarchy and the fragment defines its own view
layout.
You can insert a fragment into your activity layout by declaring the fragment in the activity's
layout file, as a <code>&lt;fragment&gt;</code> element, or from your application code by adding it to an
existing <code>ViewGroup</code>. However, a fragment is not required to be a part of the
activity layout; you may also use a fragment without its own UI as an invisible worker for the
activity.</p>
<p>This document describes how to build your application to use fragments, including
how fragments can maintain their state when added to the activity's back stack, share
events with the activity and other fragments in the activity, contribute to the activity's action
bar, and more.</p>
<h2>Design Philosophy</h2>
<p>Android introduced fragments in Android 3.0 (API level 11), primarily to support more
dynamic and flexible UI designs on large screens, such as tablets. Because a
tablet's screen is much larger than that of a handset, there's more room to combine and
interchange UI components. Fragments allow such designs without the need for you to manage complex
changes to the view hierarchy. By dividing the layout of an activity into fragments, you become able
to modify the activity's appearance at runtime and preserve those changes in a back stack
that's managed by the activity.</p>
<p>For example, a news application can use one fragment to show a list of articles on the
left and another fragment to display an article on the right—both fragments appear in one
activity, side by side, and each fragment has its own set of lifecycle callback methods and handle
their own user input events. Thus, instead of using one activity to select an article and another
activity to read the article, the user can select an article and read it all within the same
activity, as illustrated in the tablet layout in figure 1.</p>
<p>You should design each fragment as a modular and reusable activity component. That is, because
each fragment defines its own layout and its own behavior with its own lifecycle callbacks, you can
include one fragment in multiple activities, so you should design for reuse and avoid directly
manipulating one fragment from another fragment. This is especially important because a modular
fragment allows you to change your fragment combinations for different screen sizes. When designing
your application to support both tablets and handsets, you can reuse your fragments in different
layout configurations to optimize the user experience based on the available screen space. For
example, on a handset, it might be necessary to separate fragments to provide a single-pane UI when
more than one cannot fit within the same activity.</p>
<p><strong>Figure 1.</strong> An example of how two UI modules defined by
fragments can be combined into one activity for a tablet design, but separated for a
handset design.</p>
<p>For example—to continue with the news application example—the application can embed
two fragments in <em>Activity A</em>, when running on a tablet-sized device. However, on a
handset-sized screen, there's not enough room for both fragments, so <em>Activity A</em> includes
only the fragment for the list of articles, and when the user selects an article, it starts
<em>Activity B</em>, which includes the second fragment to read the article. Thus, the application
supports both tablets and handsets by reusing fragments in different combinations, as illustrated in
figure 1.</p>
<p>For more information about designing your application with different fragment combinations for
different screen configurations, see the guide to Supporting Tablets and Handsets.</p>
<h2>Creating a Fragment</h2>
<p><strong>Figure 2.</strong> The lifecycle of a fragment (while its
activity is running).</p>
<p>To create a fragment, you must create a subclass of <code>Fragment</code> (or an existing
subclass of it). The <code>Fragment</code> class has code that looks a lot like
an <code>Activity</code>. It contains callback methods similar to an activity, such
as <code>onCreate()</code>, <code>onStart()</code>,
<code>onPause()</code>, and <code>onStop()</code>. In
fact, if you're converting an existing Android application to use fragments, you might simply move
code from your activity's callback methods into the respective callback methods of your
fragment.</p>
<p>Usually, you should implement at least the following lifecycle methods:</p>
<p>Most applications should implement at least these three methods for every fragment, but there are
several other callback methods you should also use to handle various stages of the
fragment lifecycle. All the lifecycle callback methods are discussed in more detail in the section
about Handling the Fragment Lifecycle.</p>
<p>There are also a few subclasses that you might want to extend, instead of the base <code>Fragment</code> class:</p>
<h3>Adding a user interface</h3>
<p>A fragment is usually used as part of an activity's user interface and contributes its own
layout to the activity.</p>
<p>To provide a layout for a fragment, you must implement the <code>onCreateView()</code> callback method, which the Android system calls
when it's time for the fragment to draw its layout. Your implementation of this method must return a
<code>View</code> that is the root of your fragment's layout.</p>
<p><strong>Note:</strong> If your fragment is a subclass of <code>ListFragment</code>, the default implementation returns a <code>ListView</code> from
<code>onCreateView()</code>, so you don't need to implement it.</p>
<p>To return a layout from <code>onCreateView()</code>, you can inflate it from a layout resource defined in XML. To
help you do so, <code>onCreateView()</code> provides a
<code>LayoutInflater</code> object.</p>
<p>For example, here's a subclass of <code>Fragment</code> that loads a layout from the
<code>example_fragment.xml</code> file:</p>
<p>WHATSON? 1229d344-5182-41e9-a92c-93be22dd03b4</p>
<pre>
public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}
</pre>
<h3>Creating a layout</h3>
<p>In the sample above, <code>R.layout.example_fragment</code> is a reference to a layout resource
named <code>example_fragment.xml</code> saved in the application resources. For information about how to
create a layout in XML, see the User Interface
documentation.</p>
<p>The <code>container</code> parameter passed to <code>onCreateView()</code> is the parent <code>ViewGroup</code> (from the activity's layout) in which
your fragment layout
will be inserted. The <code>savedInstanceState</code> parameter is a <code>Bundle</code> that
provides data about the previous instance of the fragment, if the fragment is being resumed
(restoring state is discussed more in the section about Handling the
Fragment Lifecycle).</p>
<p>The <code>inflate()</code> method takes
three arguments:</p>
<ul>
  <li>The resource ID of the layout you want to inflate.</li>
  <li>The <code>ViewGroup</code> to be the parent of the inflated layout. Passing the <code>container</code> is important in order for the system to apply layout parameters to the root view of the
inflated layout, specified by the parent view in which it's going.</li>
  <li>A boolean indicating whether the inflated layout should be attached to the <code>ViewGroup</code> (the second parameter) during inflation. (In this case, this
is false because the system is already inserting the inflated layout into the <code>container</code>—passing true would create a redundant view group in the final layout.)</li>
</ul>
<p>Now you've seen how to create a fragment that provides a layout. Next, you need to add
the fragment to your activity.</p>
<h3>Adding a fragment to an activity</h3>
<p>Usually, a fragment contributes a portion of UI to the host activity, which is embedded as a part
of the activity's overall view hierarchy. There are two ways you can add a fragment to the activity
layout:</p>
<ul>
  <li><b>Declare the fragment inside the activity's layout file.</b>
<p>In this case, you can
specify layout properties for the fragment as if it were a view. For example, here's the layout
file for an activity with two fragments:</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
    &lt;fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;
</pre>
  <p>The <code>android:name</code> attribute in the <code>&lt;fragment&gt;</code> specifies the <code>Fragment</code> class to instantiate in the layout.</p>

<p>When the system creates this activity layout, it instantiates each fragment specified in the
layout and calls the <code>onCreateView()</code> method for each one,
to retrieve each fragment's layout. The system inserts the <code>View</code> returned by the
fragment directly in place of the <code>&lt;fragment&gt;</code> element.</p>

<div class="note">
  <p><strong>Note:</strong> Each fragment requires a unique identifier that
the system can use to restore the fragment if the activity is restarted (and which you can use to
capture the fragment to perform transactions, such as remove it). There are three ways to provide an
ID for a fragment:</p>
  <ul>
    <li>Supply the <code>android:id</code> attribute with a unique ID.</li>
    <li>Supply the <code>android:tag</code> attribute with a unique string.</li>
    <li>If you provide neither of the previous two, the system uses the ID of the container 
view.</li>
  </ul>
</div>
  </li>

  <li><b>Or, programmatically add the fragment to an existing <code>ViewGroup</code>.</b>
<p>At any time while your activity is running, you can add fragments to your activity layout. You
simply need to specify a <code>ViewGroup</code> in which to place the fragment.</p>
  <p>To make fragment transactions in your activity (such as add, remove, or replace a
fragment), you must use APIs from <code>FragmentTransaction</code>. You can get an instance
of <code>FragmentTransaction</code> from your <code>Activity</code> like this:</p>

<pre>
FragmentManager fragmentManager = <code>getFragmentManager()</code>
FragmentTransaction fragmentTransaction = fragmentManager.<code>beginTransaction()</code>;
</pre>

<p>You can then add a fragment using the <code>add()</code> method, specifying the fragment to add and
the view in which to insert it. For example:</p>

<pre>
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
</pre>

  <p>The first argument passed to <code>add()</code>
is the <code>ViewGroup</code> in which the fragment should be placed, specified by
resource ID, and the second parameter is the fragment to add.</p>
  <p>Once you've made your changes with
<code>FragmentTransaction</code>, you must
call <code>commit()</code> for the changes to take effect.</p>
  </li>
</ul>
<p>In this case, you can
specify layout properties for the fragment as if it were a view. For example, here's the layout
file for an activity with two fragments:</p>
<p>WHATSON? 6e65bdc9-f8dc-4373-9bbd-d52a04b9aa19</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
    &lt;fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;
</pre>
<p>The <code>android:name</code> attribute in the <code>&lt;fragment&gt;</code> specifies the <code>Fragment</code> class to instantiate in the layout.</p>
<p>When the system creates this activity layout, it instantiates each fragment specified in the
layout and calls the <code>onCreateView()</code> method for each one,
to retrieve each fragment's layout. The system inserts the <code>View</code> returned by the
fragment directly in place of the <code>&lt;fragment&gt;</code> element.</p>
<p><strong>Note:</strong> Each fragment requires a unique identifier that
the system can use to restore the fragment if the activity is restarted (and which you can use to
capture the fragment to perform transactions, such as remove it). There are three ways to provide an
ID for a fragment:</p>
<ul>
    <li>Supply the <code>android:id</code> attribute with a unique ID.</li>
    <li>Supply the <code>android:tag</code> attribute with a unique string.</li>
    <li>If you provide neither of the previous two, the system uses the ID of the container 
view.</li>
  </ul>
<p>At any time while your activity is running, you can add fragments to your activity layout. You
simply need to specify a <code>ViewGroup</code> in which to place the fragment.</p>
<p>To make fragment transactions in your activity (such as add, remove, or replace a
fragment), you must use APIs from <code>FragmentTransaction</code>. You can get an instance
of <code>FragmentTransaction</code> from your <code>Activity</code> like this:</p>
<p>WHATSON? 36821255-8008-4001-840a-5684bcdffa9b</p>
<pre>
FragmentManager fragmentManager = <code>getFragmentManager()</code>
FragmentTransaction fragmentTransaction = fragmentManager.<code>beginTransaction()</code>;
</pre>
<p>You can then add a fragment using the <code>add()</code> method, specifying the fragment to add and
the view in which to insert it. For example:</p>
<p>WHATSON? 5ae44e03-5f58-47dc-b6db-9f06a85a7e8e</p>
<pre>
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
</pre>
<p>The first argument passed to <code>add()</code>
is the <code>ViewGroup</code> in which the fragment should be placed, specified by
resource ID, and the second parameter is the fragment to add.</p>
<p>Once you've made your changes with
<code>FragmentTransaction</code>, you must
call <code>commit()</code> for the changes to take effect.</p>
<h4>Adding a fragment without a UI</h4>
<p>The examples above show how to add a fragment to your activity in order to provide a UI. However,
you can also use a fragment to provide a background behavior for the activity without presenting
additional UI.</p>
<p>To add a fragment without a UI, add the fragment from the activity using <code>add(Fragment, String)</code> (supplying a unique string "tag" for the
fragment, rather than a view ID). This adds the fragment, but, because it's not associated with a
view in the activity layout, it does not receive a call to <code>onCreateView()</code>. So you don't need to implement that method.</p>
<p>Supplying a string tag for the fragment isn't strictly for non-UI fragments—you can also
supply string tags to fragments that do have a UI—but if the fragment does not have a
UI, then the string tag is the only way to identify it. If you want to get the fragment from the
activity later, you need to use <code>findFragmentByTag()</code>.</p>
<p>For an example activity that uses a fragment as a background worker, without a UI, see the <code>FragmentRetainInstance.java</code> sample, which is included in the SDK samples (available through the
Android SDK Manager) and located on your system as 
<code>&lt;sdk_root&gt;/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java</code>.</p>
<h2>Managing Fragments</h2>
<p>To manage the fragments in your activity, you need to use <code>FragmentManager</code>. To
get it, call <code>getFragmentManager()</code> from your activity.</p>
<p>Some things that you can do with <code>FragmentManager</code> include:</p>
<ul>
  <li>Get fragments that exist in the activity, with <code>findFragmentById()</code> (for fragments that provide a UI in
the activity layout) or <code>findFragmentByTag()</code> (for fragments that do or don't provide a UI).</li> 
  <li>Pop fragments off the back stack, with <code>popBackStack()</code> (simulating a <em>Back</em> command by the user).</li>
  <li>Register a listener for changes to the back stack, with <code>addOnBackStackChangedListener()</code>.</li>
</ul>
<p>For more information about these methods and others, refer to the <code>FragmentManager</code> class documentation.</p>
<p>As demonstrated in the previous section, you can also use <code>FragmentManager</code>
to open a <code>FragmentTransaction</code>, which allows you to perform transactions, such as
add and remove fragments.</p>
<h2>Performing Fragment Transactions</h2>
<p>A great feature about using fragments in your activity is the ability to add, remove, replace,
and perform other actions with them, in response to user interaction. Each set of changes that you
commit to the activity is called a transaction and you can perform one using APIs in <code>FragmentTransaction</code>. You can also save each transaction to a back stack managed by the
activity, allowing the user to navigate backward through the fragment changes (similar to navigating
backward through activities).</p>
<p>You can acquire an instance of <code>FragmentTransaction</code> from the <code>FragmentManager</code> like this:</p>
<p>WHATSON? 645d6d1f-2a65-41a7-90fe-497c1819c6d3</p>
<pre>
FragmentManager fragmentManager = <code>getFragmentManager()</code>;
FragmentTransaction fragmentTransaction = fragmentManager.<code>beginTransaction()</code>;
</pre>
<p>Each transaction is a set of changes that you want to perform at the same time. You can set
up all the changes you want to perform for a given transaction using methods such as <code>add()</code>, <code>remove()</code>,
and <code>replace()</code>. Then, to apply the transaction
to the activity, you must call <code>commit()</code>.</p>
<p>Before you call <code>commit()</code>, however, you might want to call <code>addToBackStack()</code>, in order to add the transaction
to a back stack of fragment transactions. This back stack is managed by the activity and allows
the user to return to the previous fragment state, by pressing the <em>Back</em> button.</p>
<p>For example, here's how you can replace one fragment with another, and preserve the previous
state in the back stack:</p>
<p>WHATSON? 1eff518f-7e83-4478-a7ce-a8821f8f78d7</p>
<pre>
// Create new fragment and transaction
Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragmentManager().beginTransaction();

// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);

// Commit the transaction
transaction.commit();
</pre>
<p>In this example, <code>newFragment</code> replaces whatever fragment (if any) is currently in the
layout container identified by the <code>R.id.fragment_container</code> ID. By calling <code>addToBackStack()</code>, the replace transaction is
saved to the back stack so the user can reverse the transaction and bring back the
previous fragment by pressing the <em>Back</em> button.</p>
<p>If you add multiple changes to the transaction (such as another <code>add()</code> or <code>remove()</code>) and call <code>addToBackStack()</code>, then all changes applied
before you call <code>commit()</code> are added to the
back stack as a single transaction and the <em>Back</em> button will reverse them all together.</p>
<p>The order in which you add changes to a <code>FragmentTransaction</code> doesn't matter,
except:</p>
<ul>
  <li>You must call <code>commit()</code> last</li>
  <li>If you're adding multiple fragments to the same container, then the order in which
you add them determines the order they appear in the view hierarchy</li>
</ul>
<p>If you do not call <code>addToBackStack()</code> when you perform a transaction that removes a fragment, then that fragment is
destroyed when the transaction is committed and the user cannot navigate back to it. Whereas, if you
do call <code>addToBackStack()</code> when
removing a fragment, then the fragment is <em>stopped</em> and will be resumed if the user navigates
back.</p>
<p><strong>Tip:</strong> For each fragment transaction, you can apply a transition
animation, by calling <code>setTransition()</code> before
you commit.</p>
<p>Calling <code>commit()</code> does not perform the transaction
immediately. Rather, it schedules it to run on the activity's UI thread (the "main" thread) as soon
as the thread is able to do so. If necessary, however, you may call <code>executePendingTransactions()</code> from your UI thread to immediately execute
transactions submitted by <code>commit()</code>. Doing so is
usually not necessary unless the transaction is a dependency for jobs in other threads.</p>
<p><strong>Caution:</strong> You can commit a transaction using <code>commit()</code> only prior to the activity saving its
state (when the user leaves the activity). If you attempt to commit after that point, an
exception will be thrown. This is because the state after the commit can be lost if the activity
needs to be restored. For situations in which its okay that you lose the commit, use <code>commitAllowingStateLoss()</code>.</p>
<h2>Communicating with the Activity</h2>
<p>Although a <code>Fragment</code> is implemented as an object that's independent from an
<code>Activity</code> and can be used inside multiple activities, a given instance of
a fragment is directly tied to the activity that contains it.</p>
<p>Specifically, the fragment can access the <code>Activity</code> instance with <code>getActivity()</code> and easily perform tasks such as find a view in the
activity layout:</p>
<p>WHATSON? a7ac1f05-f77d-448b-ae2b-9432e19d3ba0</p>
<pre>
View listView = <code>getActivity()</code>.<code>findViewById</code>(R.id.list);
</pre>
<p>Likewise, your activity can call methods in the fragment by acquiring a reference to the
<code>Fragment</code> from <code>FragmentManager</code>, using <code>findFragmentById()</code> or <code>findFragmentByTag()</code>. For example:</p>
<p>WHATSON? 5b9b0e02-201f-4917-befc-f743321687c0</p>
<pre>
ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);
</pre>
<h3>Creating event callbacks to the activity</h3>
<p>In some cases, you might need a fragment to share events with the activity. A good way to do that
is to define a callback interface inside the fragment and require that the host activity implement
it. When the activity receives a callback through the interface, it can share the information with
other fragments in the layout as necessary.</p>
<p>For example, if a news application has two fragments in an activity—one to show a list of
articles (fragment A) and another to display an article (fragment B)—then fragment A must tell
the activity when a list item is selected so that it can tell fragment B to display the article. In
this case, the <code>OnArticleSelectedListener</code> interface is declared inside fragment A:</p>
<p>WHATSON? e00f5b26-e8b5-4b97-a1aa-f58d00224528</p>
<pre>
public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}
</pre>
<p>Then the activity that hosts the fragment implements the <code>OnArticleSelectedListener</code>
interface and
overrides <code>onArticleSelected()</code> to notify fragment B of the event from fragment A. To ensure
that the host activity implements this interface, fragment A's <code>onAttach()</code> callback method (which the system calls when adding
the fragment to the activity) instantiates an instance of <code>OnArticleSelectedListener</code> by
casting the <code>Activity</code> that is passed into <code>onAttach()</code>:</p>
<p>WHATSON? 86b5bafb-c158-40ee-8bbf-8fe730c9e4cc</p>
<pre>
public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
        }
    }
    ...
}
</pre>
<p>If the activity has not implemented the interface, then the fragment throws a
<code>ClassCastException</code>.
On success, the <code>mListener</code> member holds a reference to activity's implementation of 
<code>OnArticleSelectedListener</code>, so that fragment A can share events with the activity by calling
methods defined by the <code>OnArticleSelectedListener</code> interface. For example, if fragment A is an
extension of <code>ListFragment</code>, each time
the user clicks a list item, the system calls <code>onListItemClick()</code> in the fragment, which then calls <code>onArticleSelected()</code> to share
the event with the activity:</p>
<p>WHATSON? 97c4296d-98f5-4a5f-93f6-6dbf21c569da</p>
<pre>
public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item's row ID with the content provider Uri
        Uri noteUri = ContentUris.<code>withAppendedId</code>(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }
    ...
}
</pre>
<p>The <code>id</code> parameter passed to <code>onListItemClick()</code> is the row ID of the clicked item,
which the activity (or other fragment) uses to fetch the article from the application's <code>ContentProvider</code>.</p>
<p><!--To see a complete implementation of this kind of callback interface, see the <a
href="/resources/samples/NotePad/index.html">NotePad sample. -->More information about
using a content provider is available in the Content Providers document.</p>
<h3>Adding items to the Action Bar</h3>
<p>Your fragments can contribute menu items to the activity's Options Menu (and, consequently, the Action Bar) by implementing
<code>onCreateOptionsMenu()</code>. In order
for this method to receive calls, however, you must call <code>setHasOptionsMenu()</code> during <code>onCreate()</code>, to indicate that the fragment
would like to add items to the Options Menu (otherwise, the fragment will not receive a call to
<code>onCreateOptionsMenu()</code>).</p>
<p>Any items that you then add to the Options Menu from the fragment are appended to the existing
menu items. The fragment also receives callbacks to <code>onOptionsItemSelected()</code> when a menu item
is selected.</p>
<p>You can also register a view in your fragment layout to provide a context menu by calling <code>registerForContextMenu()</code>. When the user opens
the context menu, the fragment receives a call to <code>onCreateContextMenu()</code>. When the user selects an item, the fragment receives a call to <code>onContextItemSelected()</code>.</p>
<p><strong>Note:</strong> Although your fragment receives an on-item-selected callback
for each menu item it adds, the activity is first to receive the respective callback when the user
selects a menu item. If the activity's implementation of the on-item-selected callback does not
handle the selected item, then the event is passed to the fragment's callback. This is true for
the Options Menu and context menus.</p>
<p>For more information about menus, see the Menus and Action Bar developer guides.</p>
<h2>Handling the Fragment Lifecycle</h2>
<p><strong>Figure 3.</strong> The effect of the activity lifecycle on the fragment
lifecycle.</p>
<p>Managing the lifecycle of a fragment is a lot like managing the lifecycle of an activity. Like
an activity, a fragment can exist in three states:</p>
<p>Also like an activity, you can retain the state of a fragment using a <code>Bundle</code>, in case the activity's process is killed and you need to restore the
fragment state when the activity is recreated. You can save the state during the fragment's <code>onSaveInstanceState()</code> callback and restore it during
either <code>onCreate()</code>, <code>onCreateView()</code>, or <code>onActivityCreated()</code>. For more information about saving
state, see the Activities
document.</p>
<p>The most significant difference in lifecycle between an activity and a fragment is how one is
stored in its respective back stack. An activity is placed into a back stack of activities
that's managed by the system when it's stopped, by default (so that the user can navigate back
to it with the <em>Back</em> button, as discussed in Tasks and Back Stack).
However, a fragment is placed into a back stack managed by the host activity only when you
explicitly request that the instance be saved by calling <code>addToBackStack()</code> during a transaction that
removes the fragment.</p>
<p>Otherwise, managing the fragment lifecycle is very similar to managing the activity
lifecycle. So, the same practices for managing the activity
lifecycle also apply to fragments. What you also need to understand, though, is how the life
of the activity affects the life of the fragment.</p>
<p><strong>Caution:</strong> If you need a <code>Context</code> object
within your <code>Fragment</code>, you can call <code>getActivity()</code>.
However, be careful to call <code>getActivity()</code> only when the fragment is
attached to an activity. When the fragment is not yet attached, or was detached during the end of
its lifecycle, <code>getActivity()</code> will return null.</p>
<h3>Coordinating with the activity lifecycle</h3>
<p>The lifecycle of the activity in which the fragment lives directly affects the lifecycle of the
fragment, such that each lifecycle callback for the activity results in a similar callback for each
fragment. For example, when the activity receives <code>onPause()</code>, each
fragment in the activity receives <code>onPause()</code>.</p>
<p>Fragments have a few extra lifecycle callbacks, however, that handle unique interaction with the
activity in order to perform actions such as build and destroy the fragment's UI. These additional
callback methods are:</p>
<p>The flow of a fragment's lifecycle, as it is affected by its host activity, is illustrated
by figure 3. In this figure, you can see how each successive state of the activity determines which
callback methods a fragment may receive. For example, when the activity has received its <code>onCreate()</code> callback, a fragment in the activity receives no more than
the <code>onActivityCreated()</code> callback.</p>
<p>Once the activity reaches the resumed state, you can freely add and remove fragments to the
activity. Thus, only while the activity is in the resumed state can the lifecycle of a fragment
change independently.</p>
<p>However, when the activity leaves the resumed state, the fragment again is pushed through its
lifecycle by the activity.</p>
<h2>Example</h2>
<p>To bring everything discussed in this document together, here's an example of an activity
using two fragments to create a two-pane layout. The activity below includes one fragment to
show a list of Shakespeare play titles and another to show a summary of the play when selected
from the list. It also demonstrates how to provide different configurations of the fragments,
based on the screen configuration.</p>
<p><strong>Note:</strong> The complete source code for this activity is available in
<code>FragmentLayout.java</code>.</p>
<p>The main activity applies a layout in the usual way, during <code>onCreate()</code>:</p>
<p>WHATSON? 0ce3a7dc-f675-443b-82e0-f7689abf0d4c</p>
<pre>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.fragment_layout);
}</pre>
<p>The layout applied is <code>fragment_layout.xml</code>:</p>
<p>WHATSON? 08ec4a73-5efd-4e2c-956e-800a04407870</p>
<pre>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent" android:layout_height="match_parent"&gt;

    &lt;fragment class="com.example.android.apis.app.FragmentLayout$TitlesFragment"
            android:id="@+id/titles" android:layout_weight="1"
            android:layout_width="0px" android:layout_height="match_parent" /&gt;

    &lt;FrameLayout android:id="@+id/details" android:layout_weight="1"
            android:layout_width="0px" android:layout_height="match_parent"
            android:background="?android:attr/detailsElementBackground" /&gt;

&lt;/LinearLayout&gt;</pre>
<p>Using this layout, the system instantiates the <code>TitlesFragment</code> (which lists the play
titles) as soon as the activity loads the layout, while the <code>FrameLayout</code>
(where the fragment for showing the play summary will go) consumes space on the right side of the
screen, but remains empty at first. As you'll see below, it's not until the user selects an item
from the list that a fragment is placed into the <code>FrameLayout</code>.</p>
<p>However, not all screen configurations are wide enough to show both the list of
plays and the summary, side by side. So, the layout above is used only for the landscape
screen configuration, by saving it at <code>res/layout-land/fragment_layout.xml</code>.</p>
<p>Thus, when the screen is in portrait orientation, the system applies the following layout, which
is saved at <code>res/layout/fragment_layout.xml</code>:</p>
<p>WHATSON? 54e40876-7fe9-48be-8e31-113f502abd5e</p>
<pre>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" android:layout_height="match_parent"&gt;
    &lt;fragment class="com.example.android.apis.app.FragmentLayout$TitlesFragment"
            android:id="@+id/titles"
            android:layout_width="match_parent" android:layout_height="match_parent" /&gt;
&lt;/FrameLayout&gt;</pre>
<p>This layout includes only <code>TitlesFragment</code>. This means that, when the device is in
portrait orientation, only the list of play titles is visible. So, when the user clicks a list
item in this configuration, the application will start a new activity to show the summary,
instead of loading a second fragment.</p>
<p>Next, you can see how this is accomplished in the fragment classes. First is <code>TitlesFragment</code>, which shows the list of Shakespeare play titles. This fragment extends <code>ListFragment</code> and relies on it to handle most of the list view work.</p>
<p>As you inspect this code, notice that there are two possible behaviors when the user clicks a
list item: depending on which of the two layouts is active, it can either create and display a new
fragment to show the details in the same activity (adding the fragment to the <code>FrameLayout</code>), or start a new activity (where the fragment can be shown).</p>
<p>WHATSON? 0fe4ede2-829b-4b7d-888d-cf62aa112ad2</p>
<pre>public static class TitlesFragment extends ListFragment {
    boolean mDualPane;
    int mCurCheckPosition = 0;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        // Populate list with our static array of titles.
        setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(),
                android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES));

        // Check to see if we have a frame in which to embed the details
        // fragment directly in the containing UI.
        View detailsFrame = getActivity().findViewById(R.id.details);
        mDualPane = detailsFrame != null &amp;&amp; detailsFrame.getVisibility() == View.VISIBLE;

        if (savedInstanceState != null) {
            // Restore last state for checked position.
            mCurCheckPosition = savedInstanceState.getInt("curChoice", 0);
        }

        if (mDualPane) {
            // In dual-pane mode, the list view highlights the selected item.
            getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
            // Make sure our UI is in the correct state.
            showDetails(mCurCheckPosition);
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt("curChoice", mCurCheckPosition);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        showDetails(position);
    }

    /**
     * Helper function to show the details of a selected item, either by
     * displaying a fragment in-place in the current UI, or starting a
     * whole new activity in which it is displayed.
     */
    void showDetails(int index) {
        mCurCheckPosition = index;

        if (mDualPane) {
            // We can display everything in-place with fragments, so update
            // the list to highlight the selected item and show the data.
            getListView().setItemChecked(index, true);

            // Check what fragment is currently shown, replace if needed.
            DetailsFragment details = (DetailsFragment)
                    getFragmentManager().findFragmentById(R.id.details);
            if (details == null || details.getShownIndex() != index) {
                // Make new fragment to show this selection.
                details = DetailsFragment.newInstance(index);

                // Execute a transaction, replacing any existing fragment
                // with this one inside the frame.
                FragmentTransaction ft = getFragmentManager().beginTransaction();
                if (index == 0) {
                    ft.replace(R.id.details, details);
                } else {
                    ft.replace(R.id.a_item, details);
                }
                ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
                ft.commit();
            }

        } else {
            // Otherwise we need to launch a new activity to display
            // the dialog fragment with selected text.
            Intent intent = new Intent();
            intent.setClass(getActivity(), DetailsActivity.class);
            intent.putExtra("index", index);
            startActivity(intent);
        }
    }
}</pre>
<p>The second fragment, <code>DetailsFragment</code> shows the play summary for the item selected from
the list from <code>TitlesFragment</code>:</p>
<p>WHATSON? 3ca2cb96-bc75-4e67-9481-52c137a88fde</p>
<pre>public static class DetailsFragment extends Fragment {
    /**
     * Create a new instance of DetailsFragment, initialized to
     * show the text at 'index'.
     */
    public static DetailsFragment newInstance(int index) {
        DetailsFragment f = new DetailsFragment();

        // Supply index input as an argument.
        Bundle args = new Bundle();
        args.putInt("index", index);
        f.setArguments(args);

        return f;
    }

    public int getShownIndex() {
        return getArguments().getInt("index", 0);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (container == null) {
            // We have different layouts, and in one of them this
            // fragment's containing frame doesn't exist.  The fragment
            // may still be created from its saved state, but there is
            // no reason to try to create its view hierarchy because it
            // won't be displayed.  Note this is not needed -- we could
            // just run the code below, where we would create and return
            // the view hierarchy; it would just never be used.
            return null;
        }

        ScrollView scroller = new ScrollView(getActivity());
        TextView text = new TextView(getActivity());
        int padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                4, getActivity().getResources().getDisplayMetrics());
        text.setPadding(padding, padding, padding, padding);
        scroller.addView(text);
        text.setText(Shakespeare.DIALOGUE[getShownIndex()]);
        return scroller;
    }
}</pre>
<p>Recall from the <code>TitlesFragment</code> class, that, if the user clicks a list item and the
current layout does <em>not</em> include the <code>R.id.details</code> view (which is where the
<code>DetailsFragment</code> belongs), then the application starts the <code>DetailsActivity</code>
activity to display the content of the item.</p>
<p>Here is the <code>DetailsActivity</code>, which simply embeds the <code>DetailsFragment</code> to display
the selected play summary when the screen is in portrait orientation:</p>
<p>WHATSON? 45c7c254-1fa2-4e09-846e-c11562e1474a</p>
<pre>public static class DetailsActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (getResources().getConfiguration().orientation
                == Configuration.ORIENTATION_LANDSCAPE) {
            // If the screen is now in landscape mode, we can show the
            // dialog in-line with the list so we don't need this activity.
            finish();
            return;
        }

        if (savedInstanceState == null) {
            // During initial setup, plug in the details fragment.
            DetailsFragment details = new DetailsFragment();
            details.setArguments(getIntent().getExtras());
            getFragmentManager().beginTransaction().add(android.R.id.content, details).commit();
        }
    }
}</pre>
<p>Notice that this activity finishes itself if the configuration is landscape, so that the main
activity can take over and display the <code>DetailsFragment</code> alongside the <code>TitlesFragment</code>.
This can happen if the user begins the <code>DetailsActivity</code> while in portrait orientation, but
then rotates to landscape (which restarts the current activity).</p>
<p>For more samples using fragments (and complete source files for this example),
see the API Demos sample app available in 
ApiDemos (available for download from the Samples SDK component).</p>
<h1>Fragments</h1>
<h2>In this document</h2>
<ol>
    <li>Design Philosophy</li>
    <li>Creating a Fragment
      <ol>
        <li>Adding a user interface</li>
        <li>Adding a fragment to an activity</li>
      </ol>
    </li>
    <li>Managing Fragments</li>
    <li>Performing Fragment Transactions</li>
    <li>Communicating with the Activity
      <ol>
        <li>Creating event callbacks to the activity</li>
        <li>Adding items to the Action Bar</li>
      </ol>
    </li>
    <li>Handling the Fragment Lifecycle
      <ol>
        <li>Coordinating with the activity lifecycle</li>
      </ol>
    </li>
    <li>Example</li>
  </ol>
<ol>
        <li>Adding a user interface</li>
        <li>Adding a fragment to an activity</li>
      </ol>
<ol>
        <li>Creating event callbacks to the activity</li>
        <li>Adding items to the Action Bar</li>
      </ol>
<ol>
        <li>Coordinating with the activity lifecycle</li>
      </ol>
<h2>Key classes</h2>
<ol>
    <li><code>Fragment</code></li>
    <li><code>FragmentManager</code></li>
    <li><code>FragmentTransaction</code></li>
  </ol>
<h2>See also</h2>
<ol>
    <li>Building a Dynamic UI with Fragments</li>
    <li>Supporting Tablets
and Handsets</li>
  </ol>
<p>A <code>Fragment</code> represents a behavior or a portion of user interface in an
<code>Activity</code>. You can combine multiple fragments in a single activity to build a
multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a
modular section of an activity, which has its own lifecycle, receives its own input events, and
which you can add or remove while the activity is running (sort of like a "sub activity" that
you can reuse in different activities).</p>
<p>A fragment must always be embedded in an activity and the fragment's lifecycle is directly
affected by the host activity's lifecycle. For example, when the activity is paused, so are all
fragments in it, and when the activity is destroyed, so are all fragments. However, while an
activity is running (it is in the <em>resumed</em> lifecycle state), you can
manipulate each fragment independently, such as add or remove them. When you perform such a
fragment transaction, you can also add it to a back stack that's managed by the
activity—each back stack entry in the activity is a record of the fragment transaction that
occurred. The back stack allows the user to reverse a fragment transaction (navigate backwards),
by pressing the <em>Back</em> button.</p>
<p>When you add a fragment as a part of your activity layout, it lives in a <code>ViewGroup</code> inside the activity's view hierarchy and the fragment defines its own view
layout.
You can insert a fragment into your activity layout by declaring the fragment in the activity's
layout file, as a <code>&lt;fragment&gt;</code> element, or from your application code by adding it to an
existing <code>ViewGroup</code>. However, a fragment is not required to be a part of the
activity layout; you may also use a fragment without its own UI as an invisible worker for the
activity.</p>
<p>This document describes how to build your application to use fragments, including
how fragments can maintain their state when added to the activity's back stack, share
events with the activity and other fragments in the activity, contribute to the activity's action
bar, and more.</p>
<h2>Design Philosophy</h2>
<p>Android introduced fragments in Android 3.0 (API level 11), primarily to support more
dynamic and flexible UI designs on large screens, such as tablets. Because a
tablet's screen is much larger than that of a handset, there's more room to combine and
interchange UI components. Fragments allow such designs without the need for you to manage complex
changes to the view hierarchy. By dividing the layout of an activity into fragments, you become able
to modify the activity's appearance at runtime and preserve those changes in a back stack
that's managed by the activity.</p>
<p>For example, a news application can use one fragment to show a list of articles on the
left and another fragment to display an article on the right—both fragments appear in one
activity, side by side, and each fragment has its own set of lifecycle callback methods and handle
their own user input events. Thus, instead of using one activity to select an article and another
activity to read the article, the user can select an article and read it all within the same
activity, as illustrated in the tablet layout in figure 1.</p>
<p>You should design each fragment as a modular and reusable activity component. That is, because
each fragment defines its own layout and its own behavior with its own lifecycle callbacks, you can
include one fragment in multiple activities, so you should design for reuse and avoid directly
manipulating one fragment from another fragment. This is especially important because a modular
fragment allows you to change your fragment combinations for different screen sizes. When designing
your application to support both tablets and handsets, you can reuse your fragments in different
layout configurations to optimize the user experience based on the available screen space. For
example, on a handset, it might be necessary to separate fragments to provide a single-pane UI when
more than one cannot fit within the same activity.</p>
<p><strong>Figure 1.</strong> An example of how two UI modules defined by
fragments can be combined into one activity for a tablet design, but separated for a
handset design.</p>
<p>For example—to continue with the news application example—the application can embed
two fragments in <em>Activity A</em>, when running on a tablet-sized device. However, on a
handset-sized screen, there's not enough room for both fragments, so <em>Activity A</em> includes
only the fragment for the list of articles, and when the user selects an article, it starts
<em>Activity B</em>, which includes the second fragment to read the article. Thus, the application
supports both tablets and handsets by reusing fragments in different combinations, as illustrated in
figure 1.</p>
<p>For more information about designing your application with different fragment combinations for
different screen configurations, see the guide to Supporting Tablets and Handsets.</p>
<h2>Creating a Fragment</h2>
<p><strong>Figure 2.</strong> The lifecycle of a fragment (while its
activity is running).</p>
<p>To create a fragment, you must create a subclass of <code>Fragment</code> (or an existing
subclass of it). The <code>Fragment</code> class has code that looks a lot like
an <code>Activity</code>. It contains callback methods similar to an activity, such
as <code>onCreate()</code>, <code>onStart()</code>,
<code>onPause()</code>, and <code>onStop()</code>. In
fact, if you're converting an existing Android application to use fragments, you might simply move
code from your activity's callback methods into the respective callback methods of your
fragment.</p>
<p>Usually, you should implement at least the following lifecycle methods:</p>
<p>Most applications should implement at least these three methods for every fragment, but there are
several other callback methods you should also use to handle various stages of the
fragment lifecycle. All the lifecycle callback methods are discussed in more detail in the section
about Handling the Fragment Lifecycle.</p>
<p>There are also a few subclasses that you might want to extend, instead of the base <code>Fragment</code> class:</p>
<h3>Adding a user interface</h3>
<p>A fragment is usually used as part of an activity's user interface and contributes its own
layout to the activity.</p>
<p>To provide a layout for a fragment, you must implement the <code>onCreateView()</code> callback method, which the Android system calls
when it's time for the fragment to draw its layout. Your implementation of this method must return a
<code>View</code> that is the root of your fragment's layout.</p>
<p><strong>Note:</strong> If your fragment is a subclass of <code>ListFragment</code>, the default implementation returns a <code>ListView</code> from
<code>onCreateView()</code>, so you don't need to implement it.</p>
<p>To return a layout from <code>onCreateView()</code>, you can inflate it from a layout resource defined in XML. To
help you do so, <code>onCreateView()</code> provides a
<code>LayoutInflater</code> object.</p>
<p>For example, here's a subclass of <code>Fragment</code> that loads a layout from the
<code>example_fragment.xml</code> file:</p>
<p>WHATSON? 1ca7e5e9-c386-4d5d-8554-399123ea4ef8</p>
<pre>
public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}
</pre>
<h3>Creating a layout</h3>
<p>In the sample above, <code>R.layout.example_fragment</code> is a reference to a layout resource
named <code>example_fragment.xml</code> saved in the application resources. For information about how to
create a layout in XML, see the User Interface
documentation.</p>
<p>The <code>container</code> parameter passed to <code>onCreateView()</code> is the parent <code>ViewGroup</code> (from the activity's layout) in which
your fragment layout
will be inserted. The <code>savedInstanceState</code> parameter is a <code>Bundle</code> that
provides data about the previous instance of the fragment, if the fragment is being resumed
(restoring state is discussed more in the section about Handling the
Fragment Lifecycle).</p>
<p>The <code>inflate()</code> method takes
three arguments:</p>
<ul>
  <li>The resource ID of the layout you want to inflate.</li>
  <li>The <code>ViewGroup</code> to be the parent of the inflated layout. Passing the <code>container</code> is important in order for the system to apply layout parameters to the root view of the
inflated layout, specified by the parent view in which it's going.</li>
  <li>A boolean indicating whether the inflated layout should be attached to the <code>ViewGroup</code> (the second parameter) during inflation. (In this case, this
is false because the system is already inserting the inflated layout into the <code>container</code>—passing true would create a redundant view group in the final layout.)</li>
</ul>
<p>Now you've seen how to create a fragment that provides a layout. Next, you need to add
the fragment to your activity.</p>
<h3>Adding a fragment to an activity</h3>
<p>Usually, a fragment contributes a portion of UI to the host activity, which is embedded as a part
of the activity's overall view hierarchy. There are two ways you can add a fragment to the activity
layout:</p>
<ul>
  <li><b>Declare the fragment inside the activity's layout file.</b>
<p>In this case, you can
specify layout properties for the fragment as if it were a view. For example, here's the layout
file for an activity with two fragments:</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
    &lt;fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;
</pre>
  <p>The <code>android:name</code> attribute in the <code>&lt;fragment&gt;</code> specifies the <code>Fragment</code> class to instantiate in the layout.</p>

<p>When the system creates this activity layout, it instantiates each fragment specified in the
layout and calls the <code>onCreateView()</code> method for each one,
to retrieve each fragment's layout. The system inserts the <code>View</code> returned by the
fragment directly in place of the <code>&lt;fragment&gt;</code> element.</p>

<div class="note">
  <p><strong>Note:</strong> Each fragment requires a unique identifier that
the system can use to restore the fragment if the activity is restarted (and which you can use to
capture the fragment to perform transactions, such as remove it). There are three ways to provide an
ID for a fragment:</p>
  <ul>
    <li>Supply the <code>android:id</code> attribute with a unique ID.</li>
    <li>Supply the <code>android:tag</code> attribute with a unique string.</li>
    <li>If you provide neither of the previous two, the system uses the ID of the container 
view.</li>
  </ul>
</div>
  </li>

  <li><b>Or, programmatically add the fragment to an existing <code>ViewGroup</code>.</b>
<p>At any time while your activity is running, you can add fragments to your activity layout. You
simply need to specify a <code>ViewGroup</code> in which to place the fragment.</p>
  <p>To make fragment transactions in your activity (such as add, remove, or replace a
fragment), you must use APIs from <code>FragmentTransaction</code>. You can get an instance
of <code>FragmentTransaction</code> from your <code>Activity</code> like this:</p>

<pre>
FragmentManager fragmentManager = <code>getFragmentManager()</code>
FragmentTransaction fragmentTransaction = fragmentManager.<code>beginTransaction()</code>;
</pre>

<p>You can then add a fragment using the <code>add()</code> method, specifying the fragment to add and
the view in which to insert it. For example:</p>

<pre>
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
</pre>

  <p>The first argument passed to <code>add()</code>
is the <code>ViewGroup</code> in which the fragment should be placed, specified by
resource ID, and the second parameter is the fragment to add.</p>
  <p>Once you've made your changes with
<code>FragmentTransaction</code>, you must
call <code>commit()</code> for the changes to take effect.</p>
  </li>
</ul>
<p>In this case, you can
specify layout properties for the fragment as if it were a view. For example, here's the layout
file for an activity with two fragments:</p>
<p>WHATSON? d58a6cb8-6c52-4ec2-b0ec-bb9b70260a3f</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;fragment android:name="com.example.news.ArticleListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
    &lt;fragment android:name="com.example.news.ArticleReaderFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;
</pre>
<p>The <code>android:name</code> attribute in the <code>&lt;fragment&gt;</code> specifies the <code>Fragment</code> class to instantiate in the layout.</p>
<p>When the system creates this activity layout, it instantiates each fragment specified in the
layout and calls the <code>onCreateView()</code> method for each one,
to retrieve each fragment's layout. The system inserts the <code>View</code> returned by the
fragment directly in place of the <code>&lt;fragment&gt;</code> element.</p>
<p><strong>Note:</strong> Each fragment requires a unique identifier that
the system can use to restore the fragment if the activity is restarted (and which you can use to
capture the fragment to perform transactions, such as remove it). There are three ways to provide an
ID for a fragment:</p>
<ul>
    <li>Supply the <code>android:id</code> attribute with a unique ID.</li>
    <li>Supply the <code>android:tag</code> attribute with a unique string.</li>
    <li>If you provide neither of the previous two, the system uses the ID of the container 
view.</li>
  </ul>
<p>At any time while your activity is running, you can add fragments to your activity layout. You
simply need to specify a <code>ViewGroup</code> in which to place the fragment.</p>
<p>To make fragment transactions in your activity (such as add, remove, or replace a
fragment), you must use APIs from <code>FragmentTransaction</code>. You can get an instance
of <code>FragmentTransaction</code> from your <code>Activity</code> like this:</p>
<p>WHATSON? 2336bbf9-64e9-4621-9bce-33012e28b277</p>
<pre>
FragmentManager fragmentManager = <code>getFragmentManager()</code>
FragmentTransaction fragmentTransaction = fragmentManager.<code>beginTransaction()</code>;
</pre>
<p>You can then add a fragment using the <code>add()</code> method, specifying the fragment to add and
the view in which to insert it. For example:</p>
<p>WHATSON? cf36ba4e-7192-4eaa-8596-c50866d5a1fc</p>
<pre>
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
</pre>
<p>The first argument passed to <code>add()</code>
is the <code>ViewGroup</code> in which the fragment should be placed, specified by
resource ID, and the second parameter is the fragment to add.</p>
<p>Once you've made your changes with
<code>FragmentTransaction</code>, you must
call <code>commit()</code> for the changes to take effect.</p>
<h4>Adding a fragment without a UI</h4>
<p>The examples above show how to add a fragment to your activity in order to provide a UI. However,
you can also use a fragment to provide a background behavior for the activity without presenting
additional UI.</p>
<p>To add a fragment without a UI, add the fragment from the activity using <code>add(Fragment, String)</code> (supplying a unique string "tag" for the
fragment, rather than a view ID). This adds the fragment, but, because it's not associated with a
view in the activity layout, it does not receive a call to <code>onCreateView()</code>. So you don't need to implement that method.</p>
<p>Supplying a string tag for the fragment isn't strictly for non-UI fragments—you can also
supply string tags to fragments that do have a UI—but if the fragment does not have a
UI, then the string tag is the only way to identify it. If you want to get the fragment from the
activity later, you need to use <code>findFragmentByTag()</code>.</p>
<p>For an example activity that uses a fragment as a background worker, without a UI, see the <code>FragmentRetainInstance.java</code> sample, which is included in the SDK samples (available through the
Android SDK Manager) and located on your system as 
<code>&lt;sdk_root&gt;/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java</code>.</p>
<h2>Managing Fragments</h2>
<p>To manage the fragments in your activity, you need to use <code>FragmentManager</code>. To
get it, call <code>getFragmentManager()</code> from your activity.</p>
<p>Some things that you can do with <code>FragmentManager</code> include:</p>
<ul>
  <li>Get fragments that exist in the activity, with <code>findFragmentById()</code> (for fragments that provide a UI in
the activity layout) or <code>findFragmentByTag()</code> (for fragments that do or don't provide a UI).</li> 
  <li>Pop fragments off the back stack, with <code>popBackStack()</code> (simulating a <em>Back</em> command by the user).</li>
  <li>Register a listener for changes to the back stack, with <code>addOnBackStackChangedListener()</code>.</li>
</ul>
<p>For more information about these methods and others, refer to the <code>FragmentManager</code> class documentation.</p>
<p>As demonstrated in the previous section, you can also use <code>FragmentManager</code>
to open a <code>FragmentTransaction</code>, which allows you to perform transactions, such as
add and remove fragments.</p>
<h2>Performing Fragment Transactions</h2>
<p>A great feature about using fragments in your activity is the ability to add, remove, replace,
and perform other actions with them, in response to user interaction. Each set of changes that you
commit to the activity is called a transaction and you can perform one using APIs in <code>FragmentTransaction</code>. You can also save each transaction to a back stack managed by the
activity, allowing the user to navigate backward through the fragment changes (similar to navigating
backward through activities).</p>
<p>You can acquire an instance of <code>FragmentTransaction</code> from the <code>FragmentManager</code> like this:</p>
<p>WHATSON? ed86ada8-1e2f-48d7-9a7a-24f769c66610</p>
<pre>
FragmentManager fragmentManager = <code>getFragmentManager()</code>;
FragmentTransaction fragmentTransaction = fragmentManager.<code>beginTransaction()</code>;
</pre>
<p>Each transaction is a set of changes that you want to perform at the same time. You can set
up all the changes you want to perform for a given transaction using methods such as <code>add()</code>, <code>remove()</code>,
and <code>replace()</code>. Then, to apply the transaction
to the activity, you must call <code>commit()</code>.</p>
<p>Before you call <code>commit()</code>, however, you might want to call <code>addToBackStack()</code>, in order to add the transaction
to a back stack of fragment transactions. This back stack is managed by the activity and allows
the user to return to the previous fragment state, by pressing the <em>Back</em> button.</p>
<p>For example, here's how you can replace one fragment with another, and preserve the previous
state in the back stack:</p>
<p>WHATSON? 2857ae40-2d20-407e-b5d3-d78cf17b5d5f</p>
<pre>
// Create new fragment and transaction
Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragmentManager().beginTransaction();

// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);

// Commit the transaction
transaction.commit();
</pre>
<p>In this example, <code>newFragment</code> replaces whatever fragment (if any) is currently in the
layout container identified by the <code>R.id.fragment_container</code> ID. By calling <code>addToBackStack()</code>, the replace transaction is
saved to the back stack so the user can reverse the transaction and bring back the
previous fragment by pressing the <em>Back</em> button.</p>
<p>If you add multiple changes to the transaction (such as another <code>add()</code> or <code>remove()</code>) and call <code>addToBackStack()</code>, then all changes applied
before you call <code>commit()</code> are added to the
back stack as a single transaction and the <em>Back</em> button will reverse them all together.</p>
<p>The order in which you add changes to a <code>FragmentTransaction</code> doesn't matter,
except:</p>
<ul>
  <li>You must call <code>commit()</code> last</li>
  <li>If you're adding multiple fragments to the same container, then the order in which
you add them determines the order they appear in the view hierarchy</li>
</ul>
<p>If you do not call <code>addToBackStack()</code> when you perform a transaction that removes a fragment, then that fragment is
destroyed when the transaction is committed and the user cannot navigate back to it. Whereas, if you
do call <code>addToBackStack()</code> when
removing a fragment, then the fragment is <em>stopped</em> and will be resumed if the user navigates
back.</p>
<p><strong>Tip:</strong> For each fragment transaction, you can apply a transition
animation, by calling <code>setTransition()</code> before
you commit.</p>
<p>Calling <code>commit()</code> does not perform the transaction
immediately. Rather, it schedules it to run on the activity's UI thread (the "main" thread) as soon
as the thread is able to do so. If necessary, however, you may call <code>executePendingTransactions()</code> from your UI thread to immediately execute
transactions submitted by <code>commit()</code>. Doing so is
usually not necessary unless the transaction is a dependency for jobs in other threads.</p>
<p><strong>Caution:</strong> You can commit a transaction using <code>commit()</code> only prior to the activity saving its
state (when the user leaves the activity). If you attempt to commit after that point, an
exception will be thrown. This is because the state after the commit can be lost if the activity
needs to be restored. For situations in which its okay that you lose the commit, use <code>commitAllowingStateLoss()</code>.</p>
<h2>Communicating with the Activity</h2>
<p>Although a <code>Fragment</code> is implemented as an object that's independent from an
<code>Activity</code> and can be used inside multiple activities, a given instance of
a fragment is directly tied to the activity that contains it.</p>
<p>Specifically, the fragment can access the <code>Activity</code> instance with <code>getActivity()</code> and easily perform tasks such as find a view in the
activity layout:</p>
<p>WHATSON? ac519ad3-a28a-42b0-9b34-d3b499a91f6b</p>
<pre>
View listView = <code>getActivity()</code>.<code>findViewById</code>(R.id.list);
</pre>
<p>Likewise, your activity can call methods in the fragment by acquiring a reference to the
<code>Fragment</code> from <code>FragmentManager</code>, using <code>findFragmentById()</code> or <code>findFragmentByTag()</code>. For example:</p>
<p>WHATSON? abad6f33-6d2e-4f2a-b947-51f38d58f57a</p>
<pre>
ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);
</pre>
<h3>Creating event callbacks to the activity</h3>
<p>In some cases, you might need a fragment to share events with the activity. A good way to do that
is to define a callback interface inside the fragment and require that the host activity implement
it. When the activity receives a callback through the interface, it can share the information with
other fragments in the layout as necessary.</p>
<p>For example, if a news application has two fragments in an activity—one to show a list of
articles (fragment A) and another to display an article (fragment B)—then fragment A must tell
the activity when a list item is selected so that it can tell fragment B to display the article. In
this case, the <code>OnArticleSelectedListener</code> interface is declared inside fragment A:</p>
<p>WHATSON? 2301a3dd-90eb-4002-a60b-8a88181acf98</p>
<pre>
public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}
</pre>
<p>Then the activity that hosts the fragment implements the <code>OnArticleSelectedListener</code>
interface and
overrides <code>onArticleSelected()</code> to notify fragment B of the event from fragment A. To ensure
that the host activity implements this interface, fragment A's <code>onAttach()</code> callback method (which the system calls when adding
the fragment to the activity) instantiates an instance of <code>OnArticleSelectedListener</code> by
casting the <code>Activity</code> that is passed into <code>onAttach()</code>:</p>
<p>WHATSON? 2af405bd-2f99-4b7c-93ac-52d0e622fac1</p>
<pre>
public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
        }
    }
    ...
}
</pre>
<p>If the activity has not implemented the interface, then the fragment throws a
<code>ClassCastException</code>.
On success, the <code>mListener</code> member holds a reference to activity's implementation of 
<code>OnArticleSelectedListener</code>, so that fragment A can share events with the activity by calling
methods defined by the <code>OnArticleSelectedListener</code> interface. For example, if fragment A is an
extension of <code>ListFragment</code>, each time
the user clicks a list item, the system calls <code>onListItemClick()</code> in the fragment, which then calls <code>onArticleSelected()</code> to share
the event with the activity:</p>
<p>WHATSON? 4cffed38-9d4f-494b-acb4-85c82ce0fc88</p>
<pre>
public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item's row ID with the content provider Uri
        Uri noteUri = ContentUris.<code>withAppendedId</code>(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }
    ...
}
</pre>
<p>The <code>id</code> parameter passed to <code>onListItemClick()</code> is the row ID of the clicked item,
which the activity (or other fragment) uses to fetch the article from the application's <code>ContentProvider</code>.</p>
<p><!--To see a complete implementation of this kind of callback interface, see the <a
href="/resources/samples/NotePad/index.html">NotePad sample. -->More information about
using a content provider is available in the Content Providers document.</p>
<h3>Adding items to the Action Bar</h3>
<p>Your fragments can contribute menu items to the activity's Options Menu (and, consequently, the Action Bar) by implementing
<code>onCreateOptionsMenu()</code>. In order
for this method to receive calls, however, you must call <code>setHasOptionsMenu()</code> during <code>onCreate()</code>, to indicate that the fragment
would like to add items to the Options Menu (otherwise, the fragment will not receive a call to
<code>onCreateOptionsMenu()</code>).</p>
<p>Any items that you then add to the Options Menu from the fragment are appended to the existing
menu items. The fragment also receives callbacks to <code>onOptionsItemSelected()</code> when a menu item
is selected.</p>
<p>You can also register a view in your fragment layout to provide a context menu by calling <code>registerForContextMenu()</code>. When the user opens
the context menu, the fragment receives a call to <code>onCreateContextMenu()</code>. When the user selects an item, the fragment receives a call to <code>onContextItemSelected()</code>.</p>
<p><strong>Note:</strong> Although your fragment receives an on-item-selected callback
for each menu item it adds, the activity is first to receive the respective callback when the user
selects a menu item. If the activity's implementation of the on-item-selected callback does not
handle the selected item, then the event is passed to the fragment's callback. This is true for
the Options Menu and context menus.</p>
<p>For more information about menus, see the Menus and Action Bar developer guides.</p>
<h2>Handling the Fragment Lifecycle</h2>
<p><strong>Figure 3.</strong> The effect of the activity lifecycle on the fragment
lifecycle.</p>
<p>Managing the lifecycle of a fragment is a lot like managing the lifecycle of an activity. Like
an activity, a fragment can exist in three states:</p>
<p>Also like an activity, you can retain the state of a fragment using a <code>Bundle</code>, in case the activity's process is killed and you need to restore the
fragment state when the activity is recreated. You can save the state during the fragment's <code>onSaveInstanceState()</code> callback and restore it during
either <code>onCreate()</code>, <code>onCreateView()</code>, or <code>onActivityCreated()</code>. For more information about saving
state, see the Activities
document.</p>
<p>The most significant difference in lifecycle between an activity and a fragment is how one is
stored in its respective back stack. An activity is placed into a back stack of activities
that's managed by the system when it's stopped, by default (so that the user can navigate back
to it with the <em>Back</em> button, as discussed in Tasks and Back Stack).
However, a fragment is placed into a back stack managed by the host activity only when you
explicitly request that the instance be saved by calling <code>addToBackStack()</code> during a transaction that
removes the fragment.</p>
<p>Otherwise, managing the fragment lifecycle is very similar to managing the activity
lifecycle. So, the same practices for managing the activity
lifecycle also apply to fragments. What you also need to understand, though, is how the life
of the activity affects the life of the fragment.</p>
<p><strong>Caution:</strong> If you need a <code>Context</code> object
within your <code>Fragment</code>, you can call <code>getActivity()</code>.
However, be careful to call <code>getActivity()</code> only when the fragment is
attached to an activity. When the fragment is not yet attached, or was detached during the end of
its lifecycle, <code>getActivity()</code> will return null.</p>
<h3>Coordinating with the activity lifecycle</h3>
<p>The lifecycle of the activity in which the fragment lives directly affects the lifecycle of the
fragment, such that each lifecycle callback for the activity results in a similar callback for each
fragment. For example, when the activity receives <code>onPause()</code>, each
fragment in the activity receives <code>onPause()</code>.</p>
<p>Fragments have a few extra lifecycle callbacks, however, that handle unique interaction with the
activity in order to perform actions such as build and destroy the fragment's UI. These additional
callback methods are:</p>
<p>The flow of a fragment's lifecycle, as it is affected by its host activity, is illustrated
by figure 3. In this figure, you can see how each successive state of the activity determines which
callback methods a fragment may receive. For example, when the activity has received its <code>onCreate()</code> callback, a fragment in the activity receives no more than
the <code>onActivityCreated()</code> callback.</p>
<p>Once the activity reaches the resumed state, you can freely add and remove fragments to the
activity. Thus, only while the activity is in the resumed state can the lifecycle of a fragment
change independently.</p>
<p>However, when the activity leaves the resumed state, the fragment again is pushed through its
lifecycle by the activity.</p>
<h2>Example</h2>
<p>To bring everything discussed in this document together, here's an example of an activity
using two fragments to create a two-pane layout. The activity below includes one fragment to
show a list of Shakespeare play titles and another to show a summary of the play when selected
from the list. It also demonstrates how to provide different configurations of the fragments,
based on the screen configuration.</p>
<p><strong>Note:</strong> The complete source code for this activity is available in
<code>FragmentLayout.java</code>.</p>
<p>The main activity applies a layout in the usual way, during <code>onCreate()</code>:</p>
<p>WHATSON? e8d6930f-1a3b-4e8a-8a56-21eb07f87f37</p>
<pre>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.fragment_layout);
}</pre>
<p>The layout applied is <code>fragment_layout.xml</code>:</p>
<p>WHATSON? 3ea63b98-a506-4c6c-a56e-c56349ae7e49</p>
<pre>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent" android:layout_height="match_parent"&gt;

    &lt;fragment class="com.example.android.apis.app.FragmentLayout$TitlesFragment"
            android:id="@+id/titles" android:layout_weight="1"
            android:layout_width="0px" android:layout_height="match_parent" /&gt;

    &lt;FrameLayout android:id="@+id/details" android:layout_weight="1"
            android:layout_width="0px" android:layout_height="match_parent"
            android:background="?android:attr/detailsElementBackground" /&gt;

&lt;/LinearLayout&gt;</pre>
<p>Using this layout, the system instantiates the <code>TitlesFragment</code> (which lists the play
titles) as soon as the activity loads the layout, while the <code>FrameLayout</code>
(where the fragment for showing the play summary will go) consumes space on the right side of the
screen, but remains empty at first. As you'll see below, it's not until the user selects an item
from the list that a fragment is placed into the <code>FrameLayout</code>.</p>
<p>However, not all screen configurations are wide enough to show both the list of
plays and the summary, side by side. So, the layout above is used only for the landscape
screen configuration, by saving it at <code>res/layout-land/fragment_layout.xml</code>.</p>
<p>Thus, when the screen is in portrait orientation, the system applies the following layout, which
is saved at <code>res/layout/fragment_layout.xml</code>:</p>
<p>WHATSON? c11524d4-127f-4298-9885-056e2b92d972</p>
<pre>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent" android:layout_height="match_parent"&gt;
    &lt;fragment class="com.example.android.apis.app.FragmentLayout$TitlesFragment"
            android:id="@+id/titles"
            android:layout_width="match_parent" android:layout_height="match_parent" /&gt;
&lt;/FrameLayout&gt;</pre>
<p>This layout includes only <code>TitlesFragment</code>. This means that, when the device is in
portrait orientation, only the list of play titles is visible. So, when the user clicks a list
item in this configuration, the application will start a new activity to show the summary,
instead of loading a second fragment.</p>
<p>Next, you can see how this is accomplished in the fragment classes. First is <code>TitlesFragment</code>, which shows the list of Shakespeare play titles. This fragment extends <code>ListFragment</code> and relies on it to handle most of the list view work.</p>
<p>As you inspect this code, notice that there are two possible behaviors when the user clicks a
list item: depending on which of the two layouts is active, it can either create and display a new
fragment to show the details in the same activity (adding the fragment to the <code>FrameLayout</code>), or start a new activity (where the fragment can be shown).</p>
<p>WHATSON? 50bdcc11-46b7-46e0-a883-fdfef21579e8</p>
<pre>public static class TitlesFragment extends ListFragment {
    boolean mDualPane;
    int mCurCheckPosition = 0;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        // Populate list with our static array of titles.
        setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(),
                android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES));

        // Check to see if we have a frame in which to embed the details
        // fragment directly in the containing UI.
        View detailsFrame = getActivity().findViewById(R.id.details);
        mDualPane = detailsFrame != null &amp;&amp; detailsFrame.getVisibility() == View.VISIBLE;

        if (savedInstanceState != null) {
            // Restore last state for checked position.
            mCurCheckPosition = savedInstanceState.getInt("curChoice", 0);
        }

        if (mDualPane) {
            // In dual-pane mode, the list view highlights the selected item.
            getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
            // Make sure our UI is in the correct state.
            showDetails(mCurCheckPosition);
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt("curChoice", mCurCheckPosition);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        showDetails(position);
    }

    /**
     * Helper function to show the details of a selected item, either by
     * displaying a fragment in-place in the current UI, or starting a
     * whole new activity in which it is displayed.
     */
    void showDetails(int index) {
        mCurCheckPosition = index;

        if (mDualPane) {
            // We can display everything in-place with fragments, so update
            // the list to highlight the selected item and show the data.
            getListView().setItemChecked(index, true);

            // Check what fragment is currently shown, replace if needed.
            DetailsFragment details = (DetailsFragment)
                    getFragmentManager().findFragmentById(R.id.details);
            if (details == null || details.getShownIndex() != index) {
                // Make new fragment to show this selection.
                details = DetailsFragment.newInstance(index);

                // Execute a transaction, replacing any existing fragment
                // with this one inside the frame.
                FragmentTransaction ft = getFragmentManager().beginTransaction();
                if (index == 0) {
                    ft.replace(R.id.details, details);
                } else {
                    ft.replace(R.id.a_item, details);
                }
                ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
                ft.commit();
            }

        } else {
            // Otherwise we need to launch a new activity to display
            // the dialog fragment with selected text.
            Intent intent = new Intent();
            intent.setClass(getActivity(), DetailsActivity.class);
            intent.putExtra("index", index);
            startActivity(intent);
        }
    }
}</pre>
<p>The second fragment, <code>DetailsFragment</code> shows the play summary for the item selected from
the list from <code>TitlesFragment</code>:</p>
<p>WHATSON? e7fbd305-5542-405e-817f-3006a0e88d1e</p>
<pre>public static class DetailsFragment extends Fragment {
    /**
     * Create a new instance of DetailsFragment, initialized to
     * show the text at 'index'.
     */
    public static DetailsFragment newInstance(int index) {
        DetailsFragment f = new DetailsFragment();

        // Supply index input as an argument.
        Bundle args = new Bundle();
        args.putInt("index", index);
        f.setArguments(args);

        return f;
    }

    public int getShownIndex() {
        return getArguments().getInt("index", 0);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (container == null) {
            // We have different layouts, and in one of them this
            // fragment's containing frame doesn't exist.  The fragment
            // may still be created from its saved state, but there is
            // no reason to try to create its view hierarchy because it
            // won't be displayed.  Note this is not needed -- we could
            // just run the code below, where we would create and return
            // the view hierarchy; it would just never be used.
            return null;
        }

        ScrollView scroller = new ScrollView(getActivity());
        TextView text = new TextView(getActivity());
        int padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                4, getActivity().getResources().getDisplayMetrics());
        text.setPadding(padding, padding, padding, padding);
        scroller.addView(text);
        text.setText(Shakespeare.DIALOGUE[getShownIndex()]);
        return scroller;
    }
}</pre>
<p>Recall from the <code>TitlesFragment</code> class, that, if the user clicks a list item and the
current layout does <em>not</em> include the <code>R.id.details</code> view (which is where the
<code>DetailsFragment</code> belongs), then the application starts the <code>DetailsActivity</code>
activity to display the content of the item.</p>
<p>Here is the <code>DetailsActivity</code>, which simply embeds the <code>DetailsFragment</code> to display
the selected play summary when the screen is in portrait orientation:</p>
<p>WHATSON? c0a6667a-9b64-400d-8cff-3645c6211606</p>
<pre>public static class DetailsActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (getResources().getConfiguration().orientation
                == Configuration.ORIENTATION_LANDSCAPE) {
            // If the screen is now in landscape mode, we can show the
            // dialog in-line with the list so we don't need this activity.
            finish();
            return;
        }

        if (savedInstanceState == null) {
            // During initial setup, plug in the details fragment.
            DetailsFragment details = new DetailsFragment();
            details.setArguments(getIntent().getExtras());
            getFragmentManager().beginTransaction().add(android.R.id.content, details).commit();
        }
    }
}</pre>
<p>Notice that this activity finishes itself if the configuration is landscape, so that the main
activity can take over and display the <code>DetailsFragment</code> alongside the <code>TitlesFragment</code>.
This can happen if the user begins the <code>DetailsActivity</code> while in portrait orientation, but
then rotates to landscape (which restarts the current activity).</p>
<p>For more samples using fragments (and complete source files for this example),
see the API Demos sample app available in 
ApiDemos (available for download from the Samples SDK component).</p>
</body>
</html>