<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Metaprogramming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Metaprogramming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li><strong class="selflink">Metaprogramming</strong>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Metaprogramming</b> is the writing of computer programs with the ability to treat programs as their data. It means that a program could be designed to read, generate, analyse and/or transform other programs, and even modify itself while running. In some cases, this allows programmers to minimize the number of lines of code to express a solution (hence reducing development time), or it gives programs greater flexibility to efficiently handle new situations without recompilation.</p>
<p>The language in which the metaprogram is written is called the metalanguage. The language of the programs that are manipulated is called the <i>object language</i>. The ability of a programming language to be its own metalanguage is called <i>reflection</i> or <i>reflexivity</i>.</p>
<p>Reflection is a valuable language feature to facilitate metaprogramming. Having the programming language itself as a first-class data type (as in Lisp, Forth or Rebol) is also very useful; this is known as <i>homoiconicity</i>. Generic programming invokes a metaprogramming facility within a language, in those languages supporting it.</p>
<p>Metaprogramming usually works in one of three ways. The first way is to expose the internals of the run-time engine to the programming code through application programming interfaces (APIs). The second approach is dynamic execution of expressions that contain programming commands, often composed from strings, but can also be from other methods using arguments and/or context. Thus, "programs can write programs." Although both approaches can be used in the same language, most languages tend to lean toward one or the other.</p>
<p>The third way is to step outside the language entirely. General purpose program transformation systems, which accept language descriptions and can carry out arbitrary transformations on those languages, are direct implementations of general metaprogramming. This allows metaprogramming to be applied to virtually any target language without regard to whether that target language has any metaprogramming abilities of its own.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Approaches
<ul>
<li>1.1 In statically typed functional languages</li>
<li>1.2 Template metaprogramming</li>
<li>1.3 Staged meta-programming</li>
<li>1.4 Macro systems
<ul>
<li>1.4.1 IBM/360 assembler</li>
</ul>
</li>
</ul>
</li>
<li>2 Examples</li>
<li>3 Implementations</li>
<li>4 See also</li>
<li>5 Notes</li>
<li>6 External links</li>
</ul>
<ul>
<li>1.1 In statically typed functional languages</li>
<li>1.2 Template metaprogramming</li>
<li>1.3 Staged meta-programming</li>
<li>1.4 Macro systems
<ul>
<li>1.4.1 IBM/360 assembler</li>
</ul>
</li>
</ul>
<ul>
<li>1.4.1 IBM/360 assembler</li>
</ul>
<p></p>
<h2>Approaches</h2>
<h3>In statically typed functional languages</h3>
<ul>
<li>Usage of dependent types allows proving that generated code is never invalid.</li>
</ul>
<h3>Template metaprogramming</h3>
<ul>
<li>C "X Macros"</li>
<li>C++ Templates</li>
</ul>
<h3>Staged meta-programming</h3>
<ul>
<li>MetaML</li>
<li>MetaOCaml</li>
</ul>
<h3>Macro systems</h3>
<ul>
<li>Scheme hygienic macros</li>
<li>MacroML</li>
<li>Template Haskell</li>
</ul>
<h4>IBM/360 assembler</h4>
<p>The IBM/360 and derivatives had powerful assembler macro facilities that were often used to generate complete programs or sections of programs (for different operating systems for instance). Macros provided with CICS transaction processing system had assembler macros that generated COBOL statements as a pre-processing step.</p>
<h2>Examples</h2>
<p>A simple example of a metaprogram is this POSIX Shell script, which is an example of generative programming:</p>
<p>WHATSON? 85e41c59-bbf3-4636-b602-b0a18b6dc117</p>
<pre>
#!/bin/sh
# metaprogram
echo '#!/bin/sh' &gt;program
for I in $(seq 992)
do
        echo "echo $I" &gt;&gt; program
done
chmod +x program
</pre>
<p>This script (or program) generates a new 993-line program that prints out the numbers 1–992. This is only an illustration of how to use code to write more code; it is not the most efficient way to print out a list of numbers. Nonetheless, a programmer can write and execute this metaprogram in less than a minute, and will have generated exactly 1000 lines of code in that amount of time.</p>
<p>A quine is a special kind of metaprogram that produces its own source code as its output.</p>
<p>Not all metaprogramming involves generative programming. If programs are modifiable at runtime or if incremental compilation is available (such as in C#, Forth, Frink, Groovy, JavaScript, Lisp, Lua, Perl, PHP, Python, REBOL, Ruby, Smalltalk, and Tcl), then techniques can be used to perform metaprogramming without actually generating source code.</p>
<p>Lisp is probably the quintessential language with metaprogramming facilities, both because of its historical precedence and because of the simplicity and power of its metaprogramming. In Lisp metaprogramming, the unquote operator (typically a comma) introduces code that is evaluated at program definition time rather than at run time; see Self-evaluating forms and quoting in Lisp. The metaprogramming language is thus identical to the host programming language, and existing Lisp routines can be directly reused for metaprogramming, if desired.</p>
<p>This approach has been implemented in other languages by incorporating an interpreter in the program, which works directly with the program’s data. There are implementations of this kind for some common high-level languages, such as RemObjects’ Pascal Script for Object Pascal.</p>
<p>One style of metaprogramming is to employ domain-specific programming languages (DSLs). A fairly common example of using DSLs involves generative metaprogramming: lex and yacc, two tools used to generate lexical analyzers and parsers, let the user describe the language using regular expressions and context-free grammars, and embed the complex algorithms required to efficiently parse the language.</p>
<h2>Implementations</h2>
<ul>
<li>ASF+SDF Meta Environment</li>
<li>DMS Software Reengineering Toolkit</li>
<li>Joose (JavaScript)</li>
<li>JetBrains MPS</li>
<li>Moose (Perl)</li>
<li>Nemerle</li>
<li>Rascal Metaprogramming Language</li>
<li>Stratego/XT</li>
<li>Template Haskell</li>
</ul>
<p>See also the List of Program Transformation Systems.</p>
<h2>See also</h2>
<ul>
<li>Aspect weaver</li>
<li>Comparison of code generation tools</li>
<li>Compile-time reflection</li>
<li>Inferential programming</li>
<li>Instruction set simulator</li>
<li>Intentional Programming</li>
<li>Interpreted language</li>
<li>Metaobject</li>
<li>Partial evaluation</li>
<li>Self-interpreter</li>
<li>Self-modifying code</li>
<li>Source code generation
<ul>
<li>Source-to-source compilation: automated translation from one programming language to another</li>
</ul>
</li>
<li>Template metaprogramming</li>
</ul>
<ul>
<li>Source-to-source compilation: automated translation from one programming language to another</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Curse program on Program Analysis and Transformation. By Prof. Harald Sondergaard."Curse on Program Analysis and Transformation". Retrieved 18 September 2014. </li>
<li><b>^</b> Czarnecki, Krzysztof; Eisenecker, Ulrich W. (2000). <i>Generative Programming</i>. ISBN 0-201-30977-7. </li>
<li><b>^</b> for example, instance_eval in Ruby takes a string or an anonymous function. "Rdoc for Class: BasicObject (Ruby 1.9.3) - instance_eval". Retrieved 30 December 2011. </li>
<li><b>^</b> Chlipala, Adam (June 2010). "Ur: statically-typed metaprogramming with type-level record computation". <i>ACM SIGPLAN Notices</i>. PLDI '10 <b>45</b> (6): 122–133. doi:10.1145/1809028.1806612. Retrieved 29 August 2012. </li>
</ol>
<h2>External links</h2>
<ul>
<li>c2.com Wiki: Metaprogramming article</li>
<li>Meta Programming on the Program Transformation Wiki</li>
<li>Code generation Vs Metaprogramming</li>
<li>"Solenoid": The first metaprogramming framework for eXist-db</li>
<li>The Art of Enterprise Metaprogramming</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>Array</li>
<li>Aspect-oriented</li>
<li>Class-based</li>
<li>Concatenative</li>
<li>Concurrent</li>
<li>Data-structured</li>
<li>Dataflow</li>
<li>Declarative</li>
<li>Domain-specific</li>
<li>Dynamic</li>
<li>Esoteric</li>
<li>Event-driven</li>
<li>Extensible</li>
<li>Functional</li>
<li>Imperative</li>
<li>Logic</li>
<li>Macro</li>
<li><strong class="selflink">Metaprogramming</strong></li>
<li>Multi-paradigm</li>
<li>Object-based</li>
<li>Object-oriented</li>
<li>Pipeline</li>
<li>Procedural</li>
<li>Prototype-based</li>
<li>Reflective</li>
<li>Rule-based</li>
<li>Scripting</li>
<li>Synchronous</li>
<li>Templating</li>
</ul>
<ul>
<li>Assembly</li>
<li>Compiled</li>
<li>Interpreted</li>
<li>Machine</li>
</ul>
<ul>
<li>Low-level</li>
<li>High-level</li>
<li>Very high-level</li>
</ul>
<ul>
<li>First generation</li>
<li>Second generation</li>
<li>Third generation</li>
<li>Fourth generation</li>
<li>Fifth generation</li>
</ul>
<ul>
<li>Non-English-based</li>
<li>Off-side rule</li>
<li>Visual</li>
</ul>
</body>
</html>