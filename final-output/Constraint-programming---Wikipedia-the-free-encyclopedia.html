<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Constraint-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Constraint programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li><strong class="selflink">Constraint</strong></li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li><strong class="selflink">Constraint</strong></li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computer science, <b>constraint programming</b> is a programming paradigm wherein relations between variables are stated in the form of constraints. Constraints differ from the common primitives of imperative programming languages in that they do not specify a step or sequence of steps to execute, but rather the properties of a solution to be found. This makes constraint programming a form of declarative programming. The constraints used in constraint programming are of various kinds: those used in constraint satisfaction problems (e.g. "A or B is true"), those solved by the simplex algorithm (e.g. "<var>x</var> â‰¤ 5"), and others. Constraints are usually embedded within a programming language or provided via separate software libraries.</p>
<p>Constraint programming can be expressed in the form of constraint logic programming, which embeds constraints into a logic program. This variant of logic programming is due to Jaffar and Lassez, who extended in 1987 a specific class of constraints that were introduced in Prolog II. The first implementations of constraint logic programming were Prolog III, CLP(R), and CHIP.</p>
<p>Instead of logic programming, constraints can be mixed with functional programming, term rewriting, and imperative languages. Programming languages with built-in support for constraints include Oz (functional programming) and Kaleidoscope (imperative programming). Mostly, constraints are implemented in imperative languages via <i>constraint solving toolkits</i>, which are separate libraries for an existing imperative language.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Constraint logic programming</li>
<li>2 Domains</li>
<li>3 Logic programming based constraint logic languages</li>
<li>4 Constraint programming libraries for imperative programming languages</li>
<li>5 Some languages that support constraint programming</li>
<li>6 See also</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<p></p>
<h2>Constraint logic programming</h2>
<p>Constraint programming is an embedding of constraints in a host language. The first host languages used were logic programming languages, so the field was initially called <i>constraint logic programming</i>. The two paradigms share many important features, like logical variables and backtracking. Today most Prolog implementations include one or more libraries for constraint logic programming.</p>
<p>The difference between the two is largely in their styles and approaches to modeling the world. Some problems are more natural (and thus, simpler) to write as logic programs, while some are more natural to write as constraint programs.</p>
<p>The constraint programming approach is to search for a state of the world in which a large number of constraints are satisfied at the same time. A problem is typically stated as a state of the world containing a number of unknown variables. The constraint program searches for values for all the variables.</p>
<p>Temporal concurrent constraint programming (TCC) and non-deterministic temporal concurrent constraint programming (NTCC) are variants of constraint programming that can deal with time. Recently NTCC has proved to be a useful framework for describing and modelling biological systems [1].</p>
<h2>Domains</h2>
<p>The constraints used in constraint programming are typically over some specific domains. Some popular domains for constraint programming are:</p>
<ul>
<li>boolean domains, where only true/false constraints apply (SAT problem)</li>
<li>integer domains, rational domains</li>
<li>linear domains, where only linear functions are described and analyzed (although approaches to non-linear problems do exist)</li>
<li>finite domains, where constraints are defined over finite sets</li>
<li>mixed domains, involving two or more of the above</li>
</ul>
<p>Finite domains is one of the most successful domains of constraint programming. In some areas (like operations research) constraint programming is often identified with constraint programming over finite domains.</p>
<p>All of the above examples are commonly solved by satisfiability modulo theories (SMT) solvers.</p>
<p>Finite domain solvers are useful for solving constraint satisfaction problems, and are often based on arc consistency or one of its approximations.</p>
<p>The syntax for expressing constraints over finite domains depends on the host language. The following is a Prolog program that solves the classical alphametic puzzle SEND+MORE=MONEY in constraint logic programming:</p>
<p>WHATSON? dd74bb6e-4961-4a55-b1e9-8eb08d3693d8</p>
<pre>
% This code works in both YAP and SWI-Prolog using the environment-supplied
% CLPFD constraint solver library.  It may require minor modifications to work
% in other Prolog environments or using other constraint solvers.
:- use_module(library(clpfd)).
sendmore(Digits) :-
   Digits = [S,E,N,D,M,O,R,Y],     % Create variables
   Digits <b>ins</b> 0..9,                % Associate domains to variables
   S <b>#\=</b> 0,                        % Constraint: S must be different from 0
   M <b>#\=</b> 0,
   <b>all_different</b>(Digits),          % all the elements must take different values
                1000*S + 100*E + 10*N + D     % Other constraints
              + 1000*M + 100*O + 10*R + E
   <b>#=</b> 10000*M + 1000*O + 100*N + 10*E + Y,
   <b>label</b>(Digits).                  % Start the search
</pre>
<p>The interpreter creates a variable for each letter in the puzzle. The operator <code>ins</code> is used to specify the domains of these variables, so that they range over the set of values {0,1,2,3, ..., 9}. The constraints <code>S#\=0</code> and <code>M#\=0</code> means that these two variables cannot take the value zero. When the interpreter evaluates these constraints, it reduces the domains of these two variables by removing the value 0 from them. Then, the constraint <code>all_different(Digits)</code> is considered; it does not reduce any domain, so it is simply stored. The last constraint specifies that the digits assigned to the letters must be such that "SEND+MORE=MONEY" holds when each letter is replaced by its corresponding digit. From this constraint, the solver infers that M=1. All stored constraints involving variable M are awakened: in this case, constraint propagation on the <code>all_different</code> constraint removes value 1 from the domain of all the remaining variables. Constraint propagation may solve the problem by reducing all domains to a single value, it may prove that the problem has no solution by reducing a domain to the empty set, but may also terminate without proving satisfiability or unsatisfiability. The <b>label</b> literals are used to actually perform search for a solution.</p>
<h2>Logic programming based constraint logic languages</h2>
<ul>
<li>B-Prolog (Prolog-based, proprietary)</li>
<li>CHIP V5 (Prolog-based, also includes C++ and C libraries, proprietary)</li>
<li>Ciao (Prolog-based, Free software: GPL/LGPL)</li>
<li>ECLiPSe (Prolog-based, open source)</li>
<li>SICStus (Prolog-based, proprietary)</li>
<li>GNU Prolog (free software)</li>
<li>YAP Prolog[2]</li>
<li>SWI Prolog a free Prolog system containing several libraries for constraint solving</li>
<li>Jekejeke Minlog (Prolog-based, proprietary)</li>
<li>F1 Compiler (free software)</li>
</ul>
<h2>Constraint programming libraries for imperative programming languages</h2>
<p>Constraint programming is often realized in imperative programming via a separate library. Some popular libraries for constraint programming are:</p>
<ul>
<li>Artelys Kalis (C++, Java, Python library, FICO Xpress module, proprietary)</li>
<li>Cassowary (Smalltalk, C++ and Java library, free software: LGPL, no longer maintained)</li>
<li>CHIP V5 C++ and C libraries (proprietary)</li>
<li>Choco (Java library, free software: X11 style)</li>
<li>Comet (C style language for constraint programming, constraint-based local search and mathematical programming, free binaries available for academic use)</li>
<li>Cream (Java library, free software: LGPL)</li>
<li>Disolver (C++ library, proprietary)</li>
<li>Emma (Python library, proprietary)</li>
<li>Gecode (C++ library, free software: X11 style)</li>
<li>Google CP Solver (Python, Java, C++ and .NET library, Apache license)</li>
<li>IBM ILOG CP (C++ library, proprietary) and CP Optimizer (C++, Java, .NET libraries, proprietary) successor of ILOG Solver, which was considered the market leader in commercial constraint programming software as of 2006</li>
<li>JaCoP (Java library, open source) available here</li>
<li>JOpt (Java library, free software)</li>
<li>JSR-331 (Java Constraint Programming API, JCP standard)</li>
<li>Koalog Constraint Solver (Java library, proprietary)</li>
<li>Numberjack (Python platform, free software: LGPL)</li>
<li>Minion (C++ program, GPL)</li>
<li>python-constraint (Python library, GPL)</li>
<li>OscaR (Scala library, LGPL)</li>
<li>Turtle (free software: GPL)</li>
<li>OptaPlanner (Java library, Apache license)</li>
</ul>
<h2>Some languages that support constraint programming</h2>
<ul>
<li>AIMMS, an algebraic modeling language with support for constraint programming.</li>
<li>Alma-0 a small, strongly typed, constraint language with a limited number of features inspired by logic programming, supporting imperative programming.</li>
<li>AMPL, an algebraic modeling language with support for constraint programming.</li>
<li>Bertrand a language for building constraint programming systems.</li>
<li>Common Lisp via Screamer (a free software library which provides backtracking and CLP(R), CHiP features).</li>
<li>G12 MiniZinc (a high-level constraint programming system, BSD-style license)</li>
<li>Kaleidoscope, an object-oriented imperative constraint programming language.</li>
<li>Oz</li>
<li>Claire</li>
<li>Curry (Haskell based, with free implementations)</li>
<li>SystemVerilog Computer hardware simulation language has built in constraint solver.</li>
</ul>
<h2>See also</h2>
<ul>
<li>Combinatorial optimization</li>
<li>Constraint satisfaction</li>
<li>Constraint logic programming</li>
<li>Heuristic algorithms</li>
<li>Mathematical programming (Optimization theory)</li>
<li>Nurse scheduling problem</li>
<li>Traveling tournament problem</li>
<li>Concurrent Constraint Programming (CCP)</li>
</ul>
</body>
</html>