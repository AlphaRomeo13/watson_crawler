<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Method-computer-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Method (computer programming)</h1>
<p>A <b>method</b> (or a <b>member function</b>) in object-oriented programming (OOP) is a subroutine associated with an object of a class that forms its interface through which the outside members of the class (other objects) can access its private members (mainly the encapsulated data). Methods define the behaviour of objects at program run time. Methods can be defined both inside and outside a class. When defined inside they are automatically inline and are bound to the class at compile time (<i>static binding</i>) otherwise they are bound at runtime (<i>dynamic binding</i>).</p>
<p><br></p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Example</li>
<li>2 Abstract methods
<ul>
<li>2.1 Example</li>
</ul>
</li>
<li>3 Accessor, mutator and manager methods</li>
<li>4 Class methods</li>
<li>5 Conversion operator methods</li>
<li>6 Hook methods</li>
<li>7 Overloaded methods</li>
<li>8 Overridden methods</li>
<li>9 Special methods
<ul>
<li>9.1 Constructors</li>
<li>9.2 Destruction</li>
<li>9.3 Copy-assignment operators</li>
<li>9.4 Operator methods</li>
</ul>
</li>
<li>10 Static methods</li>
<li>11 Virtual methods</li>
<li>12 References</li>
<li>13 See also</li>
</ul>
<ul>
<li>2.1 Example</li>
</ul>
<ul>
<li>9.1 Constructors</li>
<li>9.2 Destruction</li>
<li>9.3 Copy-assignment operators</li>
<li>9.4 Operator methods</li>
</ul>
<p></p>
<h2>Example</h2>
<p>The following Java code defines a method "rectangle" in the class "Main" that can find the area of a rectangle.</p>
<p>WHATSON? 3c223c31-fca4-441f-8b43-ef7a1e56cd7d</p>
<pre>
public class Main
{
        int rectangle(int h, int w)
        {
                return h*w;
        }
}
</pre>
<p>The following C++ code defines methods "input" and "display".</p>
<p>WHATSON? df6bbbe5-65e0-430b-bea5-b6efc9a98b72</p>
<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;array&gt;
 
struct goods
{
	std::string name;
	float price;
	static int percent;
	void input()
	{
		std::cout &lt;&lt; "Good's name: ";
		std::cin &gt;&gt; name;
		std::cout &lt;&lt; "Price: ";
		std::cin &gt;&gt; price;
	}
	void display()
	{
		std::cout &lt;&lt; "\n" &lt;&lt; name;
		std::cout &lt;&lt; ", Final price with tax: ";
		std::cout &lt;&lt; static_cast&lt;long&gt;(price * (1.0 + goods::percent * 0.01));
		std::cout &lt;&lt; "\n";
	}
};
 
int goods::percent = 20;
 
int main()
{
	std::array&lt;goods, 3&gt; a;
	for (auto&amp;&amp; i : a)
	{
		i.input();
	}
	for (auto&amp;&amp; i : a)
	{
		i.display();
	}
}
</pre>
<h2>Abstract methods</h2>
<p>An <i>abstract method</i> is one with only a signature and no implementation body. It is often used to specify that a subclass must provide an implementation of the method. Abstract methods are used to specify interfaces in some computer languages.</p>
<h3>Example</h3>
<p>The following Java code shows an abstract class that needs to be extended:</p>
<p>WHATSON? 70b5ed34-d133-4f8f-bbf1-8b194a6262d5</p>
<pre>
abstract class Main {
    abstract int rectangle(int h, int w); // abstract method signature
}
</pre>
<p>The following subclass extends the main class:</p>
<p>WHATSON? a9fc6544-4280-49f0-93a5-5689d672e94e</p>
<pre>
public class Main2 extends Main {
 
    @Override
    int rectangle(int h, int w)
    {
        return h * w;
    }
 
}
</pre>
<h2>Accessor, mutator and manager methods</h2>
<p>Accessor methods (also called getters) are used to read values of private data members of an object which are directly inaccessible to non member methods. Mutator methods (also called setters) are used to modify values of private data members of an object. Manager methods are used to initialize and destroy objects of a class, e.g. constructors and destructors.</p>
<p>An 'accessor' method is a method that is usually small, simple and provides the sole means for accessing (retrieving) the state of an object from other parts of a program.</p>
<p>Although this introduces a new dependency, as stated above, use of methods is preferred, in the object-oriented paradigm, to directly accessing state data - because those methods provide an abstraction layer. For example, if a bank-account class provides a <code>getBalance()</code> accessor method to retrieve the current balance (rather than directly accessing the balance data fields), then later revisions of the same code can implement a more complex mechanism for balance retrieval (say, a database fetch), without the dependent code needing to be changed (However, this often claimed advantage is not unique to object-oriented programming, and was earlier implemented - when desirable in critical systems - through conventional modular programming with optional run-time, system-wide locking mechanisms, in the imperative/procedural paradigms).</p>
<p>To compare the value of two data items, two accessor-method calls are normally required before a comparison can take place between the retrieved primitive data type values. <i>Comparator</i> methods are required to compare entire objects for equality. This contrasts with a direct comparison in non-OOP paradigms. An <i>update</i>, <i>modifier</i>, or <i>mutator</i> method, is an accessor method that changes the state of an object. Objects that provide such methods are considered mutable objects.</p>
<h2>Class methods</h2>
<p>Class methods are methods that are called on a class (compare this to <i>class instance methods</i>, or <i>object methods</i>). Exact meaning varies depending on the programming languages.</p>
<p>In some languages (e.g. Smalltalk, Python, Ruby, Objective-C, Swift), class methods are methods that are called on a class <i>object.</i> This is virtually identical to instance methods, except that in class methods <code>this</code> refers to the class object, not the instance object. In these languages, class methods are resolved dynamically (at runtime), just like instance methods. Class methods may be implemented as class objects being instances of a <code>Class</code> class (hence called a metaclass), and the class method on the class (instance of metaclass) being an instance method on the metaclass, in which case class methods are just a form of instance methods.</p>
<p>In other languages, notably C++ and Java, class methods are synonymous with static methods (see below), which are resolved at compile-time with a known class name. <code>this</code> cannot be used in static methods, either to refer to the instance or the class.</p>
<p>Python is unusual in having both class methods in the object-oriented sense – methods called on a class object, referred to as <code>cls</code> instead of <code>self</code> for class instance objects – which are created with the <code>classmethod</code> decorator; and functions that are defined in a class – and can be overridden in derived classes – but have no <code>this</code>, and cannot refer to either the instance object or the class object. These latter are called "static methods", by analogy with C++ and Java, and are created with the <code>staticmethod</code> decorator, but are resolved dynamically (at run time). Further, Python resolves methods on the class if no matches are found on an object, thus it may resolve a method call on an object to a class method or static method, based on the type of the object.</p>
<h2>Conversion operator methods</h2>
<p>A conversion operator provides a means for the compiler to implicitly (performed by the compiler automatically when appropriate) provide an object of a type other than the type of the class object.</p>
<h2>Hook methods</h2>
<p>Hook methods are defined in abstract classes and called from a template method. Hooks are used as placeholders that can be supplied by the component's client in a concrete derived class. Here is a Java example:</p>
<p>WHATSON? 6cba3274-2889-4769-b3dd-aa066ea52998</p>
<pre>
/**
 */
public abstract class Beverage implements Beveragelike {
 
	/**
	 * Adds condiments to the beverage
	 */
	public abstract void addCondiments();
 
	/**
	 * Hook method that determines whether the customer wants condiments
	 * or not. Can be overridden.
	 * @return true, if the customer wants condiments, and false otherwise.
	 */
	public boolean customerWantsCondiments() {
		return true;
	}
 
	/**
	 * Prepares the beverage according to this recipe.
	 */
	public final void prepareRecipe() {
		// …
 
		if (customerWantsCondiments()) {
		    addCondiments();
		}
	}
}
</pre>
<h2>Overloaded methods</h2>
<p><i>Overloaded methods</i> are those that appear to have the same name, but that have different formal parameter types (or result value type, if the language supports overloading on result type). The "real name" of the method is made up by concatenating the identifier used to name the method with an encoding of the types, so this works only for languages in which the types are statically known. Overloading is generally confusing; it is better practice to simply come up with more meaningful names for methods, that is, names that explain the role of the parameters. For example, the following C++ class has two methods named "area", but their different parameter lists distinguish the methods.</p>
<p>WHATSON? e9c8bd23-dc37-4858-8e2c-3345822b77d0</p>
<pre>
#include &lt;iostream&gt;
 
class geometry
{
public:
	static double area(double h, double w)
	{
		return h * w;
	}
	static double area(double r)
	{
		return r * r * 3.14;
	}
 
};
 
int main()
{
	double rectangle_area = geometry::area(3, 4);
	double circle_area = geometry::area(5);
	std::cout &lt;&lt; rectangle_area &lt;&lt; '\n';
	std::cout &lt;&lt; circle_area &lt;&lt; '\n';
}
</pre>
<h2>Overridden methods</h2>
<p><i>Overridden methods</i> are those that are redefined in a subclass and hide methods of a superclass. The new method can use the previous definition through a special mechanism, for example, the super keyword in Smalltalk and Java. Some people confuse overriding with overloaded methods, but they are really quite different; the main difference is that the choice of method from a set of overriding methods is made according to the class of the receiver of the method request, whereas the name of an overloaded method is constructed according to the static types of the arguments to the method request. Another difference is that an overriding method must be declared in a subclass of the class that declared the overridden method, while several overloadings of a method name can be declared in the same class. Look at the following example from Java:</p>
<p>WHATSON? 3e6a28a7-1a0b-49c2-9e00-1ff1a26aa0f2</p>
<pre>
public class class1
{
	int f(int x)
	{
		return x+3;
	}
}
 
public class class2 extends class1
{
	@Override
	int f(int x) // overriding
	{
		return x*x;
	}
	int f(int x, int y) // overloading
	{
		return x*y;
	}
}
</pre>
<p></p>
<h2>Special methods</h2>
<p>Special methods are very language-specific and a language may support none, some, or all of the special methods defined here. A language's compiler may automatically generate default special methods or a programmer may be allowed to optionally define special methods. Most special methods cannot be directly called, but rather the compiler generates code to call them at appropriate times. The syntax for definition and calling (i.e., when a special method can be called) of special methods varies amongst programming languages.</p>
<h3>Constructors</h3>
<p>A <i>constructor</i> is a class method that is called automatically at the beginning of an object's lifetime to initialize the object, a process called construction (or <i>instantiation</i>). Initialization may include acquisition of resources. A language may provide a means to control whether a constructor can be called implicitly (by the compiler) or only explicitly (by the programmer). Constructors may have parameters but usually do not return values in most languages. See the following example in Java:</p>
<p>WHATSON? 8d9385c5-9429-4246-9df5-5bee8030dbf6</p>
<pre>
public class Main
{
	String name;
	int roll;
	Main(String _name, int _roll) { //constructor method
		(this).name = _name;
		(this).roll = _roll;
	}
 
}
</pre>
<h3>Destruction</h3>
<p>A <i>destructor</i> is a class method that is called automatically at the end of an object's lifetime, a process called destruction. Destruction in most languages does not allow destructor method arguments nor return values. (In some languages, a destructor can return a value which can then be used to obtain a public representation (transfer encoding) of an instance of a class and simultaneously destroy the copy of the instance stored in current thread's memory). Destruction can be implemented so as to perform cleanup chores and other tasks at object destruction.</p>
<h3>Copy-assignment operators</h3>
<p>Copy-assignment operators define actions to be performed by the compiler when a class object is assigned to a class object of the same type.</p>
<h3>Operator methods</h3>
<p>Operator methods define or redefine operator symbols and define the operations to be performed with the symbol and the associated method parameters. C++ Example:</p>
<p>WHATSON? 7b38fa59-36fc-49e0-b0f9-acf58347b8ad</p>
<pre>
class data
{
public:
	string name;
	int roll;
	bool operator &lt; (const data&amp; p) const
	{
		return roll &lt; p.roll;
	}
	bool operator == (const data&amp; p) const
	{
		return (name == p.name) and (roll == p.roll);
	}
};
</pre>
<p>Some programming languages don't support operator methods as they might create confusion. For details read: Operator overloading.</p>
<h2>Static methods</h2>
<p>Static methods neither require an instance of the class nor can they implicitly access the data (or <code>this</code>, <code>self</code>, <code>Me</code>, etc.) of such an instance. A static method is distinguished in some programming languages with the <code>static</code> keyword placed somewhere in the method's signature.</p>
<p>In statically typed languages such as Java, static methods are called "static" because they are resolved statically (i.e. at compile time) based on the class they are called on and not dynamically as in the case with instance methods which are resolved polymorphically based on the runtime type of the object. Therefore, static methods cannot be overridden.</p>
<h2>Virtual methods</h2>
<p><i>Virtual methods</i> are the means by which a class object can achieve polymorphic behavior. <i>Non-virtual methods</i>, or <i>regular methods</i>, are those which do not participate in polymorphism.</p>
<p>C++ Example:</p>
<p>WHATSON? 9c4adf24-e423-4f9d-a19d-64b979a9c580</p>
<pre>
#include &lt;iostream&gt;
#include &lt;memory&gt;
 
class Super
{
public:
	virtual void iAm() { std::cout &lt;&lt; "I'm the super class!\n"; }
}
 
class Sub : public Super
{
public:
	void iAm() { std::cout &lt;&lt; "I'm the subclass!\n"; }
}
 
int main()
{
	std::unique_ptr&lt;Super&gt; inst1(new Super());
	std::unique_ptr&lt;Super&gt; inst2(new Sub());
 
	inst1-&gt;iAm(); // calls Super::iAm()
	inst2-&gt;iAm(); // calls Sub::iAm()
}
</pre>
</body>
</html>