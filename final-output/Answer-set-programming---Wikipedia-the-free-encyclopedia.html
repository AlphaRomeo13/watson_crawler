<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Answer-set-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Answer set programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li><strong class="selflink">Answer set</strong></li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li><strong class="selflink">Answer set</strong></li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li><strong class="selflink">Answer set</strong></li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Answer set programming</b> (ASP) is a form of declarative programming oriented towards difficult (primarily NP-hard) search problems. It is based on the stable model (answer set) semantics of logic programming. In ASP, search problems are reduced to computing stable models, and <i>answer set solvers</i> — programs for generating stable models—are used to perform search. The computational process employed in the design of many answer set solvers is an enhancement of the DPLL algorithm and, in principle, it always terminates (unlike Prolog query evaluation, which may lead to an infinite loop).</p>
<p>In a more general sense, ASP includes all applications of answer sets to knowledge representation and the use of Prolog-style query evaluation for solving problems arising in these applications.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Answer set programming language AnsProlog</li>
<li>3 Generating stable models</li>
<li>4 Examples of ASP programs
<ul>
<li>4.1 Graph coloring</li>
<li>4.2 Large clique</li>
<li>4.3 Hamiltonian cycle</li>
</ul>
</li>
<li>5 Comparison of implementations</li>
<li>6 See also</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>4.1 Graph coloring</li>
<li>4.2 Large clique</li>
<li>4.3 Hamiltonian cycle</li>
</ul>
<p></p>
<h2>History</h2>
<p>The planning method proposed in 1993 by Dimopoulos, Nebel and Köhler is an early example of answer set programming. Their approach is based on the relationship between plans and stable models. Soininen and Niemelä applied what is now known as answer set programming to the problem of product configuration. The use of answer set solvers for search was identified as a new programming paradigm by Marek and Truszczyński in a paper that appeared in a 25-year perspective on the logic programming paradigm published in 1999  and in [Niemelä 1999]. Indeed, the new terminology of "answer set" instead of "stable model" was first proposed by Lifschitz in a paper appearing in the same retrospective volume as the Marek-Truszczynski paper.</p>
<h2>Answer set programming language AnsProlog</h2>
<p>Lparse is the name of the program that was originally created as grounding tool (front-end) for the answer set solver smodels. The language that Lparse accepts is now commonly called AnsProlog*, short for <i>Answer Set Programming in Logic</i>. It is now used in the same way in many other answer set solvers, including assat, clasp, cmodels, gNt, nomore++ and pbmodels. (dlv is an exception; the syntax of ASP programs written for dlv is somewhat different.)</p>
<p>An AnsProlog program consists of rules of the form</p>
<p>WHATSON? 51bd1e89-acc7-41d4-b63a-4fe5f52413d5</p>
<pre>
&lt;head&gt; :- &lt;body&gt; .
</pre>
<p>The symbol <code>:-</code> ("if") is dropped if <code>&lt;body&gt;</code> is empty; such rules are called <i>facts</i>. The simplest kind of Lparse rules are rules with constraints.</p>
<p>One other useful construct included in this language is <i>choice</i>. For instance, the choice rule</p>
<p>WHATSON? f09a09ab-7f6f-4d02-99cc-02d4db3f69ea</p>
<pre>
{p,q,r}.
</pre>
<p>says: choose arbitrarily which of the atoms <img class="mwe-math-fallback-image-inline tex" alt="p,q,r" src="//upload.wikimedia.org/math/f/8/2/f822943e0c6b5002a4eb16d73ae5e391.png"> to include in the stable model. The lparse program that contains this choice rule and no other rules has 8 stable models—arbitrary subsets of <img class="mwe-math-fallback-image-inline tex" alt="\{p,q,r\}" src="//upload.wikimedia.org/math/e/7/8/e780192ee1f3747772125f9ea037a538.png">. The definition of a stable model was generalized to programs with choice rules. Choice rules can be treated also as abbreviations for propositional formulas under the stable model semantics. For instance, the choice rule above can be viewed as shorthand for the conjunction of three "excluded middle" formulas:</p>
<p>The language of lparse allows us also to write "constrained" choice rules, such as</p>
<p>WHATSON? d1f0f90a-a431-45b9-b760-742f0853ac9e</p>
<pre>
1{p,q,r}2.
</pre>
<p>This rule says: choose at least 1 of the atoms <img class="mwe-math-fallback-image-inline tex" alt="p,q,r" src="//upload.wikimedia.org/math/f/8/2/f822943e0c6b5002a4eb16d73ae5e391.png">, but not more than 2. The meaning of this rule under the stable model semantics is represented by the propositional formula</p>
<p>Cardinality bounds can be used in the body of a rule as well, for instance:</p>
<p>WHATSON? 27f5eb7f-2261-411f-bd96-6262df4e6157</p>
<pre>
:- 2{p,q,r}.
</pre>
<p>Adding this constraint to an Lparse program eliminates the stable models that contain at least 2 of the atoms <img class="mwe-math-fallback-image-inline tex" alt="p,q,r" src="//upload.wikimedia.org/math/f/8/2/f822943e0c6b5002a4eb16d73ae5e391.png">. The meaning of this rule can be represented by the propositional formula</p>
<p>Variables (capitalized, as in Prolog) are used in Lparse to abbreviate collections of rules that follow the same pattern, and also to abbreviate collections of atoms within the same rule. For instance, the Lparse program</p>
<p>WHATSON? 17754fbf-abdd-494b-a5c8-d4f523b6d34d</p>
<pre>
p(a). p(b). p(c).
q(X) :- p(X), X!=a.
</pre>
<p>has the same meaning as</p>
<p>WHATSON? 88ffb3ce-55a9-4c45-9e37-54e7d63fee49</p>
<pre>
p(a). p(b). p(c).
q(b). q(c).
</pre>
<p>The program</p>
<p>WHATSON? 9ed46e29-5a50-418c-a3a4-6408a47b5698</p>
<pre>
p(a). p(b). p(c).
{q(X):-p(X)}2.
</pre>
<p>is shorthand for</p>
<p>WHATSON? 772ab5ba-0db0-4794-a5e1-129cfb5fd325</p>
<pre>
p(a). p(b). p(c).
{q(a),q(b),q(c)}2.
</pre>
<h2>Generating stable models</h2>
<p>To find a stable model of the Lparse program stored in file <code>&lt;filename&gt;</code> we use the command</p>
<p>WHATSON? 5b4140bc-4c82-4823-8dd6-89ef0b2cfe9b</p>
<pre>
% lparse &lt;filename&gt; | smodels
</pre>
<p>Option 0 instructs smodels to find <i>all</i> stable models of the program. For instance, if file <code>test</code> contains the rules</p>
<p>WHATSON? 6ac2bd46-babd-4d4b-81a7-7fa5dfe7ff4d</p>
<pre>
1{p,q,r}2.
s :- not p.
</pre>
<p>then the command</p>
<p>WHATSON? 7334830b-dd7e-491d-b6a7-605aad75ab43</p>
<pre>
% lparse test | smodels 0
</pre>
<p>produces the output</p>
<p>WHATSON? 49192a8e-6f6f-478f-816f-cf6625a6042a</p>
<pre>
Answer: 1
Stable Model: q p 
Answer: 2
Stable Model: p 
Answer: 3
Stable Model: r p 
Answer: 4
Stable Model: q s 
Answer: 5
Stable Model: r s 
Answer: 6
Stable Model: r q s
</pre>
<h2>Examples of ASP programs</h2>
<h3>Graph coloring</h3>
<p>An <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-coloring of a graph <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png"> is a function <img class="mwe-math-fallback-image-inline tex" alt="color\ " src="//upload.wikimedia.org/math/0/8/a/08a31d631f1f0e371e354b024649cfea.png"> from its set of vertices to <img class="mwe-math-fallback-image-inline tex" alt="\{1,\dots,n\}" src="//upload.wikimedia.org/math/7/f/5/7f5344e7d30be028726e79563bbee4fb.png"> such that <img class="mwe-math-fallback-image-inline tex" alt="color(x)\neq color(y)" src="//upload.wikimedia.org/math/7/6/3/7638657fc61fa4bf9f374c1a95f2dbee.png"> for every pair of adjacent vertices <img class="mwe-math-fallback-image-inline tex" alt="x,y" src="//upload.wikimedia.org/math/f/1/0/f10bc3c94b77e1d6b9f98106daf335c1.png">. We would like to use ASP to find an <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-coloring of a given graph (or determine that it does not exist).</p>
<p>This can be accomplished using the following Lparse program:</p>
<p>WHATSON? 51c82748-f2aa-4ade-98dd-fae7e48ffb80</p>
<pre>
c(1..n).                                           
1 {color(X,I) : c(I)} 1 :- v(X).             
:- color(X,I), color(Y,I), e(X,Y), c(I).
</pre>
<p>Line 1 defines the numbers <img class="mwe-math-fallback-image-inline tex" alt="1,\dots,n" src="//upload.wikimedia.org/math/3/9/d/39d4af9a3089186a26fe4b87d91c9279.png"> to be colors. According to the choice rule in Line 2, a unique color <img class="mwe-math-fallback-image-inline tex" alt="i" src="//upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png"> should be assigned to each vertex <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png">. The constraint in Line 3 prohibits assigning the same color to vertices <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> and <img class="mwe-math-fallback-image-inline tex" alt="y" src="//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png"> if there is an edge connecting them.</p>
<p>If we combine this file with a definition of <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png">, such as</p>
<p>WHATSON? b1aca9da-150b-43da-bdc5-ff2a2ba1bcba</p>
<pre>
v(1..100). % 1,...,100 are vertices
e(1,55). % there is an edge from 1 to 55
. . .
</pre>
<p>and run smodels on it, with the numeric value of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> specified on the command line, then the atoms of the form <img class="mwe-math-fallback-image-inline tex" alt="color(\dots,\dots)" src="//upload.wikimedia.org/math/6/4/c/64c0673f265ab35daae68991e5aa735b.png"> in the output of smodels will represent an <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-coloring of <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png">.</p>
<p>The program in this example illustrates the "generate-and-test" organization that is often found in simple ASP programs. The choice rule describes a set of "potential solutions" — a simple superset of the set of solutions to the given search problem. It is followed by a constraint, which eliminates all potential solutions that are not acceptable. However, the search process employed by smodels and other answer set solvers is not based on trial and error.</p>
<h3>Large clique</h3>
<p>A clique in a graph is a set of pairwise adjacent vertices. The following lparse program finds a clique of size <img class="mwe-math-fallback-image-inline tex" alt="\geq n" src="//upload.wikimedia.org/math/a/5/6/a5646a3abb821d8273287bc2035c9b73.png"> in a given graph, or determines that it does not exist:</p>
<p>WHATSON? 40becf70-1bf9-40b7-8d61-aff57728b147</p>
<pre>
n {in(X) : v(X)}.
:- in(X), in(Y), v(X), v(Y), X!=Y, not e(X,Y), not e(Y,X).
</pre>
<p>This is another example of the generate-and-test organization. The choice rule in Line 1 "generates" all sets consisting of <img class="mwe-math-fallback-image-inline tex" alt="\geq n" src="//upload.wikimedia.org/math/a/5/6/a5646a3abb821d8273287bc2035c9b73.png"> vertices. The constraint in Line 2 "weeds out" the sets that are not cliques.</p>
<h3>Hamiltonian cycle</h3>
<p>A Hamiltonian cycle in a directed graph is a cycle that passes through each vertex of the graph exactly once. The following Lparse program can be used to find a Hamiltonian cycle in a given directed graph if it exists; we assume that 0 is one of the vertices.</p>
<p>WHATSON? 5364038e-4878-4de3-9257-24d4bddabc21</p>
<pre>
{in(X,Y)} :- e(X,Y).
 
:- 2 {in(X,Y) : e(X,Y)}, v(X).
:- 2 {in(X,Y) : e(X,Y)}, v(Y).
 
r(X) :- in(0,X), v(X).
r(Y) :- r(X), in(X,Y), e(X,Y).
 
:- not r(X), v(X).
</pre>
<p>The choice rule in Line 1 "generates" all subsets of the set of edges. The three constraints "weed out" the subsets that are not Hamiltonian cycles. The last of them uses the auxiliary predicate <img class="mwe-math-fallback-image-inline tex" alt="r(x)" src="//upload.wikimedia.org/math/7/f/0/7f0562b7361b94feb27ee472a1cbc253.png"> ("<img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> is reachable from 0") to prohibit the vertices that do not satisfy this condition. This predicate is defined recursively in Lines 4 and 5.</p>
<p>This program is an example of the more general "generate, define and test" organization: it includes the definition of an auxiliary predicate that helps us eliminate all "bad" potential solutions.</p>
<h2>Comparison of implementations</h2>
<p>Early systems, such as Smodels, used backtracking to find solutions. As the theory and practice of Boolean SAT solvers evolved, a number of ASP solvers were built on top of SAT solvers, including ASSAT and Cmodels. These converted ASP formula into SAT propositions, applied the SAT solver, and then converted the solutions back to ASP form. More recent systems, such as Clasp, use a hybrid approach, using conflict-driven algorithms inspired by SAT, without full converting into a boolean-logic form. These approaches allow for significant improvements of performance, often by an order of magnitude, over earlier backtracking algorithms.</p>
<p>The Potassco project acts as an umbrella for many of the systems below, including <i>clasp</i>, grounding systems (<i>gringo</i>), incremental systems (<i>iclingo</i>), constraint solvers (<i>clingcon</i>), action language to ASP compilers (<i>coala</i>), distributed MPI implementations (<i>claspar</i>), and many others.</p>
<p>Most systems support variables, but only indirectly, by forcing grounding, by using a grounding system such as <i>Lparse</i> or <i>gringo</i> as a front end. The need for grounding can cause a combinatorial explosion of clauses; thus, systems that perform on-the-fly grounding might have an advantage.</p>
<h2>See also</h2>
<ul>
<li>Default logic</li>
<li>Logic programming</li>
<li>Non-monotonic logic</li>
<li>Prolog</li>
<li>Stable model semantics</li>
</ul>
</body>
</html>