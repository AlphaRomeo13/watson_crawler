<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>uses-feature--Android-Developers.html</title></head>
<body>
<h1>&lt;uses-feature&gt;</h1>
<h2>In this document</h2>
<ol>
  <li>Google Play and Feature-Based Filtering
    <ol>
      <li>Filtering based on explicitly declared features</li>
      <li>Filtering based on implicit features</li>
      <li>Special handling for Bluetooth feature</li>
      <li>Testing the features required by your application</li>
    </ol>
  </li>
  <li>Features Reference
    <ol>
      <li>Hardware features</li>
      <li>Software features</li>
      <li>Permissions that Imply Feature Requirements</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Filtering based on explicitly declared features</li>
      <li>Filtering based on implicit features</li>
      <li>Special handling for Bluetooth feature</li>
      <li>Testing the features required by your application</li>
    </ol>
<ol>
      <li>Hardware features</li>
      <li>Software features</li>
      <li>Permissions that Imply Feature Requirements</li>
    </ol>
<p>Google Play Filtering</p>
<p>Google Play uses the <code>&lt;uses-feature&gt;</code>
    elements declared in your app manifest to filter your app from devices 
    that do not meet it's hardware and software feature requirements. </p>
<p>By specifying the features that your application requires,
you enable Google Play to present your application only to users whose
devices meet the application's feature requirements, rather than presenting it
to all users. </p>
<p>For important information about how
Google Play uses features as the basis for filtering, please read Google Play and Feature-Based Filtering,
below.</p>
<p>WHATSON? cbf80e2b-141c-4b34-b143-fd30edc526ed</p>
<pre>&lt;uses-feature
  android:name="<em>string</em>"
  android:required=["true" | "false"]
  android:glEsVersion="<em>integer</em>" /&gt;</pre>
<p>The purpose of a <code>&lt;uses-feature&gt;</code> declaration is to inform
any external entity of the set of hardware and software features on which your
application depends. The element offers a <code>required</code> attribute that
lets you specify whether your application requires and cannot function without
the declared feature, or whether it prefers to have the feature but can function
without it. Because feature support can vary across Android devices, the
<code>&lt;uses-feature&gt;</code> element serves an important role in letting an
application describe the device-variable features that it uses.</p>
<p>The set of available features that your application declares corresponds to
the set of feature constants made available by the Android <code>PackageManager</code>, which are listed for
convenience in the Features Reference tables
at the bottom of this document.

</p>
<p>You must specify each feature in a separate <code>&lt;uses-feature&gt;</code>
element, so if your application requires multiple features, it would declare
multiple <code>&lt;uses-feature&gt;</code> elements. For example, an application
that requires both Bluetooth and camera features in the device would declare
these two elements:</p>
<p>WHATSON? d32e7827-4672-443b-a8d8-03c1e24b7515</p>
<pre>
&lt;uses-feature android:name="android.hardware.bluetooth" /&gt;
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</pre>
<p>In general, you should always make sure to declare
<code>&lt;uses-feature&gt;</code> elements for all of the features that your
application requires.</p>
<p>Declared <code>&lt;uses-feature&gt;</code> elements are informational only, meaning
that the Android system itself does not check for matching feature support on
the device before installing an application. However, other services
(such as Google Play) or applications may check your application's 
<code>&lt;uses-feature&gt;</code> declarations as part of handling or interacting
with your application. For this reason, it's very important that you declare all of
the features (from the list below) that your application uses. </p>
<p>For some features, there may exist a specific attribute that allows you to define
a version of the feature, such as the version of Open GL used (declared with
<code>glEsVersion</code>). Other features that either do or do not
exist for a device, such as a camera, are declared using the
<code>name</code> attribute.</p>
<p>Although the <code>&lt;uses-feature&gt;</code> element is only activated for
devices running API Level 4 or higher, it is recommended to include these
elements for all applications, even if the <code>minSdkVersion</code>
is "3" or lower. Devices running older versions of the platform will simply
ignore the element.</p>
<p><strong>Note:</strong> When declaring a feature, remember
that you must also request permissions as appropriate. For example, you must
still request the <code>CAMERA</code>
permission before your application can access the camera API. Requesting the
permission grants your application access to the appropriate hardware and
software, while declaring the features used by your application ensures proper
device compatibility.</p>
<ul>
<li>When you declare <code>"android:required="true"</code> for a feature,
you are specifying that the application <em>cannot function, or is not
designed to function</em>, when the specified feature is not present on the
device. </li>

<li>When you declare <code>"android:required="false"</code> for a feature, it
means that the application <em>prefers to use the feature</em> if present on
the device, but that it <em>is designed to function without the specified
feature</em>, if necessary. </li>

</ul>
<p>The default value for <code>android:required</code> if not declared is
<code>"true"</code>.</p>
<p>An application should specify at most one <code>android:glEsVersion</code>
attribute in its manifest. If it specifies more than one, the
<code>android:glEsVersion</code> with the numerically highest value is used and
any other values are ignored.</p>
<p>If an application does not specify an <code>android:glEsVersion</code>
attribute, then it is assumed that the application requires only OpenGL ES 1.0,
which is supported by all Android-powered devices.</p>
<p>An application can assume that if a platform supports a given OpenGL ES
version, it also supports all numerically lower OpenGL ES versions. Therefore,
an application that requires both OpenGL ES 1.0 and OpenGL ES 2.0 must specify
that it requires OpenGL ES 2.0.</p>
<p>An application that can work with any of several OpenGL ES versions should
only specify the numerically lowest version of OpenGL ES that it requires. (It
can check at run-time whether a higher level of OpenGL ES is available.)</p>
<p>For more information about using OpenGL ES, including how to check the supported OpenGL ES
version at runtime, see the OpenGL ES
API guide.</p>
<ul>
    <li><code>PackageManager</code></li>
    <li><code>FeatureInfo</code></li>
    <li><code>ConfigurationInfo</code></li>
    <li><code>&lt;uses-permission&gt;</code></li>
    <li>Filters on Google Play</li>
  </ul>
<h2>Google Play and Feature-Based Filtering</h2>
<p>Google Play filters the applications that are visible to users, so that
users can see and download only those applications that are compatible with
their devices. One of the ways it filters applications is by feature
compatibility.</p>
<p>To determine an application's feature compatibility with a given user's
device, Google Play compares:</p>
<ul>
<li>Features required by the application — an application declares features in
<code>&lt;uses-feature&gt;</code> elements in its manifest <br>with...</li>
<li>Features available on the device, in hardware or software —
a device reports the features it supports as read-only system properties.</li>
</ul>
<p>To ensure an accurate comparison of features, the Android Package Manager
provides a shared set of feature constants that both applications and devices
use to declare feature requirements and support. The available feature constants
are listed in the Features Reference tables at
the bottom of this document, and in the class documentation for <code>PackageManager</code>.</p>
<p>When the user launches Google Play, the application queries the
Package Manager for the list of features available on the device by calling
<code>getSystemAvailableFeatures()</code>. The
Store application then passes the features list up to Google Play
when establishing the session for the user.</p>
<p>Each time you upload an application to the Google Play Developer Console,
Google Play scans the application's manifest file. It looks for
<code>&lt;uses-feature&gt;</code> elements and evaluates them in combination
with other elements, in some cases, such as <code>&lt;uses-sdk&gt;</code> and
<code>&lt;uses-permission&gt;</code> elements. After establishing the
application's set of required features, it stores that list internally as
metadata associated with the application <code>.apk</code> and the application
version. </p>
<p>When a user searches or browses for applications using the Google Play
application, the service compares the features needed by each application with
the features available on the user's device. If all of an application's required
features are present on the device, Google Play allows the user to see the
application and potentially download it. If any required feature is not
supported by the device, Google Play filters the application so that it is
not visible to the user and not available for download. </p>
<p>Because the features you declare in <code>&lt;uses-feature&gt;</code>
elements directly affect how Google Play filters your application, it's
important to understand how Google Play evaluates the application's manifest
and establishes the set of required features. The sections below provide more
information. </p>
<h3>Filtering based on explicitly declared features</h3>
<p>An explicitly declared feature is one that your application declares in a
<code>&lt;uses-feature&gt;</code> element. The feature declaration can include
an <code>android:required=["true" | "false"]</code> attribute (if you are
compiling against API level 5 or higher), which lets you specify whether the
application absolutely requires the feature and cannot function properly without
it (<code>"true"</code>), or whether the application prefers to use the feature
if available, but is designed to run without it (<code>"false"</code>).</p>
<p>Google Play handles explicitly declared features in this way: </p>
<ul>
<li>If a feature is explicitly declared as being required, Google Play adds
the feature to the list of required features for the application. It then
filters the application from users on devices that do not provide that feature.
For example:
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt;</pre></li>
<li>If a feature is explicitly declared as <em>not</em> being required, Google
Play <em>does not</em> add the feature to the list of required features. For
that reason, an explicitly declared non-required feature is never considered when
filtering the application. Even if the device does not provide the declared
feature, Google Play will still consider the application compatible with the
device and will show it to the user, unless other filtering rules apply. For
example:
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre></li>
<li>If a feature is explicitly declared, but without an
<code>android:required</code> attribute, Google Play assumes that the feature
is required and sets up filtering on it. </li>
</ul>
<p>WHATSON? 683ec078-4ae2-4a86-ae56-8182e8d7d3bd</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt;</pre>
<p>WHATSON? 138d9ab1-b6f8-419c-ae1a-581c805a2657</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre>
<p>In general, if your application is designed to run on Android 1.6 and earlier
versions, the <code>android:required</code> attribute is not available in the
API and Google Play assumes that any and all
<code>&lt;uses-feature&gt;</code> declarations are required. </p>
<p><strong>Note:</strong> By declaring a feature explicitly and
including an <code>android:required="false"</code> attribute, you can
effectively disable all filtering on Google Play for the specified feature.
</p>
<h3>Filtering based on implicit features</h3>
<p>An <em>implicit</em> feature is one that an application requires in order to
function properly, but which is <em>not</em> declared in a
<code>&lt;uses-feature&gt;</code> element in the manifest file. Strictly
speaking, every application should <em>always</em> declare all features that it
uses or requires, so the absence of a declaration for a feature used by an
application should be considered an error. However, as a safeguard for users and
developers, Google Play looks for implicit features in each application and
sets up filters for those features, just as it would do for an explicitly
declared feature. </p>
<p>An application might require a feature but not declare it because: </p>
<ul>
<li>The application was compiled against an older version of the Android library
(Android 1.5 or earlier) and the <code>&lt;uses-feature&gt;</code> element was
not available.</li>
<li>The developer incorrectly assumed that the feature would be present on all
devices and a declaration was unnecessary.</li>
<li>The developer omitted the feature declaration accidentally.</li>
<li>The developer declared the feature explicitly, but the declaration was not
valid. For example, a spelling error in the <code>&lt;uses-feature&gt;</code>
element name or an unrecognized string value for the
<code>android:name</code> attribute would invalidate the feature declaration.
</li>
</ul>
<p>To account for the cases above, Google Play attempts to discover an
application's implied feature requirements by examining <em>other elements</em>
declared in the manifest file, specifically,
<code>&lt;uses-permission&gt;</code> elements.</p>
<p>If an application requests hardware-related permissions, Google Play
<em>assumes that the application uses the underlying hardware features and
therefore requires those features</em>, even though there might be no
corresponding to <code>&lt;uses-feature&gt;</code> declarations. For such
permissions, Google Play adds the underlying hardware features to the
metadata that it stores for the application and sets up filters for them.</p>
<p>For example, if an application requests the <code>CAMERA</code> permission
but does not declare a <code>&lt;uses-feature&gt;</code> element for
<code>android.hardware.camera</code>, Google Play considers that the
application requires a camera and should not be shown to users whose devices do
not offer a camera.</p>
<p>If you don't want Google Play to filter based on a specific implied
feature, you can disable that behavior. To do so, declare the feature explicitly
in a <code>&lt;uses-feature&gt;</code> element and include an 
<code>android:required="false"</code> attribute. For example, to disable
filtering derived from the <code>CAMERA</code> permission, you would declare
the feature as shown below.</p>
<p>WHATSON? 902af382-2a30-47e5-aed3-7372a81fe361</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre>
<p>It's important to understand that the permissions that you
request in <code>&lt;uses-permission&gt;</code> elements can directly affect how
Google Play filters your application. The reference section Permissions that Imply Feature Requirements,
below, lists the full set of permissions that imply feature requirements and
therefore trigger filtering.</p>
<h3>Special handling for Bluetooth feature</h3>
<p>Google Play applies slightly different rules than described above, when
determining filtering for Bluetooth.</p>
<p>If an application declares a Bluetooth permission in a
<code>&lt;uses-permission&gt;</code> element, but does not explicitly declare
the Bluetooth feature in a <code>&lt;uses-feature&gt;</code> element, Google
Play checks the version(s) of the Android platform on which the application is
designed to run, as specified in the <code>&lt;uses-sdk&gt;</code> element. </p>
<p>As shown in the table below, Google Play enables filtering for the
Bluetooth feature only if the application declares its lowest or targeted
platform as Android 2.0 (API level 5) or higher. However, note that Google
Play applies the normal rules for filtering when the application explicitly
declares the Bluetooth feature in a <code>&lt;uses-feature&gt;</code> element.
</p>
<p><strong>Table 1.</strong> How Google Play determines the
Bluetooth feature requirement for an application that requests a Bluetooth
permission but does not declare the Bluetooth feature in a
<code>&lt;uses-feature&gt;</code> element.</p>
<p>The examples below illustrate the different filtering effects, based on how
Google Play handles the Bluetooth feature. </p>
<p>WHATSON? e3b60cbe-bea0-4d0f-8fd2-dadd1e2c762c</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" /&gt;
    ...
&lt;/manifest&gt;</pre>
<p>WHATSON? 0c409c95-37c8-40a5-b61a-431e789406e7</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" /&gt;
    ...
&lt;/manifest&gt;</pre>
<p>WHATSON? 2d0580cb-a125-4fbd-ac0e-865950f081f5</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-feature android:name="android.hardware.bluetooth" /&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" /&gt;
    ...
&lt;/manifest&gt;</pre>
<p>WHATSON? 203b62fd-deef-4458-a992-fad9d675fc82</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-feature android:name="android.hardware.bluetooth" android:required="false" /&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" /&gt;
    ...
&lt;/manifest&gt;</pre>
<h3>Testing the features required by your application</h3>
<p>You can use the <code>aapt</code> tool, included in the Android SDK, to
determine how Google Play will filter your application, based on its declared
features and permissions. To do so, run  <code>aapt</code> with the <code>dump
badging</code> command. This causes <code>aapt</code> to parse your
application's manifest and apply the same rules as used by Google Play to
determine the features that your application requires. </p>
<p>To use the tool, follow these steps: </p>
<ol>
<li>First, build and export your application as an unsigned <code>.apk</code>.
If you are developing in Eclipse with ADT, right-click the project and select
<strong>Android Tools</strong> &gt; <strong>Export Unsigned Application
Package</strong>. Select a destination filename and path and click
<strong>OK</strong>. </li>
<li>Next, locate the <code>aapt</code> tool, if it is not already in your PATH.
If you are using SDK Tools r8 or higher, you can find <code>aapt</code> in the
<code>&lt;<em>SDK</em>&gt;/platform-tools/</code> directory.
<p><strong>Note:</strong> You must use the version of
<code>aapt</code> that is provided for the latest Platform-Tools component available. If
you do not have the latest Platform-Tools component, download it using the Android SDK Manager.
</p></li>
<li>Run <code>aapt</code> using this syntax: </li>
</ol>
<p><strong>Note:</strong> You must use the version of
<code>aapt</code> that is provided for the latest Platform-Tools component available. If
you do not have the latest Platform-Tools component, download it using the Android SDK Manager.
</p>
<p>WHATSON? 358533b7-69c9-4695-bcf0-5166c882b0ac</p>
<pre>$ aapt dump badging &lt;<em>path_to_exported_.apk</em>&gt;</pre>
<p>Here's an example of the command output for the second Bluetooth example, above: </p>
<p>WHATSON? 5a33cef0-093a-436c-a655-55259f2b9a41</p>
<pre>$ ./aapt dump badging BTExample.apk
package: name='com.example.android.btexample' versionCode='' versionName=''
<strong>uses-permission:'android.permission.BLUETOOTH_ADMIN'</strong>
<strong>uses-feature:'android.hardware.bluetooth'</strong>
sdkVersion:'3'
targetSdkVersion:'5'
application: label='BT Example' icon='res/drawable/app_bt_ex.png'
launchable activity name='com.example.android.btexample.MyActivity'label='' icon=''
uses-feature:'android.hardware.touchscreen'
main
supports-screens: 'small' 'normal' 'large'
locales: '--_--'
densities: '160'
</pre>
<h2>Features Reference</h2>
<p>The tables below provide reference information about hardware and software
features and the permissions that can imply them on Google Play. </p>
<h3>Hardware features</h3>
<p>The table below describes the hardware feature descriptors supported by the
most current platform release. To signal that your application uses or requires
a hardware feature, declare each value in a <code>android:name</code> attribute
in a separate <code>&lt;uses-feature&gt;</code> element. </p>
<p>For example, if your app requires portrait orientation, you should declare
<code>&lt;uses-feature android:name="android.hardware.screen.portrait"/&gt;</code> so that only devices
that support portrait orientation (whether always or by user choice) can install your app. If your
application <em>supports</em> both orientations, then you don't need to declare either.</p>
<p>Both orientations are assumed <em>not required</em>, by default, so your app may be installed
on devices that support one or both orientations. However, if any of your activities request that
they run in a specific orientation, using the <code>android:screenOrientation</code> attribute, then this also declares that the application requires that
orientation. For example, if you declare <code>android:screenOrientation</code> with either <code>"landscape"</code>, <code>"reverseLandscape"</code>, or
<code>"sensorLandscape"</code>, then your application will be available only to devices that support
landscape orientation. As a best practice, you should still declare your requirement for this
orientation using a <code>&lt;uses-feature&gt;</code> element. If you declare an orientation for your
activity using <code>android:screenOrientation</code>, but don't actually <em>require</em> it, you can disable the
requirement by declaring the orientation with a <code>&lt;uses-feature&gt;</code> element and include
<code>android:required="false"</code>.</p>
<p>For backwards compatibility, any device running a platform version that supports only API
level 12 or lower is assumed to support both landscape and portrait.</p>
<p>When declared as required, this indicates that the application is compatible with a device
only if it offers an emulated touchscreen ("fake touch" interface), or better. A device that offers
a fake touch interface provides a user input system that emulates a subset of touchscreen
capabilities. For example, a mouse or remote control that drives an on-screen cursor provides a fake
touch interface. If your application requires basic point and click interaction (in other
words, it won't work with <em>only</em> a d-pad controller), you should declare this feature.
Because this is the minimum level of touch interaction, your app will also be compatible with
devices that offer more complex touch interfaces.</p>
<p><strong>Note:</strong> Because applications require the <code>android.hardware.touchscreen</code> feature by default, if you want your application to be available to
devices that provide a fake touch interface, you must also explicitly declare that a touch screen is
<em>not</em> required by declaring <code>&lt;uses-feature
android:name="android.hardware.touchscreen" <strong>android:required="false"</strong>
/&gt;</code></p>
<p>When declared as required, this indicates that the application is compatible with a device
only if it supports touch emulation for events that supports distinct tracking of two or more
fingers, or better.</p>
<p>Unlike the distinct multitouch defined by <code>android.hardware.touchscreen.multitouch.distinct</code>, input devices that support distinct multi-touch
with a fake touch interface will not support all two-finger gestures, because the input is
being transformed to cursor movement on the screen. That is, single finger gestures on such a device
move a cursor; two-finger swipes will result in single-finger touch events; other two-finger
gestures will result in the corresponding two-finger touch event. An example device that supports
distinct multi-touch with a fake touch interface is one that provides a trackpad for cursor movement
which also supports two or more fingers.</p>
<p>When declared as required, this indicates that the application is compatible with a device
only if it supports touch emulation for events that supports distinct tracking of five or more
fingers.</p>
<p>Unlike the distinct multitouch defined by <code>android.hardware.touchscreen.multitouch.jazzhand</code>, input devices that support jazzhand multi-touch
with a fake touch interface will not support all five-finger gestures, because the input is being
transformed to cursor movement on the screen. That is, single finger gestures on such a device move
a cursor; multi-finger gestures will result in single-finger touch events; other multi-finger
gestures will result in the corresponding multi-finger touch event. An example device that supports
distinct multi-touch with a fake touch interface is one that provides a trackpad for cursor movement
which also supports five or more fingers.</p>
<p>By default, your application requires this. As such, your application is <em>not</em>
available to devices that provide only an emulated touch interface ("fake touch"), by default. If
you want your application available to devices that provide a fake touch interface (or even devices
that provide only a d-pad controller), you must explicitly declare that a touch screen is not
required, by declaring <code>android.hardware.touchscreen</code> with <code>android:required="false"</code>.
You should do so even if your application uses—but does not <em>require</em>—a real
touch screen interface.</p>
<p>If your application <em>does require</em> a touch interface (in order to perform touch
gestures such as a fling), then you don't need to do anything, because this is required by default.
However, it's best if you explicitly declare all features used by your application, so you should
still declare this if your app uses it.</p>
<p>If you require more complex touch interaction, such as multi-finger gestures, you
should declare the advanced touch screen features below.</p>
<h3>Software features</h3>
<p>The table below describes the software feature descriptors supported by the
most current platform release. To signal that your application uses or requires
a software feature, declare each value in a <code>android:name</code> attribute
in a separate <code>&lt;uses-feature&gt;</code> element. </p>
<p>Subfeature. The application uses SIP-based VOIP service on the device.
  </p>
<p>This subfeature implicitly declares the <code>android.software.sip</code> parent feature,
unless declared with <code>android:required="false"</code>.</p>
<h3>Permissions that Imply Feature Requirements</h3>
<p>Some feature constants listed in the tables above were made available to
applications <em>after</em> the corresponding API; for example, the
<code>android.hardware.bluetooth</code> feature was added in Android 2.2 (API
level 8), but the bluetooth API that it refers to was added in Android 2.0 (API
level 5). Because of this, some apps were able to use the API before they had
the ability to declare that they require the API via the
<code>&lt;uses-feature&gt;</code> system. </p>
<p>To prevent those apps from being made available unintentionally,  Google
Play assumes that certain hardware-related permissions indicate that the
underlying hardware features are required by default. For instance, applications
that use Bluetooth must request the <code>BLUETOOTH</code> permission in a
<code>&lt;uses-permission&gt;</code> element — for legacy apps, Google
Play assumes that the permission declaration means that the underlying
<code>android.hardware.bluetooth</code> feature is required by the application
and sets up filtering based on that feature. </p>
<p>The table below lists permissions that imply feature requirements
equivalent to those declared in <code>&lt;uses-feature&gt;</code> elements. Note
that <code>&lt;uses-feature&gt;</code> declarations, including any declared
<code>android:required</code> attribute, always take precedence over features
implied by the permissions below. </p>
<p>For any of the permissions below, you can disable filtering based on the
implied feature by explicitly declaring the implied feature explicitly, in a
<code>&lt;uses-feature&gt;</code> element, with an
<code>android:required="false"</code> attribute. For example, to disable any
filtering based on the <code>CAMERA</code> permission, you would add this
<code>&lt;uses-feature&gt;</code> declaration to the manifest file:</p>
<p>WHATSON? 99230c42-0be3-4c49-9a47-d5ae23f2ebd1</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre>
<p>(See Special handling for Bluetooth feature for details.)</p>
<h1>&lt;uses-feature&gt;</h1>
<h2>In this document</h2>
<ol>
  <li>Google Play and Feature-Based Filtering
    <ol>
      <li>Filtering based on explicitly declared features</li>
      <li>Filtering based on implicit features</li>
      <li>Special handling for Bluetooth feature</li>
      <li>Testing the features required by your application</li>
    </ol>
  </li>
  <li>Features Reference
    <ol>
      <li>Hardware features</li>
      <li>Software features</li>
      <li>Permissions that Imply Feature Requirements</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Filtering based on explicitly declared features</li>
      <li>Filtering based on implicit features</li>
      <li>Special handling for Bluetooth feature</li>
      <li>Testing the features required by your application</li>
    </ol>
<ol>
      <li>Hardware features</li>
      <li>Software features</li>
      <li>Permissions that Imply Feature Requirements</li>
    </ol>
<p>Google Play Filtering</p>
<p>Google Play uses the <code>&lt;uses-feature&gt;</code>
    elements declared in your app manifest to filter your app from devices 
    that do not meet it's hardware and software feature requirements. </p>
<p>By specifying the features that your application requires,
you enable Google Play to present your application only to users whose
devices meet the application's feature requirements, rather than presenting it
to all users. </p>
<p>For important information about how
Google Play uses features as the basis for filtering, please read Google Play and Feature-Based Filtering,
below.</p>
<p>WHATSON? 5842bbba-17bb-44c8-86c6-0dec421a01d4</p>
<pre>&lt;uses-feature
  android:name="<em>string</em>"
  android:required=["true" | "false"]
  android:glEsVersion="<em>integer</em>" /&gt;</pre>
<p>The purpose of a <code>&lt;uses-feature&gt;</code> declaration is to inform
any external entity of the set of hardware and software features on which your
application depends. The element offers a <code>required</code> attribute that
lets you specify whether your application requires and cannot function without
the declared feature, or whether it prefers to have the feature but can function
without it. Because feature support can vary across Android devices, the
<code>&lt;uses-feature&gt;</code> element serves an important role in letting an
application describe the device-variable features that it uses.</p>
<p>The set of available features that your application declares corresponds to
the set of feature constants made available by the Android <code>PackageManager</code>, which are listed for
convenience in the Features Reference tables
at the bottom of this document.

</p>
<p>You must specify each feature in a separate <code>&lt;uses-feature&gt;</code>
element, so if your application requires multiple features, it would declare
multiple <code>&lt;uses-feature&gt;</code> elements. For example, an application
that requires both Bluetooth and camera features in the device would declare
these two elements:</p>
<p>WHATSON? ce048eab-ba6f-4e93-b23b-f57429d3ca77</p>
<pre>
&lt;uses-feature android:name="android.hardware.bluetooth" /&gt;
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</pre>
<p>In general, you should always make sure to declare
<code>&lt;uses-feature&gt;</code> elements for all of the features that your
application requires.</p>
<p>Declared <code>&lt;uses-feature&gt;</code> elements are informational only, meaning
that the Android system itself does not check for matching feature support on
the device before installing an application. However, other services
(such as Google Play) or applications may check your application's 
<code>&lt;uses-feature&gt;</code> declarations as part of handling or interacting
with your application. For this reason, it's very important that you declare all of
the features (from the list below) that your application uses. </p>
<p>For some features, there may exist a specific attribute that allows you to define
a version of the feature, such as the version of Open GL used (declared with
<code>glEsVersion</code>). Other features that either do or do not
exist for a device, such as a camera, are declared using the
<code>name</code> attribute.</p>
<p>Although the <code>&lt;uses-feature&gt;</code> element is only activated for
devices running API Level 4 or higher, it is recommended to include these
elements for all applications, even if the <code>minSdkVersion</code>
is "3" or lower. Devices running older versions of the platform will simply
ignore the element.</p>
<p><strong>Note:</strong> When declaring a feature, remember
that you must also request permissions as appropriate. For example, you must
still request the <code>CAMERA</code>
permission before your application can access the camera API. Requesting the
permission grants your application access to the appropriate hardware and
software, while declaring the features used by your application ensures proper
device compatibility.</p>
<ul>
<li>When you declare <code>"android:required="true"</code> for a feature,
you are specifying that the application <em>cannot function, or is not
designed to function</em>, when the specified feature is not present on the
device. </li>

<li>When you declare <code>"android:required="false"</code> for a feature, it
means that the application <em>prefers to use the feature</em> if present on
the device, but that it <em>is designed to function without the specified
feature</em>, if necessary. </li>

</ul>
<p>The default value for <code>android:required</code> if not declared is
<code>"true"</code>.</p>
<p>An application should specify at most one <code>android:glEsVersion</code>
attribute in its manifest. If it specifies more than one, the
<code>android:glEsVersion</code> with the numerically highest value is used and
any other values are ignored.</p>
<p>If an application does not specify an <code>android:glEsVersion</code>
attribute, then it is assumed that the application requires only OpenGL ES 1.0,
which is supported by all Android-powered devices.</p>
<p>An application can assume that if a platform supports a given OpenGL ES
version, it also supports all numerically lower OpenGL ES versions. Therefore,
an application that requires both OpenGL ES 1.0 and OpenGL ES 2.0 must specify
that it requires OpenGL ES 2.0.</p>
<p>An application that can work with any of several OpenGL ES versions should
only specify the numerically lowest version of OpenGL ES that it requires. (It
can check at run-time whether a higher level of OpenGL ES is available.)</p>
<p>For more information about using OpenGL ES, including how to check the supported OpenGL ES
version at runtime, see the OpenGL ES
API guide.</p>
<ul>
    <li><code>PackageManager</code></li>
    <li><code>FeatureInfo</code></li>
    <li><code>ConfigurationInfo</code></li>
    <li><code>&lt;uses-permission&gt;</code></li>
    <li>Filters on Google Play</li>
  </ul>
<h2>Google Play and Feature-Based Filtering</h2>
<p>Google Play filters the applications that are visible to users, so that
users can see and download only those applications that are compatible with
their devices. One of the ways it filters applications is by feature
compatibility.</p>
<p>To determine an application's feature compatibility with a given user's
device, Google Play compares:</p>
<ul>
<li>Features required by the application — an application declares features in
<code>&lt;uses-feature&gt;</code> elements in its manifest <br>with...</li>
<li>Features available on the device, in hardware or software —
a device reports the features it supports as read-only system properties.</li>
</ul>
<p>To ensure an accurate comparison of features, the Android Package Manager
provides a shared set of feature constants that both applications and devices
use to declare feature requirements and support. The available feature constants
are listed in the Features Reference tables at
the bottom of this document, and in the class documentation for <code>PackageManager</code>.</p>
<p>When the user launches Google Play, the application queries the
Package Manager for the list of features available on the device by calling
<code>getSystemAvailableFeatures()</code>. The
Store application then passes the features list up to Google Play
when establishing the session for the user.</p>
<p>Each time you upload an application to the Google Play Developer Console,
Google Play scans the application's manifest file. It looks for
<code>&lt;uses-feature&gt;</code> elements and evaluates them in combination
with other elements, in some cases, such as <code>&lt;uses-sdk&gt;</code> and
<code>&lt;uses-permission&gt;</code> elements. After establishing the
application's set of required features, it stores that list internally as
metadata associated with the application <code>.apk</code> and the application
version. </p>
<p>When a user searches or browses for applications using the Google Play
application, the service compares the features needed by each application with
the features available on the user's device. If all of an application's required
features are present on the device, Google Play allows the user to see the
application and potentially download it. If any required feature is not
supported by the device, Google Play filters the application so that it is
not visible to the user and not available for download. </p>
<p>Because the features you declare in <code>&lt;uses-feature&gt;</code>
elements directly affect how Google Play filters your application, it's
important to understand how Google Play evaluates the application's manifest
and establishes the set of required features. The sections below provide more
information. </p>
<h3>Filtering based on explicitly declared features</h3>
<p>An explicitly declared feature is one that your application declares in a
<code>&lt;uses-feature&gt;</code> element. The feature declaration can include
an <code>android:required=["true" | "false"]</code> attribute (if you are
compiling against API level 5 or higher), which lets you specify whether the
application absolutely requires the feature and cannot function properly without
it (<code>"true"</code>), or whether the application prefers to use the feature
if available, but is designed to run without it (<code>"false"</code>).</p>
<p>Google Play handles explicitly declared features in this way: </p>
<ul>
<li>If a feature is explicitly declared as being required, Google Play adds
the feature to the list of required features for the application. It then
filters the application from users on devices that do not provide that feature.
For example:
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt;</pre></li>
<li>If a feature is explicitly declared as <em>not</em> being required, Google
Play <em>does not</em> add the feature to the list of required features. For
that reason, an explicitly declared non-required feature is never considered when
filtering the application. Even if the device does not provide the declared
feature, Google Play will still consider the application compatible with the
device and will show it to the user, unless other filtering rules apply. For
example:
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre></li>
<li>If a feature is explicitly declared, but without an
<code>android:required</code> attribute, Google Play assumes that the feature
is required and sets up filtering on it. </li>
</ul>
<p>WHATSON? 46acc7ae-7921-46c3-80c3-c9691316387d</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt;</pre>
<p>WHATSON? deca4f8b-8f1e-4928-98b3-abb27177cb6c</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre>
<p>In general, if your application is designed to run on Android 1.6 and earlier
versions, the <code>android:required</code> attribute is not available in the
API and Google Play assumes that any and all
<code>&lt;uses-feature&gt;</code> declarations are required. </p>
<p><strong>Note:</strong> By declaring a feature explicitly and
including an <code>android:required="false"</code> attribute, you can
effectively disable all filtering on Google Play for the specified feature.
</p>
<h3>Filtering based on implicit features</h3>
<p>An <em>implicit</em> feature is one that an application requires in order to
function properly, but which is <em>not</em> declared in a
<code>&lt;uses-feature&gt;</code> element in the manifest file. Strictly
speaking, every application should <em>always</em> declare all features that it
uses or requires, so the absence of a declaration for a feature used by an
application should be considered an error. However, as a safeguard for users and
developers, Google Play looks for implicit features in each application and
sets up filters for those features, just as it would do for an explicitly
declared feature. </p>
<p>An application might require a feature but not declare it because: </p>
<ul>
<li>The application was compiled against an older version of the Android library
(Android 1.5 or earlier) and the <code>&lt;uses-feature&gt;</code> element was
not available.</li>
<li>The developer incorrectly assumed that the feature would be present on all
devices and a declaration was unnecessary.</li>
<li>The developer omitted the feature declaration accidentally.</li>
<li>The developer declared the feature explicitly, but the declaration was not
valid. For example, a spelling error in the <code>&lt;uses-feature&gt;</code>
element name or an unrecognized string value for the
<code>android:name</code> attribute would invalidate the feature declaration.
</li>
</ul>
<p>To account for the cases above, Google Play attempts to discover an
application's implied feature requirements by examining <em>other elements</em>
declared in the manifest file, specifically,
<code>&lt;uses-permission&gt;</code> elements.</p>
<p>If an application requests hardware-related permissions, Google Play
<em>assumes that the application uses the underlying hardware features and
therefore requires those features</em>, even though there might be no
corresponding to <code>&lt;uses-feature&gt;</code> declarations. For such
permissions, Google Play adds the underlying hardware features to the
metadata that it stores for the application and sets up filters for them.</p>
<p>For example, if an application requests the <code>CAMERA</code> permission
but does not declare a <code>&lt;uses-feature&gt;</code> element for
<code>android.hardware.camera</code>, Google Play considers that the
application requires a camera and should not be shown to users whose devices do
not offer a camera.</p>
<p>If you don't want Google Play to filter based on a specific implied
feature, you can disable that behavior. To do so, declare the feature explicitly
in a <code>&lt;uses-feature&gt;</code> element and include an 
<code>android:required="false"</code> attribute. For example, to disable
filtering derived from the <code>CAMERA</code> permission, you would declare
the feature as shown below.</p>
<p>WHATSON? c3c9c3bb-96e1-43ac-9ebd-6173e022cc91</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre>
<p>It's important to understand that the permissions that you
request in <code>&lt;uses-permission&gt;</code> elements can directly affect how
Google Play filters your application. The reference section Permissions that Imply Feature Requirements,
below, lists the full set of permissions that imply feature requirements and
therefore trigger filtering.</p>
<h3>Special handling for Bluetooth feature</h3>
<p>Google Play applies slightly different rules than described above, when
determining filtering for Bluetooth.</p>
<p>If an application declares a Bluetooth permission in a
<code>&lt;uses-permission&gt;</code> element, but does not explicitly declare
the Bluetooth feature in a <code>&lt;uses-feature&gt;</code> element, Google
Play checks the version(s) of the Android platform on which the application is
designed to run, as specified in the <code>&lt;uses-sdk&gt;</code> element. </p>
<p>As shown in the table below, Google Play enables filtering for the
Bluetooth feature only if the application declares its lowest or targeted
platform as Android 2.0 (API level 5) or higher. However, note that Google
Play applies the normal rules for filtering when the application explicitly
declares the Bluetooth feature in a <code>&lt;uses-feature&gt;</code> element.
</p>
<p><strong>Table 1.</strong> How Google Play determines the
Bluetooth feature requirement for an application that requests a Bluetooth
permission but does not declare the Bluetooth feature in a
<code>&lt;uses-feature&gt;</code> element.</p>
<p>The examples below illustrate the different filtering effects, based on how
Google Play handles the Bluetooth feature. </p>
<p>WHATSON? 10d2e90d-1bae-4e0a-a849-44bb594c398a</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" /&gt;
    ...
&lt;/manifest&gt;</pre>
<p>WHATSON? b4ad6753-d74b-4bac-ae76-a1027aa9f915</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" /&gt;
    ...
&lt;/manifest&gt;</pre>
<p>WHATSON? 2ec4b3f9-b05b-4c0e-9866-72fda2daf0ad</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-feature android:name="android.hardware.bluetooth" /&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" /&gt;
    ...
&lt;/manifest&gt;</pre>
<p>WHATSON? 956e8da0-a87b-4cf5-a5c5-ba1dcf18a2d2</p>
<pre>&lt;manifest ...&gt;
    &lt;uses-feature android:name="android.hardware.bluetooth" android:required="false" /&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;
    &lt;uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5" /&gt;
    ...
&lt;/manifest&gt;</pre>
<h3>Testing the features required by your application</h3>
<p>You can use the <code>aapt</code> tool, included in the Android SDK, to
determine how Google Play will filter your application, based on its declared
features and permissions. To do so, run  <code>aapt</code> with the <code>dump
badging</code> command. This causes <code>aapt</code> to parse your
application's manifest and apply the same rules as used by Google Play to
determine the features that your application requires. </p>
<p>To use the tool, follow these steps: </p>
<ol>
<li>First, build and export your application as an unsigned <code>.apk</code>.
If you are developing in Eclipse with ADT, right-click the project and select
<strong>Android Tools</strong> &gt; <strong>Export Unsigned Application
Package</strong>. Select a destination filename and path and click
<strong>OK</strong>. </li>
<li>Next, locate the <code>aapt</code> tool, if it is not already in your PATH.
If you are using SDK Tools r8 or higher, you can find <code>aapt</code> in the
<code>&lt;<em>SDK</em>&gt;/platform-tools/</code> directory.
<p><strong>Note:</strong> You must use the version of
<code>aapt</code> that is provided for the latest Platform-Tools component available. If
you do not have the latest Platform-Tools component, download it using the Android SDK Manager.
</p></li>
<li>Run <code>aapt</code> using this syntax: </li>
</ol>
<p><strong>Note:</strong> You must use the version of
<code>aapt</code> that is provided for the latest Platform-Tools component available. If
you do not have the latest Platform-Tools component, download it using the Android SDK Manager.
</p>
<p>WHATSON? ab5feef9-12ca-43cb-b0cb-9f16d69b1f22</p>
<pre>$ aapt dump badging &lt;<em>path_to_exported_.apk</em>&gt;</pre>
<p>Here's an example of the command output for the second Bluetooth example, above: </p>
<p>WHATSON? dbee7913-4158-472c-b596-629240268eaf</p>
<pre>$ ./aapt dump badging BTExample.apk
package: name='com.example.android.btexample' versionCode='' versionName=''
<strong>uses-permission:'android.permission.BLUETOOTH_ADMIN'</strong>
<strong>uses-feature:'android.hardware.bluetooth'</strong>
sdkVersion:'3'
targetSdkVersion:'5'
application: label='BT Example' icon='res/drawable/app_bt_ex.png'
launchable activity name='com.example.android.btexample.MyActivity'label='' icon=''
uses-feature:'android.hardware.touchscreen'
main
supports-screens: 'small' 'normal' 'large'
locales: '--_--'
densities: '160'
</pre>
<h2>Features Reference</h2>
<p>The tables below provide reference information about hardware and software
features and the permissions that can imply them on Google Play. </p>
<h3>Hardware features</h3>
<p>The table below describes the hardware feature descriptors supported by the
most current platform release. To signal that your application uses or requires
a hardware feature, declare each value in a <code>android:name</code> attribute
in a separate <code>&lt;uses-feature&gt;</code> element. </p>
<p>For example, if your app requires portrait orientation, you should declare
<code>&lt;uses-feature android:name="android.hardware.screen.portrait"/&gt;</code> so that only devices
that support portrait orientation (whether always or by user choice) can install your app. If your
application <em>supports</em> both orientations, then you don't need to declare either.</p>
<p>Both orientations are assumed <em>not required</em>, by default, so your app may be installed
on devices that support one or both orientations. However, if any of your activities request that
they run in a specific orientation, using the <code>android:screenOrientation</code> attribute, then this also declares that the application requires that
orientation. For example, if you declare <code>android:screenOrientation</code> with either <code>"landscape"</code>, <code>"reverseLandscape"</code>, or
<code>"sensorLandscape"</code>, then your application will be available only to devices that support
landscape orientation. As a best practice, you should still declare your requirement for this
orientation using a <code>&lt;uses-feature&gt;</code> element. If you declare an orientation for your
activity using <code>android:screenOrientation</code>, but don't actually <em>require</em> it, you can disable the
requirement by declaring the orientation with a <code>&lt;uses-feature&gt;</code> element and include
<code>android:required="false"</code>.</p>
<p>For backwards compatibility, any device running a platform version that supports only API
level 12 or lower is assumed to support both landscape and portrait.</p>
<p>When declared as required, this indicates that the application is compatible with a device
only if it offers an emulated touchscreen ("fake touch" interface), or better. A device that offers
a fake touch interface provides a user input system that emulates a subset of touchscreen
capabilities. For example, a mouse or remote control that drives an on-screen cursor provides a fake
touch interface. If your application requires basic point and click interaction (in other
words, it won't work with <em>only</em> a d-pad controller), you should declare this feature.
Because this is the minimum level of touch interaction, your app will also be compatible with
devices that offer more complex touch interfaces.</p>
<p><strong>Note:</strong> Because applications require the <code>android.hardware.touchscreen</code> feature by default, if you want your application to be available to
devices that provide a fake touch interface, you must also explicitly declare that a touch screen is
<em>not</em> required by declaring <code>&lt;uses-feature
android:name="android.hardware.touchscreen" <strong>android:required="false"</strong>
/&gt;</code></p>
<p>When declared as required, this indicates that the application is compatible with a device
only if it supports touch emulation for events that supports distinct tracking of two or more
fingers, or better.</p>
<p>Unlike the distinct multitouch defined by <code>android.hardware.touchscreen.multitouch.distinct</code>, input devices that support distinct multi-touch
with a fake touch interface will not support all two-finger gestures, because the input is
being transformed to cursor movement on the screen. That is, single finger gestures on such a device
move a cursor; two-finger swipes will result in single-finger touch events; other two-finger
gestures will result in the corresponding two-finger touch event. An example device that supports
distinct multi-touch with a fake touch interface is one that provides a trackpad for cursor movement
which also supports two or more fingers.</p>
<p>When declared as required, this indicates that the application is compatible with a device
only if it supports touch emulation for events that supports distinct tracking of five or more
fingers.</p>
<p>Unlike the distinct multitouch defined by <code>android.hardware.touchscreen.multitouch.jazzhand</code>, input devices that support jazzhand multi-touch
with a fake touch interface will not support all five-finger gestures, because the input is being
transformed to cursor movement on the screen. That is, single finger gestures on such a device move
a cursor; multi-finger gestures will result in single-finger touch events; other multi-finger
gestures will result in the corresponding multi-finger touch event. An example device that supports
distinct multi-touch with a fake touch interface is one that provides a trackpad for cursor movement
which also supports five or more fingers.</p>
<p>By default, your application requires this. As such, your application is <em>not</em>
available to devices that provide only an emulated touch interface ("fake touch"), by default. If
you want your application available to devices that provide a fake touch interface (or even devices
that provide only a d-pad controller), you must explicitly declare that a touch screen is not
required, by declaring <code>android.hardware.touchscreen</code> with <code>android:required="false"</code>.
You should do so even if your application uses—but does not <em>require</em>—a real
touch screen interface.</p>
<p>If your application <em>does require</em> a touch interface (in order to perform touch
gestures such as a fling), then you don't need to do anything, because this is required by default.
However, it's best if you explicitly declare all features used by your application, so you should
still declare this if your app uses it.</p>
<p>If you require more complex touch interaction, such as multi-finger gestures, you
should declare the advanced touch screen features below.</p>
<h3>Software features</h3>
<p>The table below describes the software feature descriptors supported by the
most current platform release. To signal that your application uses or requires
a software feature, declare each value in a <code>android:name</code> attribute
in a separate <code>&lt;uses-feature&gt;</code> element. </p>
<p>Subfeature. The application uses SIP-based VOIP service on the device.
  </p>
<p>This subfeature implicitly declares the <code>android.software.sip</code> parent feature,
unless declared with <code>android:required="false"</code>.</p>
<h3>Permissions that Imply Feature Requirements</h3>
<p>Some feature constants listed in the tables above were made available to
applications <em>after</em> the corresponding API; for example, the
<code>android.hardware.bluetooth</code> feature was added in Android 2.2 (API
level 8), but the bluetooth API that it refers to was added in Android 2.0 (API
level 5). Because of this, some apps were able to use the API before they had
the ability to declare that they require the API via the
<code>&lt;uses-feature&gt;</code> system. </p>
<p>To prevent those apps from being made available unintentionally,  Google
Play assumes that certain hardware-related permissions indicate that the
underlying hardware features are required by default. For instance, applications
that use Bluetooth must request the <code>BLUETOOTH</code> permission in a
<code>&lt;uses-permission&gt;</code> element — for legacy apps, Google
Play assumes that the permission declaration means that the underlying
<code>android.hardware.bluetooth</code> feature is required by the application
and sets up filtering based on that feature. </p>
<p>The table below lists permissions that imply feature requirements
equivalent to those declared in <code>&lt;uses-feature&gt;</code> elements. Note
that <code>&lt;uses-feature&gt;</code> declarations, including any declared
<code>android:required</code> attribute, always take precedence over features
implied by the permissions below. </p>
<p>For any of the permissions below, you can disable filtering based on the
implied feature by explicitly declaring the implied feature explicitly, in a
<code>&lt;uses-feature&gt;</code> element, with an
<code>android:required="false"</code> attribute. For example, to disable any
filtering based on the <code>CAMERA</code> permission, you would add this
<code>&lt;uses-feature&gt;</code> declaration to the manifest file:</p>
<p>WHATSON? 80094bb8-7082-4f37-afc1-722e7e88cf65</p>
<pre>&lt;uses-feature android:name="android.hardware.camera" android:required="false" /&gt;</pre>
<p>(See Special handling for Bluetooth feature for details.)</p>
</body>
</html>