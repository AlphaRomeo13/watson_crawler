<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Dataflow-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Dataflow programming</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li><strong class="selflink">Dataflow</strong>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li><strong class="selflink">Dataflow</strong>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li>Block-structured</li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computer programming, <b>dataflow programming</b> is a programming paradigm that models a program as a directed graph of the data flowing between operations, thus implementing dataflow principles and architecture. Dataflow programming languages share some features of functional languages, and were generally developed in order to bring some functional concepts to a language more suitable for numeric processing. Some authors use the term Datastream instead of Dataflow to avoid confusion with Dataflow Computing or Dataflow architecture, based on an indeterministic machine paradigm.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Properties of dataflow programming languages
<ul>
<li>1.1 State</li>
<li>1.2 Representation</li>
</ul>
</li>
<li>2 History</li>
<li>3 Languages</li>
<li>4 Application programming interfaces</li>
<li>5 See also</li>
<li>6 References</li>
<li>7 External links</li>
</ul>
<ul>
<li>1.1 State</li>
<li>1.2 Representation</li>
</ul>
<p></p>
<h2>Properties of dataflow programming languages</h2>
<p>Traditionally, a program is modeled as a series of operations happening in a specific order; this may be referred to as sequential, procedural, Control flow (indicating that the program chooses a specific path), or imperative programming. The program focuses on commands, in line with the von Neumann vision of sequential programming, where data is normally "at rest"</p>
<p>In contrast, dataflow programming emphasizes the movement of data and models programs as a series of connections. Explicitly defined inputs and outputs connect operations, which function like black boxes. An operation runs as soon as all of its inputs become valid. Thus, dataflow languages are inherently parallel and can work well in large, decentralized systems. </p>
<h3>State</h3>
<p>One of the key concepts in computer programming is the idea of state, essentially a snapshot of various conditions in the system. Most programming languages require a considerable amount of state information, which is generally hidden from the programmer. Often, the computer itself has no idea which piece of information encodes the enduring state. This is a serious problem, as the state information needs to be shared across multiple processors in parallel processing machines. Most languages force the programmer to add extra code to indicate which data and parts of the code are important to the state. This code tends to be both expensive in terms of performance, as well as difficult to read or debug. Explicit parallelism is one of the main reasons for the poor performance of Enterprise Java Beans when building data-intensive, non-OLTP applications.</p>
<p>Where a linear program can be imagined as a single worker moving between tasks (operations), a dataflow program is more like a series of workers on an assembly line, each doing a specific task whenever materials are available. Since the operations are only concerned with the availability of data inputs, they have no hidden state to track, and are all "ready" at the same time.</p>
<h3>Representation</h3>
<p>Dataflow programs are represented in different ways. A traditional program is usually represented as a series of text instructions, which is reasonable for describing a serial system which pipes data between small, single-purpose tools that receive, process, and return. Dataflow programs start with an input, perhaps the command line parameters, and illustrate how that data is used and modified. The flow of data is explicit, often visually illustrated as a line or pipe.</p>
<p>In terms of encoding, a dataflow program might be implemented as a hash table, with uniquely identified inputs as the keys, used to look up pointers to the instructions. When any operation completes, the program scans down the list of operations until it finds the first operation where all inputs are currently valid, and runs it. When that operation finishes, it will typically output data, thereby making another operation become valid.</p>
<p>For parallel operation, only the list needs to be shared; it is the state of the entire program. Thus the task of maintaining state is removed from the programmer and given to the language's runtime. On machines with a single processor core where an implementation designed for parallel operation would simply introduce overhead, this overhead can be removed completely by using a different runtime.</p>
<h2>History</h2>
<p>A pioneer dataflow language was BLODI (BLOck DIagram), developed by John Larry Kelly, Jr., Carol Lochbaum and Victor A. Vyssotsky for specifying sampled data systems. A BLODI specification of functional units (amplifiers, adders, delay lines, etc.) and their interconnections was compiled into a single loop that updated the entire system for one clock tick.</p>
<p>More conventional dataflow languages were originally developed in order to make parallel programming easier. In Bert Sutherland's 1966 Ph.D. thesis, <i>The On-line Graphical Specification of Computer Procedures</i>, Sutherland created one of the first graphical dataflow programming frameworks. Subsequent dataflow languages were often developed at the large supercomputer labs. One of the most popular was SISAL, developed at Lawrence Livermore National Laboratory. SISAL looks like most statement-driven languages, but variables should be assigned once. This allows the compiler to easily identify the inputs and outputs. A number of offshoots of SISAL have been developed, including SAC, <i>Single Assignment C</i>, which tries to remain as close to the popular C programming language as possible.</p>
<p>A more radical concept is Prograph, in which programs are constructed as graphs onscreen, and variables are replaced entirely with lines linking inputs to outputs. Incidentally, Prograph was originally written on the Macintosh, which remained single-processor until the introduction of the DayStar Genesis MP in 1996.</p>
<p>There are many hardware architectures oriented toward the efficient implementation of dataflow programming models. MIT's tagged token dataflow architecture was designed by Greg Papadopoulos.</p>
<p>Data flow has been proposed as an abstraction for specifying the global behavior of distributed system components: in the live distributed objects programming model, distributed data flows are used to store and communicate state, and as such, they play the role analogous to variables, fields, and parameters in Java-like programming languages.</p>
<h2>Languages</h2>
<ul>
<li>Agilent VEE</li>
<li>Alteryx</li>
<li>ANI</li>
<li>DARTS</li>
<li>ASCET</li>
<li>AviSynth scripting language, for video processing</li>
<li>BLODI</li>
<li>BMDFM Binary Modular Dataflow Machine</li>
<li>CAL</li>
<li>COStream</li>
<li>Cassandra-vision - A Visual programming language with OpenCV support and C++ extension API</li>
<li>Curin</li>
<li>Hartmann pipelines</li>
<li>Hume</li>
<li>LabVIEW, G</li>
<li>Linda</li>
<li>Lucid</li>
<li>Lustre</li>
<li>M, used as the backend of Microsoft Excel's ETL plugin Power Query.</li>
<li>MaxCompiler - Designed by Maxeler Technologies and is compatible with OpenSPL</li>
<li>Max/MSP</li>
<li>Microsoft Visual Programming Language - A component of Microsoft Robotics Studio designed for Robotics programming</li>
<li>Nextflow - A data-driven toolkit for computational pipelines based on the dataflow programming model</li>
<li>OpenWire - adds visual dataflow programming capabilities to Delphi via VCL or FireMonkey components and a graphical editor (homonymous binary protocol is unrelated)</li>
<li>OpenWire Studio - A visual development environment which allows the development of software prototypes by non developers.</li>
<li>Oz now also distributed since 1.4.0</li>
<li>Pifagor</li>
<li>Pipeline Pilot</li>
<li>POGOL</li>
<li>Prograph</li>
<li>Pure Data</li>
<li>Pythonect</li>
<li>Quartz Composer - Designed by Apple; used for graphic animations and effects</li>
<li>SAC Single Assignment C</li>
<li>Scala (with a library SynapseGrid)</li>
<li>SIGNAL (a dataflow-oriented synchronous language enabling multi-clock specifications)</li>
<li>Simulink</li>
<li>SIMPL</li>
<li>SISAL</li>
<li>stromx - A visual programming environment focused on industrial vision (open source)</li>
<li>SWARM</li>
<li>System Verilog</li>
<li>Tersus - Visual programming platform (open source)</li>
<li>Verilog</li>
<li>VHDL</li>
<li>Vignette's VBIS language for business processes integration</li>
<li>vvvv</li>
<li>VSXu</li>
<li>Widget Workshop, a "game" designed for children which is technically a simplified dataflow programming language.</li>
<li>XEE (Starlight) XML Engineering Environment</li>
<li>XProc</li>
</ul>
<h2>Application programming interfaces</h2>
<ul>
<li>DC: Library that allows the embedding of one-way dataflow constraints in a C/C++ program.</li>
<li>SystemC: Library for C++, mainly aimed at hardware design.</li>
</ul>
<h2>See also</h2>
<ul>
<li>Actor model</li>
<li>Data-driven programming</li>
<li>Digital signal processing</li>
<li>Event-driven programming</li>
<li>Flow-based programming</li>
<li>Functional reactive programming</li>
<li>Glossary of reconfigurable computing</li>
<li>High-performance reconfigurable computing</li>
<li>Incremental computing</li>
<li>Partitioned global address space</li>
<li>Signal programming</li>
<li>Stream processing</li>
<li>Pipeline (Unix)</li>
<li>Yahoo Pipes</li>
</ul>
</body>
</html>