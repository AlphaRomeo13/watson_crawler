<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Identifier---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Identifier</h1>
<p>An <b>identifier</b> is a name that identifies (that is, labels the identity of) either a unique object or a unique <i>class</i> of objects, where the "object" or class may be an idea, physical [countable] object (or class thereof), or physical [noncountable] substance (or class thereof). The abbreviation <b>ID</b> often refers to identity, identification (the process of identifying), or an identifier (that is, an instance of identification). An identifier may be a word, number, letter, symbol, or any combination of those.</p>
<p>The words, numbers, letters, or symbols may follow an encoding system (wherein letters, digits, words, or symbols <i>stand for</i> (represent) ideas or longer names) or they may simply be arbitrary. When an identifier follows an encoding system, it is often referred to as a <b>code</b> or <b>ID code</b>. Identifiers that do not follow any encoding scheme are often said to be <b>arbitrary IDs</b>; they are arbitrarily assigned and have no greater meaning. (Sometimes identifiers are called "codes" even when they are actually arbitrary, whether because the speaker believes that they have deeper meaning or simply because he is speaking casually and imprecisely.)</p>
<p>ID codes inherently carry metadata along with them. (For example, when you know that the food package in front of you has the identifier "2011-09-25T15:42Z-MFR5-P02-243-45", you not only have that data, you also have the metadata that tells you that it was packaged on September 25, 2011, at 3:42pm UTC, manufactured by Licensed Vendor Number 5, at the Peoria, IL, USA plant, in Building 2, and was the 243rd package off the line in that shift, and was inspected by Inspector Number 45.) Arbitrary identifiers carry no metadata. (For example, if your food package just says 100054678214, its ID may not tell you anything except identity—no date, manufacturer name, production sequence rank, or inspector number.)</p>
<p>In some cases, even arbitrary identifiers such as sequential serial numbers leak too much information (see German tank problem). Opaque identifiers -- identifiers designed to avoid leaking even that small amount of information -- include "really opaque pointers" and Version 4 UUIDs.</p>
<p>The unique identifier (<b>UID</b>) is an identifier that refers to <i>only one instance</i>—only one particular object in the universe. A part number is an identifier, but it is not a <i>unique</i> identifier—for that, a serial number is needed, to identify <i>each instance</i> of the part design. Thus the <i>identifier</i> "Model T" identifies the <i>class</i> <i>(model)</i> of automobiles that Ford's Model T comprises; whereas the <i>unique identifier</i> "Model T Serial Number 159,862" identifies one specific member of that class—that is, one particular Model T car, owned by one specific person.</p>
<p>The concepts of <i>name</i> and <i>identifier</i> are denotatively equal, and the terms are thus denotatively synonymous; but they are not always connotatively synonymous, because <b>code names</b> and <b>ID numbers</b> are often connotatively distinguished from names in the sense of traditional natural language naming. For example, both "Jamie Zawinski" and "Netscape employee number 20" are identifiers for the same specific human being; but normal English-language connotation may consider "Jamie Zawinski" a "name" and not an "identifier", whereas it considers "Netscape employee number 20" an "identifier" but not a "name". This is an emic distinction rather than an etic one.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Metadata</li>
<li>2 In computer science
<ul>
<li>2.1 In computer languages</li>
</ul>
</li>
<li>3 Ambiguity
<ul>
<li>3.1 IDs versus UIDs</li>
<li>3.2 Implicit context and namespace conflicts</li>
</ul>
</li>
<li>4 Identifiers in various disciplines</li>
<li>5 See also</li>
<li>6 Notes</li>
</ul>
<ul>
<li>2.1 In computer languages</li>
</ul>
<ul>
<li>3.1 IDs versus UIDs</li>
<li>3.2 Implicit context and namespace conflicts</li>
</ul>
<p></p>
<h2>Metadata</h2>
<p>In metadata, an <b>identifier</b> is a language-independent label, sign or token that uniquely identifies an object within an identification scheme.</p>
<p>The suffix <b>identifier</b> is also used as a representation term when naming a data element.</p>
<h2>In computer science</h2>
<p>In computer science, <b>identifiers</b> (<b>IDs</b>) are lexical tokens that name entities. Identifiers are used extensively in virtually all information processing systems. Identifying entities makes it possible to refer to them, which is essential for any kind of symbolic processing.</p>
<h3>In computer languages</h3>
<p>In computer languages, identifiers are tokens (also called symbols) which name language entities. Some of the kinds of entities an identifier might denote include variables, types, labels, subroutines, and packages.</p>
<p>Which character sequences constitute identifiers depends on the lexical grammar of the language. A common rule is alphanumeric sequences, with underscore also allowed, and with the condition that it not begin with a digit (to simplify lexing by avoiding confusing with integer literals) – so <code>foo, foo1, foo_bar, _foo</code> are allowed, but <code>1foo</code> is not – this is the definition used in earlier versions of C and C++, Python 2, and many other languages. Later versions of these languages, along with many other modern languages support almost all Unicode characters in an identifier. However, a common restriction is not to permit whitespace characters and language operators; this simplifies tokenization by making it free-form and context-free. For example, forbidding <code>+</code> in identifiers (due to its use as a binary operation) means that <code>a+b</code> and <code>a + b</code> can be tokenized the same, while if it were allowed, <code>a+b</code> would be an identifier, not an addition. Whitespace in identifier is particularly problematic, as if spaces are allowed in identifiers, then a clause such as <code>if rainy day then 1</code> is legal, with <code>rainy day</code> as an identifier, but tokenizing this requires the phrasal context of being in the condition of an if clause. Some languages do allow spaces in identifiers, however, such as ALGOL 68 and some ALGOL variants – for example, the following is a valid statement: <code><b>real</b> half pi;</code> which could be entered as <code>.real. half pi;</code> (keywords are represented in boldface, concretely via stropping). In ALGOL this was possible because keywords are syntactically differentiated, so there is no risk of collision or ambiguity, spaces are eliminated during the line reconstruction phase, and the source was processed via scannerless parsing, so lexing could be context-sensitive.</p>
<p>In most languages, some character sequences have the lexical form of an identifier but are known as keywords – for example, <code>if</code> is frequently a keyword for an if clause, but lexically is of the same form as <code>ig</code> or <code>foo</code> namely a sequence of letters. This overlap can be handled in various ways: these may be forbidden from being identifiers – which simplifies tokenization and parsing – in which case they are reserved words; they may both be allowed but distinguished in other ways, such as via stropping; or keyword sequences may be allowed as identifiers and which sense is determined from context, which requires a context-sensitive lexer. Non-keywords may also be reserved words (forbidden as identifiers), particularly for forward compatibility, in case a word may become a keyword in future. In a few languages, e.g., PL/1, the distinction is not clear.</p>
<p>For implementations of programming languages that are using a compiler, identifiers are often only compile time entities. That is, at runtime the compiled program contains references to memory addresses and offsets rather than the textual identifier tokens (these memory addresses, or offsets, having been assigned by the compiler to each identifier).</p>
<p>In languages that support reflection, such as interactive evaluation of source code (using an interpreter or an incremental compiler), identifiers are also runtime entities, sometimes even as first-class objects that can be freely manipulated and evaluated. In Lisp, these are called symbols.</p>
<p>Compilers and interpreters do not usually assign any semantic meaning to an identifier based on the actual character sequence used. However, there are exceptions.</p>
<p>For example:</p>
<ul>
<li>In Perl a variable is indicated using a prefix called a sigil, which specifies aspects of how the variable is interpreted in expressions.</li>
<li>In Ruby a variable is automatically considered immutable if its identifier starts with a capital letter.</li>
<li>In Fortran, the first letter in a variable's name indicates whether by default it is created as an integer or floating point variable.</li>
<li>In Go, the capitalization of the first letter of a variable's name determines its visibility (public for uppercase, private for lowercase).</li>
</ul>
<p>In some languages such as Go, identifiers uniqueness is based on their spelling and their visibility.</p>
<p>In HTML an identifier is one of the possible attributes of an HTML element. It is unique within the document.</p>
<h2>Ambiguity</h2>
<h3>IDs versus UIDs</h3>
<p>Many resources may carry multiple identifiers. Typical examples are:</p>
<ul>
<li>One person with multiple names, nicknames, and forms of address (titles, salutations)
<ul>
<li><i>For example:</i> One specific person may be identified by all of the following identifiers: Jane Smith; Jane Elizabeth Meredith Smith; Jane E. M. Smith; Jane E. Smith; Janie Smith; Janie; Little Janie (as opposed to her mother or sister or cousin, Big Janie); Aunt Jane; Auntie Janie; Mom; Grandmom; Nana; Kelly's mother; Billy's grandmother; Ms. Smith; Dr. Smith; Jane E. Smith, PhD; and Fuzzy (her jocular nickname at work).</li>
</ul>
</li>
<li>One document with multiple versions</li>
<li>One substance with multiple names (for example, CAS index names versus IUPAC names; INN generic drug names versus USAN generic drug names versus brand names)</li>
</ul>
<ul>
<li><i>For example:</i> One specific person may be identified by all of the following identifiers: Jane Smith; Jane Elizabeth Meredith Smith; Jane E. M. Smith; Jane E. Smith; Janie Smith; Janie; Little Janie (as opposed to her mother or sister or cousin, Big Janie); Aunt Jane; Auntie Janie; Mom; Grandmom; Nana; Kelly's mother; Billy's grandmother; Ms. Smith; Dr. Smith; Jane E. Smith, PhD; and Fuzzy (her jocular nickname at work).</li>
</ul>
<p>The inverse is also possible, where multiple resources are represented with the same identifier (discussed below).</p>
<h3>Implicit context and namespace conflicts</h3>
<p>Many codes and nomenclatural systems originate within a small namespace. Over the years, some of them bleed into larger namespaces (as people interact in ways they formerly hadn't, e.g., cross-border trade, scientific collaboration, military alliance, and general cultural interconnection or assimilation). When such dissemination happens, the limitations of the original naming convention, which had formerly been latent and moot, become painfully apparent, often necessitating retronymy, synonymity, translation/transcoding, and so on. Such limitations generally accompany the shift away from the original context to the broader one. Typically the system shows implicit context (context was formerly assumed, and narrow), lack of capacity (e.g., low number of possible IDs, reflecting the outmoded narrow context), lack of extensibility (no features defined and reserved against future needs), and lack of specificity and disambiguating capability (related to the context shift, where longstanding uniqueness encounters novel nonuniqueness). Within computer science, this problem is called naming collision. The story of the origination and expansion of the CODEN system provides a good case example in a recent-decades, technical-nomenclature context. The capitalization variations seen with specific designators reveals an instance of this problem occurring in natural languages, where the proper noun/common noun distinction (and its complications) must be dealt with. A universe in which every object had a UID would not need any namespaces, which is to say that it would constitute one gigantic namespace; but human minds could never keep track of, or semantically interrelate, so many UIDs.</p>
<h2>Identifiers in various disciplines</h2>
<p>A small sample of various identifiers</p>
<h2>See also</h2>
<ul>
<li>Barcode</li>
<li>Binomial nomenclature</li>
<li>British Approved Name</li>
<li>Data descriptor</li>
<li>Data element</li>
<li>Descriptor</li>
<li>Diagnosis code</li>
<li>Document management system</li>
<li>File descriptor</li>
<li>Food labeling regulations</li>
<li>Gene nomenclature</li>
<li>Handle (computing)</li>
<li>Identification</li>
<li>Identity (object-oriented programming)</li>
<li>Identity document</li>
<li>Index term</li>
<li>Marketing part number</li>
<li>Metadata</li>
<li>Name binding</li>
<li>Namespace</li>
<li>Naming convention (programming)</li>
<li>National identification number</li>
<li>Nomenclature – contains various standardized naming systems</li>
<li>Nomenclature code
<ul>
<li>Chemical nomenclature</li>
<li>International Code of Nomenclature for algae, fungi, and plants</li>
<li>International Code of Nomenclature of Bacteria</li>
<li>International Code of Nomenclature for Cultivated Plants</li>
<li>International Code of Zoological Nomenclature</li>
</ul>
</li>
<li>Overloading</li>
<li>Part number</li>
<li>Product code</li>
<li>Reference (computer science)</li>
<li>Representation term</li>
<li>Systematized Nomenclature of Medicine</li>
<li>Uniform resource identifier (URI)</li>
<li>Unique identifier</li>
<li>Unique key</li>
</ul>
<ul>
<li>Chemical nomenclature</li>
<li>International Code of Nomenclature for algae, fungi, and plants</li>
<li>International Code of Nomenclature of Bacteria</li>
<li>International Code of Nomenclature for Cultivated Plants</li>
<li>International Code of Zoological Nomenclature</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> "The Go Programming Language Specification - The Go Programming Language". Golang.org. 2013-05-08. Retrieved 2013-06-05. </li>
<li><b>^</b> University of Glasgow. "Procedure for Applying Identifiers to Documents". Retrieved 28 April 2009. </li>
<li><b>^</b> Advanced Chemistry Development. "IUPAC vs. CAS Index". Retrieved 28 April 2009. </li>
<li><b>^</b> University of Pennsylvania. "Information on Chemical Nomenclature". Retrieved 28 April 2009. </li>
</ol>
</body>
</html>