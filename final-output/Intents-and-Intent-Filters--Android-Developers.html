<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Intents-and-Intent-Filters--Android-Developers.html</title></head>
<body>
<h1>Intents and Intent Filters</h1>
<h2>In this document</h2>
<ol>
  <li>Intent Types</li>
  <li>Building an Intent
    <ol>
      <li>Example explicit intent</li>
      <li>Example implicit intent</li>
      <li>Forcing an app chooser</li>
    </ol>
  </li>
  <li>Receiving an Implicit Intent
    <ol>
      <li>Example filters</li>
    </ol>
  </li>
  <li>Using a Pending Intent</li>
  <li>Intent Resolution
    <ol>
      <li>Action test</li>
      <li>Category test</li>
      <li>Data test</li>
      <li>Intent matching</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Example explicit intent</li>
      <li>Example implicit intent</li>
      <li>Forcing an app chooser</li>
    </ol>
<ol>
      <li>Example filters</li>
    </ol>
<ol>
      <li>Action test</li>
      <li>Category test</li>
      <li>Data test</li>
      <li>Intent matching</li>
    </ol>
<h2>See also</h2>
<ol>
<li>Interacting with Other Apps</li>
<li>Sharing Content</li>
</ol>
<p>An <code>Intent</code> is a messaging object you can use to request an action
from another app component.
Although intents facilitate communication between components in several ways, there are three
fundamental use-cases:</p>
<ul>
<li><b>To start an activity:</b>
<p>An <code>Activity</code> represents a single screen in an app. You can start a new
instance of an <code>Activity</code> by passing an <code>Intent</code>
to <code>startActivity()</code>. The <code>Intent</code>
describes the activity to start and carries any necessary data.</p>

<p>If you want to receive a result from the activity when it finishes,
call <code>startActivityForResult()</code>. Your activity receives the result
as a separate <code>Intent</code> object in your activity's <code>onActivityResult()</code> callback.
For more information, see the Activities guide.</p></li>

<li><b>To start a service:</b>
<p>A <code>Service</code> is a component that performs operations in the background
without a user interface. You can start a service to perform a one-time operation
(such as download a file) by passing an <code>Intent</code>
to <code>startService()</code>. The <code>Intent</code>
describes the service to start and carries any necessary data.</p>

<p>If the service is designed with a client-server interface, you can bind to the service
from another component by passing an <code>Intent</code> to <code>bindService()</code>. For more information, see the Services guide.</p></li>

<li><b>To deliver a broadcast:</b>
<p>A broadcast is a message that any app can receive. The system delivers various
broadcasts for system events, such as when the system boots up or the device starts charging.
You can deliver a broadcast to other apps by passing an <code>Intent</code>
to <code>sendBroadcast()</code>,
<code>sendOrderedBroadcast()</code>, or <code>sendStickyBroadcast()</code>.</p>
</li>
</ul>
<p>An <code>Activity</code> represents a single screen in an app. You can start a new
instance of an <code>Activity</code> by passing an <code>Intent</code>
to <code>startActivity()</code>. The <code>Intent</code>
describes the activity to start and carries any necessary data.</p>
<p>If you want to receive a result from the activity when it finishes,
call <code>startActivityForResult()</code>. Your activity receives the result
as a separate <code>Intent</code> object in your activity's <code>onActivityResult()</code> callback.
For more information, see the Activities guide.</p>
<p>A <code>Service</code> is a component that performs operations in the background
without a user interface. You can start a service to perform a one-time operation
(such as download a file) by passing an <code>Intent</code>
to <code>startService()</code>. The <code>Intent</code>
describes the service to start and carries any necessary data.</p>
<p>If the service is designed with a client-server interface, you can bind to the service
from another component by passing an <code>Intent</code> to <code>bindService()</code>. For more information, see the Services guide.</p>
<p>A broadcast is a message that any app can receive. The system delivers various
broadcasts for system events, such as when the system boots up or the device starts charging.
You can deliver a broadcast to other apps by passing an <code>Intent</code>
to <code>sendBroadcast()</code>,
<code>sendOrderedBroadcast()</code>, or <code>sendStickyBroadcast()</code>.</p>
<h2>Intent Types</h2>
<p>There are two types of intents:</p>
<ul>
<li><b>Explicit intents</b> specify the component to start by name (the
fully-qualified class name). You'll typically use an explicit intent to start a component in
your own app, because you know the class name of the activity or service you want to start. For
example, start a new activity in response to a user action or start a service to download
a file in the background.</li>

<li><b>Implicit intents</b> do not name a specific component, but instead declare a general action
to perform, which allows a component from another app to handle it. For example, if you want to
show the user a location on a map, you can use an implicit intent to request that another capable
app show a specified location on a map.</li>
</ul>
<p>When you create an explicit intent to start an activity or service, the system immediately
starts the app component specified in the <code>Intent</code> object.</p>
<p><strong>Figure 1.</strong> Illustration of how an implicit intent is
delivered through the system to start another activity: <b>[1]</b> <em>Activity A</em> creates an
<code>Intent</code> with an action description and passes it to <code>startActivity()</code>. <b>[2]</b> The Android System searches all
apps for an intent filter that matches the intent. When a match is found, <b>[3]</b> the system
starts the matching activity (<em>Activity B</em>) by invoking its <code>onCreate()</code> method and passing it the <code>Intent</code>.
</p>
<p>When you create an implicit intent, the Android system finds the appropriate component to start
by comparing the contents of the intent to the <em>intent filters</em> declared in the manifest file of other apps on the
device. If the intent matches an intent filter, the system starts that component and delivers it
the <code>Intent</code> object. If multiple intent filters are compatible, the system
displays a dialog so the user can pick which app to use.</p>
<p>An intent filter is an expression in an app's manifest file that
specifies the type of intents that the component
would like to receive. For instance, by declaring an intent filter for an activity,
you make it possible for other apps to directly start your activity with a certain kind of intent.
Likewise, if you do <em>not</em> declare any intent filters for an activity, then it can be started
only with an explicit intent.</p>
<p><strong>Caution:</strong> To ensure your app is secure, always use an explicit
intent when starting a <code>Service</code> and do not
declare intent filters for your services. Using an implicit intent to start a service is a
security hazard because you cannot be certain what service will respond to the intent,
and the user cannot see which service starts.</p>
<h2>Building an Intent</h2>
<p>An <code>Intent</code> object carries information that the Android system uses
to determine which component to start (such as the exact component name or component
category that should receive the intent), plus information that the recipient component uses in
order to properly perform the action (such as the action to take and the data to act upon).</p>
<p>The primary information contained in an <code>Intent</code> is the following:</p>
<p>This is optional, but it's the critical piece of information that makes an intent
<b>explicit</b>, meaning that the intent should be delivered only to the app component
defined by the component name. Without a component name, the intent is <b>implicit</b> and the
system decides which component should receive the intent based on the other intent information
(such as the action, data, and category—described below). So if you need to start a specific
component in your app, you should specify the component name.</p>
<p><strong>Note:</strong> When starting a <code>Service</code>, you should
<strong>always specify the component name</strong>. Otherwise, you cannot be certain what service
will respond to the intent, and the user cannot see which service starts.</p>
<p>This field of the <code>Intent</code> is a
<code>ComponentName</code> object, which you can specify using a fully
qualified class name of the target component, including the package name of the app. For example,
<code>com.example.ExampleActivity</code>. You can set the component name with <code>setComponent()</code>, <code>setClass()</code>, <code>setClassName()</code>, or with the
<code>Intent</code> constructor.</p>
<p></p>
<p>In the case of a broadcast intent, this is the action that took place and is being reported.
The action largely determines how the rest of the intent is structured—particularly
what is contained in the data and extras.

</p>
<p>You can specify your own actions for use by intents within your app (or for use by other
apps to invoke components in your app), but you should usually use action constants
defined by the <code>Intent</code> class or other framework classes. Here are some
common actions for starting an activity:</p>
<p>See the <code>Intent</code> class reference for more
constants that define generic actions.  Other actions are defined
elsewhere in the Android framework, such as in <code>Settings</code> for actions
that open specific screens in the system's Settings app.</p>
<p>You can specify the action for an intent with <code>setAction()</code> or with an <code>Intent</code> constructor.</p>
<p>If you define your own actions, be sure to include your app's package name
as a prefix. For example:</p>
<p>WHATSON? fb58cddf-0c7a-4772-a2e1-e7c420cc265d</p>
<pre>static final String ACTION_TIMETRAVEL = "com.example.action.TIMETRAVEL";</pre>
<p>When creating an intent,
it's often important to specify the type of data (its MIME type) in addition to its URI.
For example, an activity that's able to display images probably won't be able
to play an audio file, even though the URI formats could be similar.
So specifying the MIME type of your data helps the Android
system find the best component to receive your intent.
However, the MIME type can sometimes be inferred from the URI—particularly when the data is a
<code>content:</code> URI, which indicates the data is located on the device and controlled by a
<code>ContentProvider</code>, which makes the data MIME type visible to the system.</p>
<p>To set only the data URI, call <code>setData()</code>.
To set only the MIME type, call <code>setType()</code>. If necessary, you
can set both explicitly with <code>setDataAndType()</code>.</p>
<p><strong>Caution:</strong> If you want to set both the URI and MIME type,
<strong>do not</strong> call <code>setData()</code> and
<code>setType()</code> because they each nullify the value of the other.
Always use <code>setDataAndType()</code> to set both
URI and MIME type.</p>
<p></p>
<p>See the <code>Intent</code> class description for the full list of
categories.</p>
<p>You can specify a category with <code>addCategory()</code>.</p>
<p>These properties listed above (component name, action, data, and category) represent the
defining characteristics of an intent. By reading these properties, the Android system
is able to resolve which app component it should start.</p>
<p>However, an intent can carry additional information that does not affect
how it is resolved to an app component. An intent can also supply:</p>
<p>You can add extra data with various <code>putExtra()</code> methods,
each accepting two parameters: the key name and the value.
You can also create a <code>Bundle</code> object with all the extra data, then insert
the <code>Bundle</code> in the <code>Intent</code> with <code>putExtras()</code>.</p>
<p>For example, when creating an intent to send an email with
<code>ACTION_SEND</code>, you can specify the "to" recipient with the
<code>EXTRA_EMAIL</code> key, and specify the "subject" with the
<code>EXTRA_SUBJECT</code> key.</p>
<p>The <code>Intent</code> class specifies many <code>EXTRA_*</code> constants
for standardized data types. If you need to declare your own extra keys (for intents that
your app receives), be sure to include your app's package name
as a prefix. For example:</p>
<p>WHATSON? e949a635-f780-4f42-8d26-cb7472c1f500</p>
<pre>static final String EXTRA_GIGAWATTS = "com.example.EXTRA_GIGAWATTS";</pre>
<p>For more information, see the <code>setFlags()</code> method.</p>
<h3>Example explicit intent</h3>
<p>An explicit intent is one that you use to launch a specific app component, such as
a particular activity or service in your app. To create an explicit intent, define
the component name for the <code>Intent</code> object—all
other intent properties are optional.</p>
<p>For example, if you built a service in your app, named <code>DownloadService</code>,
designed to download a file from the web, you can start it with the following code:</p>
<p>WHATSON? 88bae6cf-b470-4093-a10b-faca86bfd910</p>
<pre>
// Executed in an Activity, so 'this' is the <code>Context</code>
// The fileUrl is a string URL, such as "http://www.example.com/image.png"
Intent downloadIntent = new Intent(this, DownloadService.class);
downloadIntent.setData(<code>Uri.parse</code>(fileUrl));
startService(downloadIntent);
</pre>
<p>The <code>Intent(Context, Class)</code>
constructor supplies the app <code>Context</code> and the
component a <code>Class</code> object. As such,
this intent explicitly starts the <code>DownloadService</code> class in the app.</p>
<p>For more information about building and starting a service, see the
Services guide.</p>
<h3>Example implicit intent</h3>
<p>An implicit intent specifies an action that can invoke any app on the device able
to perform the action. Using an implicit intent is useful when your app cannot perform the
action, but other apps probably can and you'd like the user to pick which app to use.</p>
<p>For example, if you have content you want the user to share with other people, create an intent
with the <code>ACTION_SEND</code> action
and add extras that specify the content to share. When you call
<code>startActivity()</code> with that intent, the user can
pick an app through which to share the content.</p>
<p><strong>Caution:</strong> It's possible that a user won't have <em>any</em>
apps that handle the implicit intent you send to <code>startActivity()</code>. If that happens, the call will fail and your app will crash. To verify
that an activity will receive the intent, call <code>resolveActivity()</code> on your <code>Intent</code> object. If the result is non-null,
then there is at least one app that can handle the intent and it's safe to call
<code>startActivity()</code>. If the result is null,
you should not use the intent and, if possible, you should disable the feature that issues
the intent.</p>
<p>WHATSON? ea17c1f6-bbc7-4d82-8ddb-4cad35900270</p>
<pre>
// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType(<code>HTTP.PLAIN_TEXT_TYPE</code>); // "text/plain" MIME type

// Verify that the intent will resolve to an activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}
</pre>
<p><strong>Note:</strong> In this case, a URI is not used, but the intent's data type
is declared to specify the content carried by the extras.</p>
<p>When <code>startActivity()</code> is called, the system
examines all of the installed apps to determine which ones can handle this kind of intent (an
intent with the <code>ACTION_SEND</code> action and that carries "text/plain"
data). If there's only one app that can handle it, that app opens immediately and is given the
intent. If multiple activities accept the intent, the system
displays a dialog so the user can pick which app to use..</p>
<p><strong>Figure 2.</strong> A chooser dialog.</p>
<h3>Forcing an app chooser</h3>
<p>When there is more than one app that responds to your implicit intent,
the user can select which app to use and make that app the default choice for the
action. This is nice when performing an action for which the user
probably wants to use the same app from now on, such as when opening a web page (users
often prefer just one web browser) .</p>
<p>However, if multiple apps can respond to the intent and the user might want to use a different
app each time, you should explicitly show a chooser dialog. The chooser dialog asks the
user to select which app to use for the action every time (the user cannot select a default app for
the action). For example, when your app performs "share" with the <code>ACTION_SEND</code> action, users may want to share using a different app depending
on their current situation, so you should always use the chooser dialog, as shown in figure 2.</p>
<p>To show the chooser, create an <code>Intent</code> using <code>createChooser()</code> and pass it to <code>startActivity()</code>. For example:</p>
<p>WHATSON? 67674871-ef83-403d-9f78-30f927bd0b10</p>
<pre>
Intent intent = new Intent(Intent.ACTION_SEND);
...

// Always use string resources for UI text.
// This says something like "Share this photo with"
String title = getResources().getString(R.string.chooser_title);
// Create intent to show chooser
Intent chooser = Intent.createChooser(intent, title);

// Verify the intent will resolve to at least one activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}
</pre>
<p>This displays a dialog with a list of apps that respond to the intent passed to the <code>createChooser()</code> method and uses the supplied text as the
dialog title.</p>
<h2>Receiving an Implicit Intent</h2>
<p>To advertise which implicit intents your app can receive, declare one or more intent filters for
each of your app components with an <code>&lt;intent-filter&gt;</code>
element in your manifest file.
Each intent filter specifies the type of intents it accepts based on the intent's action,
data, and category. The system will deliver an implicit intent to your app component only if the
intent can pass through one of your intent filters.</p>
<p><strong>Note:</strong> An explicit intent is always delivered to its target,
regardless of any intent filters the component declares.</p>
<p>An app component should declare separate filters for each unique job it can do.
For example, one activity in an image gallery app may have two filters: one filter
to view an image, and another filter to edit an image. When the activity starts,
it inspects the <code>Intent</code> and decides how to behave based on the information
in the <code>Intent</code> (such as to show the editor controls or not).</p>
<p>Each intent filter is defined by an <code>&lt;intent-filter&gt;</code>
element in the app's manifest file, nested in the corresponding app component (such
as an <code>&lt;activity&gt;</code>
element). Inside the <code>&lt;intent-filter&gt;</code>,
you can specify the type of intents to accept using one or more
of these three elements:</p>
<p><strong>Note:</strong> In order to receive implicit intents, you
  <strong>must include</strong> the
  <code>CATEGORY_DEFAULT</code> category in the intent filter. The methods
  <code>startActivity()</code> and
  <code>startActivityForResult()</code> treat all intents
  as if they declared the <code>CATEGORY_DEFAULT</code> category.
  If you do not declare this category in your intent filter, no implicit intents will resolve to
  your activity.</p>
<p>For example, here's an activity declaration with an intent filter to receive an
<code>ACTION_SEND</code> intent when the data type is text:</p>
<p>WHATSON? a9053fc6-4915-4492-a666-be8c98def473</p>
<pre>
&lt;activity android:name="ShareActivity"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.SEND"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="text/plain"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p>It's okay to create a filter that includes more than one instance of
<code>&lt;action&gt;</code>,
<code>&lt;data&gt;</code>, or
<code>&lt;category&gt;</code>.
If you do, you simply need to be certain that the component can handle any and all combinations
of those filter elements.</p>
<p>When you want to handle multiple kinds of intents, but only in specific combinations of
action, data, and category type, then you need to create multiple intent filters.</p>
<h2>Restricting access to components</h2>
<p>Using an intent filter is not a secure way to prevent other apps from starting
your components. Although intent filters restrict a component to respond to only
certain kinds of implicit intents, another app can potentially start your app component
by using an explicit intent if the developer determines your component names.
If it's important that <em>only your own app</em> is able to start one of your components,
set the <code>exported</code> attribute to <code>"false"</code> for that component.
</p>
<p>An implicit intent is tested against a filter by comparing the intent to each of the
three elements. To be delivered to the component, the intent must pass all three tests.
If it fails to match even one of them, the Android system won't deliver the intent to the
component.  However, because a component may have multiple intent filters, an intent that does
not pass through one of a component's filters might make it through on another filter.
More information about how the system resolves intents is provided in the section below
about Intent Resolution.</p>
<p><strong>Caution:</strong> To avoid inadvertently running a different app's
<code>Service</code>, always use an explicit intent to start your own service and do not
declare intent filters for your service.</p>
<p><strong>Note:</strong>
For all activities, you must declare your intent filters in the manifest file.
However, filters for broadcast receivers can be registered dynamically by calling
<code>registerReceiver()</code>. You can then unregister the receiver with <code>unregisterReceiver()</code>. Doing so allows your app
to listen for specific broadcasts during only a specified period of time while your app
is running.</p>
<h3>Example filters</h3>
<p>To better understand some of the intent filter behaviors, look at the following snippet
from the manifest file of a social-sharing app.</p>
<p>WHATSON? 8a6333e4-f2cb-42ce-b5b6-e85c47ecf048</p>
<pre>
&lt;activity android:name="MainActivity"&gt;
    &lt;!-- This activity is the main entry, should appear in app launcher --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity android:name="ShareActivity"&gt;
    &lt;!-- This activity handles "SEND" actions with text data --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.SEND"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="text/plain"/&gt;
    &lt;/intent-filter&gt;
    &lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.SEND"/&gt;
        &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt;
        &lt;data android:mimeType="image/*"/&gt;
        &lt;data android:mimeType="video/*"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p>The first activity, <code>MainActivity</code>, is the app's main entry point—the activity that
opens when the user initially launches the app with the launcher icon:</p>
<ul>
  <li>The <code>ACTION_MAIN</code> action
  indicates this is the main entry point and does not expect any intent data.</li>
  <li>The <code>CATEGORY_LAUNCHER</code> category indicates that this activity's
  icon should be placed in the system's app launcher. If the <code>&lt;activity&gt;</code> element
  does not specify an icon with <code>icon</code>, then the system uses the icon from the <code>&lt;application&gt;</code>
  element.</li>
</ul>
<p>These two must be paired together in order for the activity to appear in the app launcher.</p>
<p>The second activity, <code>ShareActivity</code>, is intended to facilitate sharing text and media
content. Although users might enter this activity by navigating to it from <code>MainActivity</code>,
they can also enter <code>ShareActivity</code> directly from another app that issues an implicit
intent matching one of the two intent filters.</p>
<p><strong>Note:</strong> The MIME type,
<code>application/vnd.google.panorama360+jpg</code>, is a special data type that specifies
panoramic photos, which you can handle with the Google
panorama APIs.</p>
<h2>Using a Pending Intent</h2>
<p>A <code>PendingIntent</code> object is a wrapper around an <code>Intent</code> object. The primary purpose of a <code>PendingIntent</code>
is to grant permission to a foreign application
to use the contained <code>Intent</code> as if it were executed from your
app's own process.</p>
<p>Major use cases for a pending intent include:</p>
<ul>
  <li>Declare an intent to be executed when the user performs an action with your Notification
  (the Android system's <code>NotificationManager</code>
  executes the <code>Intent</code>).
  </li><li>Declare an intent to be executed when the user performs an action with your
  App Widget
  (the Home screen app executes the <code>Intent</code>).
  </li><li>Declare an intent to be executed at a specified time in the future (the Android
  system's <code>AlarmManager</code> executes the <code>Intent</code>).
</li></ul>
<p>Because each <code>Intent</code> object is designed to be handled by a specific
type of app component (either an <code>Activity</code>, a <code>Service</code>, or
a <code>BroadcastReceiver</code>), so too must a <code>PendingIntent</code> be
created with the same consideration. When using a pending intent, your app will not
execute the intent with a call such as <code>startActivity()</code>. You must instead declare the intended component type when you create the
<code>PendingIntent</code> by calling the respective creator method:</p>
<ul>
  <li><code>PendingIntent.getActivity()</code> for an
  <code>Intent</code> that starts an <code>Activity</code>.</li>
  <li><code>PendingIntent.getService()</code> for an
  <code>Intent</code> that starts a <code>Service</code>.</li>
  <li><code>PendingIntent.getBroadcast()</code> for a
  <code>Intent</code> that starts an <code>BroadcastReceiver</code>.</li>
</ul>
<p>Unless your app is <em>receiving</em> pending intents from other apps,
the above methods to create a <code>PendingIntent</code> are the only
<code>PendingIntent</code> methods you'll probably ever need.</p>
<p>Each method takes the current app <code>Context</code>, the
<code>Intent</code> you want to wrap, and one or more flags that specify
how the intent should be used (such as whether the intent can be used more than once).</p>
<p>More information about using pending intents is provided with the documentation for each
of the respective use cases, such as in the Notifications
and App Widgets API guides.</p>
<h2>Intent Resolution</h2>
<p>When the system receives an implicit intent to start an activity, it searches for the
best activity for the intent by comparing the intent to intent filters based on three aspects:</p>
<ul>
  <li>The intent action
  </li><li>The intent data (both URI and data type)
  </li><li>The intent category
</li></ul>
<p>The following sections describe how an intents are matched to the appropriate component(s)
in terms of how the intent filter is declared in an app's manifest file.</p>
<h3>Action test</h3>
<p>To specify accepted intent actions, an intent filter can declare zero or more
<code>&lt;action&gt;</code> elements.  For example:</p>
<p>WHATSON? 9037cf2f-6087-4075-9f83-df9678698c3c</p>
<pre>
&lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.EDIT" /&gt;
    &lt;action android:name="android.intent.action.VIEW" /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>To get through this filter, the action specified in the <code>Intent</code>
  must match one of the actions listed in the filter.</p>
<p>If the filter does not list any actions, there is nothing for an
intent to match, so all intents fail the test. However, if an <code>Intent</code>
does not specify an action, it will pass the test (as long as the filter
contains at least one action).</p>
<h3>Category test</h3>
<p>To specify accepted intent categories, an intent filter can declare zero or more
<code>&lt;category&gt;</code> elements.  For example:</p>
<p>WHATSON? 10cbfb59-1213-4c76-a7c4-f2e7a638511c</p>
<pre>
&lt;intent-filter&gt;
    &lt;category android:name="android.intent.category.DEFAULT" /&gt;
    &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>For an intent to pass the category test, every category in the <code>Intent</code>
must match a category in the filter. The reverse is not necessary—the intent filter may
declare more categories than are specified in the <code>Intent</code> and the
<code>Intent</code> will still pass. Therefore, an intent with no categories should
always pass this test, regardless of what categories are declared in the filter.</p>
<p><strong>Note:</strong>
Android automatically applies the the <code>CATEGORY_DEFAULT</code> category
to all implicit intents passed to <code>startActivity()</code> and <code>startActivityForResult()</code>.
So if you want your activity to receive implicit intents, it must
include a category for <code>"android.intent.category.DEFAULT"</code> in its intent filters (as
shown in the previous <code>&lt;intent-filter&gt;</code> example.</p>
<h3>Data test</h3>
<p>To specify accepted intent data, an intent filter can declare zero or more
<code>&lt;data&gt;</code> elements.  For example:</p>
<p>WHATSON? e5f3ee93-2984-4770-b0d2-4a39335f7596</p>
<pre>
&lt;intent-filter&gt;
    &lt;data android:mimeType="video/mpeg" android:scheme="http" ... /&gt;
    &lt;data android:mimeType="audio/mpeg" android:scheme="http" ... /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>Each <code>&lt;data&gt;</code>
element can specify a URI structure and a data type (MIME media type).  There are separate
attributes — <code>scheme</code>, <code>host</code>, <code>port</code>,
and <code>path</code> — for each part of the URI:
</p>
<p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>
For example:
</p>
<p><code>content://com.example.project:200/folder/subfolder/etc</code></p>
<p>In this URI, the scheme is <code>content</code>, the host is <code>com.example.project</code>,
the port is <code>200</code>, and the path is <code>folder/subfolder/etc</code>.
</p>
<p>Each of these attributes is optional in a <code>&lt;data&gt;</code> element,
but there are linear dependencies:</p>
<ul>
  <li>If a scheme is not specified, the host is ignored.</li>
  <li>If a host is not specified, the port is ignored.</li>
  <li>If both the scheme and host are not specified, the path is ignored.</li>
</ul>
<p>When the URI in an intent is compared to a URI specification in a filter,
it's compared only to the parts of the URI included in the filter. For example:</p>
<ul>
  <li>If a filter specifies only a scheme, all URIs with that scheme match
the filter.</li>
  <li>If a filter specifies a scheme and an authority but no path, all URIs
with the same scheme and authority pass the filter, regardless of their paths.</li>
  <li>If a filter specifies a scheme, an authority, and a path, only URIs with the same scheme,
authority, and path pass the filter.</li>
</ul>
<p><strong>Note:</strong> A path specification can
contain a wildcard asterisk (*) to require only a partial match of the path name.</p>
<p>The data test compares both the URI and the MIME type in the intent to a URI
and MIME type specified in the filter.  The rules are as follows:
</p>
<ol>
<li>An intent that contains neither a URI nor a MIME type passes the
test only if the filter does not specify any URIs or MIME types.</li>

<li>An intent that contains a URI but no MIME type (neither explicit nor inferable from the
URI) passes the test only if its URI matches the filter's URI format
and the filter likewise does not specify a MIME type.</li>

<li>An intent that contains a MIME type but not a URI passes the test
only if the filter lists the same MIME type and does not specify a URI format.</li>

<li>An intent that contains both a URI and a MIME type (either explicit or inferable from the
URI) passes the MIME type part of the test only if that
type matches a type listed in the filter.  It passes the URI part of the test
either if its URI matches a URI in the filter or if it has a <code>content:</code>
or <code>file:</code> URI and the filter does not specify a URI.  In other words,
a component is presumed to support <code>content:</code> and <code>file:</code> data if
its filter lists <em>only</em> a MIME type.</li>
</ol>
<p>
This last rule, rule (d), reflects the expectation
that components are able to get local data from a file or content provider.
Therefore, their filters can list just a data type and do not need to explicitly
name the <code>content:</code> and <code>file:</code> schemes.
This is a typical case.  A <code>&lt;data&gt;</code> element
like the following, for example, tells Android that the component can get image data from a content
provider and display it:
</p>
<p>WHATSON? 92f6c184-2b04-4c57-8683-0f53f1454a2b</p>
<pre>
&lt;intent-filter&gt;
    &lt;data android:mimeType="image/*" /&gt;
    ...
&lt;/intent-filter&gt;</pre>
<p>
Because most available data is dispensed by content providers, filters that
specify a data type but not a URI are perhaps the most common.
</p>
<p>
Another common configuration is filters with a scheme and a data type.  For
example, a <code>&lt;data&gt;</code>
element like the following tells Android that
the component can retrieve video data from the network in order to perform the action:
</p>
<p>WHATSON? 087f3e5f-e296-4f62-8d88-d2d454b02e86</p>
<pre>
&lt;intent-filter&gt;
    &lt;data android:scheme="http" android:type="video/*" /&gt;
    ...
&lt;/intent-filter&gt;</pre>
<h3>Intent matching</h3>
<p>Intents are matched against intent filters not only to discover a target
component to activate, but also to discover something about the set of
components on the device.  For example, the Home app populates the app launcher
by finding all the  activities with intent filters that specify the
<code>ACTION_MAIN</code> action and
<code>CATEGORY_LAUNCHER</code> category.</p>
<p>Your application can use intent matching in a similar way.
The <code>PackageManager</code> has a set of <code>query...()</code>
methods that return all components that can accept a particular intent, and
a similar series of <code>resolve...()</code> methods that determine the best
component to respond to an intent.  For example,
<code>queryIntentActivities()</code> returns a list of all activities that can perform
the intent passed as an argument, and <code>queryIntentServices()</code> returns a similar list of services.
Neither method activates the components; they just list the ones that
can respond.  There's a similar method,
<code>queryBroadcastReceivers()</code>, for broadcast receivers.
</p>
<h1>Intents and Intent Filters</h1>
<h2>In this document</h2>
<ol>
  <li>Intent Types</li>
  <li>Building an Intent
    <ol>
      <li>Example explicit intent</li>
      <li>Example implicit intent</li>
      <li>Forcing an app chooser</li>
    </ol>
  </li>
  <li>Receiving an Implicit Intent
    <ol>
      <li>Example filters</li>
    </ol>
  </li>
  <li>Using a Pending Intent</li>
  <li>Intent Resolution
    <ol>
      <li>Action test</li>
      <li>Category test</li>
      <li>Data test</li>
      <li>Intent matching</li>
    </ol>
  </li>
</ol>
<ol>
      <li>Example explicit intent</li>
      <li>Example implicit intent</li>
      <li>Forcing an app chooser</li>
    </ol>
<ol>
      <li>Example filters</li>
    </ol>
<ol>
      <li>Action test</li>
      <li>Category test</li>
      <li>Data test</li>
      <li>Intent matching</li>
    </ol>
<h2>See also</h2>
<ol>
<li>Interacting with Other Apps</li>
<li>Sharing Content</li>
</ol>
<p>An <code>Intent</code> is a messaging object you can use to request an action
from another app component.
Although intents facilitate communication between components in several ways, there are three
fundamental use-cases:</p>
<ul>
<li><b>To start an activity:</b>
<p>An <code>Activity</code> represents a single screen in an app. You can start a new
instance of an <code>Activity</code> by passing an <code>Intent</code>
to <code>startActivity()</code>. The <code>Intent</code>
describes the activity to start and carries any necessary data.</p>

<p>If you want to receive a result from the activity when it finishes,
call <code>startActivityForResult()</code>. Your activity receives the result
as a separate <code>Intent</code> object in your activity's <code>onActivityResult()</code> callback.
For more information, see the Activities guide.</p></li>

<li><b>To start a service:</b>
<p>A <code>Service</code> is a component that performs operations in the background
without a user interface. You can start a service to perform a one-time operation
(such as download a file) by passing an <code>Intent</code>
to <code>startService()</code>. The <code>Intent</code>
describes the service to start and carries any necessary data.</p>

<p>If the service is designed with a client-server interface, you can bind to the service
from another component by passing an <code>Intent</code> to <code>bindService()</code>. For more information, see the Services guide.</p></li>

<li><b>To deliver a broadcast:</b>
<p>A broadcast is a message that any app can receive. The system delivers various
broadcasts for system events, such as when the system boots up or the device starts charging.
You can deliver a broadcast to other apps by passing an <code>Intent</code>
to <code>sendBroadcast()</code>,
<code>sendOrderedBroadcast()</code>, or <code>sendStickyBroadcast()</code>.</p>
</li>
</ul>
<p>An <code>Activity</code> represents a single screen in an app. You can start a new
instance of an <code>Activity</code> by passing an <code>Intent</code>
to <code>startActivity()</code>. The <code>Intent</code>
describes the activity to start and carries any necessary data.</p>
<p>If you want to receive a result from the activity when it finishes,
call <code>startActivityForResult()</code>. Your activity receives the result
as a separate <code>Intent</code> object in your activity's <code>onActivityResult()</code> callback.
For more information, see the Activities guide.</p>
<p>A <code>Service</code> is a component that performs operations in the background
without a user interface. You can start a service to perform a one-time operation
(such as download a file) by passing an <code>Intent</code>
to <code>startService()</code>. The <code>Intent</code>
describes the service to start and carries any necessary data.</p>
<p>If the service is designed with a client-server interface, you can bind to the service
from another component by passing an <code>Intent</code> to <code>bindService()</code>. For more information, see the Services guide.</p>
<p>A broadcast is a message that any app can receive. The system delivers various
broadcasts for system events, such as when the system boots up or the device starts charging.
You can deliver a broadcast to other apps by passing an <code>Intent</code>
to <code>sendBroadcast()</code>,
<code>sendOrderedBroadcast()</code>, or <code>sendStickyBroadcast()</code>.</p>
<h2>Intent Types</h2>
<p>There are two types of intents:</p>
<ul>
<li><b>Explicit intents</b> specify the component to start by name (the
fully-qualified class name). You'll typically use an explicit intent to start a component in
your own app, because you know the class name of the activity or service you want to start. For
example, start a new activity in response to a user action or start a service to download
a file in the background.</li>

<li><b>Implicit intents</b> do not name a specific component, but instead declare a general action
to perform, which allows a component from another app to handle it. For example, if you want to
show the user a location on a map, you can use an implicit intent to request that another capable
app show a specified location on a map.</li>
</ul>
<p>When you create an explicit intent to start an activity or service, the system immediately
starts the app component specified in the <code>Intent</code> object.</p>
<p><strong>Figure 1.</strong> Illustration of how an implicit intent is
delivered through the system to start another activity: <b>[1]</b> <em>Activity A</em> creates an
<code>Intent</code> with an action description and passes it to <code>startActivity()</code>. <b>[2]</b> The Android System searches all
apps for an intent filter that matches the intent. When a match is found, <b>[3]</b> the system
starts the matching activity (<em>Activity B</em>) by invoking its <code>onCreate()</code> method and passing it the <code>Intent</code>.
</p>
<p>When you create an implicit intent, the Android system finds the appropriate component to start
by comparing the contents of the intent to the <em>intent filters</em> declared in the manifest file of other apps on the
device. If the intent matches an intent filter, the system starts that component and delivers it
the <code>Intent</code> object. If multiple intent filters are compatible, the system
displays a dialog so the user can pick which app to use.</p>
<p>An intent filter is an expression in an app's manifest file that
specifies the type of intents that the component
would like to receive. For instance, by declaring an intent filter for an activity,
you make it possible for other apps to directly start your activity with a certain kind of intent.
Likewise, if you do <em>not</em> declare any intent filters for an activity, then it can be started
only with an explicit intent.</p>
<p><strong>Caution:</strong> To ensure your app is secure, always use an explicit
intent when starting a <code>Service</code> and do not
declare intent filters for your services. Using an implicit intent to start a service is a
security hazard because you cannot be certain what service will respond to the intent,
and the user cannot see which service starts.</p>
<h2>Building an Intent</h2>
<p>An <code>Intent</code> object carries information that the Android system uses
to determine which component to start (such as the exact component name or component
category that should receive the intent), plus information that the recipient component uses in
order to properly perform the action (such as the action to take and the data to act upon).</p>
<p>The primary information contained in an <code>Intent</code> is the following:</p>
<p>This is optional, but it's the critical piece of information that makes an intent
<b>explicit</b>, meaning that the intent should be delivered only to the app component
defined by the component name. Without a component name, the intent is <b>implicit</b> and the
system decides which component should receive the intent based on the other intent information
(such as the action, data, and category—described below). So if you need to start a specific
component in your app, you should specify the component name.</p>
<p><strong>Note:</strong> When starting a <code>Service</code>, you should
<strong>always specify the component name</strong>. Otherwise, you cannot be certain what service
will respond to the intent, and the user cannot see which service starts.</p>
<p>This field of the <code>Intent</code> is a
<code>ComponentName</code> object, which you can specify using a fully
qualified class name of the target component, including the package name of the app. For example,
<code>com.example.ExampleActivity</code>. You can set the component name with <code>setComponent()</code>, <code>setClass()</code>, <code>setClassName()</code>, or with the
<code>Intent</code> constructor.</p>
<p></p>
<p>In the case of a broadcast intent, this is the action that took place and is being reported.
The action largely determines how the rest of the intent is structured—particularly
what is contained in the data and extras.

</p>
<p>You can specify your own actions for use by intents within your app (or for use by other
apps to invoke components in your app), but you should usually use action constants
defined by the <code>Intent</code> class or other framework classes. Here are some
common actions for starting an activity:</p>
<p>See the <code>Intent</code> class reference for more
constants that define generic actions.  Other actions are defined
elsewhere in the Android framework, such as in <code>Settings</code> for actions
that open specific screens in the system's Settings app.</p>
<p>You can specify the action for an intent with <code>setAction()</code> or with an <code>Intent</code> constructor.</p>
<p>If you define your own actions, be sure to include your app's package name
as a prefix. For example:</p>
<p>WHATSON? 0d7a800a-5482-466b-8350-9e7589a84866</p>
<pre>static final String ACTION_TIMETRAVEL = "com.example.action.TIMETRAVEL";</pre>
<p>When creating an intent,
it's often important to specify the type of data (its MIME type) in addition to its URI.
For example, an activity that's able to display images probably won't be able
to play an audio file, even though the URI formats could be similar.
So specifying the MIME type of your data helps the Android
system find the best component to receive your intent.
However, the MIME type can sometimes be inferred from the URI—particularly when the data is a
<code>content:</code> URI, which indicates the data is located on the device and controlled by a
<code>ContentProvider</code>, which makes the data MIME type visible to the system.</p>
<p>To set only the data URI, call <code>setData()</code>.
To set only the MIME type, call <code>setType()</code>. If necessary, you
can set both explicitly with <code>setDataAndType()</code>.</p>
<p><strong>Caution:</strong> If you want to set both the URI and MIME type,
<strong>do not</strong> call <code>setData()</code> and
<code>setType()</code> because they each nullify the value of the other.
Always use <code>setDataAndType()</code> to set both
URI and MIME type.</p>
<p></p>
<p>See the <code>Intent</code> class description for the full list of
categories.</p>
<p>You can specify a category with <code>addCategory()</code>.</p>
<p>These properties listed above (component name, action, data, and category) represent the
defining characteristics of an intent. By reading these properties, the Android system
is able to resolve which app component it should start.</p>
<p>However, an intent can carry additional information that does not affect
how it is resolved to an app component. An intent can also supply:</p>
<p>You can add extra data with various <code>putExtra()</code> methods,
each accepting two parameters: the key name and the value.
You can also create a <code>Bundle</code> object with all the extra data, then insert
the <code>Bundle</code> in the <code>Intent</code> with <code>putExtras()</code>.</p>
<p>For example, when creating an intent to send an email with
<code>ACTION_SEND</code>, you can specify the "to" recipient with the
<code>EXTRA_EMAIL</code> key, and specify the "subject" with the
<code>EXTRA_SUBJECT</code> key.</p>
<p>The <code>Intent</code> class specifies many <code>EXTRA_*</code> constants
for standardized data types. If you need to declare your own extra keys (for intents that
your app receives), be sure to include your app's package name
as a prefix. For example:</p>
<p>WHATSON? 483fcf48-633d-4e79-a86d-650c3a05fe0b</p>
<pre>static final String EXTRA_GIGAWATTS = "com.example.EXTRA_GIGAWATTS";</pre>
<p>For more information, see the <code>setFlags()</code> method.</p>
<h3>Example explicit intent</h3>
<p>An explicit intent is one that you use to launch a specific app component, such as
a particular activity or service in your app. To create an explicit intent, define
the component name for the <code>Intent</code> object—all
other intent properties are optional.</p>
<p>For example, if you built a service in your app, named <code>DownloadService</code>,
designed to download a file from the web, you can start it with the following code:</p>
<p>WHATSON? e2395084-081b-4092-9f08-da249358a4f6</p>
<pre>
// Executed in an Activity, so 'this' is the <code>Context</code>
// The fileUrl is a string URL, such as "http://www.example.com/image.png"
Intent downloadIntent = new Intent(this, DownloadService.class);
downloadIntent.setData(<code>Uri.parse</code>(fileUrl));
startService(downloadIntent);
</pre>
<p>The <code>Intent(Context, Class)</code>
constructor supplies the app <code>Context</code> and the
component a <code>Class</code> object. As such,
this intent explicitly starts the <code>DownloadService</code> class in the app.</p>
<p>For more information about building and starting a service, see the
Services guide.</p>
<h3>Example implicit intent</h3>
<p>An implicit intent specifies an action that can invoke any app on the device able
to perform the action. Using an implicit intent is useful when your app cannot perform the
action, but other apps probably can and you'd like the user to pick which app to use.</p>
<p>For example, if you have content you want the user to share with other people, create an intent
with the <code>ACTION_SEND</code> action
and add extras that specify the content to share. When you call
<code>startActivity()</code> with that intent, the user can
pick an app through which to share the content.</p>
<p><strong>Caution:</strong> It's possible that a user won't have <em>any</em>
apps that handle the implicit intent you send to <code>startActivity()</code>. If that happens, the call will fail and your app will crash. To verify
that an activity will receive the intent, call <code>resolveActivity()</code> on your <code>Intent</code> object. If the result is non-null,
then there is at least one app that can handle the intent and it's safe to call
<code>startActivity()</code>. If the result is null,
you should not use the intent and, if possible, you should disable the feature that issues
the intent.</p>
<p>WHATSON? 65b6b775-63e8-4e9b-b7b6-54566ab6ffa2</p>
<pre>
// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType(<code>HTTP.PLAIN_TEXT_TYPE</code>); // "text/plain" MIME type

// Verify that the intent will resolve to an activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}
</pre>
<p><strong>Note:</strong> In this case, a URI is not used, but the intent's data type
is declared to specify the content carried by the extras.</p>
<p>When <code>startActivity()</code> is called, the system
examines all of the installed apps to determine which ones can handle this kind of intent (an
intent with the <code>ACTION_SEND</code> action and that carries "text/plain"
data). If there's only one app that can handle it, that app opens immediately and is given the
intent. If multiple activities accept the intent, the system
displays a dialog so the user can pick which app to use..</p>
<p><strong>Figure 2.</strong> A chooser dialog.</p>
<h3>Forcing an app chooser</h3>
<p>When there is more than one app that responds to your implicit intent,
the user can select which app to use and make that app the default choice for the
action. This is nice when performing an action for which the user
probably wants to use the same app from now on, such as when opening a web page (users
often prefer just one web browser) .</p>
<p>However, if multiple apps can respond to the intent and the user might want to use a different
app each time, you should explicitly show a chooser dialog. The chooser dialog asks the
user to select which app to use for the action every time (the user cannot select a default app for
the action). For example, when your app performs "share" with the <code>ACTION_SEND</code> action, users may want to share using a different app depending
on their current situation, so you should always use the chooser dialog, as shown in figure 2.</p>
<p>To show the chooser, create an <code>Intent</code> using <code>createChooser()</code> and pass it to <code>startActivity()</code>. For example:</p>
<p>WHATSON? 0f75a1b2-0c05-426c-9cfa-4ee03420c48f</p>
<pre>
Intent intent = new Intent(Intent.ACTION_SEND);
...

// Always use string resources for UI text.
// This says something like "Share this photo with"
String title = getResources().getString(R.string.chooser_title);
// Create intent to show chooser
Intent chooser = Intent.createChooser(intent, title);

// Verify the intent will resolve to at least one activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}
</pre>
<p>This displays a dialog with a list of apps that respond to the intent passed to the <code>createChooser()</code> method and uses the supplied text as the
dialog title.</p>
<h2>Receiving an Implicit Intent</h2>
<p>To advertise which implicit intents your app can receive, declare one or more intent filters for
each of your app components with an <code>&lt;intent-filter&gt;</code>
element in your manifest file.
Each intent filter specifies the type of intents it accepts based on the intent's action,
data, and category. The system will deliver an implicit intent to your app component only if the
intent can pass through one of your intent filters.</p>
<p><strong>Note:</strong> An explicit intent is always delivered to its target,
regardless of any intent filters the component declares.</p>
<p>An app component should declare separate filters for each unique job it can do.
For example, one activity in an image gallery app may have two filters: one filter
to view an image, and another filter to edit an image. When the activity starts,
it inspects the <code>Intent</code> and decides how to behave based on the information
in the <code>Intent</code> (such as to show the editor controls or not).</p>
<p>Each intent filter is defined by an <code>&lt;intent-filter&gt;</code>
element in the app's manifest file, nested in the corresponding app component (such
as an <code>&lt;activity&gt;</code>
element). Inside the <code>&lt;intent-filter&gt;</code>,
you can specify the type of intents to accept using one or more
of these three elements:</p>
<p><strong>Note:</strong> In order to receive implicit intents, you
  <strong>must include</strong> the
  <code>CATEGORY_DEFAULT</code> category in the intent filter. The methods
  <code>startActivity()</code> and
  <code>startActivityForResult()</code> treat all intents
  as if they declared the <code>CATEGORY_DEFAULT</code> category.
  If you do not declare this category in your intent filter, no implicit intents will resolve to
  your activity.</p>
<p>For example, here's an activity declaration with an intent filter to receive an
<code>ACTION_SEND</code> intent when the data type is text:</p>
<p>WHATSON? 55970d70-880b-48c5-b2bb-fcb04689bc5f</p>
<pre>
&lt;activity android:name="ShareActivity"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.SEND"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="text/plain"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p>It's okay to create a filter that includes more than one instance of
<code>&lt;action&gt;</code>,
<code>&lt;data&gt;</code>, or
<code>&lt;category&gt;</code>.
If you do, you simply need to be certain that the component can handle any and all combinations
of those filter elements.</p>
<p>When you want to handle multiple kinds of intents, but only in specific combinations of
action, data, and category type, then you need to create multiple intent filters.</p>
<h2>Restricting access to components</h2>
<p>Using an intent filter is not a secure way to prevent other apps from starting
your components. Although intent filters restrict a component to respond to only
certain kinds of implicit intents, another app can potentially start your app component
by using an explicit intent if the developer determines your component names.
If it's important that <em>only your own app</em> is able to start one of your components,
set the <code>exported</code> attribute to <code>"false"</code> for that component.
</p>
<p>An implicit intent is tested against a filter by comparing the intent to each of the
three elements. To be delivered to the component, the intent must pass all three tests.
If it fails to match even one of them, the Android system won't deliver the intent to the
component.  However, because a component may have multiple intent filters, an intent that does
not pass through one of a component's filters might make it through on another filter.
More information about how the system resolves intents is provided in the section below
about Intent Resolution.</p>
<p><strong>Caution:</strong> To avoid inadvertently running a different app's
<code>Service</code>, always use an explicit intent to start your own service and do not
declare intent filters for your service.</p>
<p><strong>Note:</strong>
For all activities, you must declare your intent filters in the manifest file.
However, filters for broadcast receivers can be registered dynamically by calling
<code>registerReceiver()</code>. You can then unregister the receiver with <code>unregisterReceiver()</code>. Doing so allows your app
to listen for specific broadcasts during only a specified period of time while your app
is running.</p>
<h3>Example filters</h3>
<p>To better understand some of the intent filter behaviors, look at the following snippet
from the manifest file of a social-sharing app.</p>
<p>WHATSON? dec3e4e1-fac8-4a38-b617-dfc8c2d964cb</p>
<pre>
&lt;activity android:name="MainActivity"&gt;
    &lt;!-- This activity is the main entry, should appear in app launcher --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN" /&gt;
        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity android:name="ShareActivity"&gt;
    &lt;!-- This activity handles "SEND" actions with text data --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.SEND"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="text/plain"/&gt;
    &lt;/intent-filter&gt;
    &lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.SEND"/&gt;
        &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt;
        &lt;category android:name="android.intent.category.DEFAULT"/&gt;
        &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt;
        &lt;data android:mimeType="image/*"/&gt;
        &lt;data android:mimeType="video/*"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre>
<p>The first activity, <code>MainActivity</code>, is the app's main entry point—the activity that
opens when the user initially launches the app with the launcher icon:</p>
<ul>
  <li>The <code>ACTION_MAIN</code> action
  indicates this is the main entry point and does not expect any intent data.</li>
  <li>The <code>CATEGORY_LAUNCHER</code> category indicates that this activity's
  icon should be placed in the system's app launcher. If the <code>&lt;activity&gt;</code> element
  does not specify an icon with <code>icon</code>, then the system uses the icon from the <code>&lt;application&gt;</code>
  element.</li>
</ul>
<p>These two must be paired together in order for the activity to appear in the app launcher.</p>
<p>The second activity, <code>ShareActivity</code>, is intended to facilitate sharing text and media
content. Although users might enter this activity by navigating to it from <code>MainActivity</code>,
they can also enter <code>ShareActivity</code> directly from another app that issues an implicit
intent matching one of the two intent filters.</p>
<p><strong>Note:</strong> The MIME type,
<code>application/vnd.google.panorama360+jpg</code>, is a special data type that specifies
panoramic photos, which you can handle with the Google
panorama APIs.</p>
<h2>Using a Pending Intent</h2>
<p>A <code>PendingIntent</code> object is a wrapper around an <code>Intent</code> object. The primary purpose of a <code>PendingIntent</code>
is to grant permission to a foreign application
to use the contained <code>Intent</code> as if it were executed from your
app's own process.</p>
<p>Major use cases for a pending intent include:</p>
<ul>
  <li>Declare an intent to be executed when the user performs an action with your Notification
  (the Android system's <code>NotificationManager</code>
  executes the <code>Intent</code>).
  </li><li>Declare an intent to be executed when the user performs an action with your
  App Widget
  (the Home screen app executes the <code>Intent</code>).
  </li><li>Declare an intent to be executed at a specified time in the future (the Android
  system's <code>AlarmManager</code> executes the <code>Intent</code>).
</li></ul>
<p>Because each <code>Intent</code> object is designed to be handled by a specific
type of app component (either an <code>Activity</code>, a <code>Service</code>, or
a <code>BroadcastReceiver</code>), so too must a <code>PendingIntent</code> be
created with the same consideration. When using a pending intent, your app will not
execute the intent with a call such as <code>startActivity()</code>. You must instead declare the intended component type when you create the
<code>PendingIntent</code> by calling the respective creator method:</p>
<ul>
  <li><code>PendingIntent.getActivity()</code> for an
  <code>Intent</code> that starts an <code>Activity</code>.</li>
  <li><code>PendingIntent.getService()</code> for an
  <code>Intent</code> that starts a <code>Service</code>.</li>
  <li><code>PendingIntent.getBroadcast()</code> for a
  <code>Intent</code> that starts an <code>BroadcastReceiver</code>.</li>
</ul>
<p>Unless your app is <em>receiving</em> pending intents from other apps,
the above methods to create a <code>PendingIntent</code> are the only
<code>PendingIntent</code> methods you'll probably ever need.</p>
<p>Each method takes the current app <code>Context</code>, the
<code>Intent</code> you want to wrap, and one or more flags that specify
how the intent should be used (such as whether the intent can be used more than once).</p>
<p>More information about using pending intents is provided with the documentation for each
of the respective use cases, such as in the Notifications
and App Widgets API guides.</p>
<h2>Intent Resolution</h2>
<p>When the system receives an implicit intent to start an activity, it searches for the
best activity for the intent by comparing the intent to intent filters based on three aspects:</p>
<ul>
  <li>The intent action
  </li><li>The intent data (both URI and data type)
  </li><li>The intent category
</li></ul>
<p>The following sections describe how an intents are matched to the appropriate component(s)
in terms of how the intent filter is declared in an app's manifest file.</p>
<h3>Action test</h3>
<p>To specify accepted intent actions, an intent filter can declare zero or more
<code>&lt;action&gt;</code> elements.  For example:</p>
<p>WHATSON? 6daea355-097f-494a-8eb5-8adfea56f917</p>
<pre>
&lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.EDIT" /&gt;
    &lt;action android:name="android.intent.action.VIEW" /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>To get through this filter, the action specified in the <code>Intent</code>
  must match one of the actions listed in the filter.</p>
<p>If the filter does not list any actions, there is nothing for an
intent to match, so all intents fail the test. However, if an <code>Intent</code>
does not specify an action, it will pass the test (as long as the filter
contains at least one action).</p>
<h3>Category test</h3>
<p>To specify accepted intent categories, an intent filter can declare zero or more
<code>&lt;category&gt;</code> elements.  For example:</p>
<p>WHATSON? 465b4b14-12c9-4d07-a899-2c7e5591d7d1</p>
<pre>
&lt;intent-filter&gt;
    &lt;category android:name="android.intent.category.DEFAULT" /&gt;
    &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>For an intent to pass the category test, every category in the <code>Intent</code>
must match a category in the filter. The reverse is not necessary—the intent filter may
declare more categories than are specified in the <code>Intent</code> and the
<code>Intent</code> will still pass. Therefore, an intent with no categories should
always pass this test, regardless of what categories are declared in the filter.</p>
<p><strong>Note:</strong>
Android automatically applies the the <code>CATEGORY_DEFAULT</code> category
to all implicit intents passed to <code>startActivity()</code> and <code>startActivityForResult()</code>.
So if you want your activity to receive implicit intents, it must
include a category for <code>"android.intent.category.DEFAULT"</code> in its intent filters (as
shown in the previous <code>&lt;intent-filter&gt;</code> example.</p>
<h3>Data test</h3>
<p>To specify accepted intent data, an intent filter can declare zero or more
<code>&lt;data&gt;</code> elements.  For example:</p>
<p>WHATSON? 696c55c0-8d59-4401-bb0d-654e639fa2a8</p>
<pre>
&lt;intent-filter&gt;
    &lt;data android:mimeType="video/mpeg" android:scheme="http" ... /&gt;
    &lt;data android:mimeType="audio/mpeg" android:scheme="http" ... /&gt;
    ...
&lt;/intent-filter&gt;
</pre>
<p>Each <code>&lt;data&gt;</code>
element can specify a URI structure and a data type (MIME media type).  There are separate
attributes — <code>scheme</code>, <code>host</code>, <code>port</code>,
and <code>path</code> — for each part of the URI:
</p>
<p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>
For example:
</p>
<p><code>content://com.example.project:200/folder/subfolder/etc</code></p>
<p>In this URI, the scheme is <code>content</code>, the host is <code>com.example.project</code>,
the port is <code>200</code>, and the path is <code>folder/subfolder/etc</code>.
</p>
<p>Each of these attributes is optional in a <code>&lt;data&gt;</code> element,
but there are linear dependencies:</p>
<ul>
  <li>If a scheme is not specified, the host is ignored.</li>
  <li>If a host is not specified, the port is ignored.</li>
  <li>If both the scheme and host are not specified, the path is ignored.</li>
</ul>
<p>When the URI in an intent is compared to a URI specification in a filter,
it's compared only to the parts of the URI included in the filter. For example:</p>
<ul>
  <li>If a filter specifies only a scheme, all URIs with that scheme match
the filter.</li>
  <li>If a filter specifies a scheme and an authority but no path, all URIs
with the same scheme and authority pass the filter, regardless of their paths.</li>
  <li>If a filter specifies a scheme, an authority, and a path, only URIs with the same scheme,
authority, and path pass the filter.</li>
</ul>
<p><strong>Note:</strong> A path specification can
contain a wildcard asterisk (*) to require only a partial match of the path name.</p>
<p>The data test compares both the URI and the MIME type in the intent to a URI
and MIME type specified in the filter.  The rules are as follows:
</p>
<ol>
<li>An intent that contains neither a URI nor a MIME type passes the
test only if the filter does not specify any URIs or MIME types.</li>

<li>An intent that contains a URI but no MIME type (neither explicit nor inferable from the
URI) passes the test only if its URI matches the filter's URI format
and the filter likewise does not specify a MIME type.</li>

<li>An intent that contains a MIME type but not a URI passes the test
only if the filter lists the same MIME type and does not specify a URI format.</li>

<li>An intent that contains both a URI and a MIME type (either explicit or inferable from the
URI) passes the MIME type part of the test only if that
type matches a type listed in the filter.  It passes the URI part of the test
either if its URI matches a URI in the filter or if it has a <code>content:</code>
or <code>file:</code> URI and the filter does not specify a URI.  In other words,
a component is presumed to support <code>content:</code> and <code>file:</code> data if
its filter lists <em>only</em> a MIME type.</li>
</ol>
<p>
This last rule, rule (d), reflects the expectation
that components are able to get local data from a file or content provider.
Therefore, their filters can list just a data type and do not need to explicitly
name the <code>content:</code> and <code>file:</code> schemes.
This is a typical case.  A <code>&lt;data&gt;</code> element
like the following, for example, tells Android that the component can get image data from a content
provider and display it:
</p>
<p>WHATSON? 694fa01b-f15a-480b-a0b2-f53a9297b4e6</p>
<pre>
&lt;intent-filter&gt;
    &lt;data android:mimeType="image/*" /&gt;
    ...
&lt;/intent-filter&gt;</pre>
<p>
Because most available data is dispensed by content providers, filters that
specify a data type but not a URI are perhaps the most common.
</p>
<p>
Another common configuration is filters with a scheme and a data type.  For
example, a <code>&lt;data&gt;</code>
element like the following tells Android that
the component can retrieve video data from the network in order to perform the action:
</p>
<p>WHATSON? ce7be464-c702-40e4-99e6-b83962bf8e6c</p>
<pre>
&lt;intent-filter&gt;
    &lt;data android:scheme="http" android:type="video/*" /&gt;
    ...
&lt;/intent-filter&gt;</pre>
<h3>Intent matching</h3>
<p>Intents are matched against intent filters not only to discover a target
component to activate, but also to discover something about the set of
components on the device.  For example, the Home app populates the app launcher
by finding all the  activities with intent filters that specify the
<code>ACTION_MAIN</code> action and
<code>CATEGORY_LAUNCHER</code> category.</p>
<p>Your application can use intent matching in a similar way.
The <code>PackageManager</code> has a set of <code>query...()</code>
methods that return all components that can accept a particular intent, and
a similar series of <code>resolve...()</code> methods that determine the best
component to respond to an intent.  For example,
<code>queryIntentActivities()</code> returns a list of all activities that can perform
the intent passed as an argument, and <code>queryIntentServices()</code> returns a similar list of services.
Neither method activates the components; they just list the ones that
can respond.  There's a similar method,
<code>queryBroadcastReceivers()</code>, for broadcast receivers.
</p>
</body>
</html>