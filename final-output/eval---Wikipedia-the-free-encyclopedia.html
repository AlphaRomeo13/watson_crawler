<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>eval---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>eval</h1>
<p>In some programming languages, <b><code>eval</code></b> is a function which evaluates a string as though it were an expression and returns a result; in others, it executes multiple lines of code as though they had been included instead of the line including the <code>eval</code>. The input to <code>eval</code> is not necessarily a string; in languages that support syntactic abstractions (like Lisp), <code>eval</code>'s input will consist of abstract syntactic forms.</p>
<p>Eval and apply are instances of meta-circular evaluators, interpreters of a language that can be invoked within the language itself.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Security risks</li>
<li>2 Uses</li>
<li>3 Implementation</li>
<li>4 Programming languages
<ul>
<li>4.1 ECMAScript
<ul>
<li>4.1.1 JavaScript</li>
<li>4.1.2 ActionScript</li>
</ul>
</li>
<li>4.2 Lisp</li>
<li>4.3 Perl</li>
<li>4.4 PHP</li>
<li>4.5 Lua</li>
<li>4.6 PostScript</li>
<li>4.7 Python</li>
<li>4.8 D</li>
<li>4.9 ColdFusion</li>
<li>4.10 Ruby</li>
<li>4.11 Forth</li>
<li>4.12 BASIC
<ul>
<li>4.12.1 REALbasic</li>
<li>4.12.2 VBScript</li>
<li>4.12.3 Visual Basic for Applications</li>
</ul>
</li>
<li>4.13 Smalltalk</li>
</ul>
</li>
<li>5 Command-line interpreters
<ul>
<li>5.1 Unix shells</li>
<li>5.2 Windows PowerShell</li>
</ul>
</li>
<li>6 Theory</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>4.1 ECMAScript
<ul>
<li>4.1.1 JavaScript</li>
<li>4.1.2 ActionScript</li>
</ul>
</li>
<li>4.2 Lisp</li>
<li>4.3 Perl</li>
<li>4.4 PHP</li>
<li>4.5 Lua</li>
<li>4.6 PostScript</li>
<li>4.7 Python</li>
<li>4.8 D</li>
<li>4.9 ColdFusion</li>
<li>4.10 Ruby</li>
<li>4.11 Forth</li>
<li>4.12 BASIC
<ul>
<li>4.12.1 REALbasic</li>
<li>4.12.2 VBScript</li>
<li>4.12.3 Visual Basic for Applications</li>
</ul>
</li>
<li>4.13 Smalltalk</li>
</ul>
<ul>
<li>4.1.1 JavaScript</li>
<li>4.1.2 ActionScript</li>
</ul>
<ul>
<li>4.12.1 REALbasic</li>
<li>4.12.2 VBScript</li>
<li>4.12.3 Visual Basic for Applications</li>
</ul>
<ul>
<li>5.1 Unix shells</li>
<li>5.2 Windows PowerShell</li>
</ul>
<p></p>
<h2>Security risks</h2>
<p>Special care <b>must</b> be taken when using <code>eval</code> with data from an untrusted source. For instance, assuming that the <code>get_data()</code> function gets data from the Internet, this Python code is insecure:</p>
<p>WHATSON? 427cba30-393b-4f49-b4ad-b8c79511eea8</p>
<pre>
session['authenticated'] = False
data = get_data()
foo = eval(data)
</pre>
<p>An attacker could supply the program with the string <code>"session.update(authenticated=True)"</code> as data, which would update the <code>session</code> dictionary to set an authenticated key to be True. To remedy this, all data which will be used with <code>eval</code> must be escaped, or it must be run without access to potentially harmful functions.</p>
<h2>Uses</h2>
<p>A call to <code>eval</code> is sometimes used by inexperienced programmers for all sorts of things. In most cases, there are alternatives which are more flexible and do not require the speed penalty of parsing code.</p>
<p>For instance, <code>eval</code> is sometimes used for a simple mail merge facility, as in this PHP example:</p>
<p>WHATSON? a47a64ba-1268-4861-8557-c3970499bbda</p>
<pre>
$name = 'John Doe';
$greeting = 'Hello';
$template = '"$greeting,  $name! How can I help you today?"';
print eval("return $template;");
</pre>
<p>Although this works, it can cause some security problems (see security risks), and will be much slower than other possible solutions. A faster and more secure solution would be changing the last line to <code>echo $template;</code> and removing the single quotes from the previous line, or using <code>printf</code>.</p>
<p><code>eval</code> is also sometimes used in applications needing to evaluate math expressions, such as spreadsheets. This is much easier than writing an expression parser, but finding or writing one would often be a wiser choice. Besides the fixable security risks, using the language's evaluation features would most likely be slower, and wouldn't be as customizable.</p>
<p>Perhaps the best use of <code>eval</code> is in bootstrapping a new language (as with Lisp), and in tutoring programs for languages which allow users to run their own programs in a controlled environment.</p>
<p>For the purpose of expression evaluation, the major advantage of eval over expression parsers is that, in most programming environments where <code>eval</code> is supported, the expression may be arbitrarily complex, and may include calls to functions written by the user that could not have possibly been known in advance by the parser's creator. This capability allows you to effectively augment the eval() engine with a library of functions that you can enhance as needed, without having to continually maintain an expression parser. If, however, you do not need this ultimate level of flexibility, expression parsers are far more efficient and lightweight.</p>
<h2>Implementation</h2>
<p>In interpreted languages, <code>eval</code> is almost always implemented with the same interpreter as normal code. In compiled languages, the same compiler used to compile programs may be embedded in programs using the <code>eval</code> function; separate interpreters are sometimes used, though this results in code duplication.</p>
<h2>Programming languages</h2>
<h3>ECMAScript</h3>
<h4>JavaScript</h4>
<p>In JavaScript, <code>eval</code> is something of a hybrid between an expression evaluator and a statement executor. It returns the result of the last expression evaluated.</p>
<p>Example as an expression evaluator:</p>
<p>WHATSON? 97f44d31-17dd-4ae8-9992-0221bf3b3e22</p>
<pre>
foo = 2;
alert(eval('foo + 2'));
</pre>
<p>Example as a statement executor:</p>
<p>WHATSON? d7f18a9e-4792-45e7-ad06-72c264ce5e89</p>
<pre>
foo = 2;
eval('foo = foo + 2;alert(foo);');
</pre>
<p>One use of JavaScript's <code>eval</code> is to parse JSON text, perhaps as part of an Ajax framework. However, modern browsers provide <code>JSON.parse</code> as a more secure alternative for this task.</p>
<h4>ActionScript</h4>
<p>In ActionScript (Flash's programming language), <code>eval</code> cannot be used to evaluate arbitrary expressions. According to the Flash 8 documentation, its usage is limited to expressions which represent "the name of a variable, property, object, or movie clip to retrieve. This parameter can be either a String or a direct reference to the object instance." [1]</p>
<p>ActionScript 3 does not support eval.</p>
<p>The ActionScript 3 Eval Library and the D.eval API are ongoing development projects to create equivalents to <code>eval</code> in ActionScript 3.</p>
<h3>Lisp</h3>
<p>Lisp was the original language to make use of an <code>eval</code> function. In fact, definition of the <code>eval</code> function led to the first implementation of the language interpreter. Before the <code>eval</code> function was defined, Lisp functions were manually compiled to assembly language statements. However, once the <code>eval</code> function had been manually compiled it was then used as part of a simple read-eval-print loop which formed the basis of the first Lisp interpreter.</p>
<p>Later versions of the Lisp <code>eval</code> function have also been implemented as compilers.</p>
<p>The <code>eval</code> function in Lisp expects a form to be evaluated and executed as argument. The return value of the given form will be the return value of the call to <code>eval</code>.</p>
<p>This is an example Lisp code:</p>
<p>WHATSON? 0b170650-fa30-4cd2-973a-504afdb09482</p>
<pre>
; A form which calls the + function with 1,2 and 3 as arguments.
; It returns 6.
(+ 1 2 3)
; In lisp any form is meant to be evaluated, therefore
; the call to + was performed.
; We can prevent Lisp from performing evaluation
; of a form by prefixing it with "'", for example:
(setq form1 '(+ 1 2 3))
; Now form1 contains a form that can be used by eval, for
; example:
(eval form1)
; eval evaluated (+ 1 2 3) and returned 6.
</pre>
<p>Lisp is well known to be very flexible and so is the <code>eval</code> function. For example, to evaluate the content of a string, the string would first have to be converted into a Lisp form using the <code>read-from-string</code> function and then the resulting form would have to be passed to <code>eval</code>:</p>
<p>WHATSON? e755613e-acbd-4664-9444-1fea0b4c2fbd</p>
<pre>
(eval (read-from-string "(format t \"Hello World!!!~%\")"))
</pre>
<p>One major point of confusion is the question, in which context the symbols in the form will be evaluated. In the above example, <code>form1</code> contains the symbol <code>+</code>. Evaluation of this symbol must yield the function for addition to make the example work as intended. Thus some dialects of lisp allow an additional parameter for <code>eval</code> to specify the context of evaluation (similar to the optional arguments to Python's <code>eval</code> function - see below). An example in the Scheme dialect of Lisp (RRS and later):</p>
<p>WHATSON? 77aa3a58-4de7-48c2-bd42-c99c29ed46d0</p>
<pre>
;; Define some simple form as in the above example.
(define form2 '(+ 5 2))
;Value: form2
 
;; Evaluate the form within the initial context.
;; A context for evaluation is called an "environment" in Scheme slang.
(eval form2 user-initial-environment)
;Value: 7
 
;; Confuse the initial environment, so that + will be
;; a name for the subtraction function.
(environment-define user-initial-environment '+ -)
;Value: +
 
;; Evaluate the form again.
;; Notice that the returned value has changed.
(eval form2 user-initial-environment)
;Value: 3
</pre>
<h3>Perl</h3>
<p>In Perl, the <code>eval</code> function is something of a hybrid between an expression evaluator and a statement executor. It returns the result of the last expression evaluated (all statements are expressions in Perl programming), and allows the final semicolon to be left off.</p>
<p>Example as an expression evaluator:</p>
<p>WHATSON? fd1b528d-7ea7-4914-9da7-fd1e64f2bbba</p>
<pre>
$foo = 2;
print eval('$foo + 2'), "\n";
</pre>
<p>Example as a statement executor:</p>
<p>WHATSON? 52baffbb-7234-471e-9c5a-3d5860e74ffe</p>
<pre>
$foo = 2;
eval('$foo += 2; print "$foo\n";');
</pre>
<p>(Beware about the quoting of strings. Note that single quotes were used above to quote the string. If double quotes were used, then it would interpolate the value of the variable into the string before passing it to "<code>eval</code>", defeating the purpose of the "<code>eval</code>", and possibly causing syntax errors, in the case of assignment.)</p>
<p>Perl also has <code>eval</code> <i>blocks</i>, which serves as its exception handling mechanism (see Exception handling syntax#Perl). This differs from the above use of <code>eval</code> with strings in that code inside <code>eval</code> blocks is interpreted at compile-time instead of run-time, so it is not the meaning of <code>eval</code> used in this article.</p>
<h3>PHP</h3>
<p>In PHP, <code>eval</code> executes code in a string almost exactly as if it had been put in the file instead of the call to <code>eval()</code>. The only exception is that errors are reported as coming from a call to <code>eval()</code>, and return statements become the result of the function.</p>
<p>Unlike some languages, the argument to <code>eval</code> must be a string of one or more complete statements, not just expressions; however, one can get the "expression" form of <code>eval</code> by putting the expression in a return statement, which causes <code>eval</code> to return the result of that expression.</p>
<p>Example using echo:</p>
<p>WHATSON? f0f4308f-b5d6-46a6-b912-c2759ef6f068</p>
<pre>
&lt;?php
$foo = "Hello, world!\n";
eval('echo "$foo";');
?&gt;
</pre>
<p>Example returning a value:</p>
<p>WHATSON? caf9201a-b9e1-4043-9795-ad7951ee9972</p>
<pre>
&lt;?php
$foo = "Goodbye, world!\n";  //does not work in PHP5
echo eval('return $foo;');
?&gt;
</pre>
<h3>Lua</h3>
<p>In Lua 5.1, <code>loadstring</code> compiles Lua code into an anonymous function.</p>
<p>Example as an expression evaluator:</p>
<p>WHATSON? 3449a6ec-4531-4847-99d9-ba920ef9fef6</p>
<pre>
loadstring("print('Hello World!')")()
</pre>
<p>Example to do the evaluation in two steps:</p>
<p>WHATSON? f58b398a-73ab-4468-9ada-bd0ec87f60db</p>
<pre>
a = 1
f = loadstring("return a + 1") -- compile the expression to an anonymous function
print(f()) -- execute (and print the result '2')
</pre>
<p>Lua 5.2 deprecates <code>loadstring</code> in favor of the existing <code>load</code> function, which has been augmented to accept strings. In addition, it allows providing the function's environment directly, as environments are now upvalues.</p>
<p>WHATSON? 2cfbd24a-b2cd-45fb-ba4e-fc22ba72371e</p>
<pre>
print(load("print('Hello ' .. a)", "", "t", { a = "World!", print = print })())
</pre>
<h3>PostScript</h3>
<p>PostScript's <code>exec</code> operator takes an operand — if it is a simple literal it pushes it back on the stack. If one takes a string containing a PostScript expression however, one can convert the string to an executable which then can be executed by the interpreter, for example:</p>
<p>WHATSON? bacb8f3e-90a2-4fd4-968f-f2eea414da56</p>
<pre>
((Hello World) =) cvx exec
</pre>
<p>converts the PostScript expression</p>
<p>WHATSON? 43e00102-4f91-43ef-91ac-b6b2efc230a3</p>
<pre>
(Hello World) =
</pre>
<p>which pops the string "Hello World" off the stack and displays it on the screen, to have an executable type, then is executed.</p>
<p>PostScript's <code>run</code> operator is similar in functionality but instead the interpreter interprets PostScript expressions in a file, itself.</p>
<h3>Python</h3>
<p>In Python, the <code>eval</code> function in its simplest form evaluates a single expression.</p>
<p><code>eval</code> example (interactive shell):</p>
<p>WHATSON? 8cf8a6df-1d10-4d29-a680-4e15324ebaee</p>
<pre>
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; eval('x + 1')
2
&gt;&gt;&gt; eval('x')
1
</pre>
<p>The <code>eval</code> function takes two optional arguments, <code>global</code> and <code>locals</code>, which allow the programmer to set up a restricted environment for the evaluation of the expression.</p>
<p>The <code>exec</code> statement (or the <code>exec</code> function in Python 3.x) executes statements:</p>
<p><code>exec</code> example (interactive shell):</p>
<p>WHATSON? 84ac5127-3d1f-48f7-9361-e37987665f8c</p>
<pre>
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 1
&gt;&gt;&gt; exec "x += 1; y -= 1"
&gt;&gt;&gt; x
2
&gt;&gt;&gt; y
0
</pre>
<p>The most general form for evaluating statements/expressions is using code objects. Those can be created by invoking the <code>compile()</code> function and by telling it what kind of input it has to compile: an "<code>exec</code>" statement, an "<code>eval</code>" statement or a "<code>single</code>" statement:</p>
<p><code>compile</code> example (interactive shell):</p>
<p>WHATSON? defd5956-6545-4a75-bd85-384ae55c4f37</p>
<pre>
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 2
&gt;&gt;&gt; eval (compile ("print 'x + y = ', x + y", "compile-sample.py", "single"))
x + y =  3
</pre>
<h3>D</h3>
<p>D is a statically compiled language and therefore does not include an "<code>eval</code>" statement in the traditional sense, but does include the related "<code>mixin</code>" statement. The difference is that, where "<code>eval</code>" interprets a string as code at runtime, with a "<code>mixin</code>" the string is statically compiled like ordinary code and must be known at compile time. For example:</p>
<p>WHATSON? 20624fb5-67fb-42fe-9011-5a0cab8dc228</p>
<pre>
import std.stdio;
 
void main() {
    int num = 0;
    mixin("num++;");
    writeln(num);  // Prints 1.
}
</pre>
<p>The above example will compile to exactly the same assembly language instructions as if "<code>num++;</code>" had been written directly instead of mixed in.</p>
<h3>ColdFusion</h3>
<p>ColdFusion's <code>evaluate</code> function lets you evaluate a string expression at runtime.</p>
<p>WHATSON? 259e9adf-77f3-4f7a-9b58-cfb2d17725c0</p>
<pre>
&lt;cfset x = "int(1+1)"&gt;
&lt;cfset y = Evaluate(x)&gt;
</pre>
<p>It is particularly useful when you need to programatically choose the variable you want to read from.</p>
<p>WHATSON? 57c42fb5-ee07-4c07-8c7b-a7e0460cb20f</p>
<pre>
&lt;cfset x = Evaluate("queryname.#columnname#[rownumber]")&gt;
</pre>
<h3>Ruby</h3>
<p>The Ruby programming language interpreter offers an <code>eval</code> function similar to Python or Perl, and also allows a scope, or binding, to be specified.</p>
<p>Aside from specifying a function's binding, <code>eval</code> may also be used to evaluate an expression within a specific class definition binding or object instance binding, allowing classes to be extended with new methods specified in strings.</p>
<p>WHATSON? 57379bf8-6f54-4cf1-8cfe-735d8bfc23ec</p>
<pre>
a = 1
eval('a + 1') #  (evaluates to 2)
 
# evaluating within a context
def get_binding(a)
  binding
end
eval('a+1',get_binding(3)) # (evaluates to 4, because 'a' in the context of get_binding is 3)
</pre>
<p>WHATSON? 6256fecb-0821-40e3-b255-5daf22a0d47d</p>
<pre>
class Test; end
Test.class_eval("def hello; return 'hello';end") # add a method 'hello' to this class
Test.new.hello                    # evaluates to "hello"
</pre>
<h3>Forth</h3>
<p>Most standard implementations of Forth have two variants of <code>eval</code>: <code>EVALUATE</code> and <code>INTERPRET</code>.</p>
<p>Win32FORTH code example:</p>
<p>WHATSON? f4ac9be4-fba4-4bf1-bab2-b713bf018022</p>
<pre>
 S" 2 2 + ." EVALUATE \ Outputs "4"
</pre>
<h3>BASIC</h3>
<h4>REALbasic</h4>
<p>In REALbasic, there is a class called RBScript which can execute REALbasic code at runtime. RBScript is very sandboxed—only the most core language features are there, you have to allow it access to things you want it to have. You can optionally assign an object to the context property. This allows for the code in RBScript to call functions and use properties of the context object. However, it is still limited to only understanding the most basic types, so if you have a function that returns a Dictionary or MySpiffyObject, RBScript will be unable to use it. You can also communicate with your RBScript through the Print and Input events.</p>
<h4>VBScript</h4>
<p>Microsoft's VBScript, which is an interpreted language, has two constructs. <code>Eval</code> is a function evaluator that can include calls to user-defined functions. (These functions may have side-effects such as changing the values of global variables.) <code>Execute</code> executes one or more colon-separated statements, which can change global state.</p>
<p>Both VBScript and JavaScript <code>eval</code> are available to developers of compiled Windows applications (written in languages which do not support Eval) through an ActiveX control called the Microsoft Script Control, whose Eval method can be called by application code. To support calling of user-defined functions, one must first initialize the control with the AddCode method, which loads a string (or a string resource) containing a library of user-defined functions defined in the language of one's choice, prior to calling Eval.</p>
<h4>Visual Basic for Applications</h4>
<p>Visual Basic for Applications (VBA), the programming language of Microsoft Office, is a virtual machine language where the runtime environment compiles and runs p-code. Its flavor of Eval supports only expression evaluation, where the expression may include user-defined functions and objects (but not user-defined variable names). Of note, the evaluator is different from VBS, and invocation of certain user-defined functions may work differently in VBA than the identical code in VBScript.</p>
<h3>Smalltalk</h3>
<p>As Smalltalk's compiler classes are part of the standard class library and usually present at run time, these can be used to evaluate a code string.</p>
<p>WHATSON? aed915a8-8576-4e3e-a02d-271d46ec1a78</p>
<pre>
Compiler evaluate:'1 + 2'
</pre>
<p>Because class and method definitions are also implemented by message-sends (to class objects), even code changes are possible:</p>
<p>WHATSON? fc2a1667-b8be-40c3-b99d-d2451f49332a</p>
<pre>
Compiler evaluate:'Object subclass:#Foo'
</pre>
<h2>Command-line interpreters</h2>
<h3>Unix shells</h3>
<p>The <i>eval</i> command is present in all Unix shells, including the original "sh" (Bourne shell). It concatenates all the arguments with spaces, then re-parses and executes the result as a command. <code>sh(1)</code> – FreeBSD General Commands Manual</p>
<h3>Windows PowerShell</h3>
<p>In Windows PowerShell, the <code>Invoke-Expression</code> Cmdlet serves the same purpose as the eval function in programming languages like JavaScript, PHP and Python. The Cmdlet runs any Windows PowerShell expression that is provided as a command parameter in the form of a string and outputs the result of the specified expression. Usually, the output of the Cmdlet is of the same type as the result of executing the expression. However, if the result is an empty array, it outputs <code>$null</code>. In case the result is a single-element array, it outputs that single element. Similar to JavaScript, Windows PowerShell allows the final semicolon to be left off.</p>
<p>Example as an expression evaluator:</p>
<p>WHATSON? 8dfdb695-5e39-44f0-b8e5-c6ed5f76ca1a</p>
<pre>
 PS&gt; $foo = 2
 PS&gt; invoke-expression '$foo + 2'
</pre>
<p>Example as a statement executor:</p>
<p>WHATSON? 065ddafd-e53d-4ee1-814b-5d66d694ec30</p>
<pre>
 PS&gt; $foo = 2
 PS&gt; invoke-expression '$foo += 2; $foo'
</pre>
<h2>Theory</h2>
<p>In theoretical computer science, a careful distinction is commonly made between eval and apply. <i>Eval</i> is understood to be the step of converting a quoted string into a callable function and its arguments, whereas <i>apply</i> is the actual call of the function with a given set of arguments. The distinction is particularly noticeable in functional languages, and languages based on lambda calculus, such as LISP and Scheme. Thus, for example, in Scheme, the distinction is between</p>
<p>WHATSON? 64b182d3-1a38-4b3d-8d9b-126834f5f9ce</p>
<pre>
(eval '(f x) )
</pre>
<p>where the form (f x) is to be evaluated, and</p>
<p>WHATSON? 0790cb1d-2473-4565-b057-29c5caf3fd26</p>
<pre>
(apply f (list x))
</pre>
<p>where the function <i>f</i> is to be called with argument <i>x</i>.</p>
<p><i>Eval</i> and <i>apply</i> are the two interdependent components of the <i>eval-apply cycle</i>, which is the essence of evaluating Lisp, described in SICP.</p>
<p>In category theory, the <i>eval</i> morphism is used to define the closed monoidal category. Thus, for example, the category of sets, with functions taken as morphisms, and the cartesian product taken as the product, forms a Cartesian closed category. Here, <i>eval</i> (or, properly speaking, <i>apply</i>) together with its right adjoint, currying, form the simply typed lambda calculus, which can be interpreted to be the morphisms of Cartesian closed categories.</p>
</body>
</html>