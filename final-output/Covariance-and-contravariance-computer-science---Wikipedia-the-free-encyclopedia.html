<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Covariance-and-contravariance-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Covariance and contravariance (computer science)</h1>
<p>Many programming language type systems support subtyping. For instance, if Cat is subtype of Animal, then an expression of type Cat can be used whenever an expression of type Animal could. <b>Variance</b> refers to how subtyping between more complex types (list of Cats versus list of Animals, function returning Cat versus function returning Animal, ...) relates to subtyping between their components. Depending on the variance of the type constructor, the subtyping relation may be either preserved, reversed, or ignored. For example, in C#:</p>
<ul>
<li>IEnumerable&lt;Cat&gt; is a subtype of IEnumerable&lt;Animal&gt;. The subtyping is preserved because IEnumerable is <b>covariant</b>.</li>
<li>Action&lt;Animal&gt; is a subtype of Action&lt;Cat&gt;. The subtyping is reversed because Action is <b>contravariant</b>.</li>
<li>Neither IList&lt;Cat&gt; nor IList&lt;Animal&gt; is a subtype of the other, because IList is <b>invariant</b>.</li>
</ul>
<p>The variance of a C# interface is determined by in/out annotations on its type parameters; the above interfaces are declared as IEnumerable&lt;out T&gt;, Action&lt;in T&gt;, and IList&lt;T&gt;. The typing rules for interface variance ensure type safety. For example, an Action&lt;T&gt; represents a first-class function expecting an argument of type T, and a function which can handle any type of animal can always be used instead of one which can only handle cats.</p>
<p>A programming language designer will consider variance when devising typing rules for e.g. arrays, inheritance, and generic datatypes. By making type constructors covariant or contravariant instead of invariant, more programs will be accepted as well-typed. On the other hand, programmers often find contravariance unintuitive, and accurately tracking variance to avoid runtime type errors can lead to complex typing rules. In order to keep the type system simple and allow useful programs, a language may treat a type constructor as invariant even if it would be safe to consider it variant, or treat it as covariant even when that can violate type safety.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Formal definition</li>
<li>2 Arrays
<ul>
<li>2.1 Covariant arrays in Java and C#</li>
</ul>
</li>
<li>3 Function types</li>
<li>4 Inheritance in object oriented languages
<ul>
<li>4.1 Covariant method return type</li>
<li>4.2 Contravariant method argument type</li>
<li>4.3 Covariant method argument type</li>
<li>4.4 Avoiding the need for covariant argument types</li>
<li>4.5 Summary of variance and inheritance</li>
</ul>
</li>
<li>5 Generic types
<ul>
<li>5.1 Declaration-site variance annotations
<ul>
<li>5.1.1 Interfaces</li>
<li>5.1.2 Data</li>
<li>5.1.3 Inferring Variance</li>
</ul>
</li>
<li>5.2 Use-site variance annotations (Wildcards)</li>
<li>5.3 Comparing Declaration-site and Use-site annotations</li>
<li>5.4 Covariant generics in Dart</li>
</ul>
</li>
<li>6 Origin of the term "covariance"</li>
<li>7 See also</li>
<li>8 References</li>
<li>9 External links</li>
</ul>
<ul>
<li>2.1 Covariant arrays in Java and C#</li>
</ul>
<ul>
<li>4.1 Covariant method return type</li>
<li>4.2 Contravariant method argument type</li>
<li>4.3 Covariant method argument type</li>
<li>4.4 Avoiding the need for covariant argument types</li>
<li>4.5 Summary of variance and inheritance</li>
</ul>
<ul>
<li>5.1 Declaration-site variance annotations
<ul>
<li>5.1.1 Interfaces</li>
<li>5.1.2 Data</li>
<li>5.1.3 Inferring Variance</li>
</ul>
</li>
<li>5.2 Use-site variance annotations (Wildcards)</li>
<li>5.3 Comparing Declaration-site and Use-site annotations</li>
<li>5.4 Covariant generics in Dart</li>
</ul>
<ul>
<li>5.1.1 Interfaces</li>
<li>5.1.2 Data</li>
<li>5.1.3 Inferring Variance</li>
</ul>
<p></p>
<h2>Formal definition</h2>
<p>Within the type system of a programming language, a typing rule or a type constructor is:</p>
<ul>
<li><b>covariant</b> if it preserves the ordering of types (≤), which orders types from more specific to more generic;</li>
<li><b>contravariant</b> if it reverses this ordering;</li>
<li><b>bivariant</b> if both of these apply;</li>
<li><b>invariant</b> or <b>nonvariant</b> if neither of these applies.</li>
</ul>
<p>In the rest of the article, we will consider how this applies to some common type constructors.</p>
<h2>Arrays</h2>
<p>First consider the array type constructor: from the type Animal we can make the type Animal[] ("array of animals"). Should we treat this as</p>
<ul>
<li>Covariant: a Cat[] is an Animal[]</li>
<li>Contravariant: an Animal[] is a Cat[]</li>
<li>or neither (invariant)?</li>
</ul>
<p>If we wish to avoid type errors, and the array supports both reading and writing elements, then only the third choice is safe. Clearly, not every Animal[] can be treated as if it were a Cat[], since a client reading from the array will expect a Cat, but an Animal[] may contain e.g. a Dog. So the contravariant rule is not safe.</p>
<p>Conversely, a Cat[] can not be treated as an Animal[]. It should always be possible to put a Dog into an Animal[]. With covariant arrays this can not be guaranteed to be safe, since the backing store might actually be an array of cats. So the covariant rule is also not safe—the array constructor should be <b>invariant</b>. Note that this is only an issue for mutable arrays; the covariant rule is safe for immutable (read-only) arrays.</p>
<p>This illustrates a general phenomenon. Read-only data types (sources) can be covariant; write-only data types (sinks) can be contravariant. Mutable data types which act as both sources and sinks should be invariant.</p>
<h3>Covariant arrays in Java and C#</h3>
<p>Early versions of Java and C# did not include generics (a.k.a. parametric polymorphism). In such a setting, making arrays invariant rules out useful polymorphic programs.</p>
<p>For example, consider writing a function to shuffle an array, or a function that tests two arrays for equality using the <code>Object</code>.equals method on the elements. The implementation does not depend on the exact type of element stored in the array, so it should be possible to write a single function that works on all types of arrays. It is easy to implement functions of type</p>
<p>WHATSON? 1e99f286-9d06-47fb-8506-1ccd25fdb283</p>
<pre>
    boolean equalArrays (Object[] a1, Object[] a2);
    void shuffleArray(Object[] a);
</pre>
<p>However, if array types were treated as invariant, it would only be possible to call these functions on an array of exactly the type Object[]. One could not, for example, shuffle an array of strings.</p>
<p>Therefore, both Java and C# treat array types covariantly. For instance, in C# string[] is a subtype of <code>object[]</code>, and in Java String[] is a subtype of Object[].</p>
<p>As discussed above, covariant arrays leads to problem with writes into the array. Java and C# deals with this by marking each array object with a type when it is created. Each time a value is stored into an array, the compiler inserts a check that the run-time type of the value is equal to the run-time type of the array. If there is a mismatch, an ArrayStoreException (or ArrayTypeMismatchException in C#) is thrown:</p>
<p>WHATSON? d1cbb5be-4957-4d14-81c7-da20cba811cd</p>
<pre>
    // a is a single-element array of String
    String[] a = new String[1];
 
    // b is an array of Object
    Object[] b = a;
 
    // Assign an Integer to b. This would be possible if b really were
    // an array of Object, but since it really is an array of String,
    // we will get a java.lang.ArrayStoreException.
    b[0] = 1;
</pre>
<p>In the above example you can <b>read</b> from b safely. It is only trying to <b>write</b> to the array that can lead to trouble.</p>
<p>One drawback of this approach is that it leaves the possibility of a run-time error which a stricter type system could have caught at compile-time. Also, it hurts performance because each write into an array requires an additional runtime check.</p>
<p>With the addition of generics, Java and C# now offer ways to write this kind of polymorphic functions without relying on covariance. The array comparison and shuffling functions can be given the parameterized types</p>
<p>WHATSON? bd03fcb0-4929-4619-be67-dc481f821ede</p>
<pre>
    &lt;T&gt; boolean equalArrays (T[] a1, T[] a2);
    &lt;T&gt; void shuffleArray(T[] a);
</pre>
<p>Alternatively, to enforce that a C# method accesses a collection in a read-only way, one can use the interface IEnumerable&lt;object&gt; instead of passing it an array object[].</p>
<h2>Function types</h2>
<p>Languages with first-class functions have function types like "a function expecting a Cat and returning an Animal" (written Cat -&gt; Animal in OCaml syntax or Func&lt;Cat,Animal&gt; in C# syntax).</p>
<p>Those languages also need to specify when one function type is a subtype of another—that is, when it is safe to use a function of one type in a context that expects a function of a different type. It is safe to substitute a function <i>f</i> instead of a function <i>g</i> if <i>f</i> accepts a more general type of arguments and returns a more specific type than <i>g</i>. For example, a function of type Cat-&gt;Cat can safely be used wherever a Cat-&gt;Animal was expected, and likewise a function of type Animal-&gt;Animal can be used wherever a Cat-&gt;Animal was expected. (One can compare this to the robustness principle of communication: "be liberal in what you accept and conservative in what you produce"). The general rule is</p>
<p>S<sub>1</sub> → S<sub>2</sub> ≤ T<sub>1</sub> → T<sub>2</sub> if T<sub>1</sub> ≤ S<sub>1</sub> and S<sub>2</sub> ≤ T<sub>2</sub>.</p>
<p>In other words, the → type constructor is <b>contravariant in the input type</b> and <b>covariant in the output type</b>. This rule was first stated formally by John Reynolds, and further popularized in a paper by Luca Cardelli.</p>
<p>When dealing with functions that take functions as arguments, this rule can be applied several times. For example, by applying the rule twice, we see that (A'→B)→B ≤ (A→B)→B if A'≤A. In other words, the type (A→B)→B is <i>covariant</i> in the A position. For complicated types it can be confusing to mentally trace why a given type specialization is or isn't type-safe, but it is easy to calculate which positions are co- and contravariant: a position is covariant if it is on the left side of an even number of arrows.</p>
<h2>Inheritance in object oriented languages</h2>
<p>When a subclass overrides a method in a superclass, the compiler must check that the overriding method has the right type. While some languages require that the type exactly matches the type in the superclass (invariance), it is also type safe to allow the overriding method to have a "better" type. By the usual subtyping rule for function types, this means that the overriding method should return a more specific type (return type covariance), and accept a more general argument (argument type contravariance). In UML notation, the possibilities are as follows:</p>
<ul>
<li>Variance and method overriding: overview</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:28.5px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Vererbung_T.svg/120px-Vererbung_T.svg.png" width="120" height="163" data-file-width="125" data-file-height="170"></div>
</div>
<div class="gallerytext">
<p>Subtyping of the argument/return type of the method.</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/00/Inheritance_invariant.svg/120px-Inheritance_invariant.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></div>
</div>
<div class="gallerytext">
<p><b>Invariance</b>. The signature of the overrriding method is unchanged.</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/27/Inheritance_covariant_return.svg/120px-Inheritance_covariant_return.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></div>
</div>
<div class="gallerytext">
<p><b>Covariant return type</b>. The subtyping relation is in the same direction as the relation between ClassA and ClassB.</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Inheritance_contravariant_argument.svg/120px-Inheritance_contravariant_argument.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></div>
</div>
<div class="gallerytext">
<p><b>Contravariant argument type</b>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB.</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29.5px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Inheritance_covariant_argument.svg/120px-Inheritance_covariant_argument.svg.png" width="120" height="161" data-file-width="127" data-file-height="170"></div>
</div>
<div class="gallerytext">
<p><b>Covariant argument type</b>. Not type safe.</p>
</div>
</div>
</li>
</ul>
<p>Subtyping of the argument/return type of the method.</p>
<p><b>Invariance</b>. The signature of the overrriding method is unchanged.</p>
<p><b>Covariant return type</b>. The subtyping relation is in the same direction as the relation between ClassA and ClassB.</p>
<p><b>Contravariant argument type</b>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB.</p>
<p><b>Covariant argument type</b>. Not type safe.</p>
<p>For a concrete example, suppose we are writing a class to model an animal shelter. We assume that Cat is a subclass of Animal, and that we have a base class (using Java syntax)</p>
<p>WHATSON? 7f538699-423e-4fe8-b746-fce45dc27f5b</p>
<pre>
    class AnimalShelter {
        Animal getAnimalForAdoption() {
          ...
        }
 
        void putAnimal(Animal animal) {
          ...
        }
    }
</pre>
<p>Now the question is: if we subclass AnimalShelter, what types are we allowed to give to getAnimalForAdoption and putAnimal?</p>
<h3>Covariant method return type</h3>
<p>In a language which allows covariant return types, a derived class can override the getAnimalForAdoption method to return a more specific type:</p>
<p>WHATSON? b0512b2e-e9a7-48a0-ba04-ad36cb324fba</p>
<pre>
    class CatShelter extends AnimalShelter {
        Cat getAnimalForAdoption() {
    	    return new Cat();
        }
    }
</pre>
<p>Among mainstream OO languages, Java and C++ support covariant return types, while C# does not. Adding the covariant return type was one of the first modifications of the C++ language approved by the standards committee in 1998. Scala and D also support covariant return types.</p>
<h3>Contravariant method argument type</h3>
<p>Similarly, it is type safe to allow an overriding method to accept a more general argument than the method in the base class:</p>
<p>WHATSON? db3ca7b6-c869-45a8-a316-3740f7231dbb</p>
<pre>
    class CatShelter extends AnimalShelter {
        void putAnimal(Object animal) {
           ...
        }
    }
</pre>
<p>Not many object oriented languages actually allow this—C++ and Java would interpret this as an unrelated method with an overloaded name.</p>
<p>However, Sather supports both covariance and contravariance. Calling convention for overridden methods are covariant with <i>out</i> arguments and return values, and contravariant with normal arguments (with the mode <i>in</i>).</p>
<h3>Covariant method argument type</h3>
<p>Uniquely among mainstream languages, Eiffel allows the arguments of an overriding method to have a <i>more</i> specific type than the method in the superclass (argument type covariance). Thus, the Eiffel version of the following code would type check, with putAnimal overriding the method in the base class:</p>
<p>WHATSON? 353190e5-0052-400f-b598-746ac50382ad</p>
<pre>
    class CatShelter extends AnimalShelter {
        void putAnimal(Cat animal) {
           ...
        }
    }
</pre>
<p>This is not type safe. By up-casting a CatShelter to an AnimalShelter, one can place a dog in a cat shelter. The lack of type safety (known as the "catcall problem" in the Eiffel community) has been a long-standing issue. Over the years, various combinations of global static analysis, local static analysis, and new language features have been proposed to remedy it,  and these have been implemented in some Eiffel compilers.</p>
<p>Despite the type safety problem, the Eiffel designers consider covariant argument types crucial for modeling real world requirements. The cat shelter illustrates a common phenomenon: it is <i>a kind of</i> animal shelter but has <i>additional restrictions</i>, and it seems reasonable to use inheritance and restricted argument types to model this. In proposing this use of inheritance, the Eiffel designers reject the Liskov substitution principle, which states that objects of subclasses should always be less restricted than objects of their superclass.</p>
<p>Another example where covariant arguments seem helpful is so-called binary methods, i.e. methods where the argument is expected to be of the same type as the object the method is called on. An example is the compareTo method: a.compareTo(b) checks whether a comes before or after b in some ordering, but the way to compare, say, two rational numbers will be different from the way to compare two strings. Other common examples of binary methods include equality tests, arithmetic operations, and set operations like subset and union.</p>
<p>In older versions of Java, the comparison method was specified as an interface Comparable:</p>
<p>WHATSON? 527ae6a7-1013-4839-ad99-1251c93a7aac</p>
<pre>
    interface Comparable {
        int compareTo(Object o);
    }
</pre>
<p>The drawback of this is that the method is specified to take an argument of type Object. A typical implementation would first down-cast this argument (throwing an error if it is not of the expected type):</p>
<p>WHATSON? 7e829421-e683-41b5-9b1b-f40428180e82</p>
<pre>
    class RationalNumber implements Comparable {
        int numerator;
        int denominator;
 
        ...
 
        public int compareTo(Object other) {
            RationalNumber otherNum = (RationalNumber)other;
            return Integer.compare(numerator*otherNum.denominator,
                                   otherNum.numerator*denominator);
        }
    }
</pre>
<p>In a language with covariant arguments, the argument to compareTo could be directly given the desired type RationalNumber, hiding the typecast. (Of course, this would still give a runtime error if compareTo was then called on e.g. a String).</p>
<h3>Avoiding the need for covariant argument types</h3>
<p>Other language features can provide the apparent benefits of covariant arguments while preserving Liskov substitutability.</p>
<p>In a language with <b>generics</b> (a.k.a. parametric polymorphism) and bounded quantification, the previous examples can be written in a type-safe way  . Instead of defining AnimalShelter, we define a parameterized class Shelter&lt;T&gt;. (One drawback of this is that the implementer of the base class needs to foresee which types will need to be specialized in the subclasses).</p>
<p>WHATSON? d9a2db8d-cd99-4611-bee6-f6437a2338be</p>
<pre>
    class Shelter&lt;T extends Animal&gt; {
        T getAnimalForAdoption() {
          ...
        }
 
        void putAnimal(T animal) {
          ...
        }
    }
 
 
    class CatShelter extends Shelter&lt;Cat&gt; {
        Cat getAnimalForAdoption() {
          ...
        }
 
        void putAnimal(Cat animal) {
          ...
        }
    }
</pre>
<p>Similarly, in recent versions of Java the Comparable interface has been parameterized, which allows the downcast to be omitted in a type-safe way:</p>
<p>WHATSON? af3feb89-abf5-4861-a9af-8aa4da67f013</p>
<pre>
    class RationalNumber implements Comparable&lt;RationalNumber&gt; {
        int numerator;
        int denominator;
 
        ...
 
        public int compareTo(RationalNumber otherNum) {
            return Integer.compare(numerator*otherNum.denominator, 
                                   otherNum.numerator*denominator);
        }
    }
</pre>
<p>Another language feature that can help is <b>multiple dispatch</b>. One reason that binary methods are awkward to write is that in a call like a.compareTo(b), selecting the correct implementation of compareTo really depends on the type of both a and b, but in a conventional OO language only the type of a is taken into account. In a language with CLOS-style multiple dispatch, the comparison method could be written as a generic function where both arguments are used for method selection.</p>
<p>Giuseppe Castagna observed that in a typed language with multiple dispatch, a generic function can have some arguments which control dispatch and some "left-over" arguments which do not. Because the method selection rule chooses the most specific applicable method, if a method overrides another method, then the overriding method will have more specific types for the controlling arguments. On the other hand, to ensure type safety the language still must require the left-over arguments to be at least as general. Using the previous terminology, types used for runtime method selection are covariant while types not used for runtime method selection of the method are contravariant. Conventional single-dispatch languages like Java also obey this rule: there only one argument is used for method selection (the receiver object, passed along to a method as the hidden argument this), and indeed the type of this is more specialized inside overriding methods than in the superclass.</p>
<p>Castagna suggests that examples where you want covariant argument types, in particular binary methods, should be handled using multiple dispatch which is naturally covariant. Unfortunately, most programming languages do not support multiple dispatch.</p>
<h3>Summary of variance and inheritance</h3>
<p>The following table summarizes the rules for overriding methods in the languages discussed above.</p>
<h2>Generic types</h2>
<p>In programming languages that support generics (a.k.a. parametric polymorphism), the programmer can extend the type system with new constructors. For example, a C# interface like IList&lt;T&gt; makes it possible to construct new types like IList&lt;Animal&gt; or IList&lt;Cat&gt;. The question then arises what the variance of these type constructors should be.</p>
<p>There are two main approaches. In languages with <b>declaration-site variance annotations</b> (e.g. C#), the programmer annotates the definition of a generic type with the intended variance of its type parameters. With <b>use-site variance annotations</b> (e.g. Java), the programmer instead annotates the places where a generic type is instantiated.</p>
<h3>Declaration-site variance annotations</h3>
<p>The most popular languages with declaration-site variance annotations are C# (using the keywords out and in), and Scala and OCaml (using the keywords + and -). C# only allows variance annotations for interface types, while Scala and OCaml allows them for both interface types and concrete data types.</p>
<h4>Interfaces</h4>
<p>In C#, each type parameter of a generic interface can be marked covariant (out), contravariant (in), or invariant (no annotation). For example, we can define an interface IEnumerator&lt;T&gt; of read-only iterators, and declare it to be covariant (out) in its type parameter.</p>
<p>WHATSON? 509cc490-cdba-4b47-a0b7-2659f4011582</p>
<pre>
    interface IEnumerator&lt;out T&gt;
    {
        T Current { get; }
        bool MoveNext();
    }
</pre>
<p>With this declaration, IEnumerator will be treated as covariant in its type argument, e.g. IEnumerator&lt;Cat&gt; is a subtype of IEnumerator&lt;Animal&gt;.</p>
<p>The typechecker enforces that each method declaration in an interface only mentions the type parameters in a way consistent with the in/out annotations. That is, a parameter that was declared covariant must not occur in any contravariant positions (where a position is contravariant if it occurs under an odd number of contravariant type constructors). The precise rule is that the return types of all methods in the interface must be <i>valid covariantly</i> and all the method argument types must be <i>valid contravariantly</i>, where <i>valid S-ly</i> is defined as follows:</p>
<ul>
<li>Non-generic types (classes, structs, enums, etc.) are valid both co- and contravariantly.</li>
<li>A type argument T is valid covariantly if it was not marked in, and valid contravariantly if it was not marked out</li>
<li>An array type A[] is valid S-ly if A is. (This is because C# has covariant arrays).</li>
<li>A generic type G&lt;A1,A2,...,An&gt; is valid S-ly if for each argument Ai,
<ul>
<li>Ai is valid S-ly, and the <i>i</i>th parameter to G is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <i>i</i>th parameter to G is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <i>i</i>th parameter to G is declared invariant.</li>
</ul>
</li>
</ul>
<ul>
<li>Ai is valid S-ly, and the <i>i</i>th parameter to G is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <i>i</i>th parameter to G is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <i>i</i>th parameter to G is declared invariant.</li>
</ul>
<p>As an example of how these rules apply, consider the IList&lt;T&gt; interface.</p>
<p>WHATSON? 5853dd2b-9ce8-4c54-a49a-dbd2ffc4afff</p>
<pre>
    interface IList&lt;T&gt;
    {
	void Insert(int index, T item);
	IEnumerator&lt;T&gt; GetEnumerator();
    }
</pre>
<p>The argument type T of Insert must be valid contravariantly, i.e. the type parameter T must not be tagged out. Similarly, the result type IEnumerator&lt;T&gt; of GetEnumerator must be valid covariantly, i.e. (since IEnumerator is a covariant interface) the type T must be valid covariantly, i.e. the type parameter T must not be tagged in. This shows that the interface IList is not allowed to be marked either co- or contravariant.</p>
<p>In the common case of a generic data structure such as IList, these restrictions mean that an out parameter can only be used for methods getting data out of the structure, and an in parameter can only be used for methods putting data into the structure, hence the choice of keywords.</p>
<h4>Data</h4>
<p>C# allows variance annotations on the parameters of interfaces, but not the parameters of classes. Because fields in C# classes are always mutable, variantly parameterized classes in C# would not be very useful. But languages which emphasize immutable data can make good use of covariant data types. For example, both in Scala and OCaml the immutable list type is covariant: List[Cat] is a subtype of List[Animal].</p>
<p>Scala's rules for checking variance annotations are essentially the same as C#'s. However, there are some idioms that apply to immutable datastructures in particular. They are illustrated by the following (excerpt from the) definition of the List[A] class.</p>
<p>WHATSON? 4bb857a7-36fd-43f6-965b-ed151478aa83</p>
<pre>
sealed abstract class List[+A] extends AbstractSeq[A] {
  def head: A
  def tail: List[A]
 
  /** Adds an element at the beginning of this list. */
  def ::[B &gt;: A] (x: B): List[B] =
    new scala.collection.immutable.::(x, this)
 
  ...
}
</pre>
<p>First, class members that have a variant type must be immutable. Here, head has the type A, which was declared covariant (+), and indeed head was declared as a method (def). Trying to declare it as a mutable field (var) would be rejected as type error.</p>
<p>Second, even if a data structure is immutable, it will often have methods where the parameter type occurs contravariantly. For example, consider the method :: which adds an element to the front of a list. (The implementation works by creating a new object of the similarly-named <i>class</i> ::, the class of nonempty lists). The most obvious type to give it would be</p>
<p>WHATSON? 38ab7caa-8bef-4e7f-9cbd-cd7a2a9d8f45</p>
<pre>
  def :: (x: A): List[A]
</pre>
<p>However, this would be a type error, because the covariant parameter A appears in a contravariant position (as a function argument). But there is a trick to get around this problem. We give :: a more general type, which allows adding an element of any type B as long as B is a supertype of A. Note that this relies on List being covariant, since this has type List[A] and we treat it as having type List[B]. At first glance it may not be obvious that the generalized type is sound, but if the programmer starts out with the simpler type declaration, the type errors will point out the place that needs to be generalized.</p>
<h4>Inferring Variance</h4>
<p>It is possible to design a type system where the compiler automatically infers the best possible variance annotations for all datatype parameters. However, the analysis can get complex for several reasons. First, the analysis is nonlocal since the variance of an interface I depends the variance of all interfaces that I mentions. Second, in order to get unique best solutions the type system must allow <i>bivariant</i> parameters (which are simultaneously co- and contravariant). And finally, the variance of type parameters should arguably be a deliberate choice by the designer of an interface, not something that just happens.</p>
<p>For these reasons most languages do very little variance inference. C# and Scala do not infer any variance annotations at all. OCaml can infer the variance of parameterized concrete datatypes, but the programmer must explicitly specify the variance of abstract types (interfaces).</p>
<p>For example, consider an OCaml datatype T which wraps a function</p>
<p>WHATSON? 0f664c0b-3788-4577-9d7e-093e68c6fc07</p>
<pre>
type ('a, 'b) t = T of ('a -&gt; 'b)
</pre>
<p>The compiler will automatically infer that T is contravariant in the first parameter, and covariant in the second. The programmer can also provide explicit annotations, which the compiler will check are satisfied. Thus the following declaration is equivalent to the previous one:</p>
<p>WHATSON? 4e7bb6f2-e128-4d93-be49-fb66e00b9e5a</p>
<pre>
type (-'a, +'b) t = T of ('a -&gt; 'b)
</pre>
<p>Explicit annotations in OCaml become useful when specifying interfaces. For example, the standard library interface Map.S for association tables include an annotation saying that the map type constructor is covariant in the result type.</p>
<p>WHATSON? 6f50b946-c135-44c0-8da0-2107a82f8464</p>
<pre>
module type S =
  sig
    type key
    type (+'a) t
    val empty: 'a t
    val mem: key -&gt; 'a t -&gt; bool
    ...
  end
</pre>
<p>This ensures that e.g. IntMap.t cat is a subtype of IntMap.t animal.</p>
<h3>Use-site variance annotations (Wildcards)</h3>
<p>One drawback of the declaration-site approach is that many interface types must be made invariant. For example, we saw above that IList needed to be invariant, because it contained both Insert and GetEnumerator. In order to expose more variance, the API designer could provide additional interfaces which provide subsets of the available methods (e.g. an "insert-only list" which only provides Insert). However this quickly becomes unwieldy.</p>
<p>Use-site variance annotations aim to give users of a class more opportunities for subtyping without requiring the designer of the class to define multiple interfaces with different variance. Instead, each time a class or interface is used in a type declaration, the programmer can indicate that only a subset of the methods will be used. In effect, each definition of a class also makes available interfaces for the covariant and contravariant "parts" of that class. Therefore the designer of the class no longer needs to take variance into account, increasing re-usability.</p>
<p>Java provides use-site variance annotations through wildcards, a restricted form of bounded existential types. A parameterized type can be instantiated by a wildcard ? together with an upper or lower bound, e.g. List&lt;? extends Animal&gt; or List&lt;? super Animal&gt;. (A an unbounded wildcard like List&lt;?&gt; is equivalent to List&lt;? extends Object&gt;). Such a type represents List&lt;X&gt; for some unknown type X which satisfies the bound. For example, if l has type List&lt;? extends Animal&gt;, then the typechecker will accept</p>
<p>WHATSON? 1e22c4a5-9ce2-4914-bd37-fceba284ea4e</p>
<pre>
    Animal a = l.get(3);
</pre>
<p>because the type X is known to be a subtype of Animal, but</p>
<p>WHATSON? c8b6d8cd-b4db-472c-918d-9732af1c5a99</p>
<pre>
    l.add(new Animal())
</pre>
<p>will be rejected as a type error since an Animal is not necessarily an X. In general, given some interface I&lt;T&gt;, a reference to a I&lt;? extends A&gt; forbids using methods from the interface where T occurs contravariantly in the type of the method. Conversely, if l had type List&lt;? super Animal&gt; one could call l.add but not l.get.</p>
<p>While plain generic types in Java are invariant (e.g. there is no subtyping relationship between List&lt;Cat&gt; and List&lt;Animal&gt;), wildcard types can be made more specific by specifying a tighter bound, for example List&lt;? extends Cat&gt; is a subtype of List&lt;? extends Animal&gt;. This shows that wildcard types are <b>covariant in their upper bounds</b> (and also <b>contravariant in their lower bounds</b>). In total, given a wildcard type like C&lt;? extends T&gt;, there are three ways to form a subtype: by specializing the class C, by specifying a tighter bound T, or by replacing the wildcard ? by a specific type (see figure).</p>
<p>By combining two steps of subtyping, it is therefore possible to e.g. pass an argument of type List&lt;Cat&gt; to a method expecting a List&lt;? extends Animal&gt;. This is exactly the kind of programs that covariant interface types allow. The type List&lt;? extends Animal&gt; acts as an interface type containing only the covariant methods of List&lt;T&gt;, but the implementer of List&lt;T&gt; did not have to define it ahead of time. This is use-site variance.</p>
<p>In the common case of a generic data structure IList, covariant parameters are used for methods getting data out of the structure, and contravariant parameters for methods putting data into the structure. The mnemonics PECS (Producer Extends, Consumer Super) from the book <b>Effective Java</b> by Joshua Bloch gives an easy way to remember when to use covariance and contravariance.</p>
<p>Wildcards are flexible, but there is a drawback. While use-site variance means that API designers need not consider variance of type parameters to interfaces, they must often instead use more complicated method signatures. A common example involves the <code>Comparable</code> interface. Suppose we want to write a function that finds the biggest element in a collection. The elements need to implement the compareTo method, so a first try might be</p>
<p>WHATSON? 8c71525c-f464-406a-a433-d794ce4100d9</p>
<pre>
    &lt;T extends Comparable&lt;T&gt;&gt;  T max(Collection&lt;T&gt; coll);
</pre>
<p>However, this type is not general enough—one can find the max of a Collection&lt;Calendar&gt;, but not a Collection&lt;GregorianCalendar&gt;. The problem is that <code>GregorianCalendar</code> does not implement Comparable&lt;GregorianCalendar&gt;, but instead the (better) interface Comparable&lt;Calendar&gt;. In Java, unlike in C#, Comparable&lt;Calendar&gt; is not considered a subtype of Comparable&lt;GregorianCalendar&gt;. Instead the type of max has to be modified:</p>
<p>WHATSON? 4745735e-8372-41fa-85c5-b7a32e3f5bd6</p>
<pre>
    &lt;T extends Comparable&lt;? super T&gt;&gt;  T max(Collection&lt;T&gt; coll);
</pre>
<p>The bounded wildcard ? super T conveys the information that max calls only contravariant methods from the Comparable interface. This particular example is frustrating because <i>all</i> the methods in Comparable are contravariant, so that condition is trivially true. A declaration-site system could handle this example with less clutter by annotating only the definition of Comparable.</p>
<h3>Comparing Declaration-site and Use-site annotations</h3>
<p>Use-site variance annotations provide additional flexibility, allowing more programs to type-check. However, they have been criticized for the complexity they add to the language, leading to complicated type signatures and error messages.</p>
<p>One way to assess whether the extra flexibility is useful is to see if it is used in existing programs. A survey of a large set of Java libraries found that 39% of wildcard annotations could have been directly replaced by a declaration-site annotations. Thus the remaining 61% is an indication on places where Java benefits from having the use-site system available.</p>
<p>In a declaration-site language, libraries must either expose less variance, or define more interfaces. For example, the Scala Collections library defines three separate interfaces for classes which employ covariance: a covariant base interface containing common methods, an invariant mutable version which adds side-effecting methods, and a covariant immutable version which may specialize the inherited implementations to exploit structural sharing. This design works well with declaration-site annotations, but the large number of interfaces carry a complexity cost for clients of the library. And modifying the library interface may not be an option—in particular, one goal when adding generics to Java was to maintain binary backwards compatibility.</p>
<p>On the other hand, Java wildcards are themselves complex. In a conference presentation Joshua Bloch criticized them as being too hard to understand and use, stating that when adding support for closures "we simply cannot afford another <i>wildcards</i>". Early versions of Scala used use-site variance annotations but programmers found them difficult to use in practice, while declaration-site annotations were found to be very helpful when designing classes. Later versions of Scala added Java-style existential types and wildcards; however, according to Martin Odersky, if there were no need for interoperability with Java then these would probably not have been included.</p>
<p>Ross Tate argues that part of the complexity of Java wildcards is due to the decision to encode use-site variance using a form of existential types. The original proposals  used special-purpose syntax for variance annotations, writing List&lt;+Animal&gt; instead of Java's more verbose List&lt;? extends Animal&gt;.</p>
<p>Since wildcards are a form of existential types they can be used for more things than just variance. A type like List&lt;?&gt; ("some type of list") lets objects be passed to methods or stored in fields without exactly specifying their type parameters. This is particularly valuable for classes such as <code>Class</code> where most of the methods do not mention the type parameter.</p>
<p>However, type inference for existential types is a difficult problem. For the compiler implementer, Java wildcards raise issues with type checker termination, type argument inference, and ambiguous programs. For the programmer, it leads to complicated type error messages. Java typechecks wildcard types by replacing the wildcards with fresh type variables (so-called <i>capture conversion</i>). This can make error messages harder to read, because they refer to type variables that the programmer did not directly write. For example, trying to add a Cat to a List&lt;? extends Animal&gt; will give an error like</p>
<p>WHATSON? 71265079-e404-4053-9afb-9a875841f5f4</p>
<pre>
method List.add(capture#1) is not applicable
  (actual argument Cat cannot be converted to capture#1 by method invocation conversion)
where capture#1 is a fresh type-variable:
  capture#1 extends Animal from capture of ? extends Animal
</pre>
<p>Since both declaration-site and use-site annotations can be useful, some type system provide both.</p>
<h3>Covariant generics in Dart</h3>
<p>The Dart programming language does not track variance, and instead treats all parameterized types as covariant. The language specification states</p>
<p>The type system is unsound, due to the covariance of generic types. This is a deliberate choice (and undoubtedly controversial). Experience has shown that sound type rules for generics fly in the face of programmer intuition. It is easy for tools to provide a sound type analysis if they choose, which may be useful for tasks like refactoring.</p>
<h2>Origin of the term "covariance"</h2>
<p>These terms come from the notion of covariant and contravariant functors in category theory. Consider the category <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> whose objects are types and whose morphisms represent the subtype relationship ≤. (This is an example of how any partially ordered set can be considered as a category). Then for example the function type constructor takes two types <i>p</i> and <i>r</i> and creates a new type <i>p</i> → <i>r</i>; so it takes objects in <img class="mwe-math-fallback-image-inline tex" alt="C^2" src="//upload.wikimedia.org/math/2/6/0/260dd56bacf8c0c3908fa94f84298d12.png"> to objects in <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">. By the subtyping rule for function types this operation reverses ≤ for the first argument and preserves it for the second, so it is a contravariant functor in the first argument and a covariant functor in the second.</p>
<h2>See also</h2>
<ul>
<li>Polymorphism (computer science)</li>
<li>Inheritance (computer science)</li>
</ul>
</body>
</html>