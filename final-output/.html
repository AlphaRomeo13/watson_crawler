<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>.html</title></head>
<body>
<h1>Алгоритм Малхотры — Кумара — Махешвари</h1>
<p><b>Алгоритм Малхотры — Кумара — Махешвари</b> позволяет находить максимальный поток в графе.</p>
<h2>Описание[править | править вики-текст]</h2>
<p>Рассматривается транспортная сеть, состоящая из ориентированного графа <img class="mwe-math-fallback-image-inline tex" alt="G=(V,\;E)" src="//upload.wikimedia.org/math/b/1/c/b1c0133fd062cdcf39578f0c1defe593.png">, где <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> — множество вершин, <img class="mwe-math-fallback-image-inline tex" alt="E" src="//upload.wikimedia.org/math/3/a/3/3a3ea00cfc35332cedf6e5e9a32e94da.png"> — множество рёбер, и потока <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png">. Для каждой вершины <img class="mwe-math-fallback-image-inline tex" alt="v\in V" src="//upload.wikimedia.org/math/f/5/9/f597bb2e018f9feb80df75d899613dbe.png"> вводится потенциал потока, равный максимальному дополнительному потоку, который может пройти через эту вершину. Далее следует цикл. На каждой его итерации определяется вершина <img class="mwe-math-fallback-image-inline tex" alt="r" src="//upload.wikimedia.org/math/4/b/4/4b43b0aee35624cd95b910189b3dc231.png"> с минимальным потенциалом <img class="mwe-math-fallback-image-inline tex" alt="\rho" src="//upload.wikimedia.org/math/f/7/f/f7f177957cf064a93e9811df8fe65ed1.png">. Затем пускается поток величины <img class="mwe-math-fallback-image-inline tex" alt="\rho" src="//upload.wikimedia.org/math/f/7/f/f7f177957cf064a93e9811df8fe65ed1.png"> из истока в сток, проходящий через эту вершину. При этом если остаточная пропускная способность ребра равна нулю, то это ребро удаляется. Также, удаляются все вершины, у которых не остаётся ни одного входящего и/или ни одного выходящего ребра. При удалении вершины все смежные рёбра удаляются. Таким образом, будет найден блокирующий (псевдомаксимальный) поток. Для того, чтобы найти максимальный поток в графе, нужно выполнять поиск блокирующего потока и затем соответствующим образом изменять граф, и так, до тех пор, блокирующий поток не окажется равным нулю.</p>
<h2>Сложность[править | править вики-текст]</h2>
<p>Если информация о входящих и исходящих дугах будет храниться в виде связных списков, то для того, чтобы пропустить поток, на каждой итерации будет выполнено <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|+\left|E_i\right|)" src="//upload.wikimedia.org/math/d/8/9/d89710ded47ee97516a602542f752599.png"> действий, где <img class="mwe-math-fallback-image-inline tex" alt="\left|V\right|" src="//upload.wikimedia.org/math/7/9/4/794ad7210592f2b9cd4b6ea33441ee92.png"> соответствует числу рёбер, для которых остаточная пропускная способность уменьшилась, но осталась положительной, а <img class="mwe-math-fallback-image-inline tex" alt="\left|E_i\right|" src="//upload.wikimedia.org/math/1/c/f/1cfab6311170ba4758bc07161174f5ac.png"> — числу удалённых рёбер. Таким образом, для поиска блокирующего потока будет выполнено <img class="mwe-math-fallback-image-inline tex" alt="\sum_i{O(\left|V\right|+\left|E_i\right|)} = O(\left|V\right|^2)" src="//upload.wikimedia.org/math/6/b/a/6ba8de4abfd7c7414b260f417ee80503.png"> действий. Поиск блокирующего потока будет выполнен <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|)" src="//upload.wikimedia.org/math/5/0/9/5099eafeb5e72d849339e20cf55df606.png"> раз, так как количество рёбер на пути от истока к стоку в блокирующем потоке будет не убывать. Тогда всего получается <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|^3)" src="//upload.wikimedia.org/math/f/9/4/f949db70a3b94bccdb6fed8c11673d1a.png"> действий.</p>
<h2>Ссылки[править | править вики-текст]</h2>
<p><i>Malhotra V. M., Kumar M. Pramodh, Maheshwari S. N.</i> An O(IVI) algorithm for finding maximum flows in networks (англ.). — 1978.</p>
<h1>Алгоритм Малхотры — Кумара — Махешвари</h1>
<p><b>Алгоритм Малхотры — Кумара — Махешвари</b> позволяет находить максимальный поток в графе.</p>
<h2>Описание[править | править вики-текст]</h2>
<p>Рассматривается транспортная сеть, состоящая из ориентированного графа <img class="mwe-math-fallback-image-inline tex" alt="G=(V,\;E)" src="//upload.wikimedia.org/math/b/1/c/b1c0133fd062cdcf39578f0c1defe593.png">, где <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> — множество вершин, <img class="mwe-math-fallback-image-inline tex" alt="E" src="//upload.wikimedia.org/math/3/a/3/3a3ea00cfc35332cedf6e5e9a32e94da.png"> — множество рёбер, и потока <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png">. Для каждой вершины <img class="mwe-math-fallback-image-inline tex" alt="v\in V" src="//upload.wikimedia.org/math/f/5/9/f597bb2e018f9feb80df75d899613dbe.png"> вводится потенциал потока, равный максимальному дополнительному потоку, который может пройти через эту вершину. Далее следует цикл. На каждой его итерации определяется вершина <img class="mwe-math-fallback-image-inline tex" alt="r" src="//upload.wikimedia.org/math/4/b/4/4b43b0aee35624cd95b910189b3dc231.png"> с минимальным потенциалом <img class="mwe-math-fallback-image-inline tex" alt="\rho" src="//upload.wikimedia.org/math/f/7/f/f7f177957cf064a93e9811df8fe65ed1.png">. Затем пускается поток величины <img class="mwe-math-fallback-image-inline tex" alt="\rho" src="//upload.wikimedia.org/math/f/7/f/f7f177957cf064a93e9811df8fe65ed1.png"> из истока в сток, проходящий через эту вершину. При этом если остаточная пропускная способность ребра равна нулю, то это ребро удаляется. Также, удаляются все вершины, у которых не остаётся ни одного входящего и/или ни одного выходящего ребра. При удалении вершины все смежные рёбра удаляются. Таким образом, будет найден блокирующий (псевдомаксимальный) поток. Для того, чтобы найти максимальный поток в графе, нужно выполнять поиск блокирующего потока и затем соответствующим образом изменять граф, и так, до тех пор, блокирующий поток не окажется равным нулю.</p>
<h2>Сложность[править | править вики-текст]</h2>
<p>Если информация о входящих и исходящих дугах будет храниться в виде связных списков, то для того, чтобы пропустить поток, на каждой итерации будет выполнено <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|+\left|E_i\right|)" src="//upload.wikimedia.org/math/d/8/9/d89710ded47ee97516a602542f752599.png"> действий, где <img class="mwe-math-fallback-image-inline tex" alt="\left|V\right|" src="//upload.wikimedia.org/math/7/9/4/794ad7210592f2b9cd4b6ea33441ee92.png"> соответствует числу рёбер, для которых остаточная пропускная способность уменьшилась, но осталась положительной, а <img class="mwe-math-fallback-image-inline tex" alt="\left|E_i\right|" src="//upload.wikimedia.org/math/1/c/f/1cfab6311170ba4758bc07161174f5ac.png"> — числу удалённых рёбер. Таким образом, для поиска блокирующего потока будет выполнено <img class="mwe-math-fallback-image-inline tex" alt="\sum_i{O(\left|V\right|+\left|E_i\right|)} = O(\left|V\right|^2)" src="//upload.wikimedia.org/math/6/b/a/6ba8de4abfd7c7414b260f417ee80503.png"> действий. Поиск блокирующего потока будет выполнен <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|)" src="//upload.wikimedia.org/math/5/0/9/5099eafeb5e72d849339e20cf55df606.png"> раз, так как количество рёбер на пути от истока к стоку в блокирующем потоке будет не убывать. Тогда всего получается <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|^3)" src="//upload.wikimedia.org/math/f/9/4/f949db70a3b94bccdb6fed8c11673d1a.png"> действий.</p>
<h2>Ссылки[править | править вики-текст]</h2>
<p><i>Malhotra V. M., Kumar M. Pramodh, Maheshwari S. N.</i> An O(IVI) algorithm for finding maximum flows in networks (англ.). — 1978.</p>
<h1>Алгоритм Малхотры — Кумара — Махешвари</h1>
<p><b>Алгоритм Малхотры — Кумара — Махешвари</b> позволяет находить максимальный поток в графе.</p>
<h2>Описание[править | править вики-текст]</h2>
<p>Рассматривается транспортная сеть, состоящая из ориентированного графа <img class="mwe-math-fallback-image-inline tex" alt="G=(V,\;E)" src="//upload.wikimedia.org/math/b/1/c/b1c0133fd062cdcf39578f0c1defe593.png">, где <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> — множество вершин, <img class="mwe-math-fallback-image-inline tex" alt="E" src="//upload.wikimedia.org/math/3/a/3/3a3ea00cfc35332cedf6e5e9a32e94da.png"> — множество рёбер, и потока <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png">. Для каждой вершины <img class="mwe-math-fallback-image-inline tex" alt="v\in V" src="//upload.wikimedia.org/math/f/5/9/f597bb2e018f9feb80df75d899613dbe.png"> вводится потенциал потока, равный максимальному дополнительному потоку, который может пройти через эту вершину. Далее следует цикл. На каждой его итерации определяется вершина <img class="mwe-math-fallback-image-inline tex" alt="r" src="//upload.wikimedia.org/math/4/b/4/4b43b0aee35624cd95b910189b3dc231.png"> с минимальным потенциалом <img class="mwe-math-fallback-image-inline tex" alt="\rho" src="//upload.wikimedia.org/math/f/7/f/f7f177957cf064a93e9811df8fe65ed1.png">. Затем пускается поток величины <img class="mwe-math-fallback-image-inline tex" alt="\rho" src="//upload.wikimedia.org/math/f/7/f/f7f177957cf064a93e9811df8fe65ed1.png"> из истока в сток, проходящий через эту вершину. При этом если остаточная пропускная способность ребра равна нулю, то это ребро удаляется. Также, удаляются все вершины, у которых не остаётся ни одного входящего и/или ни одного выходящего ребра. При удалении вершины все смежные рёбра удаляются. Таким образом, будет найден блокирующий (псевдомаксимальный) поток. Для того, чтобы найти максимальный поток в графе, нужно выполнять поиск блокирующего потока и затем соответствующим образом изменять граф, и так, до тех пор, блокирующий поток не окажется равным нулю.</p>
<h2>Сложность[править | править вики-текст]</h2>
<p>Если информация о входящих и исходящих дугах будет храниться в виде связных списков, то для того, чтобы пропустить поток, на каждой итерации будет выполнено <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|+\left|E_i\right|)" src="//upload.wikimedia.org/math/d/8/9/d89710ded47ee97516a602542f752599.png"> действий, где <img class="mwe-math-fallback-image-inline tex" alt="\left|V\right|" src="//upload.wikimedia.org/math/7/9/4/794ad7210592f2b9cd4b6ea33441ee92.png"> соответствует числу рёбер, для которых остаточная пропускная способность уменьшилась, но осталась положительной, а <img class="mwe-math-fallback-image-inline tex" alt="\left|E_i\right|" src="//upload.wikimedia.org/math/1/c/f/1cfab6311170ba4758bc07161174f5ac.png"> — числу удалённых рёбер. Таким образом, для поиска блокирующего потока будет выполнено <img class="mwe-math-fallback-image-inline tex" alt="\sum_i{O(\left|V\right|+\left|E_i\right|)} = O(\left|V\right|^2)" src="//upload.wikimedia.org/math/6/b/a/6ba8de4abfd7c7414b260f417ee80503.png"> действий. Поиск блокирующего потока будет выполнен <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|)" src="//upload.wikimedia.org/math/5/0/9/5099eafeb5e72d849339e20cf55df606.png"> раз, так как количество рёбер на пути от истока к стоку в блокирующем потоке будет не убывать. Тогда всего получается <img class="mwe-math-fallback-image-inline tex" alt="O(\left|V\right|^3)" src="//upload.wikimedia.org/math/f/9/4/f949db70a3b94bccdb6fed8c11673d1a.png"> действий.</p>
<h2>Ссылки[править | править вики-текст]</h2>
<p><i>Malhotra V. M., Kumar M. Pramodh, Maheshwari S. N.</i> An O(IVI) algorithm for finding maximum flows in networks (англ.). — 1978.</p>
</body>
</html>