<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Constructor-object-oriented-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Constructor (object-oriented programming)</h1>
<ul>
<li>General comparison</li>
<li>Basic syntax</li>
<li>Basic instructions</li>
<li>Arrays</li>
<li>Associative arrays</li>
<li>String operations</li>
<li>String functions</li>
<li>List comprehension</li>
<li>Object-oriented programming</li>
<li><strong class="selflink">Object-oriented constructors</strong></li>
<li>Database access</li>
</ul>
<ul>
<li>Evaluation strategy</li>
<li>List of "Hello World" programs</li>
</ul>
<ul>
<li>Web application frameworks</li>
<li>Comparison of the Java and .NET platforms</li>
</ul>
<ul>
<li>Comparison of individual programming languages
<ul>
<li>ALGOL 58's influence on ALGOL 60</li>
<li>ALGOL 60: Comparisons with other languages</li>
<li>Comparison of ALGOL 68 and C++</li>
<li>ALGOL 68: Comparisons with other languages</li>
<li>Compatibility of C and C++</li>
<li>Comparison of Pascal and Borland Delphi</li>
<li>Comparison of Object Pascal and C</li>
<li>Comparison of Pascal and C</li>
<li>Comparison of Java and C++</li>
<li>Comparison of C# and Java</li>
<li>Comparison of C# and Visual Basic .NET</li>
<li>Comparison of Visual Basic and Visual Basic .NET</li>
</ul>
</li>
</ul>
<ul>
<li>ALGOL 58's influence on ALGOL 60</li>
<li>ALGOL 60: Comparisons with other languages</li>
<li>Comparison of ALGOL 68 and C++</li>
<li>ALGOL 68: Comparisons with other languages</li>
<li>Compatibility of C and C++</li>
<li>Comparison of Pascal and Borland Delphi</li>
<li>Comparison of Object Pascal and C</li>
<li>Comparison of Pascal and C</li>
<li>Comparison of Java and C++</li>
<li>Comparison of C# and Java</li>
<li>Comparison of C# and Visual Basic .NET</li>
<li>Comparison of Visual Basic and Visual Basic .NET</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In class-based object-oriented programming, a <b>constructor</b> (abbreviation: <b>ctor</b>) in a class is a special type of subroutine called to create an object. It prepares the new object for use, often accepting arguments that the constructor uses to set required member variables.</p>
<p><b>Instance constructors</b>, sometimes referred to as <b>.ctor</b>, are used to create and initialize any instance member variables when the new expression is used to create an object of a class. To initialize a static class, or static variables in a non-static class, a <b>static constructor</b> must be defined. Static constructors are sometimes referred to as <b>.cctor</b>.</p>
<p>A constructor resembles an instance method, but it differs from a method in that it has no explicit return type, it is not implicitly inherited and it usually has different rules for scope modifiers. Constructors often have the same name as the declaring class. They have the task of initializing the object's data members and of establishing the invariant of the class, failing if the invariant is invalid. A properly written constructor leaves the resulting object in a <i>valid</i> state. Immutable objects must be initialized in a constructor.</p>
<p>Programmers also use the term <i>constructor</i> to denote one of the tags that wraps data in an algebraic data type. This is a different usage than in this article.</p>
<p>Most languages allow overloading the constructor in that there can be more than one constructor for a class, with differing parameters. Some languages take consideration of some special types of constructors. Constructors, which concretely use a single class to create objects and return a new instance of the class, are abstracted by factories, which also create objects but can do so in various ways, using multiple classes or different allocation schemes such as an object pool.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Types
<ul>
<li>1.1 Parameterized constructors</li>
<li>1.2 Default constructors</li>
<li>1.3 Copy constructors</li>
<li>1.4 Conversion constructors</li>
<li>1.5 Move constructors</li>
</ul>
</li>
<li>2 Syntax</li>
<li>3 Memory organization</li>
<li>4 Language details
<ul>
<li>4.1 Java</li>
<li>4.2 Visual Basic .NET</li>
<li>4.3 C#
<ul>
<li>4.3.1 C# static constructor</li>
</ul>
</li>
<li>4.4 C++</li>
<li>4.5 F#</li>
<li>4.6 Eiffel</li>
<li>4.7 ColdFusion</li>
<li>4.8 Object Pascal</li>
<li>4.9 Perl</li>
<li>4.10 Perl with Moose</li>
<li>4.11 PHP</li>
<li>4.12 Python</li>
<li>4.13 Ruby</li>
</ul>
</li>
<li>5 See also</li>
<li>6 Notes</li>
<li>7 References</li>
</ul>
<ul>
<li>1.1 Parameterized constructors</li>
<li>1.2 Default constructors</li>
<li>1.3 Copy constructors</li>
<li>1.4 Conversion constructors</li>
<li>1.5 Move constructors</li>
</ul>
<ul>
<li>4.1 Java</li>
<li>4.2 Visual Basic .NET</li>
<li>4.3 C#
<ul>
<li>4.3.1 C# static constructor</li>
</ul>
</li>
<li>4.4 C++</li>
<li>4.5 F#</li>
<li>4.6 Eiffel</li>
<li>4.7 ColdFusion</li>
<li>4.8 Object Pascal</li>
<li>4.9 Perl</li>
<li>4.10 Perl with Moose</li>
<li>4.11 PHP</li>
<li>4.12 Python</li>
<li>4.13 Ruby</li>
</ul>
<ul>
<li>4.3.1 C# static constructor</li>
</ul>
<p></p>
<h2>Types</h2>
<h3>Parameterized constructors</h3>
<p>Constructors that can take arguments are termed as parameterized constructors. The number of arguments can be greater or equal to one(1). For example:</p>
<p>WHATSON? d945a11c-fd64-4c3a-934c-4ebd076db0e7</p>
<pre>
class Example
{
     int x, y;
   public:
     Example();
     Example(int a, int b); // Parameterized constructor
};
Example :: Example()
{
}
Example :: Example(int a, int b)
{
     x = a;
     y = b;
}
</pre>
<p>When an object is declared in a parameterized constructor, the initial values have to be passed as arguments to the constructor function. The normal way of object declaration may not work. The constructors can be called explicitly or implicitly. The method of calling the constructor implicitly is also called the <i>shorthand</i> method.</p>
<p>WHATSON? 9f399f5d-c747-4bdc-ba52-c16cb5d49879</p>
<pre>
    Example e = Example(0, 50); // Explicit call
 
    Example e(0, 50);           // Implicit call
</pre>
<h3>Default constructors</h3>
<p>If the programmer does not supply a constructor for an instantiable class, most languages will provide a <i>default constructor</i>.</p>
<p>The behavior of the default constructor is language dependent. It may initialize data members to zero or other same values, or it may do nothing at all. In C++ a default constructor is required if an array of class objects is to be created. Other languages (Java, C#, VB .NET) have no such restriction.</p>
<h3>Copy constructors</h3>
<p>Copy constructors define the actions performed by the compiler when copying class objects. A copy constructor has one formal parameter that is the type of the class (the parameter may be a reference to an object). It is used to create a copy of an existing object of the same class. Even though both classes are the same, it counts as a conversion constructor</p>
<h3>Conversion constructors</h3>
<p>Conversion constructors provide a means for a compiler to implicitly create an object belonging to one class based on an object of a different type. These constructors are usually invoked implicitly to convert arguments or operands to an appropriate type, but they may also be called explicitly.</p>
<h3>Move constructors</h3>
<p>In C++, move constructors take a value reference to an object of the class, and are used to implement ownership transfer of the parameter object's resources.</p>
<h2>Syntax</h2>
<ul>
<li>Java, C++, C#, ActionScript, and PHP 4 have a naming convention in which constructors have the same name as the class of which they are associated with.</li>
<li>In PHP 5, a recommended name for a constructor is <code>__construct</code>. For backwards compatibility, a method with the same name as the class will be called if <code>__construct</code> method can not be found. Since PHP 5.3.3, this works only for non-namespaced classes.</li>
<li>In Perl, constructors are, by convention, named "new" and have to do a fair amount of object creation.</li>
<li>In Moose object system for Perl, constructors (named <i>new</i>) are automatically created and are extended by specifying a <i>BUILD</i> method.</li>
<li>In Visual Basic .NET, the constructor is called "<code>New</code>".</li>
<li>In Python, the constructor is split over two methods, "<code>__new__</code>" and "<code>__init__</code>". The <code>__new__</code> method is responsible for allocating memory for the instance, and receives the class as an argument (conventionally called "<code>cls</code>"). The <code>__init__</code> method (often called "the initialiser") is passed the newly created instance as an argument (conventionally called "<code>self</code>").</li>
<li>Object Pascal constructors are signified by the keyword "<code>constructor</code>" and can have user-defined names (but are mostly called "<code>Create</code>").</li>
<li>In Objective-C, the constructor method is split across two methods, "<code>alloc</code>" and "<code>init</code>" with the <code>alloc</code> method setting aside (allocating) memory for an instance of the class, and the <code>init</code> method handling the bulk of initializing the instance. A call to the method "<code>new</code>" invokes both the <code>alloc</code> and the <code>init</code> methods, for the class instance.</li>
</ul>
<h2>Memory organization</h2>
<p>In Java, C# and VB .NET the constructor creates objects in a special memory structure called heap for reference types. Value types (such as int, double etc.), are created in a sequential structure called stack. VB .NET and C# allow use of <i>new</i> to create objects of value types. However, in those languages even use of new for value types creates objects only on stack.</p>
<p>In C++, when constructor is invoked without new the objects are created on stack. When objects are created using new they are created on heap. They must be deleted implicitly by a destructor or explicitly by a call to operator <i>delete</i>.</p>
<h2>Language details</h2>
<h3>Java</h3>
<p>In Java, constructors differ from other methods in that:</p>
<ul>
<li>Constructors never have an explicit return type.</li>
<li>Constructors cannot be directly invoked (the keyword “<code>new</code>” invokes them).</li>
<li>Constructors cannot be <i>synchronized</i>, <i>final</i>, <i>abstract</i>, <i>native</i>, or <i>static</i>.</li>
</ul>
<p>Java constructors perform the following tasks in the following order:</p>
<ol>
<li>Initialize the class variables to default values. (byte, short, int, long, float, and double variables default to their respective zero values, booleans to false, chars to the null character ('\u0000') and object references to null.)</li>
<li>Call the default constructor of the superclass if no constructor is defined.</li>
<li>Initialize member variables to the specified values.</li>
<li>Executes the body of the constructor.</li>
</ol>
<p>Java provides access to the superclass's constructor through the <code>super</code> keyword.</p>
<p>WHATSON? 8d7e4416-0ed3-4879-9448-a90b8d01b3b2</p>
<pre>
public class Example
{
    // Definition of the constructor.
    public Example()
    {
        this(1);
    }
 
    // Overloading a constructor
    public Example(int input)
    {
        data = input; // This is an assignment
    }
 
    // Declaration of instance variable(s).
    private int data;
}
</pre>
<p>WHATSON? d69d9d8b-f0a6-4fc1-baa0-3de81242eeb0</p>
<pre>
// Code somewhere else
// Instantiating an object with the above constructor
Example e = new Example(42);
</pre>
<p>A constructor taking zero number of arguments is called a "no-arguments" or "no-arg" constructor.</p>
<h3>Visual Basic .NET</h3>
<p>In Visual Basic .NET, constructors use a method declaration with the name "<code>New</code>".</p>
<p>WHATSON? e1e7bf7c-9489-41f1-8e3f-bce6713ba7a5</p>
<pre>
Class Foobar
  Private strData As String
 
  ' Constructor
  Public Sub New(ByVal someParam As String)
     strData = someParam
  End Sub
End Class
</pre>
<p>WHATSON? de1deab6-cc15-4c7a-b9ae-34e79ae9a621</p>
<pre>
' code somewhere else
' instantiating an object with the above constructor
Dim foo As New Foobar(".NET")
</pre>
<h3>C#</h3>
<p>Example C# constructor:</p>
<p>WHATSON? 05990e20-fbe1-4ae4-91bc-0586c8f1332e</p>
<pre>
public class MyClass
{
    private int a;
    private string b;
 
    // Constructor
    public MyClass() : this(42, "string")
    {
    }
 
    // Overloading a constructor
    public MyClass(int a, string b)
    {
        this.a = a;
        this.b = b;
    }
}
</pre>
<p>WHATSON? 3b5beb6d-f49b-4903-94c7-3d620daf3461</p>
<pre>
// Code somewhere
// Instantiating an object with the constructor above
MyClass c = new MyClass(42, "string");
</pre>
<h4>C# static constructor</h4>
<p>In C#, a <i>static constructor</i> is a static data initializer. Static constructors are also called <i>class constructors</i>. Since the actual method generated has the name <i>.cctor</i> they are often also called "cctors".</p>
<p>Static constructors allow complex static variable initialization. Static constructors are called implicitly when the class is first accessed. Any call to a class (static or constructor call), triggers the static constructor execution. Static constructors are thread safe and implement a singleton pattern. When used in a generic programming class, static constructors are called at every new generic instantiation one per type. Static variables are instantiated as well.</p>
<p>WHATSON? 7fb5fae8-ba1f-450b-a663-cd5ed48f2e58</p>
<pre>
public class MyClass
{
    private static int _A;
 
    // Normal constructor
    static MyClass()
    {
        _A = 32;
    }
 
    // Standard default constructor
    public MyClass()
    {
 
    }
}
</pre>
<p>WHATSON? 1068c15d-36e9-427b-8586-856e0b569bf0</p>
<pre>
// Code somewhere
// Instantiating an object with the constructor above
// right before the instantiation
// The variable static constructor is executed and _A is 32
MyClass c = new MyClass();
</pre>
<h3>C++</h3>
<p>In C++, the name of the constructor is the name of the class. It returns nothing. It can have parameters like any member function. Constructor functions are usually declared in the public section, but can also be declared in the protected and private sections, if the user wants to restrict access to them.</p>
<p>The constructor has two parts. First is the initializer list which follows the parameter list and before the method body. It starts with a colon and entries are comma-separated. The initializer list is not required, but offers the opportunity to provide values for data members and avoid separate assignment statements. The initializer list is required if you have <i>const</i> or reference type data members, or members that do not have parameterless constructor logic. Assignments occur according to the order of the initializer list. The second part is the body, which is a normal method body enclosed in curly brackets.</p>
<p>C++ allows more than one constructor. The other constructors can have different default values for the parameters. The constructor of a base class (or base classes) can also be called by a derived class. Constructor functions are not inherited and their addresses cannot be referenced. When memory allocation is required, the <i>new</i> and <i>delete</i> operators are called implicitly.</p>
<p>A copy constructor has a parameter of the same type passed as <i>const</i> reference, for example <i>Vector(const Vector&amp; rhs)</i>. If it is not provided explicitly, the compiler uses the copy constructor for each member variable or simply copies values in case of primitive types. The default implementation is not efficient if the class has dynamically allocated members (or handles to other resources), because it can lead to double calls to <i>delete</i> (or double release of resources) upon destruction.</p>
<p>WHATSON? b3871f58-a72c-4bfb-9654-ade89d1d8177</p>
<pre>
class Foobar {
public:
    Foobar(double r = 1.0, double alpha = 0.0) // Constructor, parameters with default values.
    : x(r*cos(alpha)) // &lt;- Initializer list
    {
        y = r*sin(alpha); // &lt;- Normal assignment
    }
    // Other member functions
private:
    double x; // Data members, they should be private
    double y;
};
</pre>
<p>Example invocations:</p>
<p>WHATSON? f2675786-5ef7-4eaf-bd9d-9a6fff795901</p>
<pre>
Foobar a,
       b(3),
       c(5, M_PI/4);
</pre>
<p>Private data member functions appear at the top section before writing the public specifier. If you no longer have access to a constructor then you can use the destructor.</p>
<p>In C++ the copy constructor is called implicitly when class objects are returned from a method by return mechanism or when class objects are passed by value to a function. C++ provides a copy constructor if the programmer does not. The default copy constructor ONLY makes member-wise copy or shallow copies. For deep copies an explicit copy constructor that makes deep copies is required. For a class to make deep copies, the three methods below must be provided.</p>
<ol>
<li>Copy constructor</li>
<li>Overloading of assignment operator.</li>
<li>A destructor.</li>
</ol>
<p>The above is called rule of three in C++. If cloning of objects is not desired in C++ then copy constructor must be declared private.</p>
<h3>F#</h3>
<p>In F#, a constructor can include any <code>let</code> or <code>do</code> statements defined in a class. <code>let</code> statements define private fields and <code>do</code> statements execute code. Additional constructors can be defined using the <code>new</code> keyword.</p>
<p>WHATSON? 041ff34a-df26-4dbb-95e4-f07050353a87</p>
<pre>
type MyClass(_a : int, _b : string) = class
    // Primary constructor
    let a = _a
    let b = _b
    do printfn "a = %i, b = %s" a b
 
    // Additional constructors
    new(_a : int) = MyClass(_a, "") then
        printfn "Integer parameter given"
 
    new(_b : string) = MyClass(0, _b) then
        printfn "String parameter given"
 
    new() = MyClass(0, "") then
        printfn "No parameter given"
end
</pre>
<p>WHATSON? 3a32754d-4d98-4454-9751-af6648383da4</p>
<pre>
// Code somewhere
// instantiating an object with the primary constructor
let c1 = new MyClass(42, "string")
 
// instantiating an object with additional constructors
let c2 = new MyClass(42)
let c3 = new MyClass("string")
let c4 = MyClass() // "new" keyword is optional
</pre>
<h3>Eiffel</h3>
<p>In Eiffel, the routines which initialize new objects are called <i>creation procedures</i>. Creation procedures have the following traits:</p>
<ul>
<li>Creation procedures have no explicit return type (by definition of <i>procedure</i>).</li>
<li>Creation procedures are named.</li>
<li>Creation procedures are designated by name as creation procedures in the text of the class.</li>
<li>Creation procedures can be explicitly invoked to re-initialize existing objects.</li>
<li>Every effective (i.e., concrete or non-abstract) class must designate at least one creation procedure.</li>
<li>Creation procedures must leave the newly initialized object in a state that satisfies the class invariant.</li>
</ul>
<p>Although object creation involves some subtleties, the creation of an attribute with a typical declaration <code lang="eiffel" xml:lang="eiffel">x: T</code> as expressed in a creation instruction <code lang="eiffel" xml:lang="eiffel">create x.make</code> consists of the following sequence of steps:</p>
<ul>
<li>Create a new direct instance of type <code lang="eiffel" xml:lang="eiffel">T</code>.</li>
<li>Execute the creation procedure <code lang="eiffel" xml:lang="eiffel">make</code> to the newly created instance.</li>
<li>Attach the newly initialized object to the entity <code lang="eiffel" xml:lang="eiffel">x</code>.</li>
</ul>
<p>In the first snippet below, class <code lang="eiffel" xml:lang="eiffel">POINT</code> is defined. The procedure <code lang="eiffel" xml:lang="eiffel">make</code> is coded after the keyword <code lang="eiffel" xml:lang="eiffel">feature</code>.</p>
<p>The keyword <code lang="eiffel" xml:lang="eiffel">create</code> introduces a list of procedures which can be used to initialize instances. In this case the list includes <code lang="eiffel" xml:lang="eiffel">default_create</code>, a procedure with an empty implementation inherited from class <code lang="eiffel" xml:lang="eiffel">ANY</code>, and the <code lang="eiffel" xml:lang="eiffel">make</code> procedure coded within the class.</p>
<p>WHATSON? 649d7b16-fdbc-4f9c-ae1b-d28715ff2806</p>
<pre>
class
    POINT
create
    default_create, make
 
feature
 
    make (a_x_value: REAL; a_y_value: REAL)
        do
            x := a_x_value
            y := a_y_value
        end
 
    x: REAL
            -- X coordinate
 
    y: REAL
            -- Y coordinate
        ...
</pre>
<p>In the second snippet, a class which is a client to <code lang="eiffel" xml:lang="eiffel">POINT</code> has a declarations <code lang="eiffel" xml:lang="eiffel">my_point_1</code> and <code lang="eiffel" xml:lang="eiffel">my_point_2</code> of type <code lang="eiffel" xml:lang="eiffel">POINT</code>.</p>
<p>In procedural code, <code lang="eiffel" xml:lang="eiffel">my_point_1</code> is created as the origin (0.0, 0.0). Because no creation procedure is specified, the procedure <code lang="eiffel" xml:lang="eiffel">default_create</code> inherited from class <code lang="eiffel" xml:lang="eiffel">ANY</code> is used. This line could have been coded <code lang="eiffel" xml:lang="eiffel">create my_point_1.default_create</code> . Only procedures named as creation procedures can be used in an instruction with the <code lang="eiffel" xml:lang="eiffel">create</code> keyword. Next is a creation instruction for <code lang="eiffel" xml:lang="eiffel">my_point_2</code>, providing initial values for the <code lang="eiffel" xml:lang="eiffel">my_point_2</code>'s coordinates. The third instruction makes an ordinary instance call to the <code lang="eiffel" xml:lang="eiffel">make</code> procedure to reinitialize the instance attached to <code lang="eiffel" xml:lang="eiffel">my_point_2</code> with different values.</p>
<p>WHATSON? 7b054819-3ed2-4c27-ae61-dcca700fd51b</p>
<pre>
    my_point_1: POINT
    my_point_2: POINT
        ...
 
            create my_point_1
            create my_point_2.make (3.0, 4.0)
            my_point_2.make (5.0, 8.0)
        ...
</pre>
<h3>ColdFusion</h3>
<p>ColdFusion uses a method named '<code>init</code>' as a constructor method.</p>
<p><b>Cheese.cfc</b></p>
<p>WHATSON? 987c9e69-f874-4b96-a193-bc0c54652304</p>
<pre>
component displayname="Cheese" {
   // properties
   property name="cheeseName";
 
   // constructor
   function Cheese init( required string cheeseName ) {
      variables.cheeseName = arguments.cheeseName;
      return this;
   }
}
</pre>
<p>Create instance of a cheese.</p>
<p>WHATSON? 621c71f7-7971-471e-8404-be2d59f29d24</p>
<pre>
myCheese = new Cheese( 'Cheddar' );
</pre>
<h3>Object Pascal</h3>
<p>In Object Pascal, the constructor is similar to a factory method. The only syntactic difference to regular methods is the keyword <code>constructor</code> in front of the name (instead of <code>procedure</code> or <code>function</code>). It can have any name, though the convention is to have <code>Create</code> as prefix, such as in <code>CreateWithFormatting</code>. Creating an instance of a class works like calling a static method of a class: <code>TPerson.Create('Peter')</code>.</p>
<p>WHATSON? 3eadb11a-671c-4125-ad1a-819c9ee28136</p>
<pre>
program OopProgram;
 
type
  TPerson = class
  private
    FName: string;
  public
    property Name: string read FName;
    constructor Create(AName: string);
  end;
 
constructor TPerson.Create(AName: string);
begin
  FName := AName;
end;
 
var
  Person: TPerson;
begin
  Person := TPerson.Create('Peter'); // allocates an instance of TPerson and then calls TPerson.Create with the parameter AName = 'Peter'
end.
</pre>
<h3>Perl</h3>
<p>In Perl programming language version 5, by default, constructors are factory methods, that is, methods that create and return the object, concretely meaning create and return a blessed reference. A typical object is a reference to a hash, though rarely references to other types are used too. By convention the only constructor is named <i>new</i>, though it is allowed to name it otherwise, or to have multiple constructors. For example, a Person class may have a constructor named <i>new</i> as well as a constructor <i>new_from_file</i> which reads a file for Person attributes, and <i>new_from_person</i> which uses another Person object as a template.</p>
<p>WHATSON? 671a4ee7-6aa9-483b-b8f8-aec0570bb74f</p>
<pre>
package Person;
# In Perl constructors are named 'new' by convention.
sub new {
    # Class name is implicitly passed in as 0th argument.
    my $class = shift;
 
    # Default attribute values, if you have any.
    my %defaults = ( foo =&gt; "bar" );
 
    # Initialize attributes as a combination of default values and arguments passed.
    my $self = { %defaults, @_ };
 
    # Check for required arguments, class invariant, etc.
    if ( not defined $self-&gt;{first_name} ) {
        die "Mandatory attribute missing in Person-&gt;new(): first_name";
    }
    if ( not defined $self-&gt;{last_name} ) {
        die "Mandatory attribute missing in Person-&gt;new(): last_name";
    }
    if ( defined $self-&gt;{age} and $self-&gt;{age} &lt; 18 ) {
        die "Invalid attribute value in Person-&gt;new(): age &lt; 18";
    }
 
    # Perl makes an object belong to a class by 'bless'.
    bless $self, $class;
    return $self;
}
1;
</pre>
<h3>Perl with Moose</h3>
<p>With the Moose object system for Perl, most of this boilerplate can be left out, a default <i>new</i> is created, attributes can be specified, as well as whether they can be set, reset, or are required. In addition, any extra constructor functionality can be included in a <i>BUILD</i> method which the Moose generated constructor will call, after it has checked the arguments. A <i>BUILDARGS</i> method can be specified to handle constructor arguments not in hashref / key =&gt; value form.</p>
<p>WHATSON? 34f230c5-8cec-442e-a3f2-5f05615a00f5</p>
<pre>
package Person;
# enable Moose-style object construction
use Moose;
 
# first name ( a string) can only be set at construction time ('ro')
has first_name =&gt; (is =&gt; 'ro', isa =&gt; 'Str', required =&gt; 1);
# last name ( a string) can only be set at construction time ('ro')
has last_name  =&gt; (is =&gt; 'ro', isa =&gt; 'Str', required =&gt; 1);
# age (Integer) can be modified after construction ('rw'), and is not required
# to be passed to be constructor.  Also creates a 'has_age' method which returns
# true if age has been set
has age        =&gt; (is =&gt; 'rw', isa =&gt; 'Int', predicate =&gt; 'has_age');
 
# Check custom requirements
sub BUILD {
      my $self = shift;
      if ($self-&gt;has_age &amp;&amp; $self-&gt;age &lt; 18) { # no under 18s
           die "No under-18 Persons";
      }
}
1;
</pre>
<p>In both cases the Person class is instiated like this:</p>
<p>WHATSON? 2ac9bae2-b979-44a5-a13e-0c2248773d57</p>
<pre>
use Person;
my $p = Person-&gt;new( first_name =&gt; 'Sam', last_name =&gt; 'Ashe', age =&gt; 42 );
</pre>
<h3>PHP</h3>
<p>In PHP version 5 and above, the constructor is a method named <code>__construct()</code> (notice that it's a double underscore), which the keyword <code>new</code> automatically calls after creating the object. It is usually used to automatically perform initializations such as property initializations. Constructors can also accept arguments, in which case, when the <code>new</code> statement is written, you also need to send the constructor arguments for the parameters.</p>
<p>WHATSON? a4b298fa-467e-44ed-87f7-22fd1b35c4ee</p>
<pre>
class Person
{
    private $name;
 
    public function __construct($name)
    {
        $this-&gt;name = $name;
    }
 
    public function getName()
    {
        return $this-&gt;name;
    }
}
</pre>
<h3>Python</h3>
<p>In Python, constructors are defined by one or both of <code>__new__</code> and <code>__init__</code> methods. A new instance is created by calling the class as if it were a function, which calls the <code>__new__</code> and <code>__init__</code> methods. If a constructor method is not defined in the class, the next one found in the class's Method Resolution Order will be called.</p>
<p>In the typical case, only the <code>__init__</code> method need be defined. (The most common exception is for immutable objects.)</p>
<p>WHATSON? e26797f4-96a6-427b-ad71-bac7c569cb21</p>
<pre>
class ExampleClass(object):
    def __new__(cls, value):
        print("Creating new instance...")
        # Call the superclass constructor to create the instance.
        instance = super(ExampleClass, cls).__new__(cls)
        return instance
    def __init__(self, value):
        print("Initialising instance...")
        self.payload = value
 
exampleInstance = ExampleClass(42)
# prints "Creating new instance..." followed by "Initialising instance..."
 
print(exampleInstance.payload)
# prints 42
</pre>
<p>Classes normally act as factories for new instances of themselves, that is, a class is a callable object (like a function), with the call being the constructor, and calling the class returns an instance of that class. However the <code>__new__</code> method is permitted to return something other than an instance of the class for specialised purposes. In that case, the <code>__init__</code> is not invoked.</p>
<h3>Ruby</h3>
<p>In Ruby, constructors are created by defining a method called <code>initialize</code>. This method is executed to initialize each new instance.</p>
<p>WHATSON? d65eba1a-3a58-413a-a16a-788e54259de7</p>
<pre>
class ExampleClass
  def initialize
    puts "Hello there"
  end
end
 
ExampleClass.new # =&gt; "Hello there"
</pre>
<h2>See also</h2>
<ul>
<li>Allocation site</li>
<li>Creational pattern</li>
<li>Destructor</li>
<li>Global constructor in C++, and its C counterpart, ((constructor)) function attribute</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Eiffel <i>routines</i> are either <i>procedures</i> or <i>functions</i>. Procedures never have a return type. Functions always have a return type.</li>
<li><b>^</b> Because the inherited class invariant must be satisfied, there is no mandatory call to the parents' constructors.</li>
<li><b>^</b> The Eiffel standard requires fields to be initialized on first access, so it is not necessary to perform default field initialization during object creation.</li>
</ol>
</body>
</html>