<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Synchronization-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Synchronization (computer science)</h1>
<p>In computer science, <b>synchronization</b> refers to one of two distinct but related concepts: synchronization of processes, and synchronization of data. <b>Process synchronization</b> refers to the idea that multiple processes are to join up or handshake at a certain point, in order to reach an agreement or commit to a certain sequence of action. <b>Data synchronization</b> refers to the idea of keeping multiple copies of a dataset in coherence with one another, or to maintain data integrity. Process synchronization primitives are commonly used to implement data synchronization.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Thread or process synchronization
<ul>
<li>1.1 See</li>
</ul>
</li>
<li>2 Data synchronization</li>
<li>3 Mathematical foundations</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<ul>
<li>1.1 See</li>
</ul>
<p></p>
<h2>Thread or process synchronization</h2>
<p>Thread synchronization or serialization, strictly defined, is the application of particular mechanisms to ensure that two concurrently-executing threads or processes do not execute specific portions of a program at the same time, referred to as mutual exclusion. If one thread has begun to execute a serialized portion of the program called a critical section, any other thread trying to execute this portion must wait until the first thread finishes. If such synchronization measures are not taken, it can result in a race condition where variable values are unpredictable and depend on the timings of the thread or process context switch.</p>
<p>In addition to providing mutual exclusion, synchronization must also guard against the following:</p>
<ul>
<li>Deadlock : This happens when two or more processes or threads are waiting for a lock to enter a critical section, which the other process is holding. This results in them indefinitely stalling and them making no further progress.</li>
<li>Starvation: In some instances, a process or thread could have unbounded waiting time to acquire a lock and never make any progress.</li>
<li>Priority inversion: In systems that have priorities for processes and threads, a medium priority task can pre-empt a higher priority task when using synchronization thereby violating the system rules. This is especially severe in real time systems which can cause missed deadlines.</li>
</ul>
<p>Synchronization is used to control access to state both in small-scale multiprocessing systems -- in multithreaded environments and multiprocessor computers -- and in distributed computers consisting of thousands of units -- in banking and database systems, in web servers, and so on.</p>
<h3>See</h3>
<ul>
<li>Lock (computer science) and mutex</li>
<li>Monitor (synchronization)
<ul>
<li>Synchronization primitives</li>
</ul>
</li>
<li>Semaphore (programming)</li>
<li>Test-and-set</li>
<li>Simple Concurrent Object-Oriented Programming (SCOOP)</li>
</ul>
<ul>
<li>Synchronization primitives</li>
</ul>
<h2>Data synchronization</h2>
<p>A distinctly different (but related) concept is that of <b>data synchronization</b>. This refers to the need to keep multiple copies of a set of data coherent with one another.</p>
<p>Examples include:</p>
<ul>
<li>File synchronization, such as syncing a hand-held MP3 player to a desktop computer.</li>
<li>Cluster file systems, which are file systems that maintain data or indexes in a coherent fashion across a whole computing cluster.</li>
<li>Cache coherency, maintaining multiple copies of data in sync across multiple caches.</li>
<li>RAID, where data is written in a redundant fashion across multiple disks, so that the loss of any one disk does not lead to a loss of data.</li>
<li>Database replication, where copies of data on a database are kept in sync, despite possible large geographical separation.</li>
<li>Journaling, a technique used by many modern file systems to make sure that file metadata are updated on a disk in a coherent, consistent manner.</li>
</ul>
<h2>Mathematical foundations</h2>
<p>Synchronization was originally a process based concept whereby a lock could be obtained on an object. Its primary usage was in databases. There are two types of (file) lock; read-only and read-write. Read-only locks may be obtained by many processes or threads. Read-write locks are exclusive, as they may only be used by a single process/thread at a time.<br>
Although locks were derived for file databases, data is also shared in memory between processes and threads. Sometimes more than one object (or file) is locked at a time. If they are not locked simultaneously they can overlap, causing a deadlock exception.<br>
Java and Ada only have exclusive locks because they are thread based and rely on the compare-and-swap processor instruction (see mutex).<br>
An abstract mathematical foundation for synchronization primitives is given by the history monoid. There are also many higher-level theoretical devices, such as process calculi and Petri nets, which can be built on top of the history monoid.</p>
<h2>See also</h2>
<ul>
<li>Futures and promises, synchronization mechanisms in pure functional paradigms.</li>
</ul>
</body>
</html>