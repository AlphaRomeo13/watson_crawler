<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Namespace---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Namespace</h1>
<p>In general, a <b>namespace</b> is a container for a set of identifiers (also known as symbols, names). Namespaces provide a level of direction to specific identifiers, thus making it possible to distinguish between identifiers with the same exact name. For example, a surname could be thought of as a namespace that makes it possible to distinguish people who have the same given name. In computer programming, namespaces are typically employed for the purpose of grouping symbols and identifiers around a particular functionality.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Explanation for beginners
<ul>
<li>1.1 Name conflicts
<ul>
<li>1.1.1 Solution via prefix</li>
</ul>
</li>
</ul>
</li>
<li>2 Naming system
<ul>
<li>2.1 Examples</li>
<li>2.2 Delegation</li>
<li>2.3 Hierarchy</li>
<li>2.4 Namespace versus scope</li>
</ul>
</li>
<li>3 In programming languages
<ul>
<li>3.1 Computer science considerations
<ul>
<li>3.1.1 Use in common languages</li>
</ul>
</li>
<li>3.2 Emulating namespaces</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<ul>
<li>1.1 Name conflicts
<ul>
<li>1.1.1 Solution via prefix</li>
</ul>
</li>
</ul>
<ul>
<li>1.1.1 Solution via prefix</li>
</ul>
<ul>
<li>2.1 Examples</li>
<li>2.2 Delegation</li>
<li>2.3 Hierarchy</li>
<li>2.4 Namespace versus scope</li>
</ul>
<ul>
<li>3.1 Computer science considerations
<ul>
<li>3.1.1 Use in common languages</li>
</ul>
</li>
<li>3.2 Emulating namespaces</li>
</ul>
<ul>
<li>3.1.1 Use in common languages</li>
</ul>
<p></p>
<h2>Explanation for beginners</h2>
<h3>Name conflicts</h3>
<p>Element names are defined by the developer. This often results in a conflict when trying to mix XML documents from different XML applications.</p>
<p>This XML carries HTML table information:</p>
<p>WHATSON? 4377db12-3505-4884-99ed-8d4d7d6625ea</p>
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Apples&lt;/td&gt;
    &lt;td&gt;Bananas&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<p>This XML carries information about a table (i.e. a piece of furniture):</p>
<p>WHATSON? 7496651b-6754-45dc-a27f-8c62bc3c86a3</p>
<pre>
&lt;table&gt;
  &lt;name&gt;African Coffee Table&lt;/name&gt;
  &lt;width&gt;80&lt;/width&gt;
  &lt;length&gt;120&lt;/length&gt;
&lt;/table&gt;
</pre>
<p>If these XML fragments were added together, there would be a name conflict. Both contain a &lt;table&gt; element, but the elements have different content and meaning.</p>
<p>An XML parser will not know how to handle these differences.</p>
<h4>Solution via prefix</h4>
<p>Name conflicts in XML can easily be avoided using a name prefix.</p>
<p>This XML carries information about an HTML table and a piece of furniture:</p>
<p>WHATSON? a258276c-6b78-4399-a88d-79ccd131fde2</p>
<pre>
&lt;h:table&gt;
  &lt;h:tr&gt;
    &lt;h:td&gt;Apples&lt;/h:td&gt;
    &lt;h:td&gt;Bananas&lt;/h:td&gt;
  &lt;/h:tr&gt;
&lt;/h:table&gt;
 
&lt;f:table&gt;
  &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
  &lt;f:width&gt;80&lt;/f:width&gt;
  &lt;f:length&gt;120&lt;/f:length&gt;
&lt;/f:table&gt;
</pre>
<h2>Naming system</h2>
<p>A name in a namespace consists of a namespace identifier and a local name. The namespace name is usually applied as a prefix to the local name.</p>
<p>In Augmented Backus-Naur Form:</p>
<p>WHATSON? 36b6307a-eb55-43d7-b8ea-cfda16220872</p>
<pre>
name = &lt;namespace identifier&gt; separator &lt;local name&gt;
</pre>
<p>When local names are used by themselves, name resolution is used to decide which (if any) particular item is alluded to by some particular local name.</p>
<h3>Examples</h3>
<h3>Delegation</h3>
<p>Delegation of responsibilities between parties is important real-world applications, such as the structure of the World wide web. Namespaces allow delegation of identifier assignment to multiple name issuing organisations whilst retaining global uniqueness. A central Registration authority registers the assigned namespace identifiers allocated. Each namespace identifier is allocated to an organisation which is subsequently responsible for the assignment of names in their allocated namespace. This organisation may be a name issuing organisation that assign the names themselves, or another Registration authority which further delegates parts of their namespace to different organisations.</p>
<h3>Hierarchy</h3>
<p>A naming scheme that allows subdelegation of namespaces to third parties is a hierarchical namespace</p>
<p>A hierarchy is recursive if the syntax for the namespace identifiers is the same for each subdelegation. An example of a recursive hierarchy is the Domain name system.</p>
<p>An example of a non-recursive hierarchy are Uniform resource name representing an [Internet Assigned Numbers Authority]] (ISBN) number.</p>
<h3>Namespace versus scope</h3>
<p>A namespace identifier may provide context (<i>Scope</i> in computer science) to a name, and the terms are sometimes used interchangeably. However, the context of a name may also be provided by other factors, such as the location where it occurs or the syntax of the name.</p>
<h2>In programming languages</h2>
<p>For many programming languages, namespace is a context for their identifiers. In an operating system, an example of namespace is a directory. Each name in a directory uniquely identifies one file or subdirectory, but one file may have the same name multiple times.</p>
<p>As a rule, names in a namespace cannot have more than one meaning; that is, different meanings cannot share the same name in the same namespace. A namespace is also called a context, because the same name in different namespaces can have different meanings, each one appropriate for its namespace.</p>
<p>Following are other characteristics of namespaces:</p>
<ul>
<li>Names in the namespace can represent objects as well as concepts, be the namespace a natural or ethnic language, a constructed language, the technical terminology of a profession, a dialect, a sociolect, or an artificial language (e.g., a programming language).</li>
<li>In the Java programming language, identifiers that appear in namespaces have a short (local) name and a unique long "qualified" name for use outside the namespace.</li>
<li>Some compilers (for languages such as C++) combine namespaces and names for internal use in the compiler in a process called <i>name mangling</i>.</li>
</ul>
<p>Below is an example of a namespace in C++:</p>
<p>WHATSON? a97fc7c8-0e8f-4747-94ec-9b1b948e353c</p>
<pre>
namespace Box1{
   int boxSide = 4;
}
 
namespace Box2{
   int boxSide = 12; 
}
 
int main () {
  int boxSide = 42;
  cout &lt;&lt; Box1::boxSide &lt;&lt; endl;  //output 4
  cout &lt;&lt; Box2::boxSide &lt;&lt; endl;  //output 12
  cout &lt;&lt; boxSide &lt;&lt; endl;  // output 42
  return 0;
}
</pre>
<h3>Computer science considerations</h3>
<p>A namespace in computer science (sometimes also called a <b>name scope</b>), is an abstract container or environment created to hold a logical grouping of unique identifiers or symbols (i.e., names). An identifier defined in a namespace is associated only with that namespace. The same identifier can be independently defined in multiple namespaces. That is, the meaning associated with an identifier defined in one namespace may or may not have the same meaning as the same identifier defined in another namespace. Languages that support namespaces specify the rules that determine to which namespace an identifier (not its definition) belongs.</p>
<p>This concept can be illustrated with an analogy. Imagine that two companies, X and Y, each assign ID numbers to their employees. X should not have two employees with the same ID number, and likewise for Y; but it is not a problem for the same ID number to be used at both companies. For example, if Bill works for company X and Jane works for company Y, then it is not a problem for each of them to be employee #123. In this analogy, the ID number is the identifier, and the company serves as the namespace. It does not cause problems for the same identifier to identify a different person in each namespace.</p>
<p>In large computer programs or documents it is not uncommon to have hundreds or thousands of identifiers. Namespaces (or a similar technique, see Emulating namespaces) provide a mechanism for hiding local identifiers. They provide a means of grouping logically related identifiers into corresponding namespaces, thereby making the system more modular.</p>
<p>Data storage devices and many modern programming languages support namespaces. Storage devices use directories (or folders) as namespaces. This allows two files with the same name to be stored on the device so long as they are stored in different directories. In some programming languages (e.g. C++, Python), the identifiers naming namespaces are themselves associated with an enclosing namespace. Thus, in these languages namespaces can nest, forming a namespace tree. At the root of this tree is the unnamed <b>global namespace</b>.</p>
<h4>Use in common languages</h4>
<p>In C++, a namespace is defined with a namespace block.</p>
<p>WHATSON? fbf7c4d9-597b-4402-a7dd-0b73ffa58d1d</p>
<pre>
namespace abc {
 int bar;
}
</pre>
<p>Within this block, identifiers can be used exactly as they are declared. Outside of this block, the namespace specifier must be prefixed. For example, outside of <code>namespace abc</code>, <code>bar</code> must be written <code>abc::bar</code> to be accessed. C++ includes another construct that makes this verbosity unnecessary. By adding the line</p>
<p>WHATSON? 47b74264-f4a9-40ad-b320-8bf5a336cd1a</p>
<pre>
using namespace abc;
</pre>
<p>to a piece of code, the prefix <code>abc::</code> is no longer needed.</p>
<p>Code that is not explicitly declared within a namespace is considered to be in the global namespace.</p>
<p>Namespace resolution in C++ is hierarchical. This means that within the hypothetical namespace <code>food::soup</code>, the identifier <code>chicken</code> refers to <code>food::soup::chicken</code>. If <code>food::soup::chicken</code> doesn't exist, it then refers to <code>food::chicken</code>. If neither <code>food::soup::chicken</code> nor <code>food::chicken</code> exist, <code>chicken</code> refers to <code>::chicken</code>, an identifier in the global namespace.</p>
<p>Namespaces in C++ are most often used to avoid naming collisions. Although namespaces are used extensively in recent C++ code, most older code does not use this facility. For example, the entire C++ standard library is defined within <code>namespace std</code>, but before standardization many components were originally in the global namespace.</p>
<p>In Java, the idea of a namespace is embodied in Java packages. All code belongs to a package, although that package need not be explicitly named. Code from other packages is accessed by prefixing the package name before the appropriate identifier, for example <code>class String</code> in <code>package java.lang</code> can be referred to as <code>java.lang.String</code> (this is known as the fully qualified class name). Like C++, Java offers a construct that makes it unnecessary to type the package name (<code>import</code>). However, certain features (such as reflection) require the programmer to use the fully qualified name.</p>
<p>Unlike C++, namespaces in Java are not hierarchical as far as the syntax of the language is concerned. However, packages are named in a hierarchical manner. For example, all packages beginning with <code>java</code> are a part of the Java platform—the package <code>java.lang</code> contains classes core to the language, and <code>java.lang.reflect</code> contains core classes specifically relating to reflection.</p>
<p>In Java (and Ada, C#, and others), namespaces/packages express semantic categories of code. For example, in C#, <code>namespace System</code> contains code provided by the system (the .NET Framework). How specific these categories are and how deep the hierarchies go differ from language to language.</p>
<p>Function and class scopes can be viewed as implicit namespaces that are inextricably linked with visibility, accessibility, and object lifetime.</p>
<p>Namespaces are heavily used in C# language. All .NET Framework classes are organized in namespaces, to be used more clearly and to avoid chaos. Furthermore, custom namespaces are extensively used by programmers, both to organize their work and to avoid naming collisions. When referencing a class, one should specify either its fully qualified name, which means namespace followed by the class name,</p>
<p>WHATSON? cd976b98-df5b-4555-a13c-1efbcb604dab</p>
<pre>
System.Console.WriteLine("Hello World!");
int i = System.Convert.ToInt32("123");
</pre>
<p>or add a <b>using</b> statement. This, eliminates the need to mention the complete name of all classes in that namespace.</p>
<p>WHATSON? f02a3708-e485-48c6-90d3-c260ed9bfb0d</p>
<pre>
using System;
.
.
.
Console.WriteLine("Hello World!");
int i = Convert.ToInt32("123");
</pre>
<p>In the above examples, <b>System</b> is a namespace, and <b>Console</b> and <b>Convert</b> are classes defined within <b>System</b>.</p>
<p>In Python, namespaces are defined by the individual modules, and since modules can be contained in hierarchical packages, then name spaces are hierarchical too. In general when a module is imported then the names defined in the module are defined via that module's name space, and are accessed in from the calling modules by using the fully qualified name.</p>
<p>WHATSON? d39ec63d-f581-4b74-ac8a-83f64c9e262d</p>
<pre>
# assume modulea defines two functions : func1() and func2() and one class : class1
import modulea
 
modulea.func1()
modulea.func2()
a = modulea.class1()
</pre>
<p>The "from ... import ..." can be used to insert the relevant names directly into the calling module's namespace, and those names can be accessed from the calling module without the qualified name :</p>
<p>WHATSON? a70f28a3-bfc1-4003-bde8-e76461f00c7b</p>
<pre>
# assume modulea defines two functions : func1() and func2() and one class : class1
from modulea import func1
 
func1()
func2() # this will fail as an undefined name, as will the full name modulea.func2()
a = class1() # this will fail as an undefined name, as will the full name modulea.class1()
</pre>
<p>Since this directly imports names (without qualification) it can overwrite existing names with no warnings.</p>
<p>A special form is "from ... import *", which imports all names defined in the named package directly in the calling modules namespace. Use of this form of import, although supported within the language, is generally discouraged as it pollutes the namespace of the calling module and will cause already defined names to be overwritten in the case of name clashes.</p>
<p>Python also supports "import x as y" as a way of providing an alias or alternative name for use by the calling module:</p>
<p>WHATSON? 49cf66d8-69bc-4319-bfe3-98192bb2e0cd</p>
<pre>
import numpy as np
a = np.arange(1000)
</pre>
<p>In XML, the XML namespace specification enables the names of elements and attributes in an XML document to be unique, similar to the role of namespaces in programming languages. Using XML namespaces, XML documents may contain element or attribute names from more than one XML vocabulary.</p>
<p>Namespaces were introduced into PHP from version 5.3 onwards. Naming collision of classes, functions and variables can be avoided. In PHP, a namespace is defined with a namespace block.</p>
<p>WHATSON? 525fe768-16b0-4f7d-9294-5755978994e4</p>
<pre>
# assume this is a class file defines two functions : foo() and bar()
# location of the file phpstar/foobar.php
namespace phpstar;
class fooBar
{
    public function foo()
    {
	echo 'hello world, from function foo';
    }
 
    public function bar()
    {
	echo 'hello world, from function bar';
    }
}
</pre>
<p>We can reference a PHP namespace with the following different ways:</p>
<p>WHATSON? b21c92d4-7a73-4e04-ba2b-c114c8777097</p>
<pre>
# location of the file index.php
# Include the file
include "phpstar/foobar.php";
 
# Option 1: directly prefix the class name with the namespace
$obj_foobar = new \phpstar\fooBar();
 
# Option 2: import the namespace
use phpstar\fooBar;
$obj_foobar = new fooBar();
 
# Option 2a: import &amp; alias the namespace
use phpstar\fooBar as FB;
$obj_foobar = new FB();
 
# Access the properties and methods with regular way
$obj_foobar-&gt;foo();
$obj_foobar-&gt;bar();
</pre>
<h3>Emulating namespaces</h3>
<p>In programming languages lacking language support for namespaces, namespaces can be emulated to some extent by using an identifier naming convention. For example, C libraries such as Libpng often use a fixed prefix for all functions and variables that are part of their exposed interface. Libpng exposes identifiers such as:</p>
<p>WHATSON? 20d8f5c6-0930-4fde-b85b-74f220793e04</p>
<pre>
png_create_write_struct
png_get_signature
png_read_row
png_set_invalid
</pre>
<p>This naming convention provides reasonable assurance that the identifiers are unique and can therefore be used in larger programs without fear of identifier naming collisions. Likewise, many packages originally written in Fortran (e.g., BLAS, LAPACK) reserve the first few letters of a function's name to indicate which group it belongs to.</p>
<p>Unfortunately, this technique has several drawbacks:</p>
<ul>
<li>It doesn't scale well to nested namespaces; identifiers become excessively long.</li>
<li>Individuals or organizations may use dramatically inconsistent naming conventions, potentially introducing unwanted obfuscation.</li>
<li>Compound or 'query-based' operations on groups of identifiers, based on the namespaces in which they are declared, are rendered unwieldy or unfeasible.</li>
<li>All uses of the identifiers must, in effect, be fully namespace-qualified. Languages with direct support for namespaces usually provide ways for the programmer to declare up front that they wish to use some or all identifiers from a specific namespace, which they can then use without qualification for the remainder of the block.</li>
<li>In languages in which identifier length is restricted, the use of prefixes limits the number of characters that can be used to identify what the function does. This is a particular problem for packages originally written in FORTRAN 77, which offered only 6 characters per identifier. For example, the name of the BLAS function <code>DGEMM</code> function indicates that it operates on double precision numbers ('D') and general matrices ('GE'), and only the last two characters show what it actually does: matrix-matrix multiplication (the 'MM').</li>
</ul>
<h2>See also</h2>
<ul>
<li>11-Digit Delivery point ZIP code</li>
<li>Binomial nomenclature (genus-species in biology)</li>
<li>Chemical nomenclature</li>
<li>Dewey Decimal Classification</li>
<li>Digital object identifier</li>
<li>Domain name system (DNS) names (Internet addresses)</li>
<li>Identity (object-oriented programming)</li>
<li>IP address</li>
<li>Library of Congress Classification</li>
<li>Category:National identification numbers</li>
<li>Star catalogues and astronomical naming conventions</li>
<li>XML Namespaces</li>
</ul>
</body>
</html>