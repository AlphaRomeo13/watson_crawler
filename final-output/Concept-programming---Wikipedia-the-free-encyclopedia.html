<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Concept-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Concept programming</h1>
<p><b>Concept programming</b> is a programming paradigm focusing on how <i>concepts</i>, that live in the programmer's mind, translate into <i>representations</i> that are found in the code space. This approach was introduced in 2001 by Christophe de Dinechin with the XL Programming Language.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Pseudo-metrics</li>
<li>2 Rule of equivalence, equivalence breakdown</li>
<li>3 Methodology</li>
<li>4 Languages</li>
<li>5 Similar works</li>
<li>6 See also</li>
<li>7 External links</li>
</ul>
<p></p>
<h2>Pseudo-metrics</h2>
<p>Concept programming uses <i>pseudo-metrics</i> to evaluate the quality of code. They are called pseudo-metrics because they relate the concept space and the code space, with a clear understanding that the concept space cannot be formalized strictly enough for a real metric to be defined. Concept programming pseudo-metrics include:</p>
<ul>
<li><i>Syntactic noise</i> measures discrepancies between the concept and the syntax used to represent it. For instance, the semi-colon at the end of statements in C can be considered as syntactic noise, because it has no equivalent in the concept space.</li>
<li><i>Semantic noise</i> measures discrepancies between the expected meaning or behavior of the concept and its actual meaning or behavior in the code. For instance, the fact that integer data types overflow (when mathematical integers do not) is a form of semantic noise.</li>
<li><i>Bandwidth</i> measures how much of the concept space a given code construct can represent. For instance, the overloaded addition operator in C has higher bandwidth than the <code>Add</code> instruction in assembly language, because the C operator can represent addition on floating-point numbers and not just integer numbers.</li>
<li><i>Signal/noise ratio</i> measures what fraction of the code space is used for representing actual concepts, as opposed to implementation information.</li>
</ul>
<h2>Rule of equivalence, equivalence breakdown</h2>
<p>The <i>rule of equivalence</i> is verified when the code behavior matches the original concept. This equivalence may break down in many cases. Integer overflow breaks the equivalence between the mathematical integer concept and the computerized approximation of the concept.</p>
<p>Many ways to break the equivalence have been given specific names, because they are very common:</p>
<ul>
<li>A <i>domain error</i> is a condition where code executes outside of the <i>domain of equivalence</i>, which is the domain where the concept and the implementation match. An integer overflow is an example of domain error.</li>
<li>A <i>concept cast</i> (also <i>concept recast</i> or <i>concept recasting</i>) is a rewrite of a concept as a different concept because the original concept cannot be represented by the tools. In C, using pointers for output arguments because C doesn't support output arguments explicitly is an example of concept cast.</li>
<li>A <i>priority inversion</i> is a form of syntactic or semantic noise introduced by some language-enforced general rule. It is called a priority inversion because the language takes precedence over the concept. In Smalltalk, everything is an object, and that rule leads to the undesirable consequence that an expression like 2+3*5 doesn't obey the usual order of operations (Smalltalk interprets this as sending the message * to the number resulting from 2+3, which yields result 25 instead of 17).</li>
</ul>
<h2>Methodology</h2>
<p>To write code, concept programming recommends the following steps:</p>
<ol>
<li>Identify and define the relevant concepts in the concept space.</li>
<li>Identify traditional notations for the concepts, or invent usable notations.</li>
<li>Identify a combination of programming constructs that allows the concepts to be represented comfortably in code - That includes finding a code notation that matches the notation identified in the previous step as closely as possible.</li>
<li>Write code that preserves, as much as possible, the expected behavior and semantics of the relevant aspects of the original concept.</li>
</ol>
<p>Many programming tools often lack in notational abilities, thus concept programming sometimes requires the use of preprocessors, domain-specific languages, or metaprogramming techniques.</p>
<h2>Languages</h2>
<p>XL is the only programming language known to date to be explicitly created for concept programming, but concept programming can be done in nearly any language, with varying degrees of success. Lisp and Forth (and their derivatives) are examples of pre-existing languages which lend themselves well to concept programming.</p>
<h2>Similar works</h2>
<p>There are projects that exploit similar ideas to create code with higher level of abstraction. Among them are:</p>
<ul>
<li>Intentional Programming</li>
<li>Language-oriented programming</li>
<li>Literate programming</li>
<li>Model-driven architecture</li>
</ul>
<h2>See also</h2>
<ul>
<li>Programming paradigms</li>
<li>Automatic programming</li>
<li>Artefaktur (AAL)</li>
<li>Abstract syntax tree (AST)</li>
<li>Language syntax tree (LST)</li>
<li>Semantic resolution tree (RST)</li>
<li>Interpretation syntax tree (IST)</li>
<li>Code generation syntax tree (CST)</li>
<li>Domain-specific programming language</li>
</ul>
<h2>External links</h2>
<ul>
<li>The XL Programming Language on SourceForge</li>
<li>A presentation of Concept Programming</li>
<li>An interview about Concept Programming on The Register</li>
</ul>
</body>
</html>