<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Garbage-computer-science---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Garbage (computer science)</h1>
<p><b>Garbage</b>, in the context of computer science, refers to objects, data, or other regions of the memory of a computer system (or other system resources), which will not be used in any future computation by the system, or by a program running on it. As computer systems all have finite amounts of memory, it is frequently necessary to <i>deallocate</i> garbage and return it to the heap, or memory pool, so the underlying memory can be reused.</p>
<h2>Classification</h2>
<p>Garbage is generally classified into two types:</p>
<p>Note that syntactic garbage is a (usually strict) subset of semantic garbage as it is entirely possible for an object to hold a reference to another object without the latter object being used. Determination of the semantic garbage present in a program is generally undecidable, but there are many algorithms for identifying syntactic garbage.</p>
<p>Objects and/or data which are not garbage are said to be <i>live</i>.</p>
<h2>Eliminating garbage</h2>
<p>The problem of managing the deallocation of garbage is a well-known one in computer science. Several approaches are taken:</p>
<ul>
<li>Many operating systems will reclaim the memory and resources used by a process or program when it terminates. Simple or short-lived programs which are designed to run in such environments can exit and allow the operating system to perform any necessary reclamation.</li>
<li>In systems or programming languages with manual memory management, the programmer must explicitly arrange for memory to be deallocated when it is no longer used. C and C++ are two well-known languages which support this model.</li>
<li>Garbage collection uses various algorithms to automatically analyze the state of a program, identify garbage, and deallocate it without intervention by the programmer. Many modern programming languages such as Java and Haskell provide automated garbage collection. However, it is not a recent development, as it has also been used in older languages such as LISP.</li>
<li>There is ongoing research to type theoretic approaches (such as region inference) to identification and removal of garbage from a program. Note that no general type-theoretic solution to the problem has been developed.</li>
</ul>
<p>An example of the automatic removal of semantic garbage, by reference counting garbage collection, can be produced using the Python command-line interpreter:</p>
<p>WHATSON? fc2b712c-027e-446d-a6c9-1ec44ee898f3</p>
<pre>
&gt;&gt;&gt; class Foo(object):
...     'This is an empty testing class.'
...     pass
... 
&gt;&gt;&gt; bar = Foo()
&gt;&gt;&gt; bar
&lt;__main__.Foo object at 0x54f30&gt;
&gt;&gt;&gt; del bar
</pre>
<p>In this session, an object is created, its location in the memory is displayed, and the only reference to the object is then destroyedâ€”there is no way to ever use the object again from this point on, as there are no references to it. This becomes apparent when we try to access the original reference:</p>
<p>WHATSON? 850a6be6-f2a0-4cf1-9536-fd4f75f913ce</p>
<pre>
&gt;&gt;&gt; bar
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: name 'bar' is not defined
</pre>
<p>As it is impossible to refer to the object, it has become useless: the object is garbage. Since Python uses garbage collection, it automatically deallocates the memory that was used for the object so that it may be used again:</p>
<p>WHATSON? 1cb15a2c-d279-4f0b-8c88-ba5800b13ba4</p>
<pre>
&gt;&gt;&gt; class Bar(object):
...     'This is another testing class.'
...     pass
... 
&gt;&gt;&gt; baz = Bar()
&gt;&gt;&gt; baz
&lt;__main__.Bar object at 0x54f30&gt;
</pre>
<p>Note that the <tt>Bar</tt> instance now resides at the memory location <tt>0x54f30</tt>; at the same place as where our previous object, the <tt>Foo</tt> instance, was located. Since the <tt>Foo</tt> instance was destroyed, freeing up the memory used to contain it, the interpreter creates the <tt>Bar</tt> object at the same memory location as before, making good use of the available resources.</p>
<h2>External links</h2>
<ul>
<li>Benjamin Pierce (editor), <i>Advanced Topics in Types and Programming Languages</i>, MIT Press (2005), ISBN 0-262-16228-8</li>
<li>Richard Jones and Rafael Lins, <i>Garbage Collection: Algorithms for Automated Dynamic Memory Management</i>, Wiley and Sons (1996), ISBN 0-471-94148-4</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>Memory management as a function of an operating system</li>
</ul>
<ul>
<li>Static memory allocation</li>
<li>C dynamic memory allocation</li>
<li>new (C++)</li>
<li>delete (C++)</li>
</ul>
<ul>
<li>Demand paging</li>
<li>Page table</li>
<li>Paging</li>
</ul>
<ul>
<li>Memory management unit</li>
<li>Translation lookaside buffer</li>
</ul>
<ul>
<li>Boehm garbage collector</li>
<li>Finalizer</li>
<li><strong class="selflink">Garbage</strong></li>
<li>Mark-compact algorithm</li>
<li>Reference counting</li>
<li>Strong reference</li>
<li>Weak reference</li>
</ul>
<ul>
<li>Protected mode</li>
<li>Real mode</li>
<li>Virtual 8086 mode</li>
<li>x86 memory segmentation</li>
</ul>
<ul>
<li>Buffer overflow</li>
<li>Buffer over-read</li>
<li>Dangling pointer</li>
<li>Stack overflow</li>
</ul>
<ul>
<li>Fragmentation</li>
<li>Memory leak</li>
<li>Unreachable memory</li>
</ul>
<ul>
<li>Automatic variable</li>
<li>International Symposium on Memory Management</li>
<li>Region-based memory management</li>
</ul>
</body>
</html>