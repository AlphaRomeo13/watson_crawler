<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Spanning-tree---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Spanning tree</h1>
<p>In the mathematical field of graph theory, a <b>spanning tree</b> <i>T</i> of a connected, undirected graph <i>G</i> is a tree that includes all of the vertices and some of the edges of <i>G</i> such that it becomes a tree, i.e, it contains no more cycles.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Definitions
<ul>
<li>1.1 Fundamental cycles</li>
<li>1.2 Fundamental cutsets</li>
<li>1.3 Spanning forests</li>
</ul>
</li>
<li>2 Counting spanning trees
<ul>
<li>2.1 In specific graphs</li>
<li>2.2 In arbitrary graphs</li>
<li>2.3 Deletion-contraction</li>
<li>2.4 Tutte polynomial</li>
</ul>
</li>
<li>3 Algorithms
<ul>
<li>3.1 Construction</li>
<li>3.2 Optimization</li>
<li>3.3 Randomization</li>
<li>3.4 Enumeration</li>
</ul>
</li>
<li>4 In infinite graphs</li>
<li>5 Notes</li>
</ul>
<ul>
<li>1.1 Fundamental cycles</li>
<li>1.2 Fundamental cutsets</li>
<li>1.3 Spanning forests</li>
</ul>
<ul>
<li>2.1 In specific graphs</li>
<li>2.2 In arbitrary graphs</li>
<li>2.3 Deletion-contraction</li>
<li>2.4 Tutte polynomial</li>
</ul>
<ul>
<li>3.1 Construction</li>
<li>3.2 Optimization</li>
<li>3.3 Randomization</li>
<li>3.4 Enumeration</li>
</ul>
<p></p>
<h2>Definitions</h2>
<p>A tree is a connected undirected graph with no cycles. It is a spanning tree of a graph <i>G</i> if it spans <i>G</i> (that is, it includes every vertex of <i>G</i>) and is a subgraph of <i>G</i> (every edge in the tree belongs to <i>G</i>). A spanning tree of a connected graph <i>G</i> can also be defined as a maximal set of edges of <i>G</i> that contains no cycle, or as a minimal set of edges that connect all vertices.</p>
<h3>Fundamental cycles</h3>
<p>Adding just one edge to a spanning tree will create a cycle; such a cycle is called a <b>fundamental cycle</b>. There is a distinct fundamental cycle for each edge; thus, there is a one-to-one correspondence between fundamental cycles and edges not in the spanning tree. For a connected graph with <i>V</i> vertices, any spanning tree will have <i>V</i> − 1 edges, and thus, a graph of <i>E</i> edges and one of its spanning trees will have <i>E</i> − <i>V</i> + 1 fundamental cycles. For any given spanning tree the set of all <i>E</i> − <i>V</i> + 1 fundamental cycles forms a cycle basis, a basis for the cycle space.</p>
<h3>Fundamental cutsets</h3>
<p>Dual to the notion of a fundamental cycle is the notion of a <b>fundamental cutset</b>. By deleting just one edge of the spanning tree, the vertices are partitioned into two disjoint sets. The fundamental cutset is defined as the set of edges that must be removed from the graph <i>G</i> to accomplish the same partition. Thus, each spanning tree defines a set of <i>V</i> − 1 fundamental cutsets, one for each edge of the spanning tree.</p>
<p>The duality between fundamental cutsets and fundamental cycles is established by noting that cycle edges not in the spanning tree can only appear in the cutsets of the other edges in the cycle; and <i>vice versa</i>: edges in a cutset can only appear in those cycles containing the edge corresponding to the cutset. This duality can also be expressed using the theory of matroids, according to which a spanning tree is a base of the graphic matroid, a fundamental cycle is the unique circuit within the set formed by adding one element to the base, and fundamental cutsets are defined in the same way from the dual matroid.</p>
<h3>Spanning forests</h3>
<p>In graphs that are not connected, there can be no spanning tree, and one must consider <b>spanning forests</b> instead. Here there are two competing definitions:</p>
<ul>
<li>Some authors consider a spanning forest to be a maximal acyclic subgraph of the given graph, or equivalently a graph consisting of a spanning tree in each connected component of the graph.</li>
<li>For other authors, a spanning forest is a forest that spans all of the vertices, meaning only that each vertex of the graph is a vertex in the forest. For this definition, even a connected graph may have a disconnected spanning forest, such as the forest in which each vertex forms a single-vertex tree.</li>
</ul>
<p>To avoid confusion between these two definitions, Gross &amp; Yellen (2005) suggest the term "full spanning forest" for a spanning forest with the same connectivity as the given graph, while Bondy &amp; Murty (2008) instead call this kind of forest a "maximal spanning forest".</p>
<h2>Counting spanning trees</h2>
<p>The number <i>t</i>(<i>G</i>) of spanning trees of a connected graph is a well-studied invariant.</p>
<h3>In specific graphs</h3>
<p>In some cases, it is easy to calculate <i>t</i>(<i>G</i>) directly:</p>
<ul>
<li>If <i>G</i> is itself a tree, then <i>t</i>(<i>G</i>) = 1.</li>
<li>When <i>G</i> is the cycle graph <i>C<sub>n</sub> with</i> n <i>vertices, then</i> t<i>(</i>G<i>) = </i>n<i>.</i></li>
<li>For a complete graph with <i>n</i> vertices, Cayley's formula gives the number of spanning trees as <i>n</i>.</li>
<li>If <i>G</i> is the complete bipartite graph <img class="mwe-math-fallback-image-inline tex" alt="K_{p,q}" src="//upload.wikimedia.org/math/f/2/2/f228d44c0ad5dceb4a753103de1d7d9b.png">, then <img class="mwe-math-fallback-image-inline tex" alt="t(G)=p^{q-1}q^{p-1}" src="//upload.wikimedia.org/math/3/a/b/3ab55db925a813d8d6753d077c66909f.png">.</li>
<li>For the <i>n</i>-dimensional hypercube graph <img class="mwe-math-fallback-image-inline tex" alt="Q_n" src="//upload.wikimedia.org/math/c/c/2/cc2a8613d2fc6fe9c1918e15d284bb8d.png">, the number of spanning trees is <img class="mwe-math-fallback-image-inline tex" alt="t(G)=2^{2^n-n-1}\prod_{k=2}^n k^{{n\choose k}}" src="//upload.wikimedia.org/math/0/b/5/0b59ed3e25449bef1d634aaa1c058205.png">.</li>
</ul>
<h3>In arbitrary graphs</h3>
<p>More generally, for any graph <i>G</i>, the number <i>t</i>(<i>G</i>) can be calculated in polynomial time as the determinant of a matrix derived from the graph, using Kirchhoff's matrix-tree theorem.</p>
<p>Specifically, to compute <i>t</i>(<i>G</i>), one constructs a square matrix in which the rows and columns are both indexed by the vertices of <i>G</i>. The entry in row <i>i</i> and column <i>j</i> is one of three values:</p>
<ul>
<li>The degree of vertex <i>i</i>, if <i>i</i> = <i>j</i>,</li>
<li>−1, if vertices <i>i</i> and <i>j</i> are adjacent, or</li>
<li>0, if vertices <i>i</i> and <i>j</i> are different from each other but not adjacent.</li>
</ul>
<p>The resulting matrix is singular, so its determinant is zero. However, deleting the row and column for an arbitrarily chosen vertex leads to a smaller matrix whose determinant is exactly <i>t</i>(<i>G</i>).</p>
<h3>Deletion-contraction</h3>
<p>If <i>G</i> is a graph or multigraph and <i>e</i> is an arbitrary edge of <i>G</i>, then the number <i>t</i>(<i>G</i>) of spanning trees of <i>G</i> satisfies the <i>deletion-contraction recurrence</i> <i>t</i>(<i>G</i>) = <i>t</i>(<i>G</i> − <i>e</i>) + <i>t</i>(<i>G</i>/<i>e</i>), where <i>G</i> − <i>e</i> is the multigraph obtained by deleting <i>e</i> and <i>G</i>/<i>e</i> is the contraction of <i>G</i> by <i>e</i>. The term <i>t</i>(<i>G</i> − <i>e</i>) in this formula counts the spanning trees of <i>G</i> that do not use edge <i>e</i>, and the term <i>t</i>(<i>G</i>/<i>e</i>) counts the spanning trees of <i>G</i> that use <i>e</i>.</p>
<p>In this formula, if the given graph <i>G</i> is a multigraph, or if a contraction causes two vertices to be connected to each other by multiple edges, then the redundant edges should not be removed, as that would lead to the wrong total. For instance a bond graph connecting two vertices by <i>k</i> edges has <i>k</i> different spanning trees, each consisting of a single one of these edges.</p>
<h3>Tutte polynomial</h3>
<p>The Tutte polynomial of a graph can be defined as a sum, over the spanning trees of the graph, of terms computed from the "internal activity" and "external activity" of the tree. Its value at the arguments (1,1) is the number of spanning trees or, in a disconnected graph, the number of maximal spanning forest.</p>
<p>The Tutte polynomial can also be computed using a deletion-contraction recurrence, but its computational complexity is high: for many values of its arguments, computing it exactly is #P-complete, and it is also hard to approximate with a guaranteed approximation ratio. The point (1,1), at which it can be evaluated using Kirchhoff's theorem, is one of the few exceptions.</p>
<h2>Algorithms</h2>
<h3>Construction</h3>
<p>A single spanning tree of a graph can be found in linear time by either depth-first search or breadth-first search. Both of these algorithms explore the given graph, starting from an arbitrary vertex <i>v</i>, by looping through the neighbors of the vertices they discover and adding each unexplored neighbor to a data structure to be explored later. They differ in whether this data structure is a stack (in the case of depth-first search) or a queue (in the case of breadth-first search). In either case, one can form a spanning tree by connecting each vertex, other than the root vertex <i>v</i>, to the vertex from which it was discovered. This tree is known as a depth-first search tree or a breadth-first search tree according to the graph exploration algorithm used to construct it. Depth-first search trees are a special case of a class of spanning trees called Trémaux trees, named after the 19th-century discoverer of depth-first search.</p>
<p>Spanning trees are important in parallel and distributed computing, as a way of maintaining communications between a set of processors; see for instance the Spanning Tree Protocol used by OSI link layer devices. However, the depth-first and breadth-first methods for constructing spanning trees on sequential computers are not well suited for parallel and distributed computers. Instead, researchers have devised several more specialized algorithms for finding spanning trees in these models of computation.</p>
<h3>Optimization</h3>
<p>In certain fields of graph theory it is often useful to find a minimum spanning tree of a weighted graph. Other optimization problems on spanning trees have also been studied, including the maximum spanning tree, the minimum tree that spans at least k vertices, the spanning tree with the fewest edges per vertex, the spanning tree with the largest number of leaves, the spanning tree with the fewest leaves (closely related to the Hamiltonian path problem), the minimum diameter spanning tree, and the minimum dilation spanning tree.</p>
<p>Optimal spanning tree problems have also been studied for finite sets of points in a geometric space such as the Euclidean plane. For such an input, a spanning tree is again a tree that has as its vertices the given points. The quality of the tree is measured in the same way as in a graph, using the Euclidean distance between pairs of points as the weight for each edge. Thus, for instance, a Euclidean minimum spanning tree is the same as a graph minimum spanning tree in a complete graph with Euclidean edge weights. However, it is not necessary to construct this graph in order to solve the optimization problem; the Euclidean minimum spanning tree problem, for instance, can be solved more efficiently in <i>O</i>(<i>n</i> log <i>n</i>) time by constructing the Delaunay triangulation and then applying a linear time planar graph minimum spanning tree algorithm to the resulting triangulation.</p>
<h3>Randomization</h3>
<p>A spanning tree chosen randomly from among all the spanning trees with equal probability is called a uniform spanning tree. Wilson's algorithm can be used to generate uniform spanning trees in polynomial time by a process of taking a random walk on the given graph and erasing the cycles created by this walk.</p>
<p>An alternative model for generating spanning trees randomly but not uniformly is the random minimal spanning tree. In this model, the edges of the graph are assigned random weights and then the minimum spanning tree of the weighted graph is constructed.</p>
<h3>Enumeration</h3>
<p>Because a graph may have exponentially many spanning trees, it is not possible to list them all in polynomial time. However, algorithms are known for listing all spanning trees in polynomial time per tree.</p>
<h2>In infinite graphs</h2>
<p>Every finite connected graph has a spanning tree. However, for infinite connected graphs, the existence of spanning trees is equivalent to the axiom of choice. An infinite graph is connected if each pair of its vertices forms the pair of endpoints of a finite path. As with finite graphs, a tree is a connected graph with no finite cycles, and a spanning tree can be defined either as a maximal acyclic set of edges or as a tree that contains every vertex.</p>
<p>The trees within a graph may be partially ordered by their subgraph relation, and any infinite chain in this partial order has an upper bound (the union of the trees in the chain). Zorn's lemma, one of many equivalent statements to the axiom of choice, states that a partial order in which all chains are upper bounded must have a maximal element; in the partial order on the trees of the graph, this maximal element must be a spanning tree. Therefore, if Zorn's lemma is true, every infinite connected graph has a spanning tree.</p>
<p>In the other direction, given a family of sets, it is possible to construct an infinite graph such that every spanning tree of the graph corresponds to a choice function of the family of sets. Therefore, if every infinite connected graph has a spanning tree, then the axiom of choice is true.</p>
<h2>Notes</h2>
<ol>
<li><b>^</b> Kocay &amp; Kreher (2004), pp. 65–67.</li>
<li><b>^</b> Kocay &amp; Kreher (2004), pp. 67–69.</li>
<li><b>^</b> Oxley, J. G. (2006), <i>Matroid Theory</i>, Oxford Graduate Texts in Mathematics <b>3</b>, Oxford University Press, p. 141, ISBN 9780199202508 .</li>
<li><b>^</b> Bollobás, Béla (1998), <i>Modern Graph Theory</i>, Graduate Texts in Mathematics <b>184</b>, Springer, p. 350, ISBN 9780387984889 ; Mehlhorn, Kurt (1999), <i>LEDA: A Platform for Combinatorial and Geometric Computing</i>, Cambridge University Press, p. 260, ISBN 9780521563291 .</li>
<li><b>^</b> Cameron, Peter J. (1994), <i>Combinatorics: Topics, Techniques, Algorithms</i>, Cambridge University Press, p. 163, ISBN 9780521457613 .</li>
<li><b>^</b> Gross, Jonathan L.; Yellen, Jay (2005), <i>Graph Theory and Its Applications</i> (2nd ed.), CRC Press, p. 168, ISBN 9781584885054 ; Bondy, J. A.; Murty, U. S. R. (2008), <i>Graph Theory</i>, Graduate Texts in Mathematics <b>244</b>, Springer, p. 578, ISBN 9781846289705 .</li>
<li><b>^</b> Aigner, Martin; Ziegler, Günter M. (1998), <i>Proofs from THE BOOK</i>, Springer-Verlag, pp. 141–146 .</li>
<li><b>^</b> Hartsfield, Nora; Ringel, Gerhard (2003), <i>Pearls in Graph Theory: A Comprehensive Introduction</i>, Courier Dover Publications, p. 100, ISBN 9780486432328 .</li>
<li><b>^</b> Harary, Frank; Hayes, John P.; Wu, Horng-Jyh (1988), <i>A survey of the theory of hypercube graphs</i>, <i>Computers &amp; Mathematics with Applications</i> <b>15</b> (4): 277–289, doi:10.1016/0898-1221(88)90213-1, MR 949280 .</li>
<li><b>^</b> Kocay, William; Kreher, Donald L. (2004), "5.8 The matrix-tree theorem", <i>Graphs, Algorithms, and Optimization</i>, Discrete Mathematics and Its Applications, CRC Press, pp. 111–116, ISBN 9780203489055 .</li>
<li><b>^</b> Kocay &amp; Kreher (2004), p. 109.</li>
<li><b>^</b> Bollobás (1998), p. 351.</li>
<li><b>^</b> Goldberg, L.A.; Jerrum, M. (2008), <i>Inapproximability of the Tutte polynomial</i>, <i>Information and Computation</i> <b>206</b> (7): 908, doi:10.1016/j.ic.2008.04.003 ; Jaeger, F.; Vertigan, D. L.; Welsh, D. J. A. (1990), <i>On the computational complexity of the Jones and Tutte polynomials</i>, <i>Mathematical Proceedings of the Cambridge Philosophical Society</i> <b>108</b>: 35–53, doi:10.1017/S0305004100068936 .</li>
<li><b>^</b> Kozen, Dexter (1992), <i>The Design and Analysis of Algorithms</i>, Monographs in Computer Science, Springer, p. 19, ISBN 9780387976877 .</li>
<li><b>^</b> de Fraysseix, Hubert; Rosenstiehl, Pierre (1982), "A depth-first-search characterization of planarity", <i>Graph theory (Cambridge, 1981)</i>, Ann. Discrete Math. <b>13</b>, Amsterdam: North-Holland, pp. 75–80, MR 671906 .</li>
<li><b>^</b> Reif, John H. (1985), <i>Depth-first search is inherently sequential</i>, <i>Information Processing Letters</i> <b>20</b> (5): 229–234, doi:10.1016/0020-0190(85)90024-9, MR 801987 .</li>
<li><b>^</b> Gallager, R. G.; Humblet, P. A.; Spira, P. M. (1983), <i>A distributed algorithm for minimum-weight spanning trees</i>, <i>ACM Transactions on Programming Languages and Systems</i> <b>5</b> (1): 66–77, doi:10.1145/357195.357200 ; Gazit, Hillel (1991), <i>An optimal randomized parallel algorithm for finding connected components in a graph</i>, <i>SIAM Journal on Computing</i> <b>20</b> (6): 1046–1067, doi:10.1137/0220066, MR 1135748 ; Bader, David A.; Cong, Guojing (2005), <i>A fast, parallel spanning tree algorithm for symmetric multiprocessors (SMPs)</i>, <i>Journal of Parallel and Distributed Computing</i> <b>65</b> (9): 994–1006, doi:10.1016/j.jpdc.2005.03.011 .</li>
<li>^   Eppstein, David (1999), "Spanning trees and spanners", <i>Handbook of Computational Geometry</i>, Elsevier, pp. 425–461 .</li>
<li><b>^</b> Wu, Bang Ye; Chao, Kun-Mao (2004), <i>Spanning Trees and Optimization Problems</i>, CRC Press, ISBN 1-58488-436-3 .</li>
<li><b>^</b> Wilson, David Bruce (1996), "Generating random spanning trees more quickly than the cover time", <i>Proceedings of the Twenty-eighth Annual ACM Symposium on the Theory of Computing (STOC 1996)</i>, pp. 296–303, doi:10.1145/237814.237880, MR 1427525 .</li>
<li><b>^</b> McDiarmid, Colin; Johnson, Theodore; Stone, Harold S. (1997), <i>On finding a minimum spanning tree in a network with random weights</i>, <i>Random Structures &amp; Algorithms</i> <b>10</b> (1-2): 187–204, doi:10.1002/(SICI)1098-2418(199701/03)10:1/2&lt;187::AID-RSA10&gt;3.3.CO;2-Y, MR 1611522 .</li>
<li><b>^</b> Gabow, Harold N.; Myers, Eugene W. (1978), <i>Finding all spanning trees of directed and undirected graphs</i>, <i>SIAM Journal on Computing</i> <b>7</b> (3): 280–287, doi:10.1137/0207024, MR 0495152 </li>
<li>^   Serre, Jean-Pierre (2003), <i>Trees</i>, Springer Monographs in Mathematics, Springer, p. 23 .</li>
<li><b>^</b> Soukup, Lajos (2008), "Infinite combinatorics: from finite to infinite", <i>Horizons of combinatorics</i>, Bolyai Soc. Math. Stud. <b>17</b>, Berlin: Springer, pp. 189–213, doi:10.1007/978-3-540-77200-2_10, MR 2432534 . See in particular Theorem 2.1, pp. 192–193.</li>
</ol>
</body>
</html>