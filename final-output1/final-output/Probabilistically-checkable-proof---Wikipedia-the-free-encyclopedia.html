<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Probabilistically-checkable-proof---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Probabilistically checkable proof</h1>
<p>In computational complexity theory, a <b>probabilistically checkable proof</b> (<b>PCP</b>) is a type of proof that can be checked by a randomized algorithm using a bounded amount of randomness and reading a bounded number of bits of the proof. The algorithm is then required to accept correct proofs and reject incorrect proofs with very high probability. A standard proof (or certificate), as used in the verifier-based definition of the complexity class NP, also satisfies these requirements, since the checking procedure deterministically reads the whole proof, always accepts correct proofs and rejects incorrect proofs. However, what makes them interesting is the existence of probabilistically checkable proofs that can be checked by reading only a few bits of the proof using randomness in an essential way.</p>
<p>Probabilistically checkable proofs give rise to many complexity classes depending on the number of queries required and the amount of randomness used. The class <b>PCP</b>[<i>r</i>(<i>n</i>),<i>q</i>(<i>n</i>)] refers to the set of decision problems that have probabilistically checkable proofs that can be verified in polynomial time using at most <i>r</i>(<i>n</i>) random bits and by reading at most <i>q</i>(<i>n</i>) bits of the proof. Unless specified otherwise, correct proofs should always be accepted, and incorrect proofs should be rejected with probability greater than 1/2. The PCP theorem, a major result in computational complexity theory, states that <b>PCP</b>[O(log <i>n</i>),O(1)] = <b>NP</b>.</p>
<p>The complexity class <b>PCP</b> is the class of decision problems that have probabilistically checkable proofs with completeness 1, soundness α &lt; 1, randomness complexity O(log <i>n</i>) and query complexity O(1).</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Definition</li>
<li>2 History and significance</li>
<li>3 Properties</li>
<li>4 References</li>
<li>5 External links</li>
</ul>
<p></p>
<h2>Definition</h2>
<p>A <b>probabilistically checkable proof system</b> with completeness <i>c</i>(<i>n</i>) and soundness <i>s</i>(<i>n</i>) over alphabet Σ for a decision problem <i>L</i>, where 0 ≤ <i>s</i>(<i>n</i>) ≤ <i>c</i>(<i>n</i>) ≤ 1, is a randomized oracle Turing Machine <i>V</i> (the <i>verifier</i>) that, on input <i>x</i> and oracle access to a string π ∈ Σ (the <i>proof</i>), satisfies the following properties:</p>
<ul>
<li><b>Completeness</b>: If <i>x</i> ∈ <i>L</i> then for some π, <i>V</i>(<i>x</i>) accepts with probability at least <i>c</i>(<i>n</i>),</li>
<li><b>Soundness</b>: If <i>x</i> ∉ <i>L</i> then for every π, <i>V</i>(<i>x</i>) accepts with probability at most <i>s</i>(<i>n</i>).</li>
</ul>
<p>The <i>randomness complexity</i> <i>r</i>(<i>n</i>) of the verifier is the maximum number of random bits that <i>V</i> uses over all <i>x</i> of length <i>n</i>.</p>
<p>The <i>query complexity</i> <i>q</i>(<i>n</i>) of the verifier is the maximum number of queries that <i>V</i> makes to π over all <i>x</i> of length <i>n</i>.</p>
<p>The verifier is said to be <i>non-adaptive</i> if it makes all its queries before it receives any of the answers to previous queries.</p>
<p>The complexity class <b>PCP</b><sub><i>c</i>(<i>n</i>), <i>s</i>(<i>n</i>)</sub>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] is the class of all decision problems having probabilistically checkable proof systems over binary alphabet of completeness <i>c</i>(<i>n</i>) and soundness <i>s</i>(<i>n</i>), where the verifier is nonadaptive, runs in polynomial time, and it has randomness complexity <i>r</i>(<i>n</i>) and query complexity <i>q</i>(<i>n</i>).</p>
<p>The shorthand notation <b>PCP</b>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] is sometimes used for <b>PCP</b><sub>1, ½</sub>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)]. The complexity class <b>PCP</b> is defined as <b>PCP</b><sub>1, ½</sub>[O(log<i>n</i>), O(1)].</p>
<h2>History and significance</h2>
<p>The theory of probabilistically checkable proofs studies the power of probabilistically checkable proof systems under various restrictions of the parameters (completeness, soundness, randomness complexity, query complexity, and alphabet size). It has applications to computational complexity (in particular hardness of approximation) and cryptography.</p>
<p>The definition of a probabilistically checkable proof was explicitly introduced by Arora and Safra in 1992, although their properties were studied earlier. In 1990 Babai, Fortnow, and Lund proved that <b>PCP</b>[poly(<i>n</i>), poly(<i>n</i>)] = <b>NEXP</b>, providing the first nontrivial equivalence between standard proofs (<b>NEXP</b>) and probabilistically checkable proofs. The PCP theorem proved in 1992 states that <b>PCP</b>[O(log <i>n</i>),O(1)] = <b>NP</b>.</p>
<p>The theory of hardness of approximation requires a detailed understanding of the role of completeness, soundness, alphabet size, and query complexity in probabilistically checkable proofs.</p>
<h2>Properties</h2>
<p>For extreme settings of the parameters, the definition of probabilistically checkable proofs is easily seen to be equivalent to standard complexity classes. For example, we have the following:</p>
<ul>
<li><b>PCP</b>[0, 0] = <b>P</b> (<b>P</b> is defined to have no randomness and no access to a proof.)</li>
<li><b>PCP</b>[O(log(<i>n</i>)), 0] = <b>P</b> (A logarithmic number of random bits doesn't help a polynomial time Turing machine, since it could try all possibly random strings of logarithmic length in polynomial time.)</li>
<li><b>PCP</b>[0,O(log(<i>n</i>))] = <b>P</b> (Without randomness, the proof can be thought of as a fixed logarithmic sized string. A polynomial time machine could try all possible logarithmic sized proofs in polynomial time.)</li>
<li><b>PCP</b>[poly(<i>n</i>), 0] = <b>coRP</b> (By definition of <b>coRP</b>.)</li>
<li><b>PCP</b>[0, poly(<i>n</i>)] = <b>NP</b> (By the verifier-based definition of NP.)</li>
</ul>
<p>The PCP theorem and MIP = NEXP can be characterized as follows:</p>
<ul>
<li><b>PCP</b>[O(log <i>n</i>),O(1)] = <b>NP</b> (the PCP theorem)</li>
<li><b>PCP</b>[poly(<i>n</i>),O(1)] = <b>PCP</b>[poly(<i>n</i>),poly(<i>n</i>)] = <b>NEXP</b> (MIP = NEXP).</li>
</ul>
<p>It is also known that <b>PCP</b>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] ⊆ NTIME(2<i>q</i>(<i>n</i>)+poly(<i>n</i>)), if the verifier is constrained to be non-adaptive. For adaptive verifiers, <b>PCP</b>[<i>r</i>(<i>n</i>), <i>q</i>(<i>n</i>)] ⊆ NTIME(2+poly(<i>n</i>)). On the other hand, if <b>NP</b> ⊆ <b>PCP</b>[o(log <i>n</i>),o(log <i>n</i>)] then P = NP.</p>
</body>
</html>