<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Purely-functional---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Purely functional</h1>
<p>In computing, algorithms, data structures, or programming languages are called <b>purely functional</b> if they guarantee the (weak) equivalence of call-by-name, call-by-value and call-by-need evaluation strategies, often by excluding <i>destructive modifications</i> (updates) of entities in the program's running environment. According to this restriction, variables are used in a mathematical sense, with identifiers referring to immutable, persistent values.</p>
<p>To represent computations that perform side-effects in a purely functional programming language, one can use Monads, as proposed by Philip Wadler.</p>
<p>Haskell is the most common modern example of a purported pure functional programming language; however the mutable reference feature of its IO monad effectively renders it impure.</p>
<p>Purely functional data structures are often represented in a different way than their imperative counterparts.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Benefits and applications</li>
<li>2 See also</li>
<li>3 Bibliography</li>
<li>4 External links</li>
</ul>
<p></p>
<h2>Benefits and applications</h2>
<p>The persistence property of purely functional data structures can be advantageous in the development of many applications that deal with multiple versions of an object.</p>
<p>For example, consider a comprehensive web-based thesaurus service that uses a large red-black tree to store its list of synonym relationships, and that allows each user to add their own custom words to their personal thesaurus. One way to do this is to make a copy of the tree for each user, and then add their custom words to it; however, this duplication is wasteful, both of space and of time.</p>
<p>A better approach is to store the words in an immutable (and therefore purely functional) red-black tree. Then, one can simply take the original version and produce a new tree based on it for each set of custom words. Because these new trees share large amounts of structure with the main tree, the space overhead for each additional user is at most <img class="mwe-math-fallback-image-inline tex" alt="2 k \log_2 n" src="//upload.wikimedia.org/math/a/0/a/a0ac3b3fbf8cc7c7a92c10c8c81ae138.png">, where <img class="mwe-math-fallback-image-inline tex" alt="k" src="//upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"> is the number of custom nodes. With a single mutable red-black tree, this approach would not work, since changes to the main tree would affect all users.</p>
<p>Besides their efficiency benefits, the inherent referential transparency of functional data structures tends to make purely functional computation more amenable to analysis and optimization, both formal and informal.</p>
<h2>See also</h2>
<ul>
<li>Pure function</li>
<li>Persistent data structure</li>
<li>VList</li>
<li>Identity (object-oriented programming)</li>
<li>List of Pure Functional Programming Languages</li>
</ul>
<h2>Bibliography</h2>
<ol>
<li><b>^</b> Sabry, Amr (January 1998). "What is a purely functional language?". <i>Journal of Functional Progrmaming</i> <b>8</b> (1): 1–22. </li>
<li><b>^</b> <i>Comprehending Monads</i> by Philip Wadler, Cambridge University Press, Mathematical Structures in Computer Science / Volume 2 / Issue 04 / December 1992, pp 461-493</li>
<li><b>^</b> <i>A Functional Approach to the Observer Pattern</i> by Alvaro Garcia Perez</li>
<li><b>^</b> <i>Purely functional data structures</i> by Chris Okasaki, Cambridge University Press, 1998, ISBN 0-521-66350-4</li>
</ol>
<h2>External links</h2>
<ul>
<li>Purely Functional Data Structures thesis by Chris Okasaki (PDF format)</li>
<li>Making Data-Structures Persistent by James R. Driscoll, Neil Sarnak, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li>Fully Persistent Lists with Catenation by James R. Driscoll, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li>Persistent Data Structures from MIT open course Advanced Algorithms</li>
</ul>
<h1>Purely functional</h1>
<p>In computing, algorithms, data structures, or programming languages are called <b>purely functional</b> if they guarantee the (weak) equivalence of call-by-name, call-by-value and call-by-need evaluation strategies, often by excluding <i>destructive modifications</i> (updates) of entities in the program's running environment. According to this restriction, variables are used in a mathematical sense, with identifiers referring to immutable, persistent values.</p>
<p>To represent computations that perform side-effects in a purely functional programming language, one can use Monads, as proposed by Philip Wadler.</p>
<p>Haskell is the most common modern example of a purported pure functional programming language; however the mutable reference feature of its IO monad effectively renders it impure.</p>
<p>Purely functional data structures are often represented in a different way than their imperative counterparts.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Benefits and applications</li>
<li>2 See also</li>
<li>3 Bibliography</li>
<li>4 External links</li>
</ul>
<p></p>
<h2>Benefits and applications</h2>
<p>The persistence property of purely functional data structures can be advantageous in the development of many applications that deal with multiple versions of an object.</p>
<p>For example, consider a comprehensive web-based thesaurus service that uses a large red-black tree to store its list of synonym relationships, and that allows each user to add their own custom words to their personal thesaurus. One way to do this is to make a copy of the tree for each user, and then add their custom words to it; however, this duplication is wasteful, both of space and of time.</p>
<p>A better approach is to store the words in an immutable (and therefore purely functional) red-black tree. Then, one can simply take the original version and produce a new tree based on it for each set of custom words. Because these new trees share large amounts of structure with the main tree, the space overhead for each additional user is at most <img class="mwe-math-fallback-image-inline tex" alt="2 k \log_2 n" src="//upload.wikimedia.org/math/a/0/a/a0ac3b3fbf8cc7c7a92c10c8c81ae138.png">, where <img class="mwe-math-fallback-image-inline tex" alt="k" src="//upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"> is the number of custom nodes. With a single mutable red-black tree, this approach would not work, since changes to the main tree would affect all users.</p>
<p>Besides their efficiency benefits, the inherent referential transparency of functional data structures tends to make purely functional computation more amenable to analysis and optimization, both formal and informal.</p>
<h2>See also</h2>
<ul>
<li>Pure function</li>
<li>Persistent data structure</li>
<li>VList</li>
<li>Identity (object-oriented programming)</li>
<li>List of Pure Functional Programming Languages</li>
</ul>
<h2>Bibliography</h2>
<ol>
<li><b>^</b> Sabry, Amr (January 1998). "What is a purely functional language?". <i>Journal of Functional Progrmaming</i> <b>8</b> (1): 1–22. </li>
<li><b>^</b> <i>Comprehending Monads</i> by Philip Wadler, Cambridge University Press, Mathematical Structures in Computer Science / Volume 2 / Issue 04 / December 1992, pp 461-493</li>
<li><b>^</b> <i>A Functional Approach to the Observer Pattern</i> by Alvaro Garcia Perez</li>
<li><b>^</b> <i>Purely functional data structures</i> by Chris Okasaki, Cambridge University Press, 1998, ISBN 0-521-66350-4</li>
</ol>
<h2>External links</h2>
<ul>
<li>Purely Functional Data Structures thesis by Chris Okasaki (PDF format)</li>
<li>Making Data-Structures Persistent by James R. Driscoll, Neil Sarnak, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li>Fully Persistent Lists with Catenation by James R. Driscoll, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li>Persistent Data Structures from MIT open course Advanced Algorithms</li>
</ul>
</body>
</html>