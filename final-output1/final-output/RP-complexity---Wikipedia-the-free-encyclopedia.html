<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>RP-complexity---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>RP (complexity)</h1>
<p><b>Randomized polynomial time</b> (<b>RP</b>) is the complexity class of computational complexity theory, problems for which a probabilistic Turing machine exists with these properties:</p>
<ul>
<li>It always runs in polynomial time in the input size</li>
<li>If the correct answer is NO, it always returns NO</li>
<li>If the correct answer is YES, then it returns YES with probability at least 1/2 (otherwise, it returns NO).</li>
</ul>
<p>In other words, the algorithm is allowed to flip a truly random coin while it is running. The only case in which the algorithm can return YES is if the actual answer is YES; therefore if the algorithm terminates and produces YES, then the correct answer is definitely YES; however, the algorithm can terminate with NO <i>regardless</i> of the actual answer. That is, if the algorithm returns NO, it might be wrong.</p>
<p>Some authors call this class <b>R</b>, although this name is more commonly used for the class of recursive languages.</p>
<p>If the correct answer is YES and the algorithm is run <i>n</i> times with the result of each run statistically independent of the others, then it will return YES at least once with probability at least 1 − 2. So if the algorithm is run 100 times, then the chance of it giving the wrong answer every time is lower than the chance that cosmic rays corrupted the memory of the computer running the algorithm. In this sense, if a source of random numbers is available, most algorithms in <b>RP</b> are highly practical.</p>
<p>The fraction 1/2 in the definition is arbitrary. The set <b>RP</b> will contain exactly the same problems, even if the 1/2 is replaced by any constant nonzero probability less than 1; here constant means independent of the input to the algorithm.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Related complexity classes</li>
<li>2 Connection to P and NP</li>
<li>3 See also</li>
<li>4 References</li>
<li>5 External links</li>
</ul>
<p></p>
<h2>Related complexity classes</h2>
<p>The definition of <b>RP</b> says that a YES answer is always right and that a NO answer might be wrong (because a question with the YES answer can be sometimes answered NO). In other words, while NO questions are always answered NO, you cannot trust the NO answer, it may be a mistaken answer to a YES question. The complexity class <b>co-RP</b> is similarly defined, except that NO is always right and YES might be wrong. In other words, it accepts all YES instances but can either accept or reject NO instances. The class <b>BPP</b> describes algorithms that can give incorrect answers on both YES and NO instances, and thus contains both <b>RP</b> and <b>co-RP</b>. The intersection of the sets <b>RP</b> and <b>co-RP</b> is called <b>ZPP</b>. Just as <b>RP</b> may be called <b>R</b>, some authors use the name <b>co-R</b> rather than <b>co-RP</b>.</p>
<h2>Connection to P and NP</h2>
<p><b>P</b> is a subset of <b>RP</b>, which is a subset of <b>NP</b>. Similarly, <b>P</b> is a subset of <b>co-RP</b> which is a subset of <b>co-NP</b>. It is not known whether these inclusions are strict. However, if the commonly believed conjecture <b>P</b> = <b>BPP</b> is true, then <b>RP</b>, <b>co-RP</b>, and <b>P</b> collapse (are all equal). Assuming in addition that <b>P</b> ≠ <b>NP</b>, this then implies that <b>RP</b> is strictly contained in <b>NP</b>. It is not known whether <b>RP</b> = <b>co-RP</b>, or whether <b>RP</b> is a subset of the intersection of <b>NP</b> and <b>co-NP</b>, though this would be implied by <b>P</b> = <b>BPP</b>.</p>
<p>A natural example of a problem in <b>co-RP</b> currently not known to be in <b>P</b> is Polynomial Identity Testing, the problem of deciding whether a given multivariate arithmetic expression over the integers is the zero-polynomial. For instance, <i>x</i>·<i>x</i> − <i>y</i>·<i>y</i> − (<i>x</i> + <i>y</i>)·(<i>x</i> − <i>y</i>) is the zero-polynomial while <i>x</i>·<i>x</i> + <i>y</i>·<i>y</i> is not.</p>
<p>An alternative characterization of <b>RP</b> that is sometimes easier to use is the set of problems recognizable by nondeterministic Turing machines where the machine accepts if and only if at least some constant fraction of the computation paths, independent of the input size, accept. <b>NP</b> on the other hand, needs only one accepting path, which could constitute an exponentially small fraction of the paths. This characterization makes the fact that <b>RP</b> is a subset of <b>NP</b> obvious.</p>
<h2>See also</h2>
<ul>
<li>Randomized algorithm</li>
</ul>
</body>
</html>