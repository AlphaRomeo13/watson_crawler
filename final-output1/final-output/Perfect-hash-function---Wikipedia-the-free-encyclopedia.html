<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Perfect-hash-function---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Perfect hash function</h1>
<p>A <b>perfect hash function</b> for a set S is a hash function that maps distinct elements in S to a set of integers, with no collisions. A perfect hash function has many of the same applications as other hash functions, but with the advantage that no collision resolution has to be implemented. In mathematical terms, it is a total injective function.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Properties and uses</li>
<li>2 Minimal perfect hash function</li>
<li>3 See also</li>
<li>4 References</li>
<li>5 Further reading</li>
<li>6 External links</li>
</ul>
<p></p>
<h2>Properties and uses</h2>
<p>A perfect hash function for a specific set S that can be evaluated in constant time, and with values in a small range, can be found by a randomized algorithm in a number of operations that is proportional to the size of S. Any perfect hash functions suitable for use with a hash table require at least a number of bits that is proportional to the size of S.</p>
<p>A perfect hash function with values in a limited range can be used for efficient lookup operations, by placing keys from S (or other associated values) in a table indexed by the output of the function. Using a perfect hash function is best in situations where there is a frequently queried large set, S, which is seldom updated. This is because any modification of the set leads to a non-perfect hash function. Solutions which update the hash function any time the set is modified are known as dynamic perfect hashing, but these methods are relatively complicated to implement. A simple alternative to perfect hashing, which also allows dynamic updates, is cuckoo hashing.</p>
<h2>Minimal perfect hash function</h2>
<p>A <b>minimal perfect hash function</b> is a perfect hash function that maps <i>n</i> keys to <i>n</i> consecutive integers—usually [0..<i>n</i>−1] or [1..<i>n</i>]. A more formal way of expressing this is: Let <i>j</i> and <i>k</i> be elements of some finite set <b>K</b>. F is a minimal perfect hash function iff F(<i>j</i>) =F(<i>k</i>) implies <i>j</i>=<i>k</i> (injectivity) and there exists an integer <i>a</i> such that the range of F is <i>a</i>..<i>a</i>+|<b>K</b>|−1. It has been proved that a general purpose minimal perfect hash scheme requires at least 1.44 bits/key. The best currently known minimal perfect hashing schemes use around 2.6 bits/key.</p>
<p>A minimal perfect hash function F is <b>order preserving</b> if keys are given in some order <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, ..., <i>a</i><sub><i>n</i></sub> and for any keys <i>a</i><sub><i>j</i></sub> and <i>a</i><sub><i>k</i></sub>, <i>j</i>&lt;<i>k</i> implies F(<i>a</i><sub><i>j</i></sub>)&lt;F(<i>a</i><sub><i>k</i></sub>). Order-preserving minimal perfect hash functions require necessarily Ω(<i>n</i> log <i>n</i>) bits to be represented.</p>
<p>A minimal perfect hash function F is <b>monotone</b> if it preserves the lexicographical order of the keys. In this case, the function value is just the position of each key in the sorted ordering of all of the keys. If the keys to be hashed are themselves stored in a sorted array, it is possible to store a small number of additional bits per key in a data structure that can be used to compute hash values quickly.</p>
<h2>See also</h2>
<ul>
<li>Dynamic perfect hashing</li>
<li>Pearson hashing</li>
<li>Universal hashing</li>
</ul>
</body>
</html>