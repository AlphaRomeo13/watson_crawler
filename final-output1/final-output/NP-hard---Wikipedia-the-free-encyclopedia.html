<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>NP-hard---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>NP-hard</h1>
<p><b>NP-hard</b> (<b>N</b>on-deterministic <b>P</b>olynomial-time hard), in computational complexity theory, is a class of problems that are, informally, "at least as hard as the hardest problems in NP". More precisely, a problem <i>H</i> is NP-hard when every problem <i>L</i> in NP can be reduced in polynomial time to <i>H</i>. As a consequence, finding a polynomial algorithm to solve any NP-hard problem would give polynomial algorithms for all the problems in NP, which is unlikely as many of them are considered as hard.</p>
<p>A common mistake is to think that the <i>NP</i> in <i>NP-hard</i> stands for <i>non-polynomial</i>. Although it is widely suspected that there are no polynomial-time algorithms for NP-hard problems, this has never been proven. Moreover, the class NP also contains all problems which can be solved in polynomial time.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Definition</li>
<li>2 Consequences</li>
<li>3 Examples</li>
<li>4 NP-naming convention</li>
<li>5 Application areas</li>
<li>6 References</li>
</ul>
<p></p>
<h2>Definition</h2>
<p>A decision problem <i>H</i> is NP-hard when for any problem <i>L</i> in NP, there is a polynomial-time reduction from <i>L</i> to <i>H</i> An equivalent definition is to require that any problem <i>L</i> in NP can be solved in polynomial time by an oracle machine with an oracle for <i>H</i>. Informally, we can think of an algorithm that can call such an oracle machine as a subroutine for solving <i>H</i>, and solves <i>L</i> in polynomial time, if the subroutine call takes only one step to compute.</p>
<p>Another definition is to require that there is a polynomial-time reduction from an NP-complete problem <i>G</i> to <i>H</i>. As any problem <i>L</i> in NP reduces in polynomial time to <i>G</i>, <i>L</i> reduces in turn to <i>H</i> in polynomial time so this new definition implies the previous one. It does not restrict the class NP-hard to decision problems, for instance it also includes search problems, or optimization problems.</p>
<h2>Consequences</h2>
<ul>
<li>If there is a polynomial algorithm for any NP-hard problem, then there are polynomial algorithms for all problems in NP, and hence P = NP;</li>
</ul>
<ul>
<li>If P â‰  NP, then NP-hard problems cannot be solved in polynomial time, while P = NP does not resolve whether the NP-hard problems can be solved in polynomial time;</li>
</ul>
<ul>
<li>If an optimization problem H has an NP-complete decision version <i>L</i>, then <i>H</i> is NP-hard.</li>
</ul>
<h2>Examples</h2>
<p>An example of an NP-hard problem is the decision subset sum problem, which is this: given a set of integers, does any non-empty subset of them add up to zero? That is a decision problem, and happens to be NP-complete. Another example of an NP-hard problem is the optimization problem of finding the least-cost cyclic route through all nodes of a weighted graph. This is commonly known as the traveling salesman problem.</p>
<p>There are decision problems that are NP-hard but not NP-complete, for example the halting problem. This is the problem which asks "given a program and its input, will it run forever?" That's a <i>yes</i>/<i>no</i> question, so this is a decision problem. It is easy to prove that the halting problem is <i>NP-hard</i> but not <i>NP-complete</i>. For example, the Boolean satisfiability problem can be reduced to the halting problem by transforming it to the description of a Turing machine that tries all truth value assignments and when it finds one that satisfies the formula it halts and otherwise it goes into an infinite loop. It is also easy to see that the halting problem is not in <i>NP</i> since all problems in NP are decidable in a finite number of operations, while the halting problem, in general, is undecidable. There are also NP-hard problems that are neither NP-complete nor undecidable. For instance, the language of True quantified Boolean formulas is decidable in polynomial space, but not non-deterministic polynomial time (unless NP = PSPACE).</p>
<h2>NP-naming convention</h2>
<p>NP-hard problems do not have to be elements of the complexity class NP, despite having <i>NP</i> as the prefix of their class name. The <i>NP-</i>naming system has some deeper sense, because the NP family is defined in relation to the class NP and the naming conventions in the Computational Complexity Theory:</p>
<h2>Application areas</h2>
<p>NP-hard problems are often tackled with rules-based languages in areas such as:</p>
<ul>
<li>Configuration</li>
<li>Data mining</li>
<li>Selection</li>
<li>Diagnosis</li>
<li>Process monitoring and control</li>
<li>Scheduling</li>
<li>Planning</li>
<li>Rosters or schedules</li>
<li>Tutoring systems</li>
<li>Decision support</li>
<li>Phylogenetics</li>
</ul>
</body>
</html>