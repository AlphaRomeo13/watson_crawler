<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Nondeterministic-algorithm---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Nondeterministic algorithm</h1>
<p>In computer science, a <b>nondeterministic algorithm</b> is an algorithm that, even for the same input, can exhibit different behaviors on different runs, as opposed to a deterministic algorithm. There are several ways an algorithm may behave differently from run to run. A concurrent algorithm can perform differently on different runs due to a race condition. A probabilistic algorithm's behaviors depends on a random number generator. An algorithm that solves a problem in nondeterministic polynomial time can run in polynomial time or exponential time depending on the choices it makes during execution. The nondeterministic algorithms are often used to find an approximation to a solution, when the exact solution would be too costly to obtain using a deterministic one.</p>
<p>The notion was introduced by Robert W. Floyd.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Use</li>
<li>2 Implementing nondeterministic algorithms with deterministic ones</li>
<li>3 Examples
<ul>
<li>3.1 Primality testing</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 Further reading</li>
</ul>
<ul>
<li>3.1 Primality testing</li>
</ul>
<p></p>
<h2>Use</h2>
<p>Often in computational theory, the term "algorithm" refers to a deterministic algorithm. A nondeterministic algorithm is different from its more familiar deterministic counterpart in its ability to arrive at outcomes using various routes. If a deterministic algorithm represents a single path from an input to an outcome, a nondeterministic algorithm represents a single path stemming into many paths, some of which may arrive at the same output and some of which may arrive at unique outputs. This property is captured mathematically in "nondeterministic" models of computation such as the nondeterministic finite automaton. In some scenarios, all possible paths are allowed to run simultaneously.</p>
<p>In algorithm design, nondeterministic algorithms are often used when the problem solved by the algorithm inherently allows multiple outcomes (or when there is a single outcome with multiple paths by which the outcome may be discovered, each equally preferable). Crucially, every outcome the nondeterministic algorithm produces is valid, regardless of which choices the algorithm makes while running.</p>
<p>In computational complexity theory, nondeterministic algorithms are ones that, at every possible step, can allow for multiple continuations (imagine a man walking down a path in a forest and, every time he steps further, he must pick which fork in the road he wishes to take). These algorithms do not arrive at a solution for every possible computational path; however, they are guaranteed to arrive at a correct solution for some path (i.e., the man walking through the forest may only find his cabin if he picks some combination of "correct" paths). The choices can be interpreted as guesses in a search process.</p>
<p>A large number of problems can be conceptualized through nondeterministic algorithms, including the most famous unresolved question in computing theory, P vs NP.</p>
<h2>Implementing nondeterministic algorithms with deterministic ones</h2>
<p>One way to simulate a nondeterministic algorithm <i>N</i> using a deterministic algorithm <i>D</i> is to treat sets of states of <i>N</i> as states of <i>D</i>. This means that <i>D</i> simultaneously traces all the possible execution paths of <i>N</i> (see powerset construction for this technique in use for finite automata).</p>
<p>Another is randomization, which consists of letting all choices be determined by a random number generator. The result is called a probabilistic deterministic algorithm.</p>
<h2>Examples</h2>
<h3>Primality testing</h3>
<p>The problem: given a natural number <i>n</i> larger than two, determine whether it is prime.</p>
<p>A nondeterministic algorithm for this problem is the following based on Fermat's little theorem:</p>
<ol>
<li>Repeat thirty times:
<ol>
<li>Pick a random integer <i>a</i> such that 2 ≤ <i>a</i> ≤ <i>n</i>-1.</li>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="a^{n-1}\neq 1 \pmod n" src="//upload.wikimedia.org/math/f/4/3/f434cb1a2277b2685a867a53e0a8b465.png">, return answer <b>composite</b></li>
</ol>
</li>
<li>Return answer <b>probably prime</b>.</li>
</ol>
<ol>
<li>Pick a random integer <i>a</i> such that 2 ≤ <i>a</i> ≤ <i>n</i>-1.</li>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="a^{n-1}\neq 1 \pmod n" src="//upload.wikimedia.org/math/f/4/3/f434cb1a2277b2685a867a53e0a8b465.png">, return answer <b>composite</b></li>
</ol>
<p>If this algorithm returns the answer <b>composite</b> then the number is certainly not prime. If the algorithm returns the answer <b>probably prime</b> then there is a high probability that the number is prime, but a slight chance that it is composite. This is an example of a probabilistic nondeterministic algorithm, because it will not always return the same result given a particular input.</p>
<h2>See also</h2>
<ul>
<li>Non-deterministic Turing machine</li>
<li>Nondeterministic finite automaton</li>
<li>Nondeterministic programming</li>
</ul>
</body>
</html>