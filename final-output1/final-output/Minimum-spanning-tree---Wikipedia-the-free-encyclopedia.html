<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Minimum-spanning-tree---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Minimum spanning tree</h1>
<p>Given a connected, undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. A single graph can have many different spanning trees. We can also assign a <i>weight</i> to each edge, which is a number representing how unfavorable it is, and use this to assign a weight to a spanning tree by computing the sum of the weights of the edges in that spanning tree. A <b>minimum spanning tree</b> (<b>MST</b>) or <b>minimum weight spanning tree</b> is then a spanning tree with weight less than or equal to the weight of every other spanning tree. More generally, any undirected graph (not necessarily connected) has a <b>minimum spanning forest</b>, which is a union of minimum spanning trees for its connected components.</p>
<p>One example would be a telecommunications company laying cable to a new neighborhood. If it is constrained to bury the cable only along certain paths (eg. along roads), then there would be a graph representing which points are connected by those paths. Some of those paths might be more expensive, because they are longer, or require the cable to be buried deeper; these paths would be represented by edges with larger weights. Currency is an acceptable unit for edge weight — there is no requirement for edge lengths to obey normal rules of geometry such as the triangle inequality. A <i>spanning tree</i> for that graph would be a subset of those paths that has no cycles but still connects to every house; there might be several spanning trees possible. A <i>minimum spanning tree</i> would be one with the lowest total cost, thus would represent the least expensive path for laying the cable.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Properties
<ul>
<li>1.1 Possible multiplicity</li>
<li>1.2 Uniqueness</li>
<li>1.3 Minimum-cost subgraph</li>
<li>1.4 Cycle property</li>
<li>1.5 Cut property</li>
<li>1.6 Minimum-cost edge</li>
</ul>
</li>
<li>2 Algorithms</li>
<li>3 MST on complete graphs</li>
<li>4 Applications</li>
<li>5 Related problems</li>
<li>6 Minimum bottleneck spanning tree</li>
<li>7 References</li>
<li>8 Additional reading</li>
<li>9 External links</li>
</ul>
<ul>
<li>1.1 Possible multiplicity</li>
<li>1.2 Uniqueness</li>
<li>1.3 Minimum-cost subgraph</li>
<li>1.4 Cycle property</li>
<li>1.5 Cut property</li>
<li>1.6 Minimum-cost edge</li>
</ul>
<p></p>
<h2>Properties</h2>
<h3>Possible multiplicity</h3>
<p><i>There may be several minimum spanning trees of the same weight having a minimum number of edges</i>; in particular, if all the edge weights of a given graph are the same, then every spanning tree of that graph is minimum. If there are <i>n</i> vertices in the graph, then each tree has <i>n</i>-1 edges.</p>
<h3>Uniqueness</h3>
<p><i>If each edge has a distinct weight then there will be only one, unique minimum spanning tree</i>. This is true in many realistic situations, such as the telecommunications company example above, where it's unlikely any two paths have <i>exactly</i> the same cost. This generalizes to spanning forests as well. If the edge weights are not unique, only the (multi-)set of weights in minimum spanning trees is unique, that is the same for all minimum spanning trees.</p>
<p>A proof of uniqueness by contradiction is as follows.</p>
<ol>
<li>Suppose there are two different MSTs <i>A</i> and <i>B</i>.</li>
<li>Let <i>e</i><sub>1</sub> be the edge of least weight that is in one of the MSTs and not the other. Without loss of generality, assume <i>e</i><sub>1</sub> is in <i>A</i> but not in <i>B</i>.</li>
<li>As <i>B</i> is a MST, {<i>e</i><sub>1</sub>} <img class="mwe-math-fallback-image-inline tex" alt="\cup" src="//upload.wikimedia.org/math/4/3/2/432c1df69e11aba7c5c5070e7578609f.png"> <i>B</i> must contain a cycle <i>C</i>.</li>
<li>Then <i>C</i> has an edge <i>e</i><sub>2</sub> whose weight is greater than the weight of <i>e</i><sub>1</sub>, since all edges in <i>B</i> with less weight are in <i>A</i> by the choice of <i>e</i><sub>1</sub>, and <i>C</i> must have at least one edge that is not in <i>A</i> because otherwise <i>A</i> would contain a cycle in contradiction with its being an MST.</li>
<li>Replacing <i>e</i><sub>2</sub> with <i>e</i><sub>1</sub> in <i>B</i> yields a spanning tree with a smaller weight.</li>
<li>This contradicts the assumption that <i>B</i> is a MST.</li>
</ol>
<h3>Minimum-cost subgraph</h3>
<p>If the weights are <i>positive</i>, then a minimum spanning tree is in fact a minimum-cost subgraph connecting all vertices, since subgraphs containing cycles necessarily have more total weight.</p>
<h3>Cycle property</h3>
<p><i>For any cycle</i> C <i>in the graph, if the weight of an edge</i> e <i>of</i> C <i>is larger than the weights of all other edges of</i> C<i>, then this edge cannot belong to an MST.</i> Assuming the contrary, i.e. that <i>e</i> belongs to an MST T1, then deleting <i>e</i> will break T1 into two subtrees with the two ends of <i>e</i> in different subtrees. The remainder of <i>C</i> reconnects the subtrees, hence there is an edge <i>f</i> of <i>C</i> with ends in different subtrees, i.e., it reconnects the subtrees into a tree T2 with weight less than that of T1, because the weight of <i>f</i> is less than the weight of <i>e</i>.</p>
<h3>Cut property</h3>
<p><i>For any cut</i> C <i>in the graph, if the weight of an edge</i> e <i>of</i> C <i>is strictly smaller than the weights of all other edges of</i> C<i>, then this edge belongs to all MSTs of the graph.</i> To prove this, assume the contrary: in the figure at right, make edge BC (weight 6) part of the MST T instead of edge e (weight 4). Adding e to T will produce a cycle, while replacing BC with e would produce MST of smaller weight. Thus, a tree containing BC is not a MST, a contradiction that violates our assumption. By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in a minimum spanning tree.</p>
<h3>Minimum-cost edge</h3>
<p>If the edge of a graph with the minimum cost <i>e</i> is unique, then this edge is included in any MST. Indeed, if <i>e</i> was not included in the MST, removing any of the (larger cost) edges in the cycle formed after adding <i>e</i> to the MST, would yield a spanning tree of smaller weight.</p>
<h2>Algorithms</h2>
<p>The first algorithm for finding a minimum spanning tree was developed by Czech scientist Otakar Borůvka in 1926 (see Borůvka's algorithm). Its purpose was an efficient electrical coverage of Moravia. There are now two algorithms commonly used, Prim's algorithm and Kruskal's algorithm. All three are greedy algorithms that run in polynomial time, so the problem of finding such trees is in <b>FP</b>, and related decision problems such as determining whether a particular edge is in the MST or determining if the minimum total weight exceeds a certain value are in <b>P</b>. Another greedy algorithm not as commonly used is the reverse-delete algorithm, which is the reverse of Kruskal's algorithm.</p>
<p>If the edge weights are integers, then deterministic algorithms are known that solve the problem in <i>O</i>(<i>m</i> + <i>n</i>) integer operations, where <i>m</i> is the number of edges, <i>n</i> is the number of vertices. In a comparison model, in which the only allowed operations on edge weights are pairwise comparisons, Karger, Klein &amp; Tarjan (1995) found a linear time randomized algorithm based on a combination of Borůvka's algorithm and the reverse-delete algorithm. Whether the problem can be solved deterministically in linear time by a comparison-based algorithm remains an open question, however. The fastest non-randomized comparison-based algorithm with known complexity, by Bernard Chazelle, is based on the soft heap, an approximate priority queue. Its running time is <i>O</i>(<i>m</i> α(<i>m</i>,<i>n</i>)), where α is the classical functional inverse of the Ackermann function. The function α grows extremely slowly, so that for all practical purposes it may be considered a constant no greater than 4; thus Chazelle's algorithm takes very close to linear time. Seth Pettie and Vijaya Ramachandran have found a provably optimal deterministic comparison-based minimum spanning tree algorithm, the computational complexity of which is unknown.</p>
<p>Research has also considered parallel algorithms for the minimum spanning tree problem. With a linear number of processors it is possible to solve the problem in <img class="mwe-math-fallback-image-inline tex" alt="O(\log n)" src="//upload.wikimedia.org/math/0/c/a/0ca47d9a481af371d1210a620c1945db.png"> time. Bader &amp; Cong (2003) demonstrate an algorithm that can compute MSTs 5 times faster on 8 processors than an optimized sequential algorithm.</p>
<p>Other specialized algorithms have been designed for computing minimum spanning trees of a graph so large that most of it must be stored on disk at all times. These <i>external storage</i> algorithms, for example as described in "Engineering an External Memory Minimum Spanning Tree Algorithm" by Roman, Dementiev et al., can operate, by authors' claims, as little as 2 to 5 times slower than a traditional in-memory algorithm. They rely on efficient external storage sorting algorithms and on graph contraction techniques for reducing the graph's size efficiently.</p>
<p>The problem can also be approached in a distributed manner. If each node is considered a computer and no node knows anything except its own connected links, one can still calculate the distributed minimum spanning tree.</p>
<h2>MST on complete graphs</h2>
<p>Alan M. Frieze showed that given a complete graph on <i>n</i> vertices, with edge weights that are independent identically distributed random variables with distribution function <img class="mwe-math-fallback-image-inline tex" alt="F" src="//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png"> satisfying <img class="mwe-math-fallback-image-inline tex" alt="F'(0) &gt; 0" src="//upload.wikimedia.org/math/2/1/8/218e0051f8f045a2eba43ec5336d3910.png">, then as <i>n</i> approaches +∞ the expected weight of the MST approaches <img class="mwe-math-fallback-image-inline tex" alt="\zeta(3)/F'(0)" src="//upload.wikimedia.org/math/2/1/a/21a0b990e939837f4a9ec6f873e419f8.png">, where <img class="mwe-math-fallback-image-inline tex" alt="\zeta" src="//upload.wikimedia.org/math/3/2/0/320c43589fbcdde1af041ee358550ac5.png"> is the Riemann zeta function. Frieze and Steele also proved convergence in probability. Svante Janson proved a central limit theorem for weight of the MST.</p>
<p>For uniform random weights in <img class="mwe-math-fallback-image-inline tex" alt="[0,1]" src="//upload.wikimedia.org/math/c/c/f/ccfcd347d0bf65dc77afe01a3306a96b.png">, the exact expected size of the minimum spanning tree has been computed for small complete graphs.</p>
<h2>Applications</h2>
<p>Minimum spanning trees have direct applications in the design of networks, including computer networks, telecommunications networks, transportation networks, water supply networks, and electrical grids (which they were first invented for, as mentioned above). They are invoked as subroutines in algorithms for other problems, including the Christofides algorithm for approximating the traveling salesman problem, approximating the multi-terminal minimum cut problem (which is equivalent in the single-terminal case to the maximum flow problem), and approximating the minimum-cost weighted perfect matching.</p>
<p>Other practical applications based on minimal spanning trees include:</p>
<ul>
<li>Taxonomy.</li>
<li>Cluster analysis: clustering points in the plane, single-linkage clustering (a method of hierarchical clustering), graph-theoretic clustering, and clustering gene expression data.</li>
<li>Constructing trees for broadcasting in computer networks. On Ethernet networks this is accomplished by means of the Spanning tree protocol.</li>
<li>Image registration and segmentation — see minimum spanning tree-based segmentation.</li>
<li>Curvilinear feature extraction in computer vision.</li>
<li>Handwriting recognition of mathematical expressions.</li>
<li>Circuit design: implementing efficient multiple constant multiplications, as used in finite impulse response filters.</li>
<li>Regionalisation of socio-geographic areas, the grouping of areas into homogeneous, contiguous regions.</li>
<li>Comparing ecotoxicology data.</li>
<li>Topological observability in power systems.</li>
<li>Measuring homogeneity of two-dimensional materials.</li>
<li>Minimax process control.</li>
</ul>
<p>In pedagogical contexts, minimum spanning tree algorithms serve as a common introductory example of both graph algorithms and greedy algorithms due to their simplicity.</p>
<h2>Related problems</h2>
<p>The problem of finding the Steiner tree of a subset of the vertices, that is, minimum tree that spans the given subset, is known to be NP-Complete.</p>
<p>A related problem is the <i>k</i>-minimum spanning tree (<i>k</i>-MST), which is the tree that spans some subset of <i>k</i> vertices in the graph with minimum weight.</p>
<p>A set of <i>k-smallest spanning trees</i> is a subset of <i>k</i> spanning trees (out of all possible spanning trees) such that no spanning tree outside the subset has smaller weight. (Note that this problem is unrelated to the <i>k</i>-minimum spanning tree.)</p>
<p>The Euclidean minimum spanning tree is a spanning tree of a graph with edge weights corresponding to the Euclidean distance between vertices which are points in the plane (or space).</p>
<p>The rectilinear minimum spanning tree is a spanning tree of a graph with edge weights corresponding to the rectilinear distance between vertices which are points in the plane (or space).</p>
<p>In the distributed model, where each node is considered a computer and no node knows anything except its own connected links, one can consider distributed minimum spanning tree. The mathematical definition of the problem is the same but there are different approaches for a solution.</p>
<p>The capacitated minimum spanning tree is a tree that has a marked node (origin, or root) and each of the subtrees attached to the node contains no more than a <i>c</i> nodes. <i>c</i> is called a tree capacity. Solving CMST optimally is NP-hard, but good heuristics such as Esau-Williams and Sharma produce solutions close to optimal in polynomial time.</p>
<p>The degree constrained minimum spanning tree is a minimum spanning tree in with each vertex is connected to no more than <i>d</i> other vertices, for some given number <i>d</i>. The case <i>d</i> = 2 is a special case of the traveling salesman problem, so the degree constrained minimum spanning tree is NP-hard in general.</p>
<p>For directed graphs, the minimum spanning tree problem is called the Arborescence problem and can be solved in quadratic time using the Chu–Liu/Edmonds algorithm.</p>
<p>A <b>maximum spanning tree</b> is a spanning tree with weight greater than or equal to the weight of every other spanning tree. Such a tree can be found with algorithms such as Prim's or Kruskal's after multiplying the edge weights by -1 and solving the MST problem on the new graph. A path in the maximum spanning tree is the widest path in the graph between its two endpoints: among all possible paths, it maximizes the weight of the minimum-weight edge. Maximum spanning trees find applications in parsing algorithms for natural languages and in training algorithms for conditional random fields.</p>
<p>The <b>dynamic MST</b> problem concerns the update of a previously computed MST after an edge weight change in the original graph or the insertion/deletion of a vertex.</p>
<p>The minimum labeling spanning tree problem is to find a spanning tree with least types of labels if each edge in a graph is associated with a label from a finite label set instead of a weight.</p>
<h2>Minimum bottleneck spanning tree</h2>
<p>A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a <b>minimum bottleneck spanning tree</b> (or <b>MBST</b>) if the graph does not contain a spanning tree with a smaller bottleneck edge weight. A MST is necessarily a MBST (provable by the cut property), but a MBST is not necessarily a MST.</p>
</body>
</html>