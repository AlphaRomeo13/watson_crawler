<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Quadtree---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Quadtree</h1>
<p>A <b>quadtree</b> is a tree data structure in which each internal node has exactly four children. Quadtrees are most often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. The regions may be square or rectangular, or may have arbitrary shapes. This data structure was named a quadtree by Raphael Finkel and J.L. Bentley in 1974. A similar partitioning is also known as a <i>Q-tree</i>. All forms of quadtrees share some common features:</p>
<ul>
<li>They decompose space into adaptable cells</li>
<li>Each cell (or bucket) has a maximum capacity. When maximum capacity is reached, the bucket splits</li>
<li>The tree directory follows the spatial decomposition of the quadtree.</li>
</ul>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Types
<ul>
<li>1.1 The region quadtree</li>
<li>1.2 Point quadtree
<ul>
<li>1.2.1 Node structure for a point quadtree</li>
</ul>
</li>
<li>1.3 Edge quadtree</li>
<li>1.4 Polygonal map quadtree</li>
</ul>
</li>
<li>2 Some common uses of quadtrees</li>
<li>3 Pseudo code
<ul>
<li>3.1 Prerequisites</li>
<li>3.2 QuadTree class</li>
<li>3.3 Insertion</li>
<li>3.4 Query range</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References
<ul>
<li>5.1 Notes</li>
<li>5.2 General references</li>
</ul>
</li>
<li>6 External links</li>
</ul>
<ul>
<li>1.1 The region quadtree</li>
<li>1.2 Point quadtree
<ul>
<li>1.2.1 Node structure for a point quadtree</li>
</ul>
</li>
<li>1.3 Edge quadtree</li>
<li>1.4 Polygonal map quadtree</li>
</ul>
<ul>
<li>1.2.1 Node structure for a point quadtree</li>
</ul>
<ul>
<li>3.1 Prerequisites</li>
<li>3.2 QuadTree class</li>
<li>3.3 Insertion</li>
<li>3.4 Query range</li>
</ul>
<ul>
<li>5.1 Notes</li>
<li>5.2 General references</li>
</ul>
<p></p>
<h2>Types</h2>
<p>Quadtrees may be classified according to the type of data they represent, including areas, points, lines and curves. Quadtrees may also be classified by whether the shape of the tree is independent of the order data is processed. Some common types of quadtrees are:</p>
<h3>The region quadtree</h3>
<p>The region quadtree represents a partition of space in two dimensions by decomposing the region into four equal quadrants, subquadrants, and so on with each leaf node containing data corresponding to a specific subregion. Each node in the tree either has exactly four children, or has no children (a leaf node). The region quadtree is a type of trie.</p>
<p>A region quadtree with a depth of n may be used to represent an image consisting of 2 × 2 pixels, where each pixel value is 0 or 1. The root node represents the entire image region. If the pixels in any region are not entirely 0s or 1s, it is subdivided. In this application, each leaf node represents a block of pixels that are all 0s or all 1s.</p>
<p>A region quadtree may also be used as a variable resolution representation of a data field. For example, the temperatures in an area may be stored as a quadtree, with each leaf node storing the average temperature over the subregion it represents.</p>
<p>If a region quadtree is used to represent a set of point data (such as the latitude and longitude of a set of cities), regions are subdivided until each leaf contains at most a single point.</p>
<h3>Point quadtree</h3>
<p>The point quadtree is an adaptation of a binary tree used to represent two-dimensional point data. It shares the features of all quadtrees but is a true tree as the center of a subdivision is always on a point. The tree shape depends on the order in which data is processed. It is often very efficient in comparing two-dimensional, ordered data points, usually operating in O(log n) time.</p>
<h4>Node structure for a point quadtree</h4>
<p>A node of a point quadtree is similar to a node of a binary tree, with the major difference being that it has four pointers (one for each quadrant) instead of two ("left" and "right") as in an ordinary binary tree. Also a key is usually decomposed into two parts, referring to x and y coordinates. Therefore a node contains the following information:</p>
<ul>
<li>four pointers: quad[‘NW’], quad[‘NE’], quad[‘SW’], and quad[‘SE’]</li>
<li>point; which in turn contains:
<ul>
<li>key; usually expressed as x, y coordinates</li>
<li>value; for example a name</li>
</ul>
</li>
</ul>
<ul>
<li>key; usually expressed as x, y coordinates</li>
<li>value; for example a name</li>
</ul>
<h3>Edge quadtree</h3>
<p>Edge quadtrees are specifically used to store lines rather than points. Curves are approximated by subdividing cells to a very fine resolution. This can result in extremely unbalanced trees which may defeat the purpose of indexing.</p>
<h3>Polygonal map quadtree</h3>
<p>The polygonal map quadtree (or PM Quadtree) is a variation of quadtree which is used to store collections of polygons that may be degenerate (meaning that they have isolated vertices or edges). There are three main classes of PMQuadtrees, which vary depending on what information they store within each black node. PM3 quadtrees can store any amount of non-intersecting edges and at most one point. PM2 quadtrees are the same as PM3 quadtrees except that all edges must share the same end point. Finally PM1 quadtrees are similar to PM2, but black nodes can contain a point and its edges or just a set of edges that share a point, but you cannot have a point and a set of edges that do not contain the point.</p>
<h2>Some common uses of quadtrees</h2>
<ul>
<li>Image representation<br>
<img alt="Bitmap and its compressed quadtree representation" src="//upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Quad_tree_bitmap.svg/380px-Quad_tree_bitmap.svg.png" width="380" height="156" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Quad_tree_bitmap.svg/570px-Quad_tree_bitmap.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Quad_tree_bitmap.svg/760px-Quad_tree_bitmap.svg.png 2x" data-file-width="680" data-file-height="280"></li>
<li>Spatial indexing</li>
<li>Efficient collision detection in two dimensions</li>
<li>View frustum culling of terrain data</li>
<li>Storing sparse data, such as a formatting information for a spreadsheet or for some matrix calculations</li>
<li>Solution of multidimensional fields (computational fluid dynamics, electromagnetism)</li>
<li>Conway's Game of Life simulation program.</li>
<li>State estimation</li>
<li>Quadtrees are also used in the area of fractal image analysis</li>
</ul>
<p>Quadtrees are the two-dimensional analog of octrees.</p>
<h2>Pseudo code</h2>
<p>The following pseudo code shows one means of implementing a quadtree which handles only points. There are other approaches available.</p>
<h3>Prerequisites</h3>
<p>It is assumed these structures are used.</p>
<p>WHATSON? 78dd6814-646a-4617-95f0-b74b899cd7d4</p>
<pre>
<i>// Simple coordinate object to represent points and vectors</i>
<b>struct</b> XY
{
  <b>float</b> x;
  <b>float</b> y;

  <b>function</b> __construct(<i>float</i> _x, <i>float</i> _y) {...}
}

<i>// Axis-aligned bounding box with half dimension and center</i>
<b>struct</b> AABB
{
  <b>XY</b> center;
  <b>XY</b> halfDimension;

  <b>function</b> __construct(<i>XY</i> center, <i>XY</i> halfDimension) {...}
  <b>function</b> containsPoint(<i>XY</i> p) {...}
  <b>function</b> intersectsAABB(<i>AABB</i> other) {...}
}
</pre>
<h3>QuadTree class</h3>
<p>This class represents both one quad tree and the node where it is rooted.</p>
<p>WHATSON? 7374c88f-9bdf-43ca-9a40-6015ac9f0d63</p>
<pre>
<b>class</b> QuadTree
{
  <i>// Arbitrary constant to indicate how many elements can be stored in this quad tree node</i>
  <b>constant int</b> QT_NODE_CAPACITY = 4;

  <i>// Axis-aligned bounding box stored as a center with half-dimensions</i>
  // to represent the boundaries of this quad tree
  <b>AABB</b> boundary;

  <i>// Points in this quad tree node</i>
  <i>Array of XY [size = QT_NODE_CAPACITY]</i> points;

  <i>// Children</i>
  <b>QuadTree*</b> northWest;
  <b>QuadTree*</b> northEast;
  <b>QuadTree*</b> southWest;
  <b>QuadTree*</b> southEast;

  <i>// Methods</i>
  <b>function</b> __construct(<i>AABB</i> _boundary) {...}
  <b>function</b> insert(<i>XY</i> p) {...}
  <b>function</b> subdivide() {...} <i>// create four children that fully divide this quad into four quads of equal area</i>
  <b>function</b> queryRange(<i>AABB</i> range) {...}
}
</pre>
<h3>Insertion</h3>
<p>The following method inserts a point into the appropriate quad of a quadtree, splitting if necessary.</p>
<p>WHATSON? 3e26f920-d8d5-4af6-a7d6-2e93cbd2d066</p>
<pre>
<b>class</b> QuadTree
{
  ...

  <i>// Insert a point into the QuadTree</i>
  <b>function</b> insert(<i>XY</i> p)
  {
    <i>// Ignore objects that do not belong in this quad tree</i>
    <b>if</b> (!boundary.containsPoint(p))
      <b>return</b> <i>false</i>; <i>// object cannot be added</i>

    <i>// If there is space in this quad tree, add the object here</i>
    <b>if</b> (points.size &lt; QT_NODE_CAPACITY)
    {
      points.append(p);
      <b>return</b> <i>true</i>;
    }

    <i>// Otherwise, subdivide and then add the point to whichever node will accept it</i>
    <b>if</b> (northWest == <i>null</i>)
      subdivide();

    <b>if</b> (northWest-&gt;insert(p)) <b>return</b> <i>true</i>;
    <b>if</b> (northEast-&gt;insert(p)) <b>return</b> <i>true</i>;
    <b>if</b> (southWest-&gt;insert(p)) <b>return</b> <i>true</i>;
    <b>if</b> (southEast-&gt;insert(p)) <b>return</b> <i>true</i>;

    <i>// Otherwise, the point cannot be inserted for some unknown reason (this should never happen)</i>
    <b>return</b> <i>false</i>;
  }
}
</pre>
<h3>Query range</h3>
<p>The following method finds all points contained within a range.</p>
<p>WHATSON? 7a040768-6662-43d9-b8ed-555e4bb19edd</p>
<pre>
<b>class</b> QuadTree
{
  ...

  <i>// Find all points that appear within a range</i>
  <b>function</b> queryRange(<i>AABB</i> range)
  {
    <i>// Prepare an array of results</i>
    <i>Array of XY</i> pointsInRange;

    <i>// Automatically abort if the range does not intersect this quad</i>
    <b>if</b> (!boundary.intersectsAABB(range))
      <b>return</b> pointsInRange; <i>// empty list</i>

    <i>// Check objects at this quad level</i>
    <b>for</b> (<b>int</b> p := 0; p &lt; points.size; p++)
    {
      <b>if</b> (range.containsPoint(points[p]))
        pointsInRange.append(points[p]);
    }

    <i>// Terminate here, if there are no children</i>
    <b>if</b> (northWest == <i>null</i>)
      <b>return</b> pointsInRange;

    <i>// Otherwise, add the points from the children</i>
    pointsInRange.appendArray(northWest-&gt;queryRange(range));
    pointsInRange.appendArray(northEast-&gt;queryRange(range));
    pointsInRange.appendArray(southWest-&gt;queryRange(range));
    pointsInRange.appendArray(southEast-&gt;queryRange(range));

    <b>return</b> pointsInRange;
  }
}
</pre>
<h2>See also</h2>
<ul>
<li>Binary space partitioning</li>
<li>Kd-tree</li>
<li>Octree</li>
<li>R-tree</li>
<li>UB-tree</li>
<li>Spatial database</li>
<li>Subpaving</li>
</ul>
</body>
</html>