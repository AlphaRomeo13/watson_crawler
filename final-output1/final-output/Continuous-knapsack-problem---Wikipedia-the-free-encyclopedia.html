<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Continuous-knapsack-problem---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Continuous knapsack problem</h1>
<p>In theoretical computer science, the <b>continuous knapsack problem</b> (also known as the <b>fractional knapsack problem</b>) is an algorithmic problem in combinatorial optimization in which the goal is to fill a container (the "knapsack") with fractional amounts of different materials chosen to maximize the value of the selected materials. It resembles the classic knapsack problem, in which the items to be placed in the container are indivisible; however, the continuous knapsack problem may be solved in polynomial time whereas the classic knapsack problem is NP-hard. It is a classic example of how a seemingly small change in the formulation of a problem can have a large impact on its computational complexity.</p>
<h2>Problem definition</h2>
<p>An instance of either the continuous or classic knapsack problems may be specified by the numerical capacity <i>W</i> of the knapsack, together with a collection of materials, each of which has two numbers associated with it: the weight <i>w<sub>i</sub></i> of material that is available to be selected and the value per unit weight <i>v<sub>i</sub></i> of that material. The goal is to choose an amount <i>x<sub>i</sub></i> ≤ <i>w<sub>i</sub></i> of each material, subject to the capacity constraint</p>
<p>and maximizing the total benefit</p>
<p>In the classic knapsack problem, each of the amounts <i>x<sub>i</sub></i> must be either zero or <i>w<sub>i</sub></i>; the continuous knapsack problem differs by allowing <i>x<sub>i</sub></i> to range continuously from zero to <i>w<sub>i</sub></i>. Some formulations of this problem rescale the variables <i>x<sub>i</sub></i> to be in the range from 0 to 1</p>
<h2>Solution technique</h2>
<p>The continuous knapsack problem may be solved by a greedy algorithm, first published in 1957 by George Dantzig, that considers the materials in sorted order by their values per unit weight. For each material, the amount <i>x<sub>i</sub></i> is chosen to be as large as possible:</p>
<ul>
<li>If the sum of the choices made so far equals the capacity <i>W</i>, then the algorithm sets <i>x<sub>i</sub></i> = 0.</li>
<li>If the difference <i>d</i> between the sum of the choices made so far and <i>W</i> is smaller than <i>w<sub>i</sub></i>, then the algorithm sets <i>x<sub>i</sub></i> = <i>d</i>.</li>
<li>In the remaining case, the algorithm chooses <i>x<sub>i</sub></i> = <i>w<sub>i</sub></i>.</li>
</ul>
<p>Because of the need to sort the materials, this algorithm takes time <i>O</i>(<i>n</i> log <i>n</i>) on inputs with <i>n</i> materials. However, by adapting an algorithm for finding weighted medians, it is possible to solve the problem in time <i>O</i>(<i>n</i>).</p>
</body>
</html>