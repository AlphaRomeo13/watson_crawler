<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Dinics-algorithm---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Dinic's algorithm</h1>
<p><b>Dinitz's algorithm</b> is a strongly polynomial algorithm for computing the maximum flow in a flow network, conceived in 1970 by Israeli (formerly Soviet) computer scientist Yefim Dinitz. The algorithm runs in <img class="mwe-math-fallback-image-inline tex" alt="O(V^2 E)" src="//upload.wikimedia.org/math/5/3/2/5321e09d73abc9170644b976e32e4363.png"> time and is similar to the Edmonds–Karp algorithm, which runs in <img class="mwe-math-fallback-image-inline tex" alt="O(VE^2)" src="//upload.wikimedia.org/math/5/f/6/5f6efa25e70cb61890a9bc3ebae39c47.png"> time, in that it uses shortest augmenting paths. The introduction of the concepts of the <i>level graph</i> and <i>blocking flow</i> enable Dinic's algorithm to achieve its performance.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Definition</li>
<li>2 Algorithm</li>
<li>3 Analysis
<ul>
<li>3.1 Special cases</li>
</ul>
</li>
<li>4 Example</li>
<li>5 History</li>
<li>6 See also</li>
<li>7 Notes</li>
<li>8 References</li>
</ul>
<ul>
<li>3.1 Special cases</li>
</ul>
<p></p>
<h2>Definition</h2>
<p>Let <img class="mwe-math-fallback-image-inline tex" alt="G = ((V,E),c,s,t)" src="//upload.wikimedia.org/math/9/a/9/9a902516c139cdc7ad8f435292392abb.png"> be a network with <img class="mwe-math-fallback-image-inline tex" alt="c(u,v)" src="//upload.wikimedia.org/math/6/3/9/63900c7efa10a56ca2267a5fb4ee201a.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(u,v)" src="//upload.wikimedia.org/math/c/4/9/c499b59d362ea18ab698391a53819df1.png"> the capacity and the flow of the edge <img class="mwe-math-fallback-image-inline tex" alt="(u,v)" src="//upload.wikimedia.org/math/9/0/9/9093cc72d2d40694b9361424cb0a6803.png"> respectively.</p>
<ol>
<li>if <img class="mwe-math-fallback-image-inline tex" alt="(u,v)\in E" src="//upload.wikimedia.org/math/2/0/7/2077a4df35530fa21c75805d81eb3822.png">,
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt="c_f(u,v) = c(u,v) - f(u,v) " src="//upload.wikimedia.org/math/2/8/7/2876037d4ab96e4eb6a0623f19f62861.png"></dd>
<dd><img class="mwe-math-fallback-image-inline tex" alt="c_f(v,u) = f(u,v)" src="//upload.wikimedia.org/math/6/b/0/6b0ce1219d520b10e68c00511cf3c5e6.png"></dd>
</dl>
</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="c_f(u,v) = 0" src="//upload.wikimedia.org/math/a/d/2/ad2f6b6ff89e89109932f087c1431a3d.png"> otherwise.</li>
</ol>
<h2>Algorithm</h2>
<p><b>Dinic's Algorithm</b></p>
<ol>
<li>Set <img class="mwe-math-fallback-image-inline tex" alt="f(e) = 0" src="//upload.wikimedia.org/math/4/6/2/4622cef5d6ca3755c13540ad75682aa9.png"> for each <img class="mwe-math-fallback-image-inline tex" alt="e\in E" src="//upload.wikimedia.org/math/5/3/3/53375db67b95672b2b0522f38d12b96e.png">.</li>
<li>Construct <img class="mwe-math-fallback-image-inline tex" alt="G_L" src="//upload.wikimedia.org/math/0/2/6/0262d26220feb07feaef6d0c3464b7c1.png"> from <img class="mwe-math-fallback-image-inline tex" alt="G_f" src="//upload.wikimedia.org/math/1/f/a/1fae2f2405966218e18bcf694978c6e2.png"> of <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png">. If <img class="mwe-math-fallback-image-inline tex" alt="\operatorname{dist}(t) = \infty" src="//upload.wikimedia.org/math/a/0/c/a0c9e32edc90dad788237a79cc4a649a.png">, stop and output <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png">.</li>
<li>Find a blocking flow <img class="mwe-math-fallback-image-inline tex" alt="f\;'" src="//upload.wikimedia.org/math/d/3/a/d3ade12fdb606b2a3159088af7839155.png"> in <img class="mwe-math-fallback-image-inline tex" alt="G_L" src="//upload.wikimedia.org/math/0/2/6/0262d26220feb07feaef6d0c3464b7c1.png">.</li>
<li>Augment flow <img class="mwe-math-fallback-image-inline tex" alt="\ f" src="//upload.wikimedia.org/math/6/1/6/616fb717ed0ab1dbf5ded834a72ae83e.png"> by <img class="mwe-math-fallback-image-inline tex" alt="f\;'" src="//upload.wikimedia.org/math/d/3/a/d3ade12fdb606b2a3159088af7839155.png"> and go back to step 2.</li>
</ol>
<h2>Analysis</h2>
<p>It can be shown that the number of edges in each blocking flow increases by at least 1 each time and thus there are at most <img class="mwe-math-fallback-image-inline tex" alt="n-1" src="//upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"> blocking flows in the algorithm, where <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> is the number of vertices in the network. The level graph <img class="mwe-math-fallback-image-inline tex" alt="G_L" src="//upload.wikimedia.org/math/0/2/6/0262d26220feb07feaef6d0c3464b7c1.png"> can be constructed by Breadth-first search in <img class="mwe-math-fallback-image-inline tex" alt="O(E)" src="//upload.wikimedia.org/math/2/1/a/21aef3b32ae97d3e6e8ff4d095fb3d56.png"> time and a blocking flow in each level graph can be found in <img class="mwe-math-fallback-image-inline tex" alt="O(VE)" src="//upload.wikimedia.org/math/8/c/0/8c027a5c7a221c5c2f990088f3652616.png"> time. Hence, the running time of Dinic's algorithm is <img class="mwe-math-fallback-image-inline tex" alt="O(V^2 E)" src="//upload.wikimedia.org/math/5/3/2/5321e09d73abc9170644b976e32e4363.png">.</p>
<p>Using a data structure called dynamic trees, the running time of finding a blocking flow in each phase can be reduced to <img class="mwe-math-fallback-image-inline tex" alt="O(E \log V)" src="//upload.wikimedia.org/math/f/a/5/fa5658c21a16769ab29589ea2ec67faa.png"> and therefore the running time of Dinic's algorithm can be improved to <img class="mwe-math-fallback-image-inline tex" alt="O(VE \log V)" src="//upload.wikimedia.org/math/e/e/8/ee80854dc07b66e632debc19d5a558c5.png">.</p>
<h3>Special cases</h3>
<p>In networks with unit capacities, a much stronger time bound holds. Each blocking flow can be found in <img class="mwe-math-fallback-image-inline tex" alt="O(E)" src="//upload.wikimedia.org/math/2/1/a/21aef3b32ae97d3e6e8ff4d095fb3d56.png"> time, and it can be shown that the number of phases does not exceed <img class="mwe-math-fallback-image-inline tex" alt="O(\sqrt{E})" src="//upload.wikimedia.org/math/5/8/8/588b538c644ad2fa5bee689c8572d511.png"> and <img class="mwe-math-fallback-image-inline tex" alt="O(V^{2/3})" src="//upload.wikimedia.org/math/b/b/7/bb77dc416eb5dfe806d49a8427517a2a.png">. Thus the algorithm runs in <img class="mwe-math-fallback-image-inline tex" alt="O(\min\{V^{2/3}, E^{1/2}\}E)" src="//upload.wikimedia.org/math/a/d/c/adc71c40a983a9ca087a8c1d26e39af4.png"> time.</p>
<p>In networks arising during the solution of bipartite matching problem, the number of phases is bounded by <img class="mwe-math-fallback-image-inline tex" alt="O(\sqrt{V})" src="//upload.wikimedia.org/math/4/9/8/498874b0121a99520570da43415d9f8c.png">, therefore leading to the <img class="mwe-math-fallback-image-inline tex" alt="O(\sqrt{V} E)" src="//upload.wikimedia.org/math/e/5/4/e54d6a8f7b9e803aedf94def4ff1bbbd.png"> time bound. The resulting algorithm is also known as Hopcroft–Karp algorithm. More generally, this bound holds for any <i>unit network</i> — a network in which each vertex, except for source and sink, either has a single entering edge of capacity one, or a single outgoing edge of capacity one, and all other capacities are arbitrary integers.</p>
<h2>Example</h2>
<p>The following is a simulation of the Dinic's algorithm. In the level graph <img class="mwe-math-fallback-image-inline tex" alt="G_L" src="//upload.wikimedia.org/math/0/2/6/0262d26220feb07feaef6d0c3464b7c1.png">, the vertices with labels in red are the values <img class="mwe-math-fallback-image-inline tex" alt="\operatorname{dist}(v)" src="//upload.wikimedia.org/math/7/f/0/7f0c857ae214f513214fcdaec5ee6640.png">. The paths in blue form a blocking flow.</p>
<p>The blocking flow consists of</p>
<ol>
<li><img class="mwe-math-fallback-image-inline tex" alt="\{s, 1, 3, t\}" src="//upload.wikimedia.org/math/a/4/8/a487073d5731db8a20aa4bb21d2b3fb0.png"> with 4 units of flow,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\{s, 1, 4, t\}" src="//upload.wikimedia.org/math/d/9/3/d93c736e648e0ceeabe8311206bdeed8.png"> with 6 units of flow, and</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\{s, 2, 4, t\}" src="//upload.wikimedia.org/math/3/3/b/33b08bdfba6cc7f616ccefea1bb2e01b.png"> with 4 units of flow.</li>
</ol>
<p>Therefore the blocking flow is of 14 units and the value of flow <img class="mwe-math-fallback-image-inline tex" alt="|f|" src="//upload.wikimedia.org/math/1/a/d/1adcfd50c9e00fbf417ee939945504a1.png"> is 14. Note that each augmenting path in the blocking flow has <i>3</i> edges.</p>
<p>The blocking flow consists of</p>
<ol>
<li><img class="mwe-math-fallback-image-inline tex" alt="\{s, 2, 4, 3, t\}" src="//upload.wikimedia.org/math/6/e/4/6e44b8f56dc7595fcdbae57a2f283bba.png"> with 5 units of flow.</li>
</ol>
<p>Therefore the blocking flow is of 5 units and the value of flow <img class="mwe-math-fallback-image-inline tex" alt="|f|" src="//upload.wikimedia.org/math/1/a/d/1adcfd50c9e00fbf417ee939945504a1.png"> is 14 + 5 = 19. Note that each augmenting path has 4 edges.</p>
<p>Since <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> cannot be reached in <img class="mwe-math-fallback-image-inline tex" alt="G_f" src="//upload.wikimedia.org/math/1/f/a/1fae2f2405966218e18bcf694978c6e2.png">. The algorithm terminates and returns a flow with maximum value of 19. Note that in each blocking flow, the number of edges in the augmenting path increases by at least 1.</p>
<h2>History</h2>
<p>Dinic's algorithm was published in 1970 by former Russian Computer Scientist Yefim (Chaim) A. Dinitz, who is today a member of the Computer Science department at Ben-Gurion University of the Negev (Israel), earlier than the Edmonds–Karp algorithm, which was published in 1972 but was discovered earlier. They independently showed that in the Ford–Fulkerson algorithm, if each augmenting path is the shortest one, the length of the augmenting paths is non-decreasing.</p>
<h2>See also</h2>
<ul>
<li>Ford–Fulkerson algorithm</li>
<li>Maximum flow problem</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Yefim Dinitz (1970). "Algorithm for solution of a problem of maximum flow in a network with power estimation". <i>Doklady Akademii nauk SSSR</i> <b>11</b>: 1277–1280. </li>
<li><b>^</b> Tarjan 1983, p. 102.</li>
</ol>
</body>
</html>