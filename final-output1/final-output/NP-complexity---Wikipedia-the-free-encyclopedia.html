<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>NP-complexity---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>NP (complexity)</h1>
<p>In computational complexity theory, <b>NP</b> is one of the most fundamental complexity classes. The abbreviation <b>NP</b> refers to "nondeterministic polynomial time."</p>
<p>Intuitively, <b>NP</b> is the set of all decision problems for which the instances where the answer is "yes" have efficiently verifiable proofs of the fact that the answer is indeed "yes". More precisely, these proofs have to be <i>verifiable</i> in polynomial time by a deterministic Turing machine. In an equivalent formal definition, <b>NP</b> is the set of decision problems where the "yes"-instances can be accepted in polynomial time by a non-deterministic Turing machine. The equivalence of the two definitions follows from the fact that an algorithm on such a non-deterministic machine consists of two phases, the first of which consists of a guess about the solution, which is generated in a non-deterministic way, while the second consists of a deterministic algorithm that verifies or rejects the guess as a valid solution to the problem.</p>
<p>The complexity class <b>P</b> is contained in <b>NP</b>, but <b>NP</b> contains many important problems, the hardest of which are called <b>NP</b>-complete problems, whose solutions are sufficient to deal with any other NP problem in polynomial time. The most important open question in complexity theory, the <b>P</b> = <b>NP</b> problem, asks whether polynomial time algorithms actually exist for <b>NP</b>-complete, and by corollary, all <b>NP</b> problems. It is widely believed that this is not the case.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Formal definition</li>
<li>2 Introduction
<ul>
<li>2.1 Verifier-based definition</li>
<li>2.2 Machine-definition</li>
<li>2.3 Examples</li>
</ul>
</li>
<li>3 Why some NP problems are hard to solve</li>
<li>4 Equivalence of definitions</li>
<li>5 Relationship to other classes</li>
<li>6 Other characterizations</li>
<li>7 Example</li>
<li>8 References</li>
<li>9 External links</li>
</ul>
<ul>
<li>2.1 Verifier-based definition</li>
<li>2.2 Machine-definition</li>
<li>2.3 Examples</li>
</ul>
<p></p>
<h2>Formal definition</h2>
<p>The complexity class <b>NP</b> can be defined in terms of NTIME as follows:</p>
<p>Alternatively, <b>NP</b> can be defined using deterministic Turing machines as verifiers. A language <i>L</i> is in <b>NP</b> if and only if there exist polynomials <i>p</i> and <i>q</i>, and a deterministic Turing machine <i>M</i>, such that</p>
<ul>
<li>For all <i>x</i> and <i>y</i>, the machine <i>M</i> runs in time <i>p</i>(|<i>x</i>|<i>)</i> on input <i>(x,y)</i></li>
<li>For all <i>x</i> in <i>L</i>, there exists a string <i>y</i> of length <i>q</i>(|<i>x</i>|) such that <i>M(x,y)</i> = 1</li>
<li>For all <i>x</i> not in <i>L</i> and all strings <i>y</i> of length <i>q</i>(|<i>x</i>|), <i>M(x,y)</i> = 0</li>
</ul>
<h2>Introduction</h2>
<p>Many natural computer science problems are covered by the class <b>NP</b>. In particular, the decision versions of many interesting search problems and optimization problems are contained in <b>NP</b>.</p>
<h3>Verifier-based definition</h3>
<p>In order to explain the verifier-based definition of <b>NP</b>, let us consider the subset sum problem: Assume that we are given some integers, such as {−7, −3, −2, 5, 8}, and we wish to know whether some of these integers sum up to zero. In this example, the answer is "yes", since the subset of integers {−3, −2, 5} corresponds to the sum (−3) + (−2) + 5 = 0. The task of deciding whether such a subset with sum zero exists is called the <i>subset sum problem</i>.</p>
<p>To answer if some of the integers add to zero we can create an algorithm which obtains all the possible subsets. As the number of integers that we feed into the algorithm becomes larger, the number of subsets grows exponentially and so does the computation time. However, notice that, if we are given a particular subset (often called a <i>certificate</i>), we can easily check or <i>verify</i> whether the subset sum is zero, by just summing up the integers of the subset. So if the sum is indeed zero, that particular subset is the <i>proof</i> or witness for the fact that the answer is "yes". An algorithm that verifies whether a given subset has sum zero is called <i>verifier</i>. A problem is said to be in <b>NP</b> if there exists a verifier for the problem that executes in polynomial time. In case of the subset sum problem, the verifier needs only polynomial time, for which reason the subset sum problem is in <b>NP</b>.</p>
<p>The "no"-answer version of this problem is stated as: "given a finite set of integers, does every non-empty subset have a nonzero sum?". The verifier-based definition of <b>NP</b> does <i>not</i> require an easy-to-verify certificate for the "no"-answers. The class of problems with such certificates for the "no"-answers is called <b>co-NP</b>. In fact, it is an open question whether all problems in <b>NP</b> also have certificates for the "no"-answers and thus are in <b>co-NP</b>.</p>
<h3>Machine-definition</h3>
<p>Equivalent to the verifier-based definition is the following characterization: <b>NP</b> is the set of decision problems solvable by a non-deterministic Turing machine that runs in polynomial time. (This means that there is an accepting computation path if a word is in the language – <b>co-NP</b> is defined dually with rejecting paths.) This definition is equivalent to the verifier-based definition because a non-deterministic Turing machine could solve an NP problem in polynomial time by non-deterministically selecting a certificate and running the verifier on the certificate. Similarly, if such a machine exists, then a polynomial time verifier can naturally be constructed from it.</p>
<h3>Examples</h3>
<p>This is an incomplete list of problems that are in <b>NP</b>.</p>
<ul>
<li>All problems in <b>P</b> (For, given a certificate for a problem in <b>P</b>, we can ignore the certificate and just solve the problem in polynomial time. Alternatively, a deterministic Turing machine is also trivially a non-deterministic Turing machine that just happens to not use any non-determinism.)</li>
<li>The decision problem version of the integer factorization problem: given integers <i>n</i> and <i>k</i>, is there a factor <i>f</i> with 1 &lt; <i>f</i> &lt; <i>k</i> and <i>f</i> dividing <i>n</i>?</li>
<li>The graph isomorphism problem of determining whether two graphs can be drawn identically</li>
<li>All NP-complete problems, e.g.:
<ul>
<li>A variant of the travelling salesman problem, where we want to know if there is a route of some length that goes through all the nodes in a certain network</li>
<li>The boolean satisfiability problem, where we want to know whether or not a certain formula in propositional logic with boolean variables is true for some value of the variables</li>
</ul>
</li>
</ul>
<ul>
<li>A variant of the travelling salesman problem, where we want to know if there is a route of some length that goes through all the nodes in a certain network</li>
<li>The boolean satisfiability problem, where we want to know whether or not a certain formula in propositional logic with boolean variables is true for some value of the variables</li>
</ul>
<h2>Why some NP problems are hard to solve</h2>
<p>Because of the many important problems in this class, there have been extensive efforts to find polynomial-time algorithms for problems in <b>NP</b>. However, there remain a large number of problems in <b>NP</b> that defy such attempts, seeming to require super-polynomial time. Whether these problems are not decidable in polynomial time is one of the greatest open questions in computer science (see <b>P</b> = <b>NP</b> problem for an in-depth discussion).</p>
<p>An important notion in this context is the set of NP-complete decision problems, which is a subset of <b>NP</b> and might be informally described as the "hardest" problems in <b>NP</b>. If there is a polynomial-time algorithm for even <i>one</i> of them, then there is a polynomial-time algorithm for <i>all</i> the problems in <b>NP</b>. Because of this, and because dedicated research has failed to find a polynomial algorithm for any <b>NP</b>-complete problem, once a problem has been proven to be <b>NP</b>-complete this is widely regarded as a sign that a polynomial algorithm for this problem is unlikely to exist.</p>
<p>However, in practical uses, instead of spending computational resources looking for an optimal solution, a good enough (but potentially suboptimal) solution may often be found in polynomial time. Also, the real life applications of some problems are easier than their theoretical equivalents. For example, inputs to the general Travelling salesman problem need not obey the triangle inequality, unlike real road networks.</p>
<h2>Equivalence of definitions</h2>
<p>The two definitions of <b>NP</b> as the class of problems solvable by a nondeterministic Turing machine (TM) in polynomial time and the class of problems verifiable by a deterministic Turing machine in polynomial time are equivalent. The proof is described by many textbooks, for example Sipser's <i>Introduction to the Theory of Computation</i>, section 7.3.</p>
<p>To show this, first suppose we have a deterministic verifier. A nondeterministic machine can simply nondeterministically run the verifier on all possible proof strings (this requires only polynomially many steps because it can nondeterministically choose the next character in the proof string in each step, and the length of the proof string must be polynomially bounded). If any proof is valid, some path will accept; if no proof is valid, the string is not in the language and it will reject.</p>
<p>Conversely, suppose we have a nondeterministic TM called A accepting a given language L. At each of its polynomially many steps, the machine's computation tree branches in at most a constant number of directions. There must be at least one accepting path, and the string describing this path is the proof supplied to the verifier. The verifier can then deterministically simulate A, following only the accepting path, and verifying that it accepts at the end. If A rejects the input, there is no accepting path, and the verifier will never accept.</p>
<h2>Relationship to other classes</h2>
<p><b>NP</b> contains all problems in <b>P</b>, since one can verify any instance of the problem by simply ignoring the proof and solving it. <b>NP</b> is contained in <b>PSPACE</b>—to show this, it suffices to construct a <b>PSPACE</b> machine that loops over all proof strings and feeds each one to a polynomial-time verifier. Since a polynomial-time machine can only read polynomially many bits, it cannot use more than polynomial space, nor can it read a proof string occupying more than polynomial space (so we do not have to consider proofs longer than this). <b>NP</b> is also contained in EXPTIME, since the same algorithm operates in exponential time.</p>
<p>The complement of <b>NP</b>, co-NP, contains those problems which have a simple proof for <i>no</i> instances, sometimes called counterexamples. For example, primality testing trivially lies in co-NP, since one can refute the primality of an integer by merely supplying a nontrivial factor. <b>NP</b> and co-NP together form the first level in the polynomial hierarchy, higher only than <b>P</b>.</p>
<p><b>NP</b> is defined using only deterministic machines. If we permit the verifier to be probabilistic (this however, is not necessarily a BPP machine  ), we get the class <b>MA</b> solvable using an Arthur-Merlin protocol with no communication from Merlin to Arthur.</p>
<p><b>NP</b> is a class of decision problems; the analogous class of function problems is FNP.</p>
<p>The only known strict inclusions came from the space hierarchy theorem and the time hierarchy theorem, and respectively they are <b>NP</b> <img class="mwe-math-fallback-image-inline tex" alt="\subsetneq" src="//upload.wikimedia.org/math/d/5/5/d5557175d90cbb263ae71f0dfebbf732.png"> <b>NEXPTIME</b> and <b>NP</b> <img class="mwe-math-fallback-image-inline tex" alt="\subsetneq" src="//upload.wikimedia.org/math/d/5/5/d5557175d90cbb263ae71f0dfebbf732.png"> <b>EXPSPACE</b>.</p>
<h2>Other characterizations</h2>
<p>In terms of descriptive complexity theory, <b>NP</b> corresponds precisely to the set of languages definable by existential second-order logic (Fagin's theorem).</p>
<p><b>NP</b> can be seen as a very simple type of interactive proof system, where the prover comes up with the proof certificate and the verifier is a deterministic polynomial-time machine that checks it. It is complete because the right proof string will make it accept if there is one, and it is sound because the verifier cannot accept if there is no acceptable proof string.</p>
<p>A major result of complexity theory is that <b>NP</b> can be characterized as the problems solvable by probabilistically checkable proofs where the verifier uses O(log <i>n</i>) random bits and examines only a constant number of bits of the proof string (the class <b>PCP</b>(log <i>n</i>, 1)). More informally, this means that the <b>NP</b> verifier described above can be replaced with one that just "spot-checks" a few places in the proof string, and using a limited number of coin flips can determine the correct answer with high probability. This allows several results about the hardness of approximation algorithms to be proven.</p>
<h2>Example</h2>
<p>The decision version of the travelling salesman problem is in <b>NP</b>. Given an input matrix of distances between <i>n</i> cities, the problem is to determine if there is a route visiting all cities with total distance less than <i>k</i>.</p>
<p>A proof certificate can simply be a list of the cities. Then verification can clearly be done in polynomial time by a deterministic Turing machine. It simply adds the matrix entries corresponding to the paths between the cities.</p>
<p>A non-deterministic Turing machine can find such a route as follows:</p>
<ul>
<li>At each city it visits it "guesses" the next city to visit, until it has visited every vertex. If it gets stuck, it stops immediately.</li>
<li>At the end it verifies that the route it has taken has cost less than <i>k</i> in O(<i>n</i>) time.</li>
</ul>
<p>One can think of each guess as "forking" a new copy of the Turing machine to follow each of the possible paths forward, and if at least one machine finds a route of distance less than <i>k</i>, that machine accepts the input. (Equivalently, this can be thought of as a single Turing machine that always guesses correctly)</p>
<p>A binary search on the range of possible distances can convert the decision version of Traveling Salesman to the optimization version, by calling the decision version repeatedly (a polynomial number of times).</p>
</body>
</html>