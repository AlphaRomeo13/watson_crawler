<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Polynomial-time-reduction---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Polynomial-time reduction</h1>
<p>In computational complexity theory, a <b>polynomial-time reduction</b> is a method of solving one problem by means of a hypothetical subroutine for solving a different problem (that is, a reduction), that uses polynomial time excluding the time within the subroutine. There are several different types of polynomial-time reduction, depending on the details of how the subroutine is used. Intuitively, a polynomial-time reduction proves that the first problem is no more difficult than the second one, because whenever an efficient algorithm exists for the second problem, one exists for the first problem as well. Polynomial-time reductions are frequently used in complexity theory for defining both complexity classes and complete problems for those classes.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Types of reduction</li>
<li>2 Completeness</li>
<li>3 Defining complexity classes</li>
<li>4 See also</li>
<li>5 References</li>
</ul>
<p></p>
<h2>Types of reduction</h2>
<p>The three most common types of polynomial-time reduction, from the most to the least restrictive, are polynomial-time many-one reductions, truth-table reductions, and Turing reductions.</p>
<ul>
<li>A polynomial-time many-one reduction from a problem <i>A</i> to a problem <i>B</i> (both of which are usually required to be decision problems) is a polynomial-time algorithm for transforming inputs to problem <i>A</i> into inputs to problem <i>B</i>, such that the transformed problem has the same output as the original problem. An instance <i>x</i> of problem <i>A</i> can be solved by applying this transformation to produce an instance <i>y</i> of problem <i>B</i>, giving <i>y</i> as the input to an algorithm for problem <i>B</i>, and returning its output. Polynomial-time many-one reductions may also be known as <b>polynomial transformations</b> or <b>Karp reductions</b>, named after Richard Karp. A reduction of this type may be denoted by the expression <img class="mwe-math-fallback-image-inline tex" alt="A \le_m^P B" src="//upload.wikimedia.org/math/e/2/a/e2a345e8563da7ac084119420bd26669.png">.</li>
<li>A polynomial-time truth-table reduction from a problem <i>A</i> to a problem <i>B</i> (both decision problems) is a polynomial time algorithm for transforming inputs to problem <i>A</i> into a fixed number of inputs to problem <i>B</i>, such that the output for the original problem can be expressed as a function of the outputs for <i>B</i>. The function that maps outputs for <i>B</i> into the output for <i>A</i> must be the same for all inputs, so that it can be expressed by a truth table. A reduction of this type may be denoted by the expression <img class="mwe-math-fallback-image-inline tex" alt="A \le_{tt}^P B" src="//upload.wikimedia.org/math/2/6/6/266c16e28a740530bee9b73bd835fe4c.png">.</li>
<li>A polynomial-time Turing reduction from a problem <i>A</i> to a problem <i>B</i> is an algorithm that solves problem <i>A</i> using a polynomial number of calls to a subroutine for problem <i>B</i>, and polynomial time outside of those subroutine calls. Polynomial-time Turing reductions are also known as <b>Cook reductions</b>, named after Stephen Cook. A reduction of this type may be denoted by the expression <img class="mwe-math-fallback-image-inline tex" alt="A \le_T^P B" src="//upload.wikimedia.org/math/4/3/0/430aa9523eb337350e27a41f4e1a963f.png">.</li>
</ul>
<p>The most frequently used of these are the many-one reductions, and in some cases the phrase "polynomial-time reduction" may be used to mean a polynomial-time many-one reduction.</p>
<h2>Completeness</h2>
<p>A complete problem for a given complexity class <b>C</b> and reduction ≤ is a problem <i>P</i> that belongs to <b>C</b>, such that every problem <i>A</i> in <b>C</b> has a reduction <i>A</i> ≤ <i>P</i>. For instance, a problem is <b>NP</b>-complete if it belongs to <b>NP</b> and all problems in <b>NP</b> have polynomial-time many-one reductions to it. A problem that belongs to <b>NP</b> can be proven to be <b>NP</b>-complete by finding a single polynomial-time many-one reduction to it from a known <b>NP</b>-complete problem. Polynomial-time many-one reductions have been used to define complete problems for other complexity classes, including the <b>PSPACE</b>-complete languages and <b>EXPTIME</b>-complete languages.</p>
<p>Every nontrivial decision problem in <b>P</b> (the class of polynomial-time decision problems, where nontrivial means that not every input has the same output) may be reduced to every other nontrivial decision problem, by a polynomial-time many-one reduction. To transform an instance of problem <i>A</i> to <i>B</i>, solve <i>A</i> in polynomial time, and then use the solution to choose one of two instances of problem <i>B</i> with different answers. Therefore, for complexity classes within <b>P</b> such as <b>L</b>, <b>NL</b>, <b>NC</b>, and <b>P</b> itself, polynomial-time reductions cannot be used to define complete languages: if they were used in this way, every nontrivial problem in <b>P</b> would be complete. Instead, weaker reductions such as log-space reductions or <b>NC</b> reductions are used for defining classes of complete problems for these classes, such as the <b>P</b>-complete problems.</p>
<h2>Defining complexity classes</h2>
<p>The definitions of the complexity classes <b>NP</b>, <b>PSPACE</b>, and <b>EXPTIME</b> do not involve reductions: reductions come into their study only in the definition of complete languages for these classes. However, in some cases a complexity class may be defined by reductions. If <i>C</i> is any decision problem, then one can define a complexity class <b>C</b> consisting of the languages <i>A</i> for which <img class="mwe-math-fallback-image-inline tex" alt="A \le_m^P C" src="//upload.wikimedia.org/math/7/c/b/7cbc0c953d3da381fb12a9cf262dbcff.png">. In this case, <i>C</i> will automatically be complete for <b>C</b>, but <b>C</b> may have other complete problems as well.</p>
<p>An example of this is the complexity class <img class="mwe-math-fallback-image-inline tex" alt="\exists \mathbb{R}" src="//upload.wikimedia.org/math/5/f/7/5f7b0f85d748337f1373aa256fd3c4a8.png"> defined from the existential theory of the reals, a computational problem that is known to be <b>NP</b>-hard and in <b>PSPACE</b>, but is not known to be complete for <b>NP</b>, <b>PSPACE</b>, or any language in the polynomial hierarchy. <img class="mwe-math-fallback-image-inline tex" alt="\exists \mathbb{R}" src="//upload.wikimedia.org/math/5/f/7/5f7b0f85d748337f1373aa256fd3c4a8.png"> is the set of problems having a polynomial-time many-one reduction to the existential theory of the reals; it has several other complete problems such as determining the rectilinear crossing number of an undirected graph. Each problem in <img class="mwe-math-fallback-image-inline tex" alt="\exists \mathbb{R}" src="//upload.wikimedia.org/math/5/f/7/5f7b0f85d748337f1373aa256fd3c4a8.png"> inherits the property of belonging to <b>PSPACE</b>, and each <img class="mwe-math-fallback-image-inline tex" alt="\exists \mathbb{R}" src="//upload.wikimedia.org/math/5/f/7/5f7b0f85d748337f1373aa256fd3c4a8.png">-complete problem is <b>NP</b>-hard.</p>
<p>Similarly, the complexity class <b>GI</b> consists of the problems that can be reduced to the graph isomorphism problem. Since graph isomorphism is known to belong both to <b>NP</b> and co-<b>AM</b>, the same is true for every problem in this class. A problem is <b>GI</b>-complete if it is complete for this class; the graph isomorphism problem itself is <b>GI</b>-complete, as are several other related problems.</p>
<h2>See also</h2>
<ul>
<li>Karp's 21 NP-complete problems</li>
</ul>
</body>
</html>