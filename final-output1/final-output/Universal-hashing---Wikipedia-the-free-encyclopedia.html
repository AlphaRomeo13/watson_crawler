<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Universal-hashing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Universal hashing</h1>
<p>Using <b>universal hashing</b> (in a randomized algorithm or data structure) refers to selecting a hash function at random from a family of hash functions with a certain mathematical property (see definition below). This guarantees a low number of collisions in expectation, even if the data is chosen by an adversary. Many universal families are known (for hashing integers, vectors, strings), and their evaluation is often very efficient. Universal hashing has numerous uses in computer science, for example in implementations of hash tables, randomized algorithms, and cryptography.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Introduction</li>
<li>2 Mathematical guarantees</li>
<li>3 Constructions
<ul>
<li>3.1 Hashing integers
<ul>
<li>3.1.1 Avoiding modular arithmetic</li>
</ul>
</li>
<li>3.2 Hashing vectors</li>
<li>3.3 Hashing strings</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 Further reading</li>
<li>7 External links</li>
</ul>
<ul>
<li>3.1 Hashing integers
<ul>
<li>3.1.1 Avoiding modular arithmetic</li>
</ul>
</li>
<li>3.2 Hashing vectors</li>
<li>3.3 Hashing strings</li>
</ul>
<ul>
<li>3.1.1 Avoiding modular arithmetic</li>
</ul>
<p></p>
<h2>Introduction</h2>
<p>Assume we want to map keys from some universe <img class="mwe-math-fallback-image-inline tex" alt="U" src="//upload.wikimedia.org/math/4/c/6/4c614360da93c0a041b22e537de151eb.png"> into <img class="mwe-math-fallback-image-inline tex" alt="m" src="//upload.wikimedia.org/math/6/f/8/6f8f57715090da2632453988d9a1501b.png"> bins (labelled <img class="mwe-math-fallback-image-inline tex" alt="[m] = \{0, \dots, m-1\}" src="//upload.wikimedia.org/math/9/9/6/996198cf634c01f7df11d24f34f17980.png">). The algorithm will have to handle some data set <img class="mwe-math-fallback-image-inline tex" alt="S \subseteq U" src="//upload.wikimedia.org/math/8/e/8/8e8fd947728f32b7e0b5d6a1cbf753a3.png"> of <img class="mwe-math-fallback-image-inline tex" alt="|S|=n" src="//upload.wikimedia.org/math/1/1/1/1114c80010a66a42faea3d20cfa4cbd2.png"> keys, which is not known in advance. Usually, the goal of hashing is to obtain a low number of collisions (keys from <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> that land in the same bin). A deterministic hash function cannot offer any guarantee in an adversarial setting if the size of <img class="mwe-math-fallback-image-inline tex" alt="U" src="//upload.wikimedia.org/math/4/c/6/4c614360da93c0a041b22e537de151eb.png"> is greater than <img class="mwe-math-fallback-image-inline tex" alt="m^2" src="//upload.wikimedia.org/math/b/8/c/b8c460643608d59ace5819d3971b4261.png">, since the adversary may choose <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> to be precisely the preimage of a bin. This means that all data keys land in the same bin, making hashing useless. Furthermore, a deterministic hash function does not allow for <i>rehashing</i>: sometimes the input data turns out to be bad for the hash function (e.g. there are too many collisions), so one would like to change the hash function.</p>
<p>The solution to these problems is to pick a function randomly from a family of hash functions. A family of functions <img class="mwe-math-fallback-image-inline tex" alt="H = \{ h : U \to [m] \}" src="//upload.wikimedia.org/math/4/f/5/4f541cb630b1b1301c0aecfc337b0844.png"> is called a <b>universal family</b> if, <img class="mwe-math-fallback-image-inline tex" alt="\forall x, y \in U, ~ x\ne y: ~~ \Pr_{h\in H} [h(x) = h(y)] \le \frac{1}{m}" src="//upload.wikimedia.org/math/0/3/0/030fb4de473ae00dd33831fca8d4cbaa.png">.</p>
<p>In other words, any two keys of the universe collide with probability at most <img class="mwe-math-fallback-image-inline tex" alt="1/m" src="//upload.wikimedia.org/math/6/6/e/66e395e2c81b71fbbe0aa725fd4e8c82.png"> when the hash function <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> is drawn randomly from <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png">. This is exactly the probability of collision we would expect if the hash function assigned truly random hash codes to every key. Sometimes, the definition is relaxed to allow collision probability <img class="mwe-math-fallback-image-inline tex" alt="O(1/m)" src="//upload.wikimedia.org/math/7/e/5/7e5471555a2941aa1b1b96e8197fe10b.png">. This concept was introduced by Carter and Wegman in 1977, and has found numerous applications in computer science (see, for example ). If we have an upper bound of <img class="mwe-math-fallback-image-inline tex" alt="\epsilon&lt;1" src="//upload.wikimedia.org/math/7/7/f/77f9c753a5926d6a7394057176713433.png"> on the collision probability, we say that we have <img class="mwe-math-fallback-image-inline tex" alt="\epsilon" src="//upload.wikimedia.org/math/c/5/0/c50b9e82e318d4c163e4b1b060f7daf5.png">-almost universality.</p>
<p>Many, but not all, universal families have the following stronger <b>uniform difference property</b>:</p>
<p>Note that the definition of universality is only concerned with whether <img class="mwe-math-fallback-image-inline tex" alt="h(x)-h(y)=0" src="//upload.wikimedia.org/math/3/5/2/3528fe167d6dd743b46460ace71f47cb.png">, which counts collisions. The uniform difference property is stronger.</p>
<p>(Similarly, a universal family can be XOR universal if <img class="mwe-math-fallback-image-inline tex" alt="\forall x,y\in U, ~ x\ne y" src="//upload.wikimedia.org/math/3/b/2/3b2570194a921d4e40bdb721b8d6ba9a.png">, the value <img class="mwe-math-fallback-image-inline tex" alt="h(x) \oplus h(y) ~\bmod~ m" src="//upload.wikimedia.org/math/b/a/5/ba53d36c7576b80dd47024ac9fdea9eb.png"> is uniformly distributed in <img class="mwe-math-fallback-image-inline tex" alt="[m]" src="//upload.wikimedia.org/math/e/f/c/efc831aabf9ade051f781ccb54c2dcdb.png"> where <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> is the bitwise exclusive or operation. This is only possible if <img class="mwe-math-fallback-image-inline tex" alt="m" src="//upload.wikimedia.org/math/6/f/8/6f8f57715090da2632453988d9a1501b.png"> is a power of two.)</p>
<p>An even stronger condition is pairwise independence: we have this property when <img class="mwe-math-fallback-image-inline tex" alt="\forall x,y\in U, ~ x\ne y" src="//upload.wikimedia.org/math/3/b/2/3b2570194a921d4e40bdb721b8d6ba9a.png"> we have the probability that <img class="mwe-math-fallback-image-inline tex" alt="x,y" src="//upload.wikimedia.org/math/f/1/0/f10bc3c94b77e1d6b9f98106daf335c1.png"> will hash to any pair of hash values <img class="mwe-math-fallback-image-inline tex" alt="z_1, z_2" src="//upload.wikimedia.org/math/6/9/7/69748c0e35087dc0d3c54ab0a0d41cd6.png"> is as if they were perfectly random: <img class="mwe-math-fallback-image-inline tex" alt="P(h(x)=z_1 \land h(y)=z_2)= 1/m^2" src="//upload.wikimedia.org/math/b/0/e/b0e69b8b176b5027044991cf53227482.png">. Pairwise independence is sometimes called strong universality.</p>
<p>Another property is uniformity. We say that a family is uniform if all hash values are equally likely: <img class="mwe-math-fallback-image-inline tex" alt="P(h(x)=z)=1/m" src="//upload.wikimedia.org/math/f/f/4/ff40a0f5f45ff7d42ee70296897240a7.png"> for any hash value <img class="mwe-math-fallback-image-inline tex" alt="z" src="//upload.wikimedia.org/math/f/b/a/fbade9e36a3f36d3d676c1b808451dd7.png">. Universality does not imply uniformity. However, strong universality does imply uniformity.</p>
<p>Given a family with the uniform distance property, one can produce a pairwise independent or strongly universal hash family by adding a uniformly distributed random constant with values in <img class="mwe-math-fallback-image-inline tex" alt="[m]" src="//upload.wikimedia.org/math/e/f/c/efc831aabf9ade051f781ccb54c2dcdb.png"> to the hash functions. (Similarly, if <img class="mwe-math-fallback-image-inline tex" alt="m" src="//upload.wikimedia.org/math/6/f/8/6f8f57715090da2632453988d9a1501b.png"> is a power of two, we can achieve pairwise independence from an XOR universal hash family by doing an exclusive or with a uniformly distributed random constant.) Since a shift by a constant is sometimes irrelevant in applications (e.g. hash tables), a careful distinction between the uniform distance property and pairwise independent is sometimes not made.</p>
<p>For some applications (such as hash tables), it is important for the least significant bits of the hash values to be also universal. When a family is strongly universal, this is guaranteed: if <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> is a strongly universal family with <img class="mwe-math-fallback-image-inline tex" alt="m=2^L" src="//upload.wikimedia.org/math/d/4/b/d4b2d170152c718c54e1d9d3bb9f0211.png">, then the family made of the functions <img class="mwe-math-fallback-image-inline tex" alt="h \bmod{2^{L'}}" src="//upload.wikimedia.org/math/e/f/e/efececd1b42a4195efeb11ccd3b3f894.png"> for all <img class="mwe-math-fallback-image-inline tex" alt="h \in H" src="//upload.wikimedia.org/math/3/6/7/3675c32b8a780f2e55bc4c046f1acfd3.png"> is also strongly universal for <img class="mwe-math-fallback-image-inline tex" alt="L'\leq L" src="//upload.wikimedia.org/math/4/2/d/42dec5642ebd5f959fe63db4d5c734b1.png">. Unfortunately, the same is not true of (merely) universal families. For example the family made of the identity function <img class="mwe-math-fallback-image-inline tex" alt="h(x)=x" src="//upload.wikimedia.org/math/c/4/8/c489dbb15f7d1ce4d75dffecc7102bb2.png"> is clearly universal, but the family made of the function <img class="mwe-math-fallback-image-inline tex" alt="h(x)=x  \bmod{2^{L'}}" src="//upload.wikimedia.org/math/b/2/8/b28b2b42ed20af3682b2aa4e8274e2ac.png"> fails to be universal.</p>
<h2>Mathematical guarantees</h2>
<p>For any fixed set <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> keys, using a universal family guarantees the following properties.</p>
<ol>
<li>For any fixed <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> in <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png">, the expected number of keys in the bin <img class="mwe-math-fallback-image-inline tex" alt="h(x)" src="//upload.wikimedia.org/math/c/a/8/ca8e608169b20a94570ac837e8ba0833.png"> is <img class="mwe-math-fallback-image-inline tex" alt="n/m" src="//upload.wikimedia.org/math/a/4/0/a40e90362648982ac44f754f22d4f677.png">. When implementing hash tables by chaining, this number is proportional to the expected running time of an operation involving the key <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> (for example a query, insertion or deletion).</li>
<li>The expected number of pairs of keys <img class="mwe-math-fallback-image-inline tex" alt="x,y" src="//upload.wikimedia.org/math/f/1/0/f10bc3c94b77e1d6b9f98106daf335c1.png"> in <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> with <img class="mwe-math-fallback-image-inline tex" alt="x\ne y" src="//upload.wikimedia.org/math/7/3/c/73c7070fbc887c38daea22738774c01c.png"> that collide (<img class="mwe-math-fallback-image-inline tex" alt="h(x) = h(y)" src="//upload.wikimedia.org/math/7/a/d/7ad9b0846fd98d4bcd01575c83e0c383.png">) is bounded above by <img class="mwe-math-fallback-image-inline tex" alt="n(n-1)/2m" src="//upload.wikimedia.org/math/a/7/4/a74b13f822d0c55a1c9beb0961bbd3c5.png">, which is of order <img class="mwe-math-fallback-image-inline tex" alt="O(n^2/m)" src="//upload.wikimedia.org/math/a/f/9/af900183f62d33b94a7c200e2b8e3936.png">. When the number of bins, <img class="mwe-math-fallback-image-inline tex" alt="m" src="//upload.wikimedia.org/math/6/f/8/6f8f57715090da2632453988d9a1501b.png">, is <img class="mwe-math-fallback-image-inline tex" alt="O(n)" src="//upload.wikimedia.org/math/7/b/a/7ba55e7c64a9405a0b39a1107e90ca94.png">, the expected number of collisions is <img class="mwe-math-fallback-image-inline tex" alt="O(n)" src="//upload.wikimedia.org/math/7/b/a/7ba55e7c64a9405a0b39a1107e90ca94.png">. When hashing into <img class="mwe-math-fallback-image-inline tex" alt="n^2" src="//upload.wikimedia.org/math/b/0/8/b08b1c6ec09f20907eb1d6f1392c01c6.png"> bins, there are no collisions at all with probability at least a half.</li>
<li>The expected number of keys in bins with at least <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> keys in them is bounded above by <img class="mwe-math-fallback-image-inline tex" alt="2n/(t-2(n/m)+1)" src="//upload.wikimedia.org/math/4/6/3/463c447a31dd7d475123f381c9bfedc8.png">. Thus, if the capacity of each bin is capped to three times the average size (<img class="mwe-math-fallback-image-inline tex" alt="t = 3n/m" src="//upload.wikimedia.org/math/8/a/f/8afbe7c0d1bececb4eadc894a4eef55a.png">), the total number of keys in overflowing bins is at most <img class="mwe-math-fallback-image-inline tex" alt="O(m)" src="//upload.wikimedia.org/math/0/e/2/0e2ae329177722b1818828e92b441032.png">. This only holds with a hash family whose collision probability is bounded above by <img class="mwe-math-fallback-image-inline tex" alt="1/m" src="//upload.wikimedia.org/math/6/6/e/66e395e2c81b71fbbe0aa725fd4e8c82.png">. If a weaker definition is used, bounding it by <img class="mwe-math-fallback-image-inline tex" alt="O(1/m)" src="//upload.wikimedia.org/math/7/e/5/7e5471555a2941aa1b1b96e8197fe10b.png">, this result is no longer true.</li>
</ol>
<p>As the above guarantees hold for any fixed set <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png">, they hold if the data set is chosen by an adversary. However, the adversary has to make this choice before (or independent of) the algorithm's random choice of a hash function. If the adversary can observe the random choice of the algorithm, randomness serves no purpose, and the situation is the same as deterministic hashing.</p>
<p>The second and third guarantee are typically used in conjunction with rehashing. For instance, a randomized algorithm may be prepared to handle some <img class="mwe-math-fallback-image-inline tex" alt="O(n)" src="//upload.wikimedia.org/math/7/b/a/7ba55e7c64a9405a0b39a1107e90ca94.png"> number of collisions. If it observes too many collisions, it chooses another random <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> from the family and repeats. Universality guarantees that the number of repetitions is a geometric random variable.</p>
<h2>Constructions</h2>
<p>Since any computer data can be represented as one or more machine words, one generally needs hash functions for three types of domains: machine words ("integers"); fixed-length vectors of machine words; and variable-length vectors ("strings").</p>
<h3>Hashing integers</h3>
<p>This section refers to the case of hashing integers that fit in machines words; thus, operations like multiplication, addition, division, etc. are cheap machine-level instructions. Let the universe to be hashed be <img class="mwe-math-fallback-image-inline tex" alt="U = \{0, \dots, u-1\}" src="//upload.wikimedia.org/math/6/9/b/69b28b2263e01b690703cd567eca7a5f.png">.</p>
<p>The original proposal of Carter and Wegman was to pick a prime <img class="mwe-math-fallback-image-inline tex" alt="p \ge u" src="//upload.wikimedia.org/math/7/7/7/77789787d4a22a8eb6391ce7ecfcdaeb.png"> and define</p>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="a,b" src="//upload.wikimedia.org/math/b/3/4/b345e1dc09f20fdefdea469f09167892.png"> are randomly chosen integers modulo <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> with <img class="mwe-math-fallback-image-inline tex" alt="a \neq 0" src="//upload.wikimedia.org/math/d/f/4/df44347863ac17dc898a13f44f681d01.png">. Technically, adding <img class="mwe-math-fallback-image-inline tex" alt="b" src="//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png"> is not needed for universality (but it does make the hash function 2-independent). (This is a single iteration of a linear congruential generator).</p>
<p>To see that <img class="mwe-math-fallback-image-inline tex" alt="H = \{ h_{a,b} \}" src="//upload.wikimedia.org/math/5/f/f/5ff1199d4718b38dfe6d7dfea317ba1b.png"> is a universal family, note that <img class="mwe-math-fallback-image-inline tex" alt="h(x) = h(y)" src="//upload.wikimedia.org/math/7/a/d/7ad9b0846fd98d4bcd01575c83e0c383.png"> only holds when</p>
<p>for some integer <img class="mwe-math-fallback-image-inline tex" alt="i" src="//upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png"> between <img class="mwe-math-fallback-image-inline tex" alt="0" src="//upload.wikimedia.org/math/c/f/c/cfcd208495d565ef66e7dff9f98764da.png"> and <img class="mwe-math-fallback-image-inline tex" alt="p/m" src="//upload.wikimedia.org/math/1/8/6/18657a80050f9b39dc140f0c7010defb.png">. If <img class="mwe-math-fallback-image-inline tex" alt="x \neq y" src="//upload.wikimedia.org/math/7/3/c/73c7070fbc887c38daea22738774c01c.png">, their difference, <img class="mwe-math-fallback-image-inline tex" alt="x-y" src="//upload.wikimedia.org/math/1/9/d/19d59c7d61b117f2865b20b59c8b70f7.png"> is nonzero and has an inverse modulo <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png">. Solving for <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png">,</p>
<p>There are <img class="mwe-math-fallback-image-inline tex" alt="p-1" src="//upload.wikimedia.org/math/7/0/f/70ff83728fb2701cbc52fac8df762bf1.png"> possible choices for <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> (since <img class="mwe-math-fallback-image-inline tex" alt="a=0" src="//upload.wikimedia.org/math/d/e/d/ded681eaa02d11064c9a469dd1b3e04c.png"> is excluded) and, varying <img class="mwe-math-fallback-image-inline tex" alt="i" src="//upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png"> in the allowed range, <img class="mwe-math-fallback-image-inline tex" alt="\lfloor p/m \rfloor" src="//upload.wikimedia.org/math/4/c/8/4c8b77b3e731dc186dfc70812dec631c.png"> possible values for the right hand side. Thus the collision probability is</p>
<p>which tends to <img class="mwe-math-fallback-image-inline tex" alt="1/m" src="//upload.wikimedia.org/math/6/6/e/66e395e2c81b71fbbe0aa725fd4e8c82.png"> for large <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> as required. This analysis also shows that <img class="mwe-math-fallback-image-inline tex" alt="b" src="//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png"> does not have to be randomised in order to have universality.</p>
<p>Another way to see <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> is a universal family is via the notion of statistical distance. Write the difference <img class="mwe-math-fallback-image-inline tex" alt="h(x) - h(y)" src="//upload.wikimedia.org/math/c/c/a/cca9890d5b99f0c6f9f81b8cd3241163.png"> as</p>
<p>Since <img class="mwe-math-fallback-image-inline tex" alt="x - y" src="//upload.wikimedia.org/math/1/9/d/19d59c7d61b117f2865b20b59c8b70f7.png"> is nonzero and <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> is uniformly distributed in <img class="mwe-math-fallback-image-inline tex" alt="\{1,\dots,p\}" src="//upload.wikimedia.org/math/a/b/9/ab957e5531ec41c2ae46154d44a0cb0a.png">, it follows that <img class="mwe-math-fallback-image-inline tex" alt="a(x-y)" src="//upload.wikimedia.org/math/1/e/8/1e878283d8545e84fa5ae0c64ad5c558.png"> modulo <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> is also uniformly distributed in <img class="mwe-math-fallback-image-inline tex" alt="\{1,\dots,p\}" src="//upload.wikimedia.org/math/a/b/9/ab957e5531ec41c2ae46154d44a0cb0a.png">. The distribution of <img class="mwe-math-fallback-image-inline tex" alt="(h(x)-h(y)) ~\bmod~ m" src="//upload.wikimedia.org/math/3/9/d/39d6741ba516f2f4454b8f475c3a4358.png"> is thus almost uniform, up to a difference in probability of <img class="mwe-math-fallback-image-inline tex" alt="\pm 1/p" src="//upload.wikimedia.org/math/a/c/5/ac567eee0a6fef4b26e9eded313b1e3b.png"> between the samples. As a result, the statistical distance to a uniform family is <img class="mwe-math-fallback-image-inline tex" alt="O(m/p)" src="//upload.wikimedia.org/math/0/7/5/07563033a4de7e7e36e051717b7b93e0.png">, which becomes negligible when <img class="mwe-math-fallback-image-inline tex" alt="p \gg m" src="//upload.wikimedia.org/math/e/a/f/eaf978632855668be8172174460dd569.png">.</p>
<h4>Avoiding modular arithmetic</h4>
<p>The state of the art for hashing integers is the <b>multiply-shift</b> scheme described by Dietzfelbinger et al. in 1997. By avoiding modular arithmetic, this method is much easier to implement and also runs significantly faster in practice (usually by at least a factor of four). The scheme assumes the number of bins is a power of two, <img class="mwe-math-fallback-image-inline tex" alt="m=2^M" src="//upload.wikimedia.org/math/0/4/f/04fe2259a7ced8c5385cebb1e232f9c4.png">. Let <img class="mwe-math-fallback-image-inline tex" alt="w" src="//upload.wikimedia.org/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png"> be the number of bits in a machine word. Then the hash functions are parametrised over odd positive integers <img class="mwe-math-fallback-image-inline tex" alt="a &lt; 2^w" src="//upload.wikimedia.org/math/d/7/9/d792dc1f9cd799cf896d409ca78476a4.png"> (that fit in a word of <img class="mwe-math-fallback-image-inline tex" alt="w" src="//upload.wikimedia.org/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png"> bits). To evaluate <img class="mwe-math-fallback-image-inline tex" alt="h_{a}(x)" src="//upload.wikimedia.org/math/b/3/e/b3efbfec079d7a0c56c87c010c4b7efa.png">, multiply <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> by <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> modulo <img class="mwe-math-fallback-image-inline tex" alt="2^w" src="//upload.wikimedia.org/math/8/7/e/87e0723e7037feff1d625225caec78a0.png"> and then keep the high order <img class="mwe-math-fallback-image-inline tex" alt="M" src="//upload.wikimedia.org/math/6/9/6/69691c7bdcc3ce6d5d8a1361f22d04ac.png"> bits as the hash code. In mathematical notation, this is</p>
<p>and it can be implemented in C-like programming languages by</p>
<p>This scheme does <i>not</i> satisfy the uniform difference property and is only <i><img class="mwe-math-fallback-image-inline tex" alt="2/m" src="//upload.wikimedia.org/math/4/e/5/4e52893efe38d1d90ab63cfd1e83df57.png">-almost-universal</i>; for any <img class="mwe-math-fallback-image-inline tex" alt="x\neq y" src="//upload.wikimedia.org/math/7/3/c/73c7070fbc887c38daea22738774c01c.png">, <img class="mwe-math-fallback-image-inline tex" alt="\Pr\{h_a(x) = h_a(y)\} \le 2/m" src="//upload.wikimedia.org/math/5/d/b/5dbc0977f35140c9a19c62de3621f848.png">.</p>
<p>To understand the behavior of the hash function, notice that, if <img class="mwe-math-fallback-image-inline tex" alt="ax \bmod 2^w" src="//upload.wikimedia.org/math/c/0/2/c02eebe71114ff2ea82556c768b700e0.png"> and <img class="mwe-math-fallback-image-inline tex" alt="ay\bmod 2^w" src="//upload.wikimedia.org/math/c/2/9/c29bc5d6910c30625a8151ec9b913241.png"> have the same highest-order 'M' bits, then <img class="mwe-math-fallback-image-inline tex" alt="a(x-y) \bmod 2^w" src="//upload.wikimedia.org/math/7/1/f/71f28fc531c8e57412a0ff19c9bd2be9.png"> has either all 1's or all 0's as its highest order M bits (depending on whether <img class="mwe-math-fallback-image-inline tex" alt="ax \bmod 2^w" src="//upload.wikimedia.org/math/c/0/2/c02eebe71114ff2ea82556c768b700e0.png"> or <img class="mwe-math-fallback-image-inline tex" alt="ay \bmod 2^w" src="//upload.wikimedia.org/math/c/2/9/c29bc5d6910c30625a8151ec9b913241.png"> is larger. Assume that the least significant set bit of <img class="mwe-math-fallback-image-inline tex" alt="x-y" src="//upload.wikimedia.org/math/1/9/d/19d59c7d61b117f2865b20b59c8b70f7.png"> appears on position <img class="mwe-math-fallback-image-inline tex" alt="w-c" src="//upload.wikimedia.org/math/4/7/f/47f85f2dbdc2d846f0524067d2ce0655.png">. Since <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> is a random odd integer and odd integers have inverses in the ring <img class="mwe-math-fallback-image-inline tex" alt="Z_{2^w}" src="//upload.wikimedia.org/math/e/a/3/ea31d84bda468201975d0bbbfd751847.png">, it follows that <img class="mwe-math-fallback-image-inline tex" alt="a(x-y)\bmod 2^w" src="//upload.wikimedia.org/math/7/1/f/71f28fc531c8e57412a0ff19c9bd2be9.png"> will be uniformly distributed among <img class="mwe-math-fallback-image-inline tex" alt="w" src="//upload.wikimedia.org/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png">-bit integers with the least significant set bit on position <img class="mwe-math-fallback-image-inline tex" alt="w-c" src="//upload.wikimedia.org/math/4/7/f/47f85f2dbdc2d846f0524067d2ce0655.png">. The probability that these bits are all 0's or all 1's is therefore at most <img class="mwe-math-fallback-image-inline tex" alt="2/2^M=2/m" src="//upload.wikimedia.org/math/f/a/a/faaaf575a36fb7df7db5f08850d39fc6.png">. On the other hand, if <img class="mwe-math-fallback-image-inline tex" alt="c &lt; M" src="//upload.wikimedia.org/math/8/1/e/81e03b128a355abb4d90d7ca898c9f30.png">, then higher-order M bits of <img class="mwe-math-fallback-image-inline tex" alt="a(x-y) \bmod 2^w" src="//upload.wikimedia.org/math/7/1/f/71f28fc531c8e57412a0ff19c9bd2be9.png"> contain both 0's and 1's, so it is certain that <img class="mwe-math-fallback-image-inline tex" alt="h(x) \ne h(y)" src="//upload.wikimedia.org/math/b/7/a/b7a44a0dcd878c7fb7f2af68d449b9fe.png">. Finally, if <img class="mwe-math-fallback-image-inline tex" alt="c=M" src="//upload.wikimedia.org/math/d/4/4/d449922bd5d933a3c3fe9525cb921fd8.png"> then bit <img class="mwe-math-fallback-image-inline tex" alt="w-M" src="//upload.wikimedia.org/math/2/2/a/22a9b1494679181dc52202d0ba1f31ec.png"> of <img class="mwe-math-fallback-image-inline tex" alt="a(x-y) \bmod 2^w" src="//upload.wikimedia.org/math/7/1/f/71f28fc531c8e57412a0ff19c9bd2be9.png"> is 1 and <img class="mwe-math-fallback-image-inline tex" alt="h_a(x)=h_a(y)" src="//upload.wikimedia.org/math/c/1/9/c1906e302881be93518285ee1a353334.png"> if and only if bits <img class="mwe-math-fallback-image-inline tex" alt="w-1,\ldots,w-M+1" src="//upload.wikimedia.org/math/4/5/2/4521f05a61036f1293442b3fbd0d98be.png"> are also 1, which happens with probability <img class="mwe-math-fallback-image-inline tex" alt="1/2^{M-1}=2/m" src="//upload.wikimedia.org/math/0/f/f/0ff91759075539342270f1e63f01ea8a.png">.</p>
<p>This analysis is tight, as can be shown with the example <img class="mwe-math-fallback-image-inline tex" alt="x=2^{w-M-2}" src="//upload.wikimedia.org/math/7/0/2/702a86357c01a8ac39799701e9e8fc0f.png"> and <img class="mwe-math-fallback-image-inline tex" alt="y=3x" src="//upload.wikimedia.org/math/9/c/6/9c6982e6b4f47b0e55208e5f8a307781.png">. To obtain a truly 'universal' hash function, one can use the multiply-add-shift scheme</p>
<p>which can be implemented in C-like programming languages by</p>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> is a random odd positive integer with <img class="mwe-math-fallback-image-inline tex" alt="a &lt; 2^w" src="//upload.wikimedia.org/math/d/7/9/d792dc1f9cd799cf896d409ca78476a4.png"> and <img class="mwe-math-fallback-image-inline tex" alt="b" src="//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png"> is a random non-negative integer with <img class="mwe-math-fallback-image-inline tex" alt="b &lt; 2^{w-M}" src="//upload.wikimedia.org/math/6/c/8/6c87c6898ef2b04f5a17aab7c9b672ae.png">. With these choices of <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> and <img class="mwe-math-fallback-image-inline tex" alt="b" src="//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png">, <img class="mwe-math-fallback-image-inline tex" alt="\Pr\{h_{a,b}(x) = h_{a,b}(y)\}\le 1/m" src="//upload.wikimedia.org/math/5/c/1/5c18220823d5f841fe9ac6ec914541bd.png"> for all <img class="mwe-math-fallback-image-inline tex" alt="x\not\equiv y\pmod{2^w}" src="//upload.wikimedia.org/math/2/a/7/2a75cdc2ff0919a9d9f288c2f935a544.png">. This differs slightly but importantly from the mistranslation in the English paper.</p>
<h3>Hashing vectors</h3>
<p>This section is concerned with hashing a fixed-length vector of machine words. Interpret the input as a vector <img class="mwe-math-fallback-image-inline tex" alt="\bar{x} = (x_0, \dots, x_{k-1})" src="//upload.wikimedia.org/math/e/f/1/ef18017f7cc957b91264b04706b6f4dc.png"> of <img class="mwe-math-fallback-image-inline tex" alt="k" src="//upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"> machine words (integers of <img class="mwe-math-fallback-image-inline tex" alt="w" src="//upload.wikimedia.org/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png"> bits each). If <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> is a universal family with the uniform difference property, the following family (dating back to Carter and Wegman) also has the uniform difference property (and hence is universal):</p>
<p>If <img class="mwe-math-fallback-image-inline tex" alt="m" src="//upload.wikimedia.org/math/6/f/8/6f8f57715090da2632453988d9a1501b.png"> is a power of two, one may replace summation by exclusive or.</p>
<p>In practice, if double-precision arithmetic is available, this is instantiated with the multiply-shift hash family of. Initialize the hash function with a vector <img class="mwe-math-fallback-image-inline tex" alt="\bar{a} = (a_0, \dots, a_{k-1})" src="//upload.wikimedia.org/math/0/1/f/01f35e49424e636ab6cd3202e08e65fe.png"> of random <b>odd</b> integers on <img class="mwe-math-fallback-image-inline tex" alt="2w" src="//upload.wikimedia.org/math/e/c/9/ec9cbcbeaf6327c7d0b9f89df3df9423.png"> bits each. Then if the number of bins is <img class="mwe-math-fallback-image-inline tex" alt="m=2^M" src="//upload.wikimedia.org/math/0/4/f/04fe2259a7ced8c5385cebb1e232f9c4.png"> for <img class="mwe-math-fallback-image-inline tex" alt="M\le w" src="//upload.wikimedia.org/math/c/4/3/c4344c3524fb8776c327eba285999cf3.png">:</p>
<p>It is possible to halve the number of multiplications, which roughly translates to a two-fold speed-up in practice. Initialize the hash function with a vector <img class="mwe-math-fallback-image-inline tex" alt="\bar{a} = (a_0, \dots, a_{k-1})" src="//upload.wikimedia.org/math/0/1/f/01f35e49424e636ab6cd3202e08e65fe.png"> of random <b>odd</b> integers on <img class="mwe-math-fallback-image-inline tex" alt="2w" src="//upload.wikimedia.org/math/e/c/9/ec9cbcbeaf6327c7d0b9f89df3df9423.png"> bits each. The following hash family is universal:</p>
<p>If double-precision operations are not available, one can interpret the input as a vector of half-words (<img class="mwe-math-fallback-image-inline tex" alt="w/2" src="//upload.wikimedia.org/math/7/9/e/79e9481e518f7e42b00028b00420161f.png">-bit integers). The algorithm will then use <img class="mwe-math-fallback-image-inline tex" alt="\lceil k/2 \rceil" src="//upload.wikimedia.org/math/2/d/d/2dd7a1212c3bc7ac9a64c123017e18f8.png"> multiplications, where <img class="mwe-math-fallback-image-inline tex" alt="k" src="//upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"> was the number of half-words in the vector. Thus, the algorithm runs at a "rate" of one multiplication per word of input.</p>
<p>The same scheme can also be used for hashing integers, by interpreting their bits as vectors of bytes. In this variant, the vector technique is known as tabulation hashing and it provides a practical alternative to multiplication-based universal hashing schemes.</p>
<p>Strong universality at high speed is also possible. Initialize the hash function with a vector <img class="mwe-math-fallback-image-inline tex" alt="\bar{a} = (a_0, \dots, a_{k})" src="//upload.wikimedia.org/math/3/1/2/3129d5aed587a05bf69bdfd9ce7507c0.png"> of random integers on <img class="mwe-math-fallback-image-inline tex" alt="2w" src="//upload.wikimedia.org/math/e/c/9/ec9cbcbeaf6327c7d0b9f89df3df9423.png"> bits. Compute</p>
<p>The result is strongly universal on <img class="mwe-math-fallback-image-inline tex" alt="w" src="//upload.wikimedia.org/math/f/1/2/f1290186a5d0b1ceab27f4e77c0c5d68.png"> bits. Experimentally, it was found to run at 0.2 CPU cycle per byte on recent Intel processors for<img class="mwe-math-fallback-image-inline tex" alt="w = 32" src="//upload.wikimedia.org/math/7/6/c/76ca4b44acf26644f664a7fb65ad465f.png">.</p>
<h3>Hashing strings</h3>
<p>This refers to hashing a <i>variable-sized</i> vector of machine words. If the length of the string can be bounded by a small number, it is best to use the vector solution from above (conceptually padding the vector with zeros up to the upper bound). The space required is the maximal length of the string, but the time to evaluate <img class="mwe-math-fallback-image-inline tex" alt="h(s)" src="//upload.wikimedia.org/math/9/9/0/990694bc2268b9bb3776144e770c25d9.png"> is just the length of <img class="mwe-math-fallback-image-inline tex" alt="s" src="//upload.wikimedia.org/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png">. As long as zeroes are forbidden in the string, the zero-padding can be ignored when evaluating the hash function without affecting universality). Note that if zeroes are allowed in the string, then it might be best to append a fictitious non-zero (e.g., 1) character to all strings prior to padding: this will ensure that universality is not affected.</p>
<p>Now assume we want to hash <img class="mwe-math-fallback-image-inline tex" alt="\bar{x} = (x_0,\dots, x_\ell)" src="//upload.wikimedia.org/math/6/a/b/6ab7c32953cf803535d53ccacad2f25b.png">, where a good bound on <img class="mwe-math-fallback-image-inline tex" alt="\ell" src="//upload.wikimedia.org/math/3/3/4/334ce9eb79df1178b0380461c9eaa09e.png"> is not known a priori. A universal family proposed by  treats the string <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> as the coefficients of a polynomial modulo a large prime. If <img class="mwe-math-fallback-image-inline tex" alt="x_i \in [u]" src="//upload.wikimedia.org/math/1/7/2/172d10d5b2b0afb601ee9a6f2cacafcb.png">, let <img class="mwe-math-fallback-image-inline tex" alt="p \ge \max \{ u, m \}" src="//upload.wikimedia.org/math/e/a/1/ea1e1bad533cbdbefbb1c48f3f7f5338.png"> be a prime and define:</p>
<p>Using properties of modular arithmetic, above can be computed without producing large numbers for large strings as follows:</p>
<p>WHATSON? 15abf1d6-0023-4b70-b3d3-b0d39b42cea3</p>
<pre>
int hash(String x, int a, int p)
	int h=x[0]
	for ( i=1 ; i &lt; x.length ; i++)
	h = ((h*a) + x[i])) mod p
	return h
</pre>
<p>Consider two strings <img class="mwe-math-fallback-image-inline tex" alt="\bar{x}, \bar{y}" src="//upload.wikimedia.org/math/8/2/5/825c117c20ef2c93ce1414918e056ce7.png"> and let <img class="mwe-math-fallback-image-inline tex" alt="\ell" src="//upload.wikimedia.org/math/3/3/4/334ce9eb79df1178b0380461c9eaa09e.png"> be length of the longer one; for the analysis, the shorter string is conceptually padded with zeros up to length <img class="mwe-math-fallback-image-inline tex" alt="\ell" src="//upload.wikimedia.org/math/3/3/4/334ce9eb79df1178b0380461c9eaa09e.png">. A collision before applying <img class="mwe-math-fallback-image-inline tex" alt="h_\mathrm{int}" src="//upload.wikimedia.org/math/b/5/0/b506f277ecbd85594f0facadf3064b83.png"> implies that <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> is a root of the polynomial with coefficients <img class="mwe-math-fallback-image-inline tex" alt="\bar{x} - \bar{y}" src="//upload.wikimedia.org/math/8/4/2/842b7b432fc0f6aaffbc71425aef0888.png">. This polynomial has at most <img class="mwe-math-fallback-image-inline tex" alt="\ell" src="//upload.wikimedia.org/math/3/3/4/334ce9eb79df1178b0380461c9eaa09e.png"> roots modulo <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png">, so the collision probability is at most <img class="mwe-math-fallback-image-inline tex" alt="\ell/p" src="//upload.wikimedia.org/math/c/d/7/cd70b9c0e5bc405c41d702bc2e2a97fb.png">. The probability of collision through the random <img class="mwe-math-fallback-image-inline tex" alt="h_\mathrm{int}" src="//upload.wikimedia.org/math/b/5/0/b506f277ecbd85594f0facadf3064b83.png"> brings the total collision probability to <img class="mwe-math-fallback-image-inline tex" alt="\frac{1}{m} + \frac{\ell}{p}" src="//upload.wikimedia.org/math/d/8/b/d8b709fa2c68be1bcd8c140670649102.png">. Thus, if the prime <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> is sufficiently large compared to the length of strings hashed, the family is very close to universal (in statistical distance).</p>
<p>To mitigate the computational penalty of modular arithmetic, two tricks are used in practice:</p>
<ol>
<li>One chooses the prime <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> to be close to a power of two, such as a Mersenne prime. This allows arithmetic modulo <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> to be implemented without division (using faster operations like addition and shifts). For instance, on modern architectures one can work with <img class="mwe-math-fallback-image-inline tex" alt="p = 2^{61}-1" src="//upload.wikimedia.org/math/d/2/3/d230020e2f2c71bddbfac471959916cc.png">, while <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png">'s are 32-bit values.</li>
<li>One can apply vector hashing to blocks. For instance, one applies vector hashing to each 16-word block of the string, and applies string hashing to the <img class="mwe-math-fallback-image-inline tex" alt="\lceil k/16 \rceil" src="//upload.wikimedia.org/math/a/1/4/a14a6cba08a0f416cd13b38068875bc0.png"> results. Since the slower string hashing is applied on a substantially smaller vector, this will essentially be as fast as vector hashing.</li>
</ol>
<h2>See also</h2>
<ul>
<li>K-independent hashing</li>
<li>Rolling hashing</li>
<li>Tabulation hashing</li>
<li>Min-wise independence</li>
<li>Universal one-way hash function</li>
<li>Low-discrepancy sequence</li>
<li>Perfect hashing</li>
</ul>
</body>
</html>