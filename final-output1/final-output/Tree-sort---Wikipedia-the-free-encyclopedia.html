<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tree-sort---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Tree sort</h1>
<p><i>O</i>(<i>n</i>²) (unbalanced)</p>
<p><i>O</i>(<i>n</i>) (unbalanced)</p>
<p>A <b>tree sort</b> is a sort algorithm that builds a binary search tree from the keys to be sorted, and then traverses the tree (in-order) so that the keys come out in sorted order. Its typical use is sorting elements adaptively: after each insertion, the set of elements seen so far is available in sorted order.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Efficiency</li>
<li>2 Example</li>
<li>3 See also</li>
<li>4 External links</li>
</ul>
<p></p>
<h2>Efficiency</h2>
<p>Adding one item to a binary search tree is on average an <i>O</i>(log <i>n</i>) process (in big O notation), so adding n items is an <i>O</i>(<i>n</i> log <i>n</i>) process, making tree sort a so-called 'fast sort'. But adding an item to an unbalanced binary tree needs <i>O</i>(<i>n</i>) time in the worst-case, when the tree resembles a linked list (degenerate tree), causing a worst case of <i>O</i>(<i>n</i>²) for this sorting algorithm. This worst case occurs when the algorithm operates on an already sorted set, or one that is nearly sorted. Expected <i>O</i>(log <i>n</i>) time can however be achieved in this case by shuffling the array.</p>
<p>The worst-case behaviour can be improved upon by using a self-balancing binary search tree. Using such a tree, the algorithm has an <i>O</i>(<i>n</i> log <i>n</i>) worst-case performance, thus being degree-optimal for a comparison sort. When using a splay tree as the binary search tree, the resulting algorithm (called splaysort) has the additional property that it is an adaptive sort, meaning that its running time is faster than <i>O</i>(<i>n</i> log <i>n</i>) for inputs that are nearly sorted.</p>
<h2>Example</h2>
<p>The following tree sort algorithm in pseudocode accepts an array of comparable items and outputs the items in ascending order:</p>
<p>WHATSON? ef1ad508-d0dd-4a87-a50d-495306f5f7a0</p>
<pre>
<code>STRUCTURE BinaryTree
    BinaryTree:LeftSubTree
    Object:Node
    BinaryTree:RightSubTree

PROCEDURE Insert(BinaryTree:searchTree, Object:item)
    IF searchTree IS NULL THEN
        SET searchTree.Node TO item
    ELSE
        IF item IS LESS THAN searchTree.Node THEN
            Insert(searchTree.LeftSubTree, item)
        ELSE
            Insert(searchTree.RightSubTree, item)

PROCEDURE InOrder(BinaryTree:searchTree)
    IF searchTree IS NULL THEN
        EXIT PROCEDURE
    ELSE
        InOrder(searchTree.LeftSubTree)
        EMIT searchTree.Node
        InOrder(searchTree.RightSubTree)

PROCEDURE TreeSort(Array:items)
    BinaryTree:searchTree
   
    FOR EACH individualItem IN items
        Insert(searchTree, individualItem)
   
    InOrder(searchTree)
</code>
</pre>
<p>In a simple functional programming form, the algorithm (in Haskell) would look something like this:</p>
<p>WHATSON? 72f107df-4b26-4227-b583-9f9e3d54b281</p>
<pre>
data Tree a = Leaf | Node (Tree a) a (Tree a)
 
insert :: Ord a =&gt; a -&gt; Tree a -&gt; Tree a
insert x Leaf = Node Leaf x Leaf
insert x (Node t y s) | x &lt;= y = Node (insert x t) y s
insert x (Node t y s) | x &gt; y = Node t y (insert x s)
 
flatten :: Tree a -&gt; [a]
flatten Leaf = []
flatten (Node t x s) = flatten t ++ [x] ++ flatten s
 
treesort :: Ord a =&gt; [a] -&gt; [a]
treesort = flatten . foldr insert Leaf
</pre>
<p>In the above implementation, both the insertion algorithm and the retrieval algorithm have <i>O</i>(<i>n</i>²) worst-case scenarios.</p>
<h2>See also</h2>
<ul>
<li>Heapsort: builds a binary heap out of its input instead of a binary search tree, and can be used to sort in-place (but not adaptively).</li>
</ul>
<h2>External links</h2>
<ul>
<li>Binary Tree Java Applet and Explanation</li>
<li>Tree Sort of a Linked List</li>
<li>Tree Sort in C++</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>Computational complexity theory</li>
<li>Big O notation</li>
<li>Total order</li>
<li>Lists</li>
<li>Inplacement</li>
<li>Stability</li>
<li>Comparison sort</li>
<li>Adaptive sort</li>
<li>Sorting network</li>
<li>Integer sorting</li>
</ul>
<ul>
<li>Bubble sort</li>
<li>Cocktail sort</li>
<li>Odd–even sort</li>
<li>Comb sort</li>
<li>Gnome sort</li>
<li>Quicksort</li>
<li>Stooge sort</li>
<li>Bogosort</li>
</ul>
<ul>
<li>Selection sort</li>
<li>Heapsort</li>
<li>Smoothsort</li>
<li>Cartesian tree sort</li>
<li>Tournament sort</li>
<li>Cycle sort</li>
</ul>
<ul>
<li>Insertion sort</li>
<li>Shellsort</li>
<li>Splaysort</li>
<li><strong class="selflink">Tree sort</strong></li>
<li>Library sort</li>
<li>Patience sorting</li>
</ul>
<ul>
<li>Merge sort</li>
<li>Cascade merge sort</li>
<li>Oscillating merge sort</li>
<li>Polyphase merge sort</li>
<li>Strand sort</li>
</ul>
<ul>
<li>American flag sort</li>
<li>Bead sort</li>
<li>Bucket sort</li>
<li>Burstsort</li>
<li>Counting sort</li>
<li>Pigeonhole sort</li>
<li>Proxmap sort</li>
<li>Radix sort</li>
<li>Flashsort</li>
</ul>
<ul>
<li>Bitonic sorter</li>
<li>Batcher odd–even mergesort</li>
<li>Pairwise sorting network</li>
</ul>
<ul>
<li>Block sort</li>
<li>Timsort</li>
<li>Introsort</li>
<li>Spreadsort</li>
<li>JSort</li>
</ul>
<ul>
<li>Topological sorting</li>
<li>Pancake sorting</li>
<li>Spaghetti sort</li>
</ul>
</body>
</html>