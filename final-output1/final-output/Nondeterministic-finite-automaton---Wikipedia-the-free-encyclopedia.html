<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Nondeterministic-finite-automaton---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Nondeterministic finite automaton</h1>
<p>In automata theory, a <b>nondeterministic finite automaton</b> (NFA), or nondeterministic finite state machine, is a finite state machine that <i><b>(1)</b></i> does not require input symbols for state transitions and <i><b>(2)</b></i> is capable of transitioning to zero or two or more states for a given start state and input symbol. This distinguishes it from a deterministic finite automaton (DFA), in which all transitions are uniquely determined and in which an input symbol is required for all state transitions. Although NFA and DFA have distinct definitions, all NFAs can be translated to equivalent DFAs using the subset construction algorithm, i.e., constructed DFAs and their corresponding NFAs recognize the same formal language. Like DFAs, NFAs only recognize regular languages.</p>
<p>NFAs were introduced in 1959 by Michael O. Rabin and Dana Scott, who also showed their equivalence to DFAs.</p>
<p>NFAs have been generalized in multiple ways, e.g., nondeterministic finite automaton with ε-moves, pushdown automaton, ω-automaton, and probabilistic automata.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Informal introduction</li>
<li>2 Formal definition</li>
<li>3 Example</li>
<li>4 Variations of NFA</li>
<li>5 Equivalence to DFA</li>
<li>6 Closure properties</li>
<li>7 Properties</li>
<li>8 Implementation</li>
<li>9 Application of NFA</li>
<li>10 See also</li>
<li>11 Notes</li>
<li>12 References</li>
</ul>
<p></p>
<h2>Informal introduction</h2>
<p>An NFA, similar to a DFA, consumes a string of input symbols. For each input symbol, it transitions to a new state until all input symbols have been consumed. Unlike a DFA, it is non-deterministic, i.e., for some state and input symbol, the next state may be one of two or more possible states. Thus, in the formal definition, the next state is an element of the power set of the states, which is a set of states to be considered at once. The notion of accepting an input is similar to that for the DFA. When the last input symbol is consumed, the NFA accepts if and only if there is <i>some</i> set of transitions that will take it to an accepting state. Equivalently, it rejects, if, no matter what transitions are applied, it would not end in an accepting state.</p>
<h2>Formal definition</h2>
<p>An <i>NFA</i> is represented formally by a 5-tuple, (<i>Q</i>, Σ, Δ, <i>q<sub>0</sub></i>, <i>F</i>), consisting of</p>
<ul>
<li>a finite set of states <i>Q</i></li>
<li>a finite set of input symbols Σ</li>
<li>a transition function Δ : <i>Q</i> × Σ → <i>P(Q)</i>.</li>
<li>an <i>initial</i> (or <i>start</i>) state <i>q</i><sub>0</sub> ∈ <i>Q</i></li>
<li>a set of states <i>F</i> distinguished as <i>accepting</i> (or <i>final</i>) <i>states</i> <i>F</i> ⊆ <i>Q</i>.</li>
</ul>
<p>Here, <i>P</i>(<i>Q</i>) denotes the power set of <i>Q</i>. Let <i>w = a<sub>1</sub>a<sub>2</sub> ... a<sub>n</sub></i> be a word over the alphabet Σ. The automaton <i>M</i> accepts the word <i>w</i> if a sequence of states, <i>r<sub>0</sub>,r<sub>1</sub>, ..., r<sub>n</sub></i>, exists in <i>Q</i> with the following conditions:</p>
<ol>
<li><i>r<sub>0</sub></i> = <i>q</i><sub><i>0</i></sub></li>
<li><i>r<sub>i+1</sub></i> ∈ Δ(<i>r<sub>i</sub></i>, <i>a<sub>i+1</sub></i>), for <i>i</i> = <i>0, ..., n−1</i></li>
<li><i>r<sub>n</sub></i> ∈ <i>F</i>.</li>
</ol>
<p>In words, the first condition says that the machine starts in the start state <i>q</i><sub>0</sub>. The second condition says that given each character of string <i>w</i>, the machine will transition from state to state according to the transition function Δ. The last condition says that the machine accepts <i>w</i> if the last input of <i>w</i> causes the machine to halt in one of the accepting states. Otherwise, it is said that the automaton <i>rejects</i> the string. The set of strings <i>M</i> accepts is the language <i>recognized</i> by <i>M</i> and this language is denoted by <i>L(M)</i>.</p>
<h1>Nondeterministic finite automaton</h1>
<p>In automata theory, a <b>nondeterministic finite automaton</b> (NFA), or nondeterministic finite state machine, is a finite state machine that <i><b>(1)</b></i> does not require input symbols for state transitions and <i><b>(2)</b></i> is capable of transitioning to zero or two or more states for a given start state and input symbol. This distinguishes it from a deterministic finite automaton (DFA), in which all transitions are uniquely determined and in which an input symbol is required for all state transitions. Although NFA and DFA have distinct definitions, all NFAs can be translated to equivalent DFAs using the subset construction algorithm, i.e., constructed DFAs and their corresponding NFAs recognize the same formal language. Like DFAs, NFAs only recognize regular languages.</p>
<p>NFAs were introduced in 1959 by Michael O. Rabin and Dana Scott, who also showed their equivalence to DFAs.</p>
<p>NFAs have been generalized in multiple ways, e.g., nondeterministic finite automaton with ε-moves, pushdown automaton, ω-automaton, and probabilistic automata.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Informal introduction</li>
<li>2 Formal definition</li>
<li>3 Example</li>
<li>4 Variations of NFA</li>
<li>5 Equivalence to DFA</li>
<li>6 Closure properties</li>
<li>7 Properties</li>
<li>8 Implementation</li>
<li>9 Application of NFA</li>
<li>10 See also</li>
<li>11 Notes</li>
<li>12 References</li>
</ul>
<p>We can also define <i>L(M)</i> in terms of Δ*: Q × Σ* → <i>P</i>(<i>Q</i>) such that:</p>
<ol>
<li>Δ*(<i>r</i>, ε)= {<i>r</i>} where ε is the empty string, and</li>
<li>If <i>x</i> ∈ Σ*, <i>a</i> ∈ Σ, and Δ*(<i>r</i>, x)={r<sub>1</sub>, r<sub>2</sub>,..., r<sub>k</sub>} then Δ*(<i>r</i>, <i>xa</i>)= Δ(r<sub>1</sub>, a)∪...∪Δ(r<sub>k</sub>, a).</li>
</ol>
<p>Now L(M) = {w | Δ*(q<sub>0</sub>, w) ∩ <i>F</i> ≠ ∅}.</p>
<p>Note that there is a <i>single initial state</i>, which is not necessary. Sometimes, NFAs are defined with a set of initial states. There is an easy construction that translates a NFA with multiple initial states to a NFA with single initial state, which provides a convenient notation.</p>
<p>For more elementary introduction of the formal definition see automata theory.</p>
<h2>Example</h2>
<p>Let <i>M</i> be a NFA, with a binary alphabet, that determines if the input ends with a 1.</p>
<p>In formal notation, let <i>M</i> = ({<i>p</i>, <i>q</i>}, {0, 1}, Δ, <i>p</i>, {<i>q</i>}) where the transition function Δ can be defined by this state transition table:</p>
<p>Note that Δ(<i>p</i>,1) has more than one state therefore <i>M</i> is nondeterministic. The language of <i>M</i> can be described by the regular language given by the regular expression (0|1)*1.</p>
<h2>Variations of NFA</h2>
<p></p>
<h2>Informal introduction</h2>
<p>An NFA, similar to a DFA, consumes a string of input symbols. For each input symbol, it transitions to a new state until all input symbols have been consumed. Unlike a DFA, it is non-deterministic, i.e., for some state and input symbol, the next state may be one of two or more possible states. Thus, in the formal definition, the next state is an element of the power set of the states, which is a set of states to be considered at once. The notion of accepting an input is similar to that for the DFA. When the last input symbol is consumed, the NFA accepts if and only if there is <i>some</i> set of transitions that will take it to an accepting state. Equivalently, it rejects, if, no matter what transitions are applied, it would not end in an accepting state.</p>
<h2>Formal definition</h2>
<p>An <i>NFA</i> is represented formally by a 5-tuple, (<i>Q</i>, Σ, Δ, <i>q<sub>0</sub></i>, <i>F</i>), consisting of</p>
<ul>
<li>a finite set of states <i>Q</i></li>
<li>a finite set of input symbols Σ</li>
<li>a transition function Δ : <i>Q</i> × Σ → <i>P(Q)</i>.</li>
<li>an <i>initial</i> (or <i>start</i>) state <i>q</i><sub>0</sub> ∈ <i>Q</i></li>
<li>a set of states <i>F</i> distinguished as <i>accepting</i> (or <i>final</i>) <i>states</i> <i>F</i> ⊆ <i>Q</i>.</li>
</ul>
<p>Here, <i>P</i>(<i>Q</i>) denotes the power set of <i>Q</i>. Let <i>w = a<sub>1</sub>a<sub>2</sub> ... a<sub>n</sub></i> be a word over the alphabet Σ. The automaton <i>M</i> accepts the word <i>w</i> if a sequence of states, <i>r<sub>0</sub>,r<sub>1</sub>, ..., r<sub>n</sub></i>, exists in <i>Q</i> with the following conditions:</p>
<ol>
<li><i>r<sub>0</sub></i> = <i>q</i><sub><i>0</i></sub></li>
<li><i>r<sub>i+1</sub></i> ∈ Δ(<i>r<sub>i</sub></i>, <i>a<sub>i+1</sub></i>), for <i>i</i> = <i>0, ..., n−1</i></li>
<li><i>r<sub>n</sub></i> ∈ <i>F</i>.</li>
</ol>
<p>In words, the first condition says that the machine starts in the start state <i>q</i><sub>0</sub>. The second condition says that given each character of string <i>w</i>, the machine will transition from state to state according to the transition function Δ. The last condition says that the machine accepts <i>w</i> if the last input of <i>w</i> causes the machine to halt in one of the accepting states. Otherwise, it is said that the automaton <i>rejects</i> the string. The set of strings <i>M</i> accepts is the language <i>recognized</i> by <i>M</i> and this language is denoted by <i>L(M)</i>.</p>
<p>We can also define <i>L(M)</i> in terms of Δ*: Q × Σ* → <i>P</i>(<i>Q</i>) such that:</p>
<ol>
<li>Δ*(<i>r</i>, ε)= {<i>r</i>} where ε is the empty string, and</li>
<li>If <i>x</i> ∈ Σ*, <i>a</i> ∈ Σ, and Δ*(<i>r</i>, x)={r<sub>1</sub>, r<sub>2</sub>,..., r<sub>k</sub>} then Δ*(<i>r</i>, <i>xa</i>)= Δ(r<sub>1</sub>, a)∪...∪Δ(r<sub>k</sub>, a).</li>
</ol>
<p>Now L(M) = {w | Δ*(q<sub>0</sub>, w) ∩ <i>F</i> ≠ ∅}.</p>
<p>Note that there is a <i>single initial state</i>, which is not necessary. Sometimes, NFAs are defined with a set of initial states. There is an easy construction that translates a NFA with multiple initial states to a NFA with single initial state, which provides a convenient notation.</p>
<p>For more elementary introduction of the formal definition see automata theory.</p>
<ul>
<li>Deterministic finite automaton (DFA): In this automaton, for each state and alphabet, the transition function has exactly one state.</li>
<li>Nondeterministic finite automaton with ε-moves(NFA-ε): This automaton replaces the transition function with the one that allows the empty string ε as a possible input, so the transition function is defined as Δ : <i>Q</i> × (Σ ∪{ε}) → <i>P</i>(<i>Q</i>).</li>
</ul>
<h2>Equivalence to DFA</h2>
<p>For each NFA, there is a DFA such that both recognize the same formal language. The DFA can be constructed using the powerset construction. It is important in theory because it establishes that NFAs, despite their additional flexibility, are unable to recognize any language that cannot be recognized by some DFA. It is also important in practice for converting easier-to-construct NFAs into more efficiently executable DFAs. However, if the NFA has <i>n</i> states, the resulting DFA may have up to 2 states, an exponentially larger number, which sometimes makes the construction impractical for large NFAs.</p>
<h2>Closure properties</h2>
<p>NFAs are said to be closed under a (binary/unary) operator if NFAs recognize the languages that are obtained by applying the operation on the NFA recognizable languages. The NFAs are closed under the following operations.</p>
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Concatenation</li>
<li>Negation</li>
<li>Kleene closure</li>
</ul>
<p>Since NFAs are equivalent to nondeterministic finite automaton with ε-moves(NFA-ε), the above closures are proved using closure properties of NFA-ε. The above closure properties imply that NFAs only recognize regular languages.</p>
<p>NFAs can be constructed from any regular expression using Thompson's construction algorithm.</p>
<h2>Example</h2>
<h2>Properties</h2>
<p>The machine starts in the specified initial state and reads in a string of symbols from its alphabet. The automaton uses the state transition function Δ to determine the next state using the current state, and the symbol just read or the empty string. However, "the next state of an NFA depends not only on the current input event, but also on an arbitrary number of subsequent input events. Until these subsequent events occur it is not possible to determine which state the machine is in". If, when the automaton has finished reading, it is in an accepting state, the NFA is said to accept the string, otherwise it is said to reject the string.</p>
<p>The set of all strings accepted by an NFA is the language the NFA accepts. This language is a regular language.</p>
<p>For every NFA a deterministic finite automaton (DFA) can be found that accepts the same language. Therefore it is possible to convert an existing NFA into a DFA for the purpose of implementing a (perhaps) simpler machine. This can be performed using the powerset construction, which may lead to an exponential rise in the number of necessary states. A formal proof of the powerset construction is given here.</p>
<h2>Implementation</h2>
<p>There are many ways to implement a NFA:</p>
<ul>
<li>Convert to the equivalent DFA. In some cases this may cause exponential blowup in the size of the automaton and thus auxiliary space proportional to the number of states in the NFA (as storage of the state value requires at most one bit for every state in the NFA)</li>
<li>Keep a set data structure of all states which the machine might currently be in. On the consumption of the last input symbol, if one of these states is a final state, the machine accepts the string. In the worst case, this may require auxiliary space proportional to the number of states in the NFA; if the set structure uses one bit per NFA state, then this solution is exactly equivalent to the above.</li>
<li>Create multiple copies. For each n way decision, the NFA creates up to <img class="mwe-math-fallback-image-inline tex" alt="n-1" src="//upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"> copies of the machine. Each will enter a separate state. If, upon consuming the last input symbol, at least one copy of the NFA is in the accepting state, the NFA will accept. (This, too, requires linear storage with respect to the number of NFA states, as there can be one machine for every NFA state.)</li>
<li>Explicitly propagate tokens through the transition structure of the NFA and match whenever a token reaches the final state. This is sometimes useful when the NFA should encode additional context about the events that triggered the transition. (For an implementation that uses this technique to keep track of object references have a look at Tracematches.)</li>
</ul>
<h2>Application of NFA</h2>
<p>NFAs and DFAs are equivalent in that if a language is recognized by an NFA, it is also recognized by a DFA and vice versa. The establishment of such equivalence is important and useful. It is useful because constructing an NFA to recognize a given language is sometimes much easier than constructing a DFA for that language. It is important because NFAs can be used to reduce the complexity of the mathematical work required to establish many important properties in the theory of computation. For example, it is much easier to prove closure properties of regular languages using NFAs than DFAs.</p>
<ul>
<li>The union of two regular languages is regular.</li>
<li>The concatenation of two regular languages is regular.</li>
<li>The Kleene closure of a regular language is regular.</li>
</ul>
<h2>See also</h2>
<ul>
<li>Turing Machine</li>
<li>Deterministic finite automaton</li>
<li>Pushdown automaton</li>
<li>Parikh automaton</li>
</ul>
<p>Let <i>M</i> be a NFA, with a binary alphabet, that determines if the input ends with a 1.</p>
<p>In formal notation, let <i>M</i> = ({<i>p</i>, <i>q</i>}, {0, 1}, Δ, <i>p</i>, {<i>q</i>}) where the transition function Δ can be defined by this state transition table:</p>
<p>Note that Δ(<i>p</i>,1) has more than one state therefore <i>M</i> is nondeterministic. The language of <i>M</i> can be described by the regular language given by the regular expression (0|1)*1.</p>
<h2>Variations of NFA</h2>
<ul>
<li>Deterministic finite automaton (DFA): In this automaton, for each state and alphabet, the transition function has exactly one state.</li>
<li>Nondeterministic finite automaton with ε-moves(NFA-ε): This automaton replaces the transition function with the one that allows the empty string ε as a possible input, so the transition function is defined as Δ : <i>Q</i> × (Σ ∪{ε}) → <i>P</i>(<i>Q</i>).</li>
</ul>
<h2>Equivalence to DFA</h2>
<p>For each NFA, there is a DFA such that both recognize the same formal language. The DFA can be constructed using the powerset construction. It is important in theory because it establishes that NFAs, despite their additional flexibility, are unable to recognize any language that cannot be recognized by some DFA. It is also important in practice for converting easier-to-construct NFAs into more efficiently executable DFAs. However, if the NFA has <i>n</i> states, the resulting DFA may have up to 2 states, an exponentially larger number, which sometimes makes the construction impractical for large NFAs.</p>
<h2>Closure properties</h2>
<p>NFAs are said to be closed under a (binary/unary) operator if NFAs recognize the languages that are obtained by applying the operation on the NFA recognizable languages. The NFAs are closed under the following operations.</p>
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Concatenation</li>
<li>Negation</li>
<li>Kleene closure</li>
</ul>
<p>Since NFAs are equivalent to nondeterministic finite automaton with ε-moves(NFA-ε), the above closures are proved using closure properties of NFA-ε. The above closure properties imply that NFAs only recognize regular languages.</p>
<p>NFAs can be constructed from any regular expression using Thompson's construction algorithm.</p>
<h2>Properties</h2>
<p>The machine starts in the specified initial state and reads in a string of symbols from its alphabet. The automaton uses the state transition function Δ to determine the next state using the current state, and the symbol just read or the empty string. However, "the next state of an NFA depends not only on the current input event, but also on an arbitrary number of subsequent input events. Until these subsequent events occur it is not possible to determine which state the machine is in". If, when the automaton has finished reading, it is in an accepting state, the NFA is said to accept the string, otherwise it is said to reject the string.</p>
<h2>Notes</h2>
<ol>
<li><b>^</b> Martin, John (2010). <i>Introduction to Languages and the Theory of Computation</i>. McGraw Hill. p. 108. ISBN 978-0071289429. </li>
<li><b>^</b> Rabin, M. O.; Scott, D. (April 1959). "Finite Automata and Their Decision Problems" (PDF, IEEE Xplore access required). <i>IBM Journal of Research and Development</i> <b>3</b> (2): 114–125. doi:10.1147/rd.32.0114. Retrieved 2007-03-15. </li>
<li><b>^</b> FOLDOC Free Online Dictionary of Computing, <i>Finite State Machine</i></li>
<li><b>^</b> How to convert finite automata to regular expressions?</li>
<li><b>^</b> http://cseweb.ucsd.edu/~ccalabro/essays/fsa.pdf</li>
<li><b>^</b> Allan, C., Avgustinov, P., Christensen, A. S., Hendren, L., Kuzins, S., Lhoták, O., de Moor, O., Sereni, D., Sittampalam, G., and Tibble, J. 2005. Adding trace matching with free variables to AspectJ. In Proceedings of the 20th Annual ACM SIGPLAN Conference on Object Oriented Programming, Systems, Languages, and Applications (San Diego, CA, USA, October 16–20, 2005). OOPSLA '05. ACM, New York, NY, 345-364.</li>
</ol>
<p>The set of all strings accepted by an NFA is the language the NFA accepts. This language is a regular language.</p>
<p>For every NFA a deterministic finite automaton (DFA) can be found that accepts the same language. Therefore it is possible to convert an existing NFA into a DFA for the purpose of implementing a (perhaps) simpler machine. This can be performed using the powerset construction, which may lead to an exponential rise in the number of necessary states. A formal proof of the powerset construction is given here.</p>
<h2>Implementation</h2>
<p>There are many ways to implement a NFA:</p>
<ul>
<li>Convert to the equivalent DFA. In some cases this may cause exponential blowup in the size of the automaton and thus auxiliary space proportional to the number of states in the NFA (as storage of the state value requires at most one bit for every state in the NFA)</li>
<li>Keep a set data structure of all states which the machine might currently be in. On the consumption of the last input symbol, if one of these states is a final state, the machine accepts the string. In the worst case, this may require auxiliary space proportional to the number of states in the NFA; if the set structure uses one bit per NFA state, then this solution is exactly equivalent to the above.</li>
<li>Create multiple copies. For each n way decision, the NFA creates up to <img class="mwe-math-fallback-image-inline tex" alt="n-1" src="//upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"> copies of the machine. Each will enter a separate state. If, upon consuming the last input symbol, at least one copy of the NFA is in the accepting state, the NFA will accept. (This, too, requires linear storage with respect to the number of NFA states, as there can be one machine for every NFA state.)</li>
<li>Explicitly propagate tokens through the transition structure of the NFA and match whenever a token reaches the final state. This is sometimes useful when the NFA should encode additional context about the events that triggered the transition. (For an implementation that uses this technique to keep track of object references have a look at Tracematches.)</li>
</ul>
<h2>Application of NFA</h2>
<p>NFAs and DFAs are equivalent in that if a language is recognized by an NFA, it is also recognized by a DFA and vice versa. The establishment of such equivalence is important and useful. It is useful because constructing an NFA to recognize a given language is sometimes much easier than constructing a DFA for that language. It is important because NFAs can be used to reduce the complexity of the mathematical work required to establish many important properties in the theory of computation. For example, it is much easier to prove closure properties of regular languages using NFAs than DFAs.</p>
<ul>
<li>The union of two regular languages is regular.</li>
<li>The concatenation of two regular languages is regular.</li>
<li>The Kleene closure of a regular language is regular.</li>
</ul>
<h2>See also</h2>
<ul>
<li>Turing Machine</li>
<li>Deterministic finite automaton</li>
<li>Pushdown automaton</li>
<li>Parikh automaton</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Martin, John (2010). <i>Introduction to Languages and the Theory of Computation</i>. McGraw Hill. p. 108. ISBN 978-0071289429. </li>
<li><b>^</b> Rabin, M. O.; Scott, D. (April 1959). "Finite Automata and Their Decision Problems" (PDF, IEEE Xplore access required). <i>IBM Journal of Research and Development</i> <b>3</b> (2): 114–125. doi:10.1147/rd.32.0114. Retrieved 2007-03-15. </li>
<li><b>^</b> FOLDOC Free Online Dictionary of Computing, <i>Finite State Machine</i></li>
<li><b>^</b> How to convert finite automata to regular expressions?</li>
<li><b>^</b> http://cseweb.ucsd.edu/~ccalabro/essays/fsa.pdf</li>
<li><b>^</b> Allan, C., Avgustinov, P., Christensen, A. S., Hendren, L., Kuzins, S., Lhoták, O., de Moor, O., Sereni, D., Sittampalam, G., and Tibble, J. 2005. Adding trace matching with free variables to AspectJ. In Proceedings of the 20th Annual ACM SIGPLAN Conference on Object Oriented Programming, Systems, Languages, and Applications (San Diego, CA, USA, October 16–20, 2005). OOPSLA '05. ACM, New York, NY, 345-364.</li>
</ol>
</body>
</html>