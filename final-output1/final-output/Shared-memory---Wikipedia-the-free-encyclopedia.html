<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Shared-memory---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Shared memory</h1>
<p>In computing, <b>shared memory</b> is memory that may be simultaneously accessed by multiple programs with an intent to provide communication among them or avoid redundant copies. Shared memory is an efficient means of passing data between programs. Depending on context, programs may run on a single processor or on multiple separate processors.</p>
<p>Using memory for communication inside a single program, for example among its multiple threads, is also referred to as shared memory.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 In hardware</li>
<li>2 In software
<ul>
<li>2.1 Support on UNIX platforms</li>
<li>2.2 Support on other platforms</li>
</ul>
</li>
<li>3 See also</li>
<li>4 References</li>
<li>5 External links</li>
</ul>
<ul>
<li>2.1 Support on UNIX platforms</li>
<li>2.2 Support on other platforms</li>
</ul>
<p></p>
<h2>In hardware</h2>
<p>In computer hardware, <b>shared memory</b> refers to a (typically large) block of random access memory (RAM) that can be accessed by several different central processing units (CPUs) in a multiple-processor computer system.</p>
<p>A shared memory system is relatively easy to program since all processors share a single view of data and the communication between processors can be as fast as memory accesses to a same location. The issue with shared memory systems is that many CPUs need fast access to memory and will likely cache memory, which has two complications:</p>
<ul>
<li>CPU-to-memory connection becomes a bottleneck. Shared memory computers cannot scale very well. Most of them have ten or fewer processors.</li>
<li>Cache coherence: Whenever one cache is updated with information that may be used by other processors, the change needs to be reflected to the other processors, otherwise the different processors will be working with incoherent data (see cache coherence and memory coherence). Such coherence protocols can, when they work well, provide extremely high-performance access to shared information between multiple processors. On the other hand they can sometimes become overloaded and become a bottleneck to performance.</li>
</ul>
<p>Technologies like crossbar switches, Omega networks, HyperTransport or Front-side bus can be used to dampen the bottleneck-effects.</p>
<p>The alternatives to shared memory are distributed memory and distributed shared memory, each having a similar set of issues. See also Non-Uniform Memory Access.</p>
<h2>In software</h2>
<p>In computer software, <i>shared memory</i> is either</p>
<ul>
<li>a method of inter-process communication (IPC), i.e. a way of exchanging data between programs running at the same time. One process will create an area in RAM which other processes can access, <i>or</i></li>
<li>a method of conserving memory space by directing accesses to what would ordinarily be copies of a piece of data to a single instance instead, by using virtual memory mappings or with explicit support of the program in question. This is most often used for shared libraries and for XIP.</li>
</ul>
<p>Since both processes can access the shared memory area like regular working memory, this is a very fast way of communication (as opposed to other mechanisms of IPC such as named pipes, Unix domain sockets or CORBA). On the other hand, it is less scalable, as for example the communicating processes must be running on the same machine (of other IPC methods, only Internet Domain sockets (not UNIX sockets) can use a computer network), and care must be taken to avoid issues if processes sharing memory are running on separate CPUs and the underlying architecture is not cache coherent.</p>
<p>IPC by shared memory is used for example to transfer images between the application and the X server on Unix systems, or inside the IStream object returned by CoMarshalInterThreadInterfaceInStream in the COM libraries under Windows.</p>
<p>Dynamic libraries are generally held in memory once and mapped to multiple processes, and only pages that had to be customized for the individual process (because a symbol resolved differently there) are duplicated, usually with a mechanism known as copy-on-write that transparently copies the page when a write is attempted, and then lets the write succeed on the private copy.</p>
<h3>Support on UNIX platforms</h3>
<p>POSIX provides a standardized API for using shared memory, <i>POSIX Shared Memory</i>. This uses the function <code>shm_open</code> from sys/mman.h. POSIX interprocess communication (part of the POSIX:XSI Extension) includes the shared-memory functions <code>shmat</code>, <code>shmctl</code>, <code>shmdt</code> and <code>shmget</code>. UNIX System V provides an API for shared memory as well. This uses shmget from sys/shm.h. BSD systems provide "anonymous mapped memory" which can be used by several processes.</p>
<p>The shared memory created by <code>shm_open</code> is persistent. It stays in the system until explicitly removed by a process. This has a drawback that if the process crashes and fails to clean up shared memory it will stay until system shutdown. To avoid this issue mmap can be used to create a shared memory. Two communicating processes should open a temporary file with the same name and do mmap on it to get a file mapping in the memory. As a result changes in mapped memory are visible by both processes at the same time. The advantage of these approaches is that when both processes exit, OS will automatically close the files and remove shared memory.</p>
<p>Recent Linux distributions based on the 2.6 kernel have started to offer /dev/shm as shared memory in the form of a RAM disk, more specifically as a world-writable directory (a directory in which every user of the system can create files) that is stored in memory. Both the RedHat and Debian based distributions include it by default. Support for this type of RAM disk is completely optional within the kernel configuration file.</p>
<h3>Support on other platforms</h3>
<p>On Windows the function <code>CreateSharedMemory</code> can be used to create a shared memory. Alternatively one can use <code>CreateFileMapping</code> and <code>MapViewOfFile</code> functions </p>
<p>Some C++ libraries provide a portable and object-oriented access to shared memory functionality. For example, Boost contains Boost.Interprocess C++ Library. Qt provides QSharedMemory class.</p>
<p>There is native support for shared memory also in programming languages besides C/C++. For example, PHP provides API to create a shared memory, similar to POSIX functions.</p>
<h2>See also</h2>
<ul>
<li>Distributed shared memory</li>
<li>Global variable</li>
<li>Nano-threads</li>
<li>Shared graphics memory</li>
<li>Shared memory architecture</li>
<li>Execute in place</li>
</ul>
</body>
</html>