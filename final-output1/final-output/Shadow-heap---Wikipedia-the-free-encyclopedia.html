<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Shadow-heap---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Shadow heap</h1>
<p>In computer science, a <b>shadow heap</b> is a mergeable heap data structure which supports efficient heap merging in the amortized sense. More specifically, <b>shadow heaps</b> make use of the shadow merge algorithm to achieve insertion in <i>O</i>(f(<i>n</i>)) amortized time and deletion in <i>O</i>((log <i>n</i> log log <i>n</i>)/f(<i>n</i>)) amortized time, for any choice of 1 ≤ f(<i>n</i>) ≤ log log <i>n</i>.</p>
<p>Throughout this article, it is assumed that <i>A</i> and <i>B</i> are binary heaps with |<i>A</i>| ≤ |<i>B</i>|.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Shadow merge
<ul>
<li>1.1 Algorithm</li>
<li>1.2 Running time</li>
</ul>
</li>
<li>2 Structure</li>
<li>3 Analysis</li>
<li>4 Related algorithms &amp; data structures</li>
<li>5 References</li>
</ul>
<ul>
<li>1.1 Algorithm</li>
<li>1.2 Running time</li>
</ul>
<p></p>
<h2>Shadow merge</h2>
<p>Shadow merge is an algorithm for merging two binary heaps efficiently if these heaps are implemented as arrays. Specifically, the running time of shadow merge on two heaps <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> and <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> is <img class="mwe-math-fallback-image-inline tex" alt="O(|A| + \min\{\log |B| \log \log |B|, \log |A| \log |B|\})" src="//upload.wikimedia.org/math/0/f/0/0f078dd15c8d457216365a3800bbc366.png">.</p>
<h3>Algorithm</h3>
<p>We wish to merge the two binary min-heaps <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> and <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png">. The algorithm is as follows:</p>
<ol>
<li>Concatenate the array <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> at the end of the array <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> to obtain an array <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">.</li>
<li>Identify the <i>shadow</i> of <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> in <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">; that is, the ancestors of the last <img class="mwe-math-fallback-image-inline tex" alt="|A|" src="//upload.wikimedia.org/math/8/c/e/8ce7f2ced5b55654edb86bb9cefb944e.png"> nodes in <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> which destroy the heap property.</li>
<li>Identify the following two parts of the shadow from <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">:
<ul>
<li>The <i>path</i> <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png">: the set of nodes in the shadow for which there are at most 2 at any depth of <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">;</li>
<li>The <i>subtree</i> <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png">: the remainder of the shadow.</li>
</ul>
</li>
<li>Extract and sort the smallest <img class="mwe-math-fallback-image-inline tex" alt="|P|" src="//upload.wikimedia.org/math/5/9/b/59b2821087d5125aeddc19aa235434ef.png"> nodes from the shadow into an array <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png">.</li>
<li>Transform <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> as follows:
<ul>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="|S| &gt; |C|" src="//upload.wikimedia.org/math/5/e/0/5e00d6f1a0f814edf0e1be43688546cd.png">, then starting from the smallest element in the sorted array, sequentially insert each element of <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> into <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">, replacing them with <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">'s smallest elements.</li>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="|S| \leq |C|" src="//upload.wikimedia.org/math/b/c/7/bc7b54c8e051ae04b198e31ae17bdda2.png">, then extract and sort the <img class="mwe-math-fallback-image-inline tex" alt="|P|" src="//upload.wikimedia.org/math/5/9/b/59b2821087d5125aeddc19aa235434ef.png"> smallest elements from <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">, and merge this sorted list with <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png">.</li>
</ul>
</li>
<li>Replace the elements of <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> into their original positions in <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">.</li>
<li>Make a heap out of <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png">.</li>
</ol>
<ul>
<li>The <i>path</i> <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png">: the set of nodes in the shadow for which there are at most 2 at any depth of <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">;</li>
<li>The <i>subtree</i> <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png">: the remainder of the shadow.</li>
</ul>
<ul>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="|S| &gt; |C|" src="//upload.wikimedia.org/math/5/e/0/5e00d6f1a0f814edf0e1be43688546cd.png">, then starting from the smallest element in the sorted array, sequentially insert each element of <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> into <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">, replacing them with <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">'s smallest elements.</li>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="|S| \leq |C|" src="//upload.wikimedia.org/math/b/c/7/bc7b54c8e051ae04b198e31ae17bdda2.png">, then extract and sort the <img class="mwe-math-fallback-image-inline tex" alt="|P|" src="//upload.wikimedia.org/math/5/9/b/59b2821087d5125aeddc19aa235434ef.png"> smallest elements from <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">, and merge this sorted list with <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png">.</li>
</ul>
<h3>Running time</h3>
<p>Again, let <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png"> denote the path, and <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> denote the subtree of the concatenated heap <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">. The number of nodes in <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png"> is at most twice the depth of <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png">, which is <img class="mwe-math-fallback-image-inline tex" alt="O(\log |B|)" src="//upload.wikimedia.org/math/c/7/e/c7e4b987bfcb03c10a1c92a2c57a01bf.png">. Moreover, the number of nodes in <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> at depth <img class="mwe-math-fallback-image-inline tex" alt="d" src="//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png"> is at most 3/4 the number of nodes at depth <img class="mwe-math-fallback-image-inline tex" alt="d + 1" src="//upload.wikimedia.org/math/7/6/5/765f09f9b6abc99f555c131a5475b9db.png">, so the subtree has size <img class="mwe-math-fallback-image-inline tex" alt="O(|A|)" src="//upload.wikimedia.org/math/0/f/b/0fb4b2ce253e5464780904303b2a5dda.png">. Since there are at most 2 nodes at each level on <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png">, then reading the smallest <img class="mwe-math-fallback-image-inline tex" alt="|P|" src="//upload.wikimedia.org/math/5/9/b/59b2821087d5125aeddc19aa235434ef.png"> elements of the shadow into the sorted array <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> takes <img class="mwe-math-fallback-image-inline tex" alt="O(\log |B|)" src="//upload.wikimedia.org/math/c/7/e/c7e4b987bfcb03c10a1c92a2c57a01bf.png"> time.</p>
<p>If <img class="mwe-math-fallback-image-inline tex" alt="|S| &gt; |C|" src="//upload.wikimedia.org/math/5/e/0/5e00d6f1a0f814edf0e1be43688546cd.png">, then combining <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png"> and <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> as in step 5 above takes time <img class="mwe-math-fallback-image-inline tex" alt="O(\log |A| \log |B|)" src="//upload.wikimedia.org/math/b/0/b/b0b0024c297768e90780bf11fae92592.png">. Otherwise, the time taken in this step is <img class="mwe-math-fallback-image-inline tex" alt="O(|A| + \log |B| \log \log |B|)" src="//upload.wikimedia.org/math/0/6/e/06e14116875474540193f22a3fb11289.png">. Finally, making a heap of the subtree <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> takes <img class="mwe-math-fallback-image-inline tex" alt="O(|A|)" src="//upload.wikimedia.org/math/0/f/b/0fb4b2ce253e5464780904303b2a5dda.png"> time. This amounts to a total running time for shadow merging of <img class="mwe-math-fallback-image-inline tex" alt="O(|A| + \min\{\log |A| \log |B|, \log |B| \log \log |B|\})" src="//upload.wikimedia.org/math/1/5/7/157837bab244a7bd0e77a0dab58e310e.png">.</p>
<h2>Structure</h2>
<p>A shadow heap <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> consists of threshold function <img class="mwe-math-fallback-image-inline tex" alt="f(H)" src="//upload.wikimedia.org/math/e/6/6/e664efe3aa659d458e515f5a18bec7c9.png">, and an array for which the usual array-implemented binary heap property is upheld in its first entries, and for which the heap property is not necessarily upheld in the other entries. Thus, the shadow heap is essentially a binary heap <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> adjacent to an array <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png">. To add an element to the shadow heap, place it in the array <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png">. If the array becomes too large according to the specified threshold, we first build a heap out of <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> using Floyd's algorithm for heap construction, and then merge this heap with <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> using shadow merge. Finally, the merging of shadow heaps is simply done through sequential insertion of one heap into the other using the above insertion procedure.</p>
<h2>Analysis</h2>
<p>We are given a shadow heap <img class="mwe-math-fallback-image-inline tex" alt="H = (B, A)" src="//upload.wikimedia.org/math/9/8/e/98e26f3410e74a546abfb8e43656ac07.png">, with threshold function <img class="mwe-math-fallback-image-inline tex" alt="\log |H| \leq f(H) \leq \log |H| \log \log |H|" src="//upload.wikimedia.org/math/a/3/d/a3d5d0d095bc0bc195e23437018dce89.png"> as above. Suppose that the threshold function is such that any change in <img class="mwe-math-fallback-image-inline tex" alt="|B|" src="//upload.wikimedia.org/math/1/7/b/17b6c7afdd706c907dc8ffc226eb6be8.png"> induces no larger a change than in <img class="mwe-math-fallback-image-inline tex" alt="f(H)" src="//upload.wikimedia.org/math/e/6/6/e664efe3aa659d458e515f5a18bec7c9.png">. We derive the desired running time bounds for the mergeable heap operations using the potential method for amortized analysis. The potential <img class="mwe-math-fallback-image-inline tex" alt="\Psi(H)" src="//upload.wikimedia.org/math/1/4/a/14adea306046c8e35821dbae7b6c84e9.png"> of the heap is chosen to be:</p>
<p>Using this potential, we can obtain the desired amortized running times:</p>
<p><b>create(<i>H</i>)</b>: initializes a new empty shadow heap <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"></p>
<p><b>insert(<i>x</i>, <i>H</i>)</b>: inserts <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> into the shadow heap <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"></p>
<ul>
<li>If the merge is employed, then the drop in the potential function is exactly the actual cost of merging <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> and <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png">, so the amortized cost is <img class="mwe-math-fallback-image-inline tex" alt="O(1)" src="//upload.wikimedia.org/math/5/e/0/5e079a28737d5dd019a3b8f6133ee55e.png">.</li>
<li>If the merge is not done, then the amortized cost is <img class="mwe-math-fallback-image-inline tex" alt="O(1 + \min\{\log |B| \log \log |B|, \log |B| \log |A|\}/f(H))" src="//upload.wikimedia.org/math/4/b/a/4ba15487c1fb349d367668d9f402976f.png"></li>
</ul>
<p><b>delete_min(<i>H</i>)</b>: deletes the minimum priority element from <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"></p>
<h2>Related algorithms &amp; data structures</h2>
<p>A naive binary heap merging algorithm will merge the two heaps <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> and <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> in in time <img class="mwe-math-fallback-image-inline tex" alt="O(|B|)" src="//upload.wikimedia.org/math/2/a/4/2a436c9625ab7255c9037b631239ea3f.png"> by simply concatenating both heaps and making a heap out of the resulting array using Floyd's algorithm for heap construction. Alternatively, the heaps can simply be merged by sequentially inserting each element of <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> into <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png">, taking time <img class="mwe-math-fallback-image-inline tex" alt="O(|A| \log |B|)" src="//upload.wikimedia.org/math/7/3/b/73b17be72904c7a36222c0a419ff9bb6.png">.</p>
<p>Sack and Strothotte proposed an algorithm for merging the binary heaps in <img class="mwe-math-fallback-image-inline tex" alt="O(|A| + \log |A| \log |B|)" src="//upload.wikimedia.org/math/8/b/1/8b1ead52ed7a18182240acb7a7f6a208.png"> time. Their algorithm is known to be more efficient than the second naive solution described above roughly when <img class="mwe-math-fallback-image-inline tex" alt="|A| &gt; \log |B|" src="//upload.wikimedia.org/math/8/1/5/8159b1da5049455e9ed304e93b161604.png">. Shadow merge performs asymptotically better than their algorithm, even in the worst case.</p>
<p>There are several other heaps which support faster merge times. For instance, Fibonacci heaps can be merged in <img class="mwe-math-fallback-image-inline tex" alt="O(1)" src="//upload.wikimedia.org/math/5/e/0/5e079a28737d5dd019a3b8f6133ee55e.png"> time. Since binary heaps require <img class="mwe-math-fallback-image-inline tex" alt="\Omega(|A|)" src="//upload.wikimedia.org/math/a/a/6/aa6d8a35d0f3eb7f3756fc91c9db308b.png"> time to merge, shadow merge remains efficient.</p>
</body>
</html>