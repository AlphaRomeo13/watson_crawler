<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Deterministic-algorithm---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Deterministic algorithm</h1>
<p>In computer science, a <b>deterministic algorithm</b> is an algorithm which, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states. Deterministic algorithms are by far the most studied and familiar kind of algorithm, as well as one of the most practical, since they can be run on real machines efficiently.</p>
<p>Formally, a deterministic algorithm computes a mathematical function; a function has a unique value for any input in its domain, and the algorithm is a process that produces this particular value as output.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Formal definition</li>
<li>2 What makes algorithms non-deterministic?</li>
<li>3 Disadvantages of Determinism</li>
<li>4 Determinism categories in languages
<ul>
<li>4.1 Mercury</li>
<li>4.2 Haskell</li>
<li>4.3 ML family and derived languages</li>
<li>4.4 Java</li>
</ul>
</li>
<li>5 References</li>
</ul>
<ul>
<li>4.1 Mercury</li>
<li>4.2 Haskell</li>
<li>4.3 ML family and derived languages</li>
<li>4.4 Java</li>
</ul>
<p></p>
<h2>Formal definition</h2>
<p>Deterministic algorithms can be defined in terms of a state machine: a <i>state</i> describes what a machine is doing at a particular instant in time. State machines pass in a discrete manner from one state to another. Just after we enter the input, the machine is in its <i>initial state</i> or <i>start state</i>. If the machine is deterministic, this means that from this point onwards, its current state determines what its next state will be; its course through the set of states is predetermined. Note that a machine can be deterministic and still never stop or finish, and therefore fail to deliver a result.</p>
<p>Examples of particular abstract machines which are deterministic include the deterministic Turing machine and deterministic finite automaton.</p>
<h2>What makes algorithms non-deterministic?</h2>
<p>A variety of factors can cause an algorithm to behave in a way which is not deterministic, or non-deterministic:</p>
<ul>
<li>If it uses external state other than the input, such as user input, a global variable, a hardware timer value, a random value, or stored disk data.</li>
<li>If it operates in a way that is timing-sensitive, for example if it has multiple processors writing to the same data at the same time. In this case, the precise order in which each processor writes its data will affect the result.</li>
<li>If a hardware error causes its state to change in an unexpected way.</li>
</ul>
<p>Although real programs are rarely purely deterministic, it is easier for humans as well as other programs to reason about programs that are. For this reason, most programming languages and especially functional programming languages make an effort to prevent the above events from happening except under controlled conditions.</p>
<p>The prevalence of multi-core processors has resulted in a surge of interest in determinism in parallel programming and challenges of non-determinism have been well documented. A number of tools to help deal with the challenges have been proposed to deal with deadlocks and race conditions.</p>
<h2>Disadvantages of Determinism</h2>
<p>It is advantageous, in some cases, for a program to exhibit nondeterministic behavior. The behavior of a card shuffling program used in a game of blackjack, for example, should not be predictable by players â€” even if the source code of the program is visible. The use of a pseudorandom number generator is often not sufficient to ensure that players are unable to predict the outcome of a shuffle. A clever gambler might guess precisely the numbers the generator will choose and so determine the entire contents of the deck ahead of time, allowing him to cheat; for example, the Software Security Group at Reliable Software Technologies was able to do this for an implementation of Texas Hold 'em Poker that is distributed by ASF Software, Inc, allowing them to consistently predict the outcome of hands ahead of time. These problems can be avoided, in part, through the use of a cryptographically secure pseudo-random number generator, but it is still necessary for an unpredictable random seed to be used to initialize the generator. For this purpose a source of nondeterminism is required, such as that provided by a hardware random number generator.</p>
<p>Note that a negative answer to the P=NP problem would not imply that programs with nondeterministic output are theoretically more powerful than those with deterministic output. The complexity class NP (complexity) can be defined without any reference to nondeterminism using the verifier-based definition.</p>
<h2>Determinism categories in languages</h2>
<h3>Mercury</h3>
<p>This logic-functional programming language establish different determinism categories for predicate modes as explained in the ref.</p>
<h3>Haskell</h3>
<p>Haskell provides several mechanisms:</p>
<ul>
<li>the <i>Maybe</i> and <i>Either</i> types include the notion of success in the result.</li>
<li>the <i>fail</i> method of the class Monad, may be used to signal <i>fail</i> as exception.</li>
<li>the Maybe monad and MaybeT monad transformer provide for failed computations (stop the computation sequence and return Nothing)</li>
</ul>
<h3>ML family and derived languages</h3>
<p>As seen in Standard ML, OCaml and Scala</p>
<ul>
<li>The <i>option</i> type includes the notion of success.</li>
</ul>
<h3>Java</h3>
<ul>
<li>The <i>null</i> reference value may represent an unsuccessful (out-of-domain) result.</li>
</ul>
</body>
</html>