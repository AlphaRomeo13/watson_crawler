<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cycle-sort---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Cycle sort</h1>
<p><b>Cycle sort</b> is an in-place, unstable sorting algorithm, a comparison sort that is theoretically optimal in terms of the total number of writes to the original array, unlike any other in-place sorting algorithm. It is based on the idea that the permutation to be sorted can be factored into cycles, which can individually be rotated to give a sorted result.</p>
<p>Unlike nearly every other sort, items are <i>never</i> written elsewhere in the array simply to push them out of the way of the action. Each value is either written zero times, if it's already in its correct position, or written one time to its correct position. This matches the minimal number of overwrites required for a completed in-place sort.</p>
<p>Minimizing the number of writes is useful when making writes to some huge data set is very expensive, such as with EEPROMs like Flash memory where each write reduces the lifespan of the memory.</p>
<h2>Algorithm</h2>
<p>The following algorithm finds cycles and rotates them, giving a sorted result. Arrays are zero-indexed.</p>
<p>WHATSON? 7a9e58c9-fab5-47af-ac95-869a8f9d6357</p>
<pre>
# Sort an array in place and return the number of writes.
procedure cycleSort(array):
  writes = 0

  # Loop through the array to find cycles to rotate.
  for cycleStart from 0 to length(array) - 2, inclusive:
    item = array[cycleStart]

    # Find where to put the item.
    pos = cycleStart
    for i from cycleStart + 1 to length(array)), inclusive:
      if array[i] &lt; item:
        pos += 1

    # If the item is already there, this is not a cycle.
    if pos == cycleStart:
      continue

    # Otherwise, put the item there or right after any duplicates.
    while item == array[pos]:
      pos += 1
    array[pos], item = item, array[pos]
    writes += 1

    # Rotate the rest of the cycle.
    while pos != cycleStart:
      # Find where to put the item.
      pos = cycleStart
      for i from cycleStart + 1 to length(array), inclusive
        if array[i] &lt; item:
          pos += 1

      # Put the item there or right after any duplicates.
      while item == array[pos]:
        pos += 1
      array[pos], item = item, array[pos]
      writes += 1

  return writes
</pre>
<h2>Situation-specific optimizations</h2>
<p>When the array contains only duplicates of a relatively small number of items, a constant-time perfect hash function can greatly speed up finding where to put an item, turning the sort from Θ(<i>n</i>) time to Θ(<i>n</i> + <i>k</i>) time, where <i>k</i> is the total number of hashes. The array ends up sorted in the order of the hashes, so choosing a hash function that gives you the right ordering is important.</p>
<p>Before the sort, create a histogram, sorted by hash, counting the number of occurrences of each hash in the array. Then create a table with the cumulative sum of each entry in the histogram. The cumulative sum table will then contain the position in the array of each element. The proper place of elements can then be found by a constant-time hashing and cumulative sum table lookup rather than a linear search.</p>
<h2>External links</h2>
<p><b>^</b> "Cycle-Sort: A Linear Sorting Method", The Computer Journal (1990) 33 (4): 365-367.</p>
<ul>
<li>Original source of unrestricted variant</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>Computational complexity theory</li>
<li>Big O notation</li>
<li>Total order</li>
<li>Lists</li>
<li>Inplacement</li>
<li>Stability</li>
<li>Comparison sort</li>
<li>Adaptive sort</li>
<li>Sorting network</li>
<li>Integer sorting</li>
</ul>
<ul>
<li>Bubble sort</li>
<li>Cocktail sort</li>
<li>Odd–even sort</li>
<li>Comb sort</li>
<li>Gnome sort</li>
<li>Quicksort</li>
<li>Stooge sort</li>
<li>Bogosort</li>
</ul>
<ul>
<li>Selection sort</li>
<li>Heapsort</li>
<li>Smoothsort</li>
<li>Cartesian tree sort</li>
<li>Tournament sort</li>
<li><strong class="selflink">Cycle sort</strong></li>
</ul>
<ul>
<li>Insertion sort</li>
<li>Shellsort</li>
<li>Splaysort</li>
<li>Tree sort</li>
<li>Library sort</li>
<li>Patience sorting</li>
</ul>
<ul>
<li>Merge sort</li>
<li>Cascade merge sort</li>
<li>Oscillating merge sort</li>
<li>Polyphase merge sort</li>
<li>Strand sort</li>
</ul>
<ul>
<li>American flag sort</li>
<li>Bead sort</li>
<li>Bucket sort</li>
<li>Burstsort</li>
<li>Counting sort</li>
<li>Pigeonhole sort</li>
<li>Proxmap sort</li>
<li>Radix sort</li>
<li>Flashsort</li>
</ul>
<ul>
<li>Bitonic sorter</li>
<li>Batcher odd–even mergesort</li>
<li>Pairwise sorting network</li>
</ul>
<ul>
<li>Block sort</li>
<li>Timsort</li>
<li>Introsort</li>
<li>Spreadsort</li>
<li>JSort</li>
</ul>
<ul>
<li>Topological sorting</li>
<li>Pancake sorting</li>
<li>Spaghetti sort</li>
</ul>
</body>
</html>