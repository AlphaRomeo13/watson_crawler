<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Quadratic-probing---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Quadratic probing</h1>
<p><b>Quadratic probing</b> is an open addressing scheme in computer programming for resolving collisions in hash tables—when an incoming data's hash value indicates it should be stored in an already-occupied slot or bucket. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.</p>
<p>For a given hash value, the indices generated by linear probing are as follows:</p>
<p><img class="mwe-math-fallback-image-inline tex" alt="H + 1 , H + 2 , H + 3 , H + 4 , ... , H + k" src="//upload.wikimedia.org/math/f/b/a/fba80058a51128c60f8432763398b37e.png"></p>
<p>This method results in primary clustering, and as the cluster grows larger, the search for those items hashing within the cluster becomes less efficient.</p>
<p>An example sequence using quadratic probing is:</p>
<p><img class="mwe-math-fallback-image-inline tex" alt="H + 1^2 , H + 2^2 , H + 3^2 , H + 4^2 , ... , H + k^2" src="//upload.wikimedia.org/math/d/2/5/d25d86f069cb0dd8b1d48592b631b1a9.png"></p>
<p>Quadratic probing can be a more efficient algorithm in a closed hash table, since it better avoids the clustering problem that can occur with linear probing, although it is not immune. It also provides good memory caching because it preserves some locality of reference; however, linear probing has greater locality and, thus, better cache performance.</p>
<p>Quadratic probing is used in the Berkeley Fast File System to allocate free blocks. The allocation routine chooses a new cylinder-group when the current is nearly full using quadratic probing, because of the speed it shows in finding unused cylinder-groups.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Quadratic function</li>
<li>2 Quadratic probing insertion
<ul>
<li>2.1 Algorithm to insert key in hash table</li>
<li>2.2 C function for key insertion</li>
</ul>
</li>
<li>3 Quadratic probing search
<ul>
<li>3.1 Algorithm to search element in hash table</li>
<li>3.2 C function for key searching</li>
</ul>
</li>
<li>4 Limitations
<ul>
<li>4.1 Alternating sign</li>
</ul>
</li>
<li>5 See also</li>
<li>6 References</li>
<li>7 External links</li>
</ul>
<ul>
<li>2.1 Algorithm to insert key in hash table</li>
<li>2.2 C function for key insertion</li>
</ul>
<ul>
<li>3.1 Algorithm to search element in hash table</li>
<li>3.2 C function for key searching</li>
</ul>
<ul>
<li>4.1 Alternating sign</li>
</ul>
<p></p>
<h2>Quadratic function</h2>
<p>Let h(k) be a hash function that maps an element k to an integer in [0,m-1], where m is the size of the table. Let the i probe position for a value k be given by the function</p>
<p>where c<sub>2</sub> ≠ 0. If c<sub>2</sub> = 0, then h(k,i) degrades to a linear probe. For a given hash table, the values of c<sub>1</sub> and c<sub>2</sub> remain constant.</p>
<p><b>Examples:</b></p>
<ul>
<li>If <img class="mwe-math-fallback-image-inline tex" alt="h(k,i) = (h(k) + i + i^2) \pmod{m}" src="//upload.wikimedia.org/math/d/5/a/d5acd6ad977ac05618efe06d44659435.png">, then the probe sequence will be <img class="mwe-math-fallback-image-inline tex" alt="h(k), h(k)+2, h(k)+6, ..." src="//upload.wikimedia.org/math/9/5/8/958c8ff6f49a30867c56b29217d50ce2.png"></li>
<li>For m = 2, a good choice for the constants are c<sub>1</sub> = c<sub>2</sub> = 1/2, as the values of h(k,i) for i in [0,m-1] are all distinct. This leads to a probe sequence of <img class="mwe-math-fallback-image-inline tex" alt="h(k), h(k)+1, h(k)+3, h(k)+6, ..." src="//upload.wikimedia.org/math/5/7/9/57956aa60720da84a3b23441e1603b09.png"> where the values increase by 1, 2, 3, ...</li>
<li>For prime m &gt; 2, most choices of c<sub>1</sub> and c<sub>2</sub> will make h(k,i) distinct for i in [0, (m-1)/2]. Such choices include c<sub>1</sub> = c<sub>2</sub> = 1/2, c<sub>1</sub> = c<sub>2</sub> = 1, and c<sub>1</sub> = 0, c<sub>2</sub> = 1. Because there are only about m/2 distinct probes for a given element, it is difficult to guarantee that insertions will succeed when the load factor is &gt; 1/2.</li>
</ul>
<h2>Quadratic probing insertion</h2>
<p>The problem, here, is to insert a key at an available key space in a given Hash Table using quadratic probing.</p>
<h3>Algorithm to insert key in hash table</h3>
<p>WHATSON? 3db056f5-fcd9-4145-b19e-3249b55670ca</p>
<pre>
<code> 1. Get the key k
 2. Set counter j = 0
 3. Compute hash function h[k] = k % SIZE
 4. If hashtable[h[k]] is empty
         (4.1) Insert key k at hashtable[h[k]]
         (4.2) Stop
    Else
        (4.3) The key space at hashtable[h[k]] is occupied, so we need to find the next available key space
        (4.4) Increment j
        (4.5) Compute new hash function h[k] = ( k + j * j ) % SIZE
        (4.6) Repeat Step 4 till j is equal to the SIZE of hash table
 5. The hash table is full
 6. Stop
</code>
</pre>
<h3>C function for key insertion</h3>
<p>WHATSON? d8b5d296-ca45-431c-bde5-6cdc68ec45ce</p>
<pre>
int quadratic_probing_insert(int *hashtable, int key, int *empty){
    /* hashtable[] is an integer hash table; empty[] is another array which indicates whether the key space is occupied;
       If an empty key space is found, the function returns the index of the bucket where the key is inserted, otherwise it 
       returns (-1) if no empty key space is found */
 
    int j = 0, hk;
    hk = key  % SIZE;
    while(j &lt; SIZE) {
        if(empty[hk] == 1){
            hashtable[hk] = key;
            empty[hk] = 0;
            return (hk);
        }
        j++;
        hk = (key + j * j) % SIZE;
    }
    return (-1);
}
</pre>
<h2>Quadratic probing search</h2>
<h3>Algorithm to search element in hash table</h3>
<p>WHATSON? 3aa42b86-daa9-4ffe-bd3a-496a763e98c8</p>
<pre>
<code> 1. Get the key k to be searched
 2. Set counter j = 0
 3. Compute hash function h[k] = k % SIZE
 4. If the key space at hashtable[h[k]] is occupied
         (4.1) Compare the element at hashtable[h[k]] with the key k.
         (4.2) If they are equal
         (4.2.1) The key is found at the bucket h[k]
         (4.2.2) Stop
    Else
         (4.3) The element might be placed at the next location given by the quadratic function
         (4.4) Increment j
         (4.5) Compute new hash function h[k] = ( k + j * j ) % SIZE
         (4.6) Repeat Step 4 till j is greater than SIZE of hash table
 5. The key was not found in the hash table
 6. Stop
</code>
</pre>
<h3>C function for key searching</h3>
<p>WHATSON? c4b795a5-ad22-4624-8343-73a9e135efcf</p>
<pre>
int quadratic_probing_search(int *hashtable, int key, int *empty)
{
    /* If the key is found in the hash table, the function returns the index of the hashtable where the key is inserted, otherwise it 
       returns (-1) if the key is not found */ 
 
    int j = 0, hk;
    hk = key  % SIZE;
    while(j &lt; SIZE) 
    {
        if((empty[hk] == 0) &amp;&amp; (hashtable[hk] == key))
            return (hk);
        j++;
        hk = (key + j * j) % SIZE;
    }
    return (-1);
}
</pre>
<h2>Limitations</h2>
<p> For linear probing it is a bad idea to let the hash table get nearly full, because performance is degraded as the hash table gets filled. In the case of quadratic probing, the situation is even more drastic. With the exception of the triangular number case for a power-of-two-sized hash table, there is no guarantee of finding an empty cell once the table gets more than half full, or even before the table gets half full if the table size is not prime. This is because at most half of the table can be used as alternative locations to resolve collisions. If the hash table size is b (a prime greater than 3), it can be proven that the first <img class="mwe-math-fallback-image-inline tex" alt=" b / 2 " src="//upload.wikimedia.org/math/8/3/7/83725edea4c6f6a7dae4d7f884b59894.png"> alternative locations including the initial location h(k) are all distinct and unique. Suppose, we assume two of the alternative locations to be given by <img class="mwe-math-fallback-image-inline tex" alt=" h(k) + x^2 \pmod{b} " src="//upload.wikimedia.org/math/e/d/6/ed67a7260fdabd582628c78fb6193938.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" h(k) + y^2 \pmod{b} " src="//upload.wikimedia.org/math/e/6/0/e60236454db636b6c8c7999749832562.png">, where 0 ≤ x, y ≤ (b / 2). If these two locations point to the same key space, but x ≠ y. Then the following would have to be true,</p>
<p>WHATSON? 8522055d-f336-4ebc-9c83-eb6f162ffca9</p>
<pre>
   <img class="mwe-math-fallback-image-inline tex" alt=" h(k) + x^2 = h(k) + y^2     \pmod{b} " src="//upload.wikimedia.org/math/2/7/f/27fee35e1f0d741426f5422450763af7.png">
   <img class="mwe-math-fallback-image-inline tex" alt=" x^2 = y^2                   \pmod{b}  " src="//upload.wikimedia.org/math/3/4/a/34aefabb63e7b098bcbf61a63de2d916.png">
   <img class="mwe-math-fallback-image-inline tex" alt=" x^2 - y^2 = 0               \pmod{b}  " src="//upload.wikimedia.org/math/e/7/7/e77c2121a8508dcfe9f511f63da4bc7d.png">
   <img class="mwe-math-fallback-image-inline tex" alt=" (x - y)(x + y) = 0          \pmod{b}   " src="//upload.wikimedia.org/math/2/8/7/2876518c282db48a26325e5c64e82b4c.png">
</pre>
<p>As b (table size) is a prime greater than 3, either (x - y) or (x + y) has to be equal to zero. Since x and y are unique, (x - y) cannot be zero. Also, since 0 ≤ x, y ≤ (b / 2), (x + y) cannot be zero.</p>
<p>Thus, by contradiction, it can be said that the first (b / 2) alternative locations after h(k) are unique. So an empty key space can always be found as long as at most (b / 2) locations are filled, i.e., the hash table is not more than half full.</p>
<h3>Alternating sign</h3>
<p>If the sign of the offset is alternated (e.g. +1, -4, +9, -16 etc.), and if the number of buckets is a prime number p congruent to 3 modulo 4 (i.e. one of 3, 7, 11, 19, 23, 31 and so on), then the first p offsets will be unique modulo p.</p>
<p>In other words, a permutation of 0 through p-1 is obtained, and, consequently, a free bucket will always be found as long as there exists at least one.</p>
<p>The insertion algorithm only receives a minor modification (but do note that SIZE has to be a suitable prime number as explained above):</p>
<p>WHATSON? fe91b1c5-af2c-415f-8062-4e2641580bc4</p>
<pre>
<code>1. Get the key k
2. Set counter j = 0
3. Compute hash function h[k] = k % SIZE
4. If hashtable[h[k]] is empty
        (4.1) Insert key k at hashtable[h[k]]
        (4.2) Stop
   Else
       (4.3) The key space at hashtable[h[k]] is occupied, so we need to find the next available key space
       (4.4) Increment j
       (4.5) Compute new hash function h[k]. If j is odd, then
             h[k] = ( k + j * j ) % SIZE, else h[k] = ( k - j * j ) % SIZE
       (4.6) Repeat Step 4 till j is equal to the SIZE of hash table
5. The hash table is full
6. Stop
</code>
</pre>
<p>The search algorithm is modified likewise.</p>
<h2>See also</h2>
<ul>
<li>Hash tables</li>
<li>Hash collision</li>
<li>Double hashing</li>
<li>Linear probing</li>
<li>Hash function</li>
</ul>
</body>
</html>