<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Memory-segmentation---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Memory segmentation</h1>
<p><b>Memory segmentation</b> is the division of a computer's primary memory into <b>segments</b> or <b>sections</b>. In a computer system using segmentation, a reference to a memory location includes a value that identifies a segment and an offset within that segment. Segments or sections are also used in object files of compiled programs when they are linked together into a program image and when the image is loaded into memory.</p>
<p>Segments usually correspond to natural divisions of a program such as individual routines or data tables so segmentation is generally more visible to the programmer than paging alone. Different segments may be created for different program modules, or for different classes of memory usage such as code and data segments. Certain segments may be shared between programs.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Hardware implementation
<ul>
<li>1.1 Segmentation without paging</li>
<li>1.2 Segmentation with paging</li>
</ul>
</li>
<li>2 History</li>
<li>3 x86 architecture</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<ul>
<li>1.1 Segmentation without paging</li>
<li>1.2 Segmentation with paging</li>
</ul>
<p></p>
<h2>Hardware implementation</h2>
<p>In a system using segmentation computer memory addresses consist of a segment id and an offset within the segment. A hardware memory management unit (MMU) is responsible for translating the segment and offset into a physical memory address, and for performing checks to make sure the translation can be done and that the reference to that segment and offset is permitted.</p>
<p>Each segment has a length and set of permissions (for example, <i>read</i>, <i>write</i>, <i>execute</i>) associated with it. A process is only allowed to make a reference into a segment if the type of reference is allowed by the permissions, and if the offset within the segment is within the range specified by the length of the segment. Otherwise, a hardware exception such as a segmentation fault is raised.</p>
<p>Segments may also be used to implement virtual memory. In this case each segment has an associated flag indicating whether it is present in main memory or not. If a segment is accessed that is not present in main memory, an exception is raised, and the operating system will read the segment into memory from secondary storage.</p>
<p>Segmentation is one method of implementing memory protection. Paging is another, and they can be combined. The size of a memory segment is generally not fixed and may be as small as a single byte.</p>
<p>Segmentation has been implemented in several different ways on different hardware, with or without paging. The Intel x86 implementation of segments does not fit either model and is discussed separately below.</p>
<h3>Segmentation without paging</h3>
<p>Associated with each segment is information that indicates where the segment is located in memory— the <i>segment base</i>. When a program references a memory location the offset is added to the segment base to generate a physical memory address.</p>
<p>An implementation of virtual memory on a system using segmentation without paging requires that entire segments be swapped back and forth between main memory and secondary storage. When a segment is swapped in, the operating system has to allocate enough contiguous free memory to hold the entire segment. Often memory fragmentation results in there being not enough contiguous memory even though there may be enough in total.</p>
<h3>Segmentation with paging</h3>
<p>Instead of an actual memory location the segment information includes the address of a page table for the segment. When a program references a memory location the offset is translated to a memory address using the page table. A segment can be extended simply by allocating another memory page and adding it to the segment's page table.</p>
<p>An implementation of virtual memory on a system using segmentation with paging usually only moves individual pages back and forth between main memory and secondary storage, similar to a paged non-segmented system. Pages of the segment can be located anywhere in main memory and need not be contiguous. This usually results in less paging input/output and reduced memory fragmentation</p>
<h2>History</h2>
<p>The Burroughs Corporation B5000 computer was one of the first to implement segmentation, and "perhaps the first commercial computer to provide virtual memory" based on segmentation. The later B6500 computer also implemented segmentation; a version of its architecture is still in use today on the Unisys ClearPath Libra servers.</p>
<p>The GE-645 computer, a modification of the GE-635 with segmentation and paging support added, was designed in 1964 to support Multics.</p>
<p>The Intel iAPX 432, begun in 1975, attempted to implement a true segmented architecture with memory protection on a microprocessor.</p>
<p>Prime, Stratus, Apollo, IBM System/38, and IBM AS/400 computers use memory segmentation.</p>
<h2>x86 architecture</h2>
<p>The memory segmentation used by early x86 processors, beginning with the Intel 8086, does not provide any protection. Any program running on these processors can access any segment with no restrictions. A segment is only identified by its starting location; there is no length checking.</p>
<p>Segmentation in the Intel 80286 and later provides protection: with the introduction of the 80286, Intel retroactively named the sole operating mode of the previous x86 CPU models "real mode" and introduced a new "protected mode" with protection features. For backward compatibility, all x86 CPUs start in "real mode" with no memory protection, fixed 64 KiB segments, and only 20-bit (1024 KiB) addressing. An 80286 or later processor must be switched into another mode by software in order to use its full address space and advanced MMU features.</p>
<p>In the x86 implementation of segmentation the segment table, rather than pointing to a page table for the segment, contains the segment address in <i>linear memory</i>. This address is then mapped to a physical address using a separate page table. Unlike other paged implementations of segmentation this prevents segments from dynamically growing in size.</p>
<p>The x86-64 architecture does not use segmentation in long mode (64-bit mode). Four of the segment registers: CS, SS, DS, and ES are forced to 0, and the limit to 2. The segment registers FS and GS can still have a nonzero base address. This allows operating systems to use these segments for special purposes.</p>
<h2>See also</h2>
<ul>
<li>Data segment</li>
<li>BSS Segment</li>
<li>Virtual address space</li>
<li>Virtual memory</li>
<li>x86 memory segmentation</li>
<li>Segmentation fault</li>
</ul>
</body>
</html>