<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Halting-problem---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Halting problem</h1>
<p>In computability theory, the <b>halting problem</b> is the problem of determining, from a description of an arbitrary computer program and an input, whether the program will finish running or continue to run forever.</p>
<p>Alan Turing proved in 1936 that a general algorithm to solve the halting problem for <i>all</i> possible program-input pairs cannot exist. A key part of the proof was a mathematical definition of a computer and program, which became known as a Turing machine; the halting problem is <i>undecidable</i> over Turing machines. It is one of the first examples of a decision problem.</p>
<p>Jack Copeland (2004) attributes the term <i>halting problem</i> to Martin Davis.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Background</li>
<li>2 Importance and consequences</li>
<li>3 Representation as a set</li>
<li>4 Sketch of proof</li>
<li>5 Common pitfalls</li>
<li>6 Formalization</li>
<li>7 Relationship with Gödel's incompleteness theorems</li>
<li>8 Recognizing partial solutions</li>
<li>9 History</li>
<li>10 Avoiding the halting problem</li>
<li>11 See also</li>
<li>12 Notes</li>
<li>13 References</li>
<li>14 External links</li>
</ul>
<p></p>
<h2>Background</h2>
<p>The halting problem is a decision problem about properties of computer programs on a fixed Turing-complete model of computation, i.e. all programs that can be written in some given programming language that is general enough to be equivalent to a Turing machine. The problem is to determine, given a program and an input to the program, whether the program will eventually halt when run with that input. In this abstract framework, there are no resource limitations on the amount of memory or time required for the program's execution; it can take arbitrarily long, and use arbitrarily much storage space, before halting. The question is simply whether the given program will ever halt on a particular input.</p>
<p>For example, in pseudocode, the program:</p>
<p>does not halt; rather, it goes on forever in an infinite loop. On the other hand, the program</p>
<p>does halt.</p>
<p>While deciding whether these programs halt is simple, more complex programs prove problematic.</p>
<p>One approach to the problem might be to run the program for some number of steps and check if it halts. But if the program does not halt, it is unknown whether the program will eventually halt or run forever.</p>
<p>Turing proved no algorithm can exist which will always correctly decide whether, for a given arbitrary program and its input, the program halts when run with that input; the essence of Turing's proof is that any such algorithm can be made to contradict itself, and therefore cannot be correct.</p>
<h2>Importance and consequences</h2>
<p>The halting problem is historically important because it was one of the first problems to be proved undecidable. (Turing's proof went to press in May 1936, whereas Alonzo Church's proof of the undecidability of a problem in the lambda calculus had already been published in April 1936.) Subsequently, many other undecidable problems have been described; the typical method of proving a problem to be undecidable is with the technique of <i>reduction</i>. To do this, it is sufficient to show that if a solution to the new problem were found, it could be used to decide an undecidable problem by transforming instances of the undecidable problem into instances of the new problem. Since we already know that <i>no</i> method can decide the old problem, no method can decide the new problem either. Often the new problem is reduced to solving the halting problem. (Note: the same technique is used to demonstrate that a problem is NP complete, only in this case, rather than demonstrating that there is no solution, it demonstrates there is no <i>polynomial time</i> solution, assuming P ≠ NP).</p>
<p>For example, one such consequence of the halting problem's undecidability is that there cannot be a general algorithm that decides whether a given statement about natural numbers is true or not. The reason for this is that the proposition stating that a certain program will halt given a certain input can be converted into an equivalent statement about natural numbers. If we had an algorithm that could solve every statement about natural numbers, it could certainly solve this one; but that would determine whether the original program halts, which is impossible, since the halting problem is undecidable.</p>
<p>Rice's theorem generalizes the theorem that the halting problem is unsolvable. It states that for <i>any</i> non-trivial property, there is no general decision procedure that, for all programs, decides whether the partial function implemented by the input program has that property. (A partial function is a function which may not always produce a result, and so is used to model programs, which can either produce results or fail to halt.) For example, the property "halt for the input 0" is undecidable. Here, "non-trivial" means that the set of partial functions that satisfy the property is neither the empty set nor the set of all partial functions. For example, "halts or fails to halt on input 0" is clearly true of all partial functions, so it is a trivial property, and can be decided by an algorithm that simply reports "true." Also, note that this theorem holds only for properties of the partial function implemented by the program; Rice's Theorem does not apply to properties of the program itself. For example, "halt on input 0 within 100 steps" is <b>not</b> a property of the partial function that is implemented by the program—it is a property of the program implementing the partial function and is very much decidable.</p>
<p>Gregory Chaitin has defined a halting probability, represented by the symbol Ω, a type of real number that informally is said to represent the probability that a randomly produced program halts. These numbers have the same Turing degree as the halting problem. It is a normal and transcendental number which can be defined but cannot be completely computed. This means one can prove that there is no algorithm which produces the digits of Ω, although its first few digits can be calculated in simple cases.</p>
<p>While Turing's proof shows that there can be no general method or algorithm to determine whether algorithms halt, individual instances of that problem may very well be susceptible to attack. Given a specific algorithm, one can often show that it must halt for any input, and in fact computer scientists often do just that as part of a correctness proof. But each proof has to be developed specifically for the algorithm at hand; there is no <i>mechanical, general way</i> to determine whether algorithms on a Turing machine halt. However, there are some heuristics that can be used in an automated fashion to attempt to construct a proof, which succeed frequently on typical programs. This field of research is known as automated termination analysis.</p>
<p>Since the negative answer to the halting problem shows that there are problems that cannot be solved by a Turing machine, the Church–Turing thesis limits what can be accomplished by any machine that implements effective methods. However, not all machines conceivable to human imagination are subject to the Church–Turing thesis (e.g. oracle machines). It is an open question whether there can be actual deterministic physical processes that, in the long run, elude simulation by a Turing machine, and in particular whether any such hypothetical process could usefully be harnessed in the form of a calculating machine (a hypercomputer) that could solve the halting problem for a Turing machine amongst other things. It is also an open question whether any such unknown physical processes are involved in the working of the human brain, and whether humans can solve the halting problem (Copeland 2004, p. 15).</p>
<h2>Representation as a set</h2>
<p>The conventional representation of decision problems is the set of objects possessing the property in question. The <b>halting set</b></p>
<p>represents the halting problem.</p>
<p>This set is recursively enumerable, which means there is a computable function that lists all of the pairs (<i>i</i>, <i>x</i>) it contains. However, the complement of this set is not recursively enumerable.</p>
<p>There are many equivalent formulations of the halting problem; any set whose Turing degree equals that of the halting problem is such a formulation. Examples of such sets include:</p>
<ul>
<li>{ <i>i</i> | program <i>i</i> eventually halts when run with input 0 }</li>
<li>{ <i>i</i> | there is an input <i>x</i> such that program <i>i</i> eventually halts when run with input <i>x</i> }.</li>
</ul>
<h2>Sketch of proof</h2>
<p>The proof shows there is no total computable function that decides whether an arbitrary program <i>i</i> halts on arbitrary input <i>x</i>; that is, the following function <i>h</i> is not computable (Penrose 1990, p. 57–63):</p>
<p>Here <i>program i</i> refers to the <i>i</i> th program in an enumeration of all the programs of a fixed Turing-complete model of computation.</p>
<p>The proof proceeds by directly establishing that every total computable function with two arguments differs from the required function <i>h</i>. To this end, given any total computable binary function <i>f</i>, the following partial function <i>g</i> is also computable by some program <i>e</i>:</p>
<p>The verification that <i>g</i> is computable relies on the following constructs (or their equivalents):</p>
<ul>
<li>computable subprograms (the program that computes <i>f</i> is a subprogram in program <i>e</i>),</li>
<li>duplication of values (program <i>e</i> computes the inputs <i>i</i>,<i>i</i> for <i>f</i> from the input <i>i</i> for <i>g</i>),</li>
<li>conditional branching (program <i>e</i> selects between two results depending on the value it computes for <i>f</i>(<i>i</i>,<i>i</i>)),</li>
<li>not producing a defined result (for example, by looping forever),</li>
<li>returning a value of 0.</li>
</ul>
<p>The following pseudocode illustrates a straightforward way to compute <i>g</i>:</p>
<p>WHATSON? eb57b210-36a8-40d7-bfd6-2f0253d31a5c</p>
<pre>
procedure compute_g(i):
    if f(i,i) == 0 then
        return 0
    else
        loop forever
</pre>
<p>Because <i>g</i> is partial computable, there must be a program <i>e</i> that computes <i>g</i>, by the assumption that the model of computation is Turing-complete. This program is one of all the programs on which the halting function <i>h</i> is defined. The next step of the proof shows that <i>h</i>(<i>e</i>,<i>e</i>) will not have the same value as <i>f</i>(<i>e</i>,<i>e</i>).</p>
<p>It follows from the definition of <i>g</i> that exactly one of the following two cases must hold:</p>
<ul>
<li><i>f</i>(<i>e</i>,<i>e</i>) = 0 and so <i>g</i>(<i>e</i>) = 0. In this case <i>h</i>(<i>e</i>,<i>e</i>) = 1, because program <i>e</i> halts on input <i>e</i>.</li>
<li><i>f</i>(<i>e</i>,<i>e</i>) ≠ 0 and so <i>g</i>(<i>e</i>) is undefined. In this case <i>h</i>(<i>e</i>,<i>e</i>) = 0, because program <i>e</i> does not halt on input <i>e</i>.</li>
</ul>
<p>In either case, <i>f</i> cannot be the same function as <i>h</i>. Because <i>f</i> was an <i>arbitrary</i> total computable function with two arguments, all such functions must differ from <i>h</i>.</p>
<p>This proof is analogous to Cantor's diagonal argument. One may visualize a two-dimensional array with one column and one row for each natural number, as indicated in the table above. The value of <i>f</i>(<i>i</i>,<i>j</i>) is placed at column <i>i</i>, row <i>j</i>. Because <i>f</i> is assumed to be a total computable function, any element of the array can be calculated using <i>f</i>. The construction of the function <i>g</i> can be visualized using the main diagonal of this array. If the array has a 0 at position (<i>i</i>,<i>i</i>), then <i>g</i>(<i>i</i>) is 0. Otherwise, <i>g</i>(<i>i</i>) is undefined. The contradiction comes from the fact that there is some column <i>e</i> of the array corresponding to <i>g</i> itself. Now assume <i>f</i> was the halting function <i>h</i>, if <i>g</i>(<i>e</i>) is defined ( <i>g</i>(<i>e</i>) = 0 in this case ), <i>g</i>(<i>e</i>) halts so <i>f</i>(<i>e,e</i>) = 1. But <i>g</i>(<i>e</i>) = 0 only when <i>f</i>(<i>e,e</i>) = 0, contradicting <i>f</i>(<i>e,e</i>) = 1. Similarly, if <i>g</i>(<i>e</i>) is not defined, then halting function <i>f</i>(<i>e,e</i>) = 0, which leads to <i>g</i>(<i>e</i>) = 0 under <i>g'</i>s construction. This contradicts the assumption that <i>g</i>(<i>e</i>) not being defined. In both cases contradiction arises. Therefore any arbitrary function <i>f</i> cannot be halting function <i>h</i>.</p>
<h2>Common pitfalls</h2>
<p>The difficulty in the halting problem lies in the requirement that the decision procedure must work for all programs and inputs. A particular program either halts on a given input or does not halt. Consider one algorithm that always answers "halts" and another that always answers "doesn't halt". For any specific program and input, one of these two algorithms answers correctly, even though nobody may know which one.</p>
<p>There are programs (interpreters) that simulate the execution of whatever source code they are given. Such programs can demonstrate that a program does halt if this is the case: the interpreter itself will eventually halt its simulation, which shows that the original program halted. However, an interpreter will not halt if its input program does not halt, so this approach cannot solve the halting problem as stated. It does not successfully answer "doesn't halt" for programs that do not halt.</p>
<p>The halting problem is theoretically decidable for linear bounded automata (LBAs) or deterministic machines with finite memory. A machine with finite memory has a finite number of states, and thus any deterministic program on it must eventually either halt or repeat a previous state:</p>
<p>Minsky warns us, however, that machines such as computers with e.g., a million small parts, each with two states, will have at least 2 possible states:</p>
<p>Minsky exhorts the reader to be suspicious—although a machine may be finite, and finite automata "have a number of theoretical limitations":</p>
<p>It can also be decided automatically whether a nondeterministic machine with finite memory halts on none of, some of, or all of the possible sequences of nondeterministic decisions, by enumerating states after each possible decision.</p>
<h2>Formalization</h2>
<p>In his original proof Turing formalized the concept of <i>algorithm</i> by introducing Turing machines. However, the result is in no way specific to them; it applies equally to any other model of computation that is equivalent in its computational power to Turing machines, such as Markov algorithms, Lambda calculus, Post systems, register machines, or tag systems.</p>
<p>What is important is that the formalization allows a straightforward mapping of algorithms to some data type that the algorithm can operate upon. For example, if the formalism lets algorithms define functions over strings (such as Turing machines) then there should be a mapping of these algorithms to strings, and if the formalism lets algorithms define functions over natural numbers (such as computable functions) then there should be a mapping of algorithms to natural numbers. The mapping to strings is usually the most straightforward, but strings over an alphabet with <i>n</i> characters can also be mapped to numbers by interpreting them as numbers in an <i>n</i>-ary numeral system.</p>
<h2>Relationship with Gödel's incompleteness theorems</h2>
<p>The concepts raised by Gödel's incompleteness theorems are very similar to those raised by the halting problem, and the proofs are quite similar. In fact, a weaker form of the First Incompleteness Theorem is an easy consequence of the undecidability of the halting problem. This weaker form differs from the standard statement of the incompleteness theorem by asserting that a complete, consistent and sound axiomatization of all statements about natural numbers is unachievable. The "sound" part is the weakening: it means that we require the axiomatic system in question to prove only <i>true</i> statements about natural numbers (it's very important to observe that the statement of the standard form of Gödel's First Incompleteness Theorem is completely unconcerned with the question of truth, and only concerns formal provability).</p>
<p>The weaker form of the theorem can be proven from the undecidability of the halting problem as follows. Assume that we have a consistent and complete axiomatization of all true first-order logic statements about natural numbers. Then we can build an algorithm that enumerates all these statements. This means that there is an algorithm <i>N</i>(<i>n</i>) that, given a natural number <i>n</i>, computes a true first-order logic statement about natural numbers such that, for all the true statements, there is at least one <i>n</i> such that <i>N</i>(<i>n</i>) yields that statement. Now suppose we want to decide if the algorithm with representation <i>a</i> halts on input <i>i</i>. By using Kleene's T predicate, we can express the statement "<i>a</i> halts on input <i>i</i>" as a statement <i>H</i>(<i>a</i>, <i>i</i>) in the language of arithmetic. Since the axiomatization is complete it follows that either there is an <i>n</i> such that <i>N</i>(<i>n</i>) = <i>H</i>(<i>a</i>, <i>i</i>) or there is an <i>n'</i> such that <i>N</i>(<i>n'</i>) = ¬ <i>H</i>(<i>a</i>, <i>i</i>). So if we iterate over all <i>n</i> until we either find <i>H</i>(<i>a</i>, <i>i</i>) or its negation, we will always halt. This means that this gives us an algorithm to decide the halting problem. Since we know that there cannot be such an algorithm, it follows that the assumption that there is a consistent and complete axiomatization of all true first-order logic statements about natural numbers must be false.</p>
<h2>Recognizing partial solutions</h2>
<p>There are many programs that either return a correct answer to the halting problem or do not return an answer at all. If it were possible to decide whether any given program gives only correct answers, one might hope to collect a large number of such programs and run them in parallel and determine whether any programs halt. Curiously, deciding whether a program is a partial halting solver (PHS) is as hard as the halting problem itself.</p>
<p>Suppose it's possible to decide whether any given program is a partial halting solver. Then there exists a partial halting solver recognizer, PHSR, guaranteed to terminate with an answer. Construct a program H:</p>
<p>WHATSON? 3b8c244b-48cf-48a4-b3a4-7e60aa207f1d</p>
<pre>
input a program P
X := "input Q. <b>if</b> Q = P output 'halts' <b>else</b> loop forever"
run PHSR with X as input
</pre>
<p>By construction, program H is also guaranteed to terminate with an answer. If PHSR recognizes the constructed program X as a partial halting solver, that means that P, the only input for which X produces a result, halts. If PHSR fails to recognize X, then it must be because P does not halt. Therefore H can decide whether an arbitrary program P halts; it solves the halting problem. Since this is impossible, then the program PHSR could not have existed as supposed. Therefore, it's not possible to decide whether any given program is a partial halting solver.</p>
<h2>History</h2>
<ul>
<li>1900: David Hilbert poses his "23 questions" (now known as Hilbert's problems) at the Second International Congress of Mathematicians in Paris. "Of these, the second was that of proving the consistency of the 'Peano axioms' on which, as he had shown, the rigour of mathematics depended". (Hodges p. 83, Davis' commentary in Davis, 1965, p. 108)</li>
<li>1920–1921: Emil Post explores the halting problem for tag systems, regarding it as a candidate for unsolvability. (<i>Absolutely unsolvable problems and relatively undecidable propositions – account of an anticipation</i>, in Davis, 1965, pp. 340–433.) Its unsolvability was not established until much later, by Marvin Minsky (1967).</li>
<li>1928: Hilbert recasts his 'Second Problem' at the Bologna International Congress. (Reid pp. 188–189) Hodges claims he posed three questions: i.e. #1: Was mathematics <i>complete</i>? #2: Was mathematics <i>consistent</i>? #3: Was mathematics <i>decidable</i>? (Hodges p. 91). The third question is known as the <i>Entscheidungsproblem</i> (Decision Problem). (Hodges p. 91, Penrose p. 34)</li>
<li>1930: Kurt Gödel announces a proof as an answer to the first two of Hilbert's 1928 questions [cf Reid p. 198]. "At first he [Hilbert] was only angry and frustrated, but then he began to try to deal constructively with the problem... Gödel himself felt—and expressed the thought in his paper—that his work did not contradict Hilbert's formalistic point of view" (Reid p. 199)</li>
<li>1931: Gödel publishes "On Formally Undecidable Propositions of Principia Mathematica and Related Systems I", (reprinted in Davis, 1965, p. 5ff)</li>
<li>19 April 1935: Alonzo Church publishes "An Unsolvable Problem of Elementary Number Theory", wherein he identifies what it means for a function to be <i>effectively calculable</i>. Such a function will have an algorithm, and "...the fact that the algorithm has terminated becomes effectively known ..." (Davis, 1965, p. 100)</li>
<li>1936: Church publishes the first proof that the <i>Entscheidungsproblem</i> is unsolvable. (<i>A Note on the Entscheidungsproblem</i>, reprinted in Davis, 1965, p. 110.)</li>
<li>7 October 1936: Emil Post's paper "Finite Combinatory Processes. Formulation I" is received. Post adds to his "process" an instruction "(C) Stop". He called such a process "type 1 ... if the process it determines terminates for each specific problem." (Davis, 1965, p. 289ff)</li>
<li>1937: Alan Turing's paper <i>On Computable Numbers With an Application to the Entscheidungsproblem</i> reaches print in January 1937 (reprinted in Davis, 1965, p. 115). Turing's proof departs from calculation by recursive functions and introduces the notion of computation by machine. Stephen Kleene (1952) refers to this as one of the "first examples of decision problems proved unsolvable".</li>
<li>1939: J. Barkley Rosser observes the essential equivalence of "effective method" defined by Gödel, Church, and Turing (Rosser in Davis, 1965, p. 273, "Informal Exposition of Proofs of Gödel's Theorem and Church's Theorem")</li>
<li>1943: In a paper, Stephen Kleene states that "In setting up a complete algorithmic theory, what we do is describe a procedure ... which procedure necessarily terminates and in such manner that from the outcome we can read a definite answer, 'Yes' or 'No,' to the question, 'Is the predicate value true?'."</li>
<li>1952: Kleene (1952) Chapter XIII ("Computable Functions") includes a discussion of the unsolvability of the halting problem for Turing machines and reformulates it in terms of machines that "eventually stop", i.e. halt: "... there is no algorithm for deciding whether any given machine, when started from any given situation, <i>eventually <b>stops</b></i>." (Kleene (1952) p. 382)</li>
<li>1952: "Martin Davis thinks it likely that he first used the term 'halting problem' in a series of lectures that he gave at the Control Systems Laboratory at the University of Illinois in 1952 (letter from Davis to Copeland, 12 December 2001)." (Footnote 61 in Copeland (2004) pp. 40ff)</li>
</ul>
<h2>Avoiding the halting problem</h2>
<p>In many practical situations, programmers try to avoid infinite loops -- they want every subroutine to finish (halt). In particular, in hard real-time computing, programmers attempt to write subroutines that are not only guaranteed to finish (halt), but are guaranteed to finish before the given deadline.</p>
<p>Sometimes these programmers use some general-purpose (Turing-complete) programming language, but attempt to write in a restricted style -- such as MISRA C -- that makes it easy to prove that the resulting subroutines finish before the given deadline.</p>
<p>Other times these programmers apply the rule of least power -- they deliberately use a computer language that is not quite fully Turing-complete, often a language that guarantees that all subroutines are guaranteed to finish, such as Coq.</p>
<h2>See also</h2>
<ul>
<li>Busy beaver</li>
<li>Generic-case complexity</li>
<li>Geoffrey K. Pullum</li>
<li>Gödel's incompleteness theorem</li>
<li>P versus NP problem</li>
<li>Termination analysis</li>
<li>Worst-case execution time</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> In none of his work did Turing use the word "halting" or "termination". Turing's biographer Hodges does not have the word "halting" or words "halting problem" in his index. The earliest known use of the words "halting problem" is in a proof by Davis (1958, p. 70–71):
<dl>
<dd>"Theorem 2.2 <i>There exists a Turing machine whose halting problem is recursively unsolvable</i>.</dd>
<dd>"A related problem is the <i>printing problem</i> for a simple Turing machine Z with respect to a symbol S<sub>i</sub>".</dd>
</dl>
Davis adds no attribution for his proof, so one infers that it is original with him. But Davis has pointed out that a statement of the proof exists informally in Kleene (1952, p. 382). Copeland (2004, p 40) states that:
<dl>
<dd>"The halting problem was so named (and it appears, first stated) by Martin Davis [cf Copeland footnote 61]... (It is often said that Turing stated and proved the halting theorem in 'On Computable Numbers', but strictly this is not true)."</dd>
</dl>
</li>
<li>^   Moore, Cristopher; Mertens, Stephan (2011), <i>The Nature of Computation</i>, Oxford University Press, pp. 236–237, ISBN 9780191620805 .</li>
</ol>
</body>
</html>