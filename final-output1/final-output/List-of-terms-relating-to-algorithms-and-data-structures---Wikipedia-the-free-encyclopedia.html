<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>List-of-terms-relating-to-algorithms-and-data-structures---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>List of terms relating to algorithms and data structures</h1>
<p>The NIST Dictionary of Algorithms and Data Structures is a reference work maintained by the U.S. National Institute of Standards and Technology. It defines a large number of <b>terms relating to algorithms and data structures</b>. For algorithms and data structures not necessarily mentioned here, see list of algorithms and list of data structures.</p>
<p>This list of terms was originally derived from the index of that document, and is in the public domain, as it was compiled by a Federal Government employee as part of a Federal Government work. Some of the terms defined are:</p>
<p><br></p>
<ul>
<li>Top</li>
<li>0–9</li>
<li>A</li>
<li>B</li>
<li>C</li>
<li>D</li>
<li>E</li>
<li>F</li>
<li>G</li>
<li>H</li>
<li>I</li>
<li>J</li>
<li>K</li>
<li>L</li>
<li>M</li>
<li>N</li>
<li>O</li>
<li>P</li>
<li>Q</li>
<li>R</li>
<li>S</li>
<li>T</li>
<li>U</li>
<li>V</li>
<li>W</li>
<li>X</li>
<li>Y</li>
<li>Z</li>
</ul>
<h2>A</h2>
<ul>
<li>absolute performance guarantee</li>
<li>abstract data type (ADT)</li>
<li>(a,b)-tree</li>
<li>accepting state</li>
<li>Ackermann's function</li>
<li>active data structure</li>
<li>acyclic directed graph</li>
<li>adaptive heap sort</li>
<li>adaptive Huffman coding</li>
<li>adaptive k-d tree</li>
<li>adaptive sort</li>
<li>address-calculation sort</li>
<li>adjacency-list representation</li>
<li>adjacency-matrix representation</li>
<li>adversary</li>
<li>algorithm</li>
<li>algorithm BSTW</li>
<li>algorithm FGK</li>
<li>algorithmic efficiency</li>
<li>algorithmically solvable</li>
<li>algorithm V</li>
<li>all pairs shortest path</li>
<li>alphabet</li>
<li>Alpha Skip Search algorithm</li>
<li>alternating path</li>
<li>alternating Turing machine</li>
<li>alternation</li>
<li>American flag sort</li>
<li>amortized cost</li>
<li>ancestor</li>
<li>and</li>
<li>ANSI</li>
<li>antichain</li>
<li>antisymmetric relation</li>
<li>AP</li>
<li>Apostolico–Crochemore</li>
<li>Apostolico–Giancarlo algorithm</li>
<li>approximate string matching</li>
<li>approximation algorithm</li>
<li>arborescence</li>
<li>arithmetic coding</li>
<li>array</li>
<li>array index</li>
<li>array merging</li>
<li>array search</li>
<li>articulation point</li>
<li>assignment problem</li>
<li>association list</li>
<li>associative</li>
<li>associative array</li>
<li>asymptotically tight bound</li>
<li>asymptotic bound</li>
<li>asymptotic lower bound</li>
<li>asymptotic space complexity</li>
<li>asymptotic time complexity</li>
<li>asymptotic upper bound</li>
<li>augmenting path</li>
<li>automaton</li>
<li>average case</li>
<li>average-case cost</li>
<li>AVL tree</li>
<li>axiomatic semantics</li>
</ul>
<h2>B</h2>
<ul>
<li>backtracking</li>
<li>bag</li>
<li>Baillie-PSW primality test</li>
<li>balanced binary search tree</li>
<li>balanced binary tree</li>
<li>balanced k-way merge sort</li>
<li>balanced merge sort</li>
<li>balanced multiway merge</li>
<li>balanced multiway tree</li>
<li>balanced quicksort</li>
<li>balanced tree</li>
<li>balanced two-way merge sort</li>
<li>BANG file</li>
<li>Batcher sort</li>
<li>Baum Welch algorithm</li>
<li>BB α tree</li>
<li>BDD</li>
<li>BD-tree</li>
<li>Bellman–Ford algorithm</li>
<li>Benford's law</li>
<li>best case</li>
<li>best-case cost</li>
<li>best-first search</li>
<li>biconnected component</li>
<li>biconnected graph</li>
<li>bidirectional bubble sort</li>
<li>big-O notation</li>
<li>binary function</li>
<li>binary GCD algorithm</li>
<li>binary heap</li>
<li>binary insertion sort</li>
<li>binary knapsack problem</li>
<li>binary priority queue</li>
<li>binary relation</li>
<li>binary search</li>
<li>binary search tree</li>
<li>binary tree</li>
<li>binary tree representation of trees</li>
<li>bingo sort</li>
<li>binomial heap</li>
<li>binomial tree</li>
<li>bin packing problem</li>
<li>bin sort</li>
<li>bintree</li>
<li>bipartite graph</li>
<li>bipartite matching</li>
<li>bisector</li>
<li>bitonic sort</li>
<li>bit vector</li>
<li>Bk tree</li>
<li>block</li>
<li>block addressing index</li>
<li>blocking flow</li>
<li>block search</li>
<li>Bloom filter</li>
<li>blossom (graph theory)</li>
<li>bogosort</li>
<li>boogol</li>
<li>boolean</li>
<li>boolean expression</li>
<li>boolean function</li>
<li>bottleneck traveling salesman</li>
<li>bottom-up tree automaton</li>
<li>boundary-based representation</li>
<li>bounded error probability in polynomial time</li>
<li>bounded queue</li>
<li>bounded stack</li>
<li>Bounding volume hierarchy, also referred to as bounding volume tree (BV-tree, BVT)</li>
<li>Boyer–Moore string search algorithm</li>
<li>Boyer–Moore–Horspool algorithm</li>
<li>bozo sort</li>
<li>B+ tree</li>
<li>BPP (complexity)</li>
<li>Bradford's law</li>
<li>branch (as in control flow)</li>
<li>branch (as in revision control)</li>
<li>branch and bound</li>
<li>breadth-first search</li>
<li>Bresenham's algorithm</li>
<li>brick sort</li>
<li>bridge</li>
<li>British Museum algorithm</li>
<li>brute force attack</li>
<li>brute force search</li>
<li>brute force string search</li>
<li>brute force string search with mismatches</li>
<li>BSP-tree</li>
<li>B*-tree</li>
<li>B-tree</li>
<li>bubble sort</li>
<li>bucket</li>
<li>bucket array</li>
<li>bucketing method</li>
<li>bucket sort</li>
<li>bucket trie</li>
<li>buddy system</li>
<li>buddy tree</li>
<li>build-heap</li>
<li>Burrows–Wheeler transform (BWT)</li>
<li>busy beaver</li>
<li>Byzantine generals</li>
</ul>
<h2>C</h2>
<ul>
<li>cactus stack</li>
<li>Calculus of Communicating Systems (CCS)</li>
<li>calendar queue</li>
<li>candidate consistency testing</li>
<li>candidate verification</li>
<li>canonical complexity class</li>
<li>capacitated facility location</li>
<li>capacity</li>
<li>capacity constraint</li>
<li>cartesian tree</li>
<li>cascade merge sort</li>
<li>caverphone</li>
<li>Cayley–Purser algorithm</li>
<li>C curve</li>
<li>cell probe model</li>
<li>cell tree</li>
<li>cellular automaton</li>
<li>centroid</li>
<li>certificate</li>
<li>chain (order theory)</li>
<li>chaining (algorithm)</li>
<li>child</li>
<li>Chinese postman problem</li>
<li>Chinese remainder theorem</li>
<li>Christofides algorithm</li>
<li>Christofides heuristic</li>
<li>chromatic index</li>
<li>chromatic number</li>
<li>Church–Turing thesis</li>
<li>circuit</li>
<li>circuit complexity</li>
<li>circuit value problem</li>
<li>circular list</li>
<li>circular queue</li>
<li>clique</li>
<li>clique problem</li>
<li>clustering (see hash table)</li>
<li>clustering free</li>
<li>coalesced hashing</li>
<li>coarsening</li>
<li>cocktail shaker sort</li>
<li>codeword</li>
<li>coding tree</li>
<li>collective recursion</li>
<li>collision</li>
<li>collision resolution scheme</li>
<li>Colussi</li>
<li>combination</li>
<li>comb sort</li>
<li>Communicating Sequential Processes</li>
<li>commutative</li>
<li>compact DAWG</li>
<li>compact trie</li>
<li>comparison sort</li>
<li>competitive analysis</li>
<li>competitive ratio</li>
<li>complement</li>
<li>complete binary tree</li>
<li>complete graph</li>
<li>completely connected graph</li>
<li>complete tree</li>
<li>complexity</li>
<li>complexity class</li>
<li>computable</li>
<li>concave function</li>
<li>concurrent flow</li>
<li>concurrent read, concurrent write</li>
<li>concurrent read, exclusive write</li>
<li>configuration</li>
<li>confluently persistent data structure</li>
<li>conjunction</li>
<li>connected components</li>
<li>connected graph</li>
<li>co-NP</li>
<li>constant function</li>
<li>continuous knapsack problem</li>
<li>Cook reduction</li>
<li>Cook's theorem</li>
<li>counting sort</li>
<li>covering</li>
<li>CRCW</li>
<li>Crew (algorithm)</li>
<li>critical path problem</li>
<li>CSP (communicating sequential processes)</li>
<li>CSP (constraint satisfaction problem)</li>
<li>CTL</li>
<li>cuckoo hashing</li>
<li>cut (graph theory)</li>
<li>cut (logic programming)</li>
<li>cutting plane</li>
<li>cutting stock problem</li>
<li>cutting theorem</li>
<li>cut vertex</li>
<li>cycle</li>
<li>cycle sort</li>
<li>cyclic redundancy check (CRC)</li>
</ul>
<h2>D</h2>
<ul>
<li>D-adjacent</li>
<li>DAG shortest paths</li>
<li>Damerau–Levenshtein distance</li>
<li>data structure</li>
<li>decidable</li>
<li>decidable language</li>
<li>decimation</li>
<li>decision problem</li>
<li>decision tree</li>
<li>decomposable searching problem</li>
<li>degree</li>
<li>dense graph</li>
<li>depoissonization</li>
<li>depth</li>
<li>depth-first search (DFS)</li>
<li>deque</li>
<li>derangement</li>
<li>descendant (see tree structure)</li>
<li>deterministic</li>
<li>deterministic algorithm</li>
<li>deterministic finite automata string search</li>
<li>deterministic finite automaton (DFA)</li>
<li>deterministic finite state machine</li>
<li>deterministic finite tree automaton</li>
<li>deterministic pushdown automaton (DPDA)</li>
<li>deterministic tree automaton</li>
<li>Deutsch–Jozsa algorithm</li>
<li>DFS forest</li>
<li>DFTA</li>
<li>diagonalization argument</li>
<li>diameter</li>
<li>dichotomic search</li>
<li>dictionary</li>
<li>diet (see <i>discrete interval encoding tree</i> below)</li>
<li>difference (set theory)</li>
<li>digital search tree</li>
<li>digital tree</li>
<li>digraph</li>
<li>Dijkstra's algorithm</li>
<li>diminishing increment sort</li>
<li>dining philosophers</li>
<li>direct chaining hashing</li>
<li>directed acyclic graph (DAG)</li>
<li>directed acyclic word graph (DAWG)</li>
<li>directed graph</li>
<li>discrete interval encoding tree</li>
<li>discrete p-center</li>
<li>disjoint set</li>
<li>disjunction</li>
<li>distributed algorithm</li>
<li>distributional complexity</li>
<li>distribution sort</li>
<li>divide and conquer algorithm</li>
<li>divide and marriage before conquest</li>
<li>division method</li>
<li>Data domain</li>
<li>don't care</li>
<li>Doomsday rule</li>
<li>double-direction bubble sort</li>
<li>double-ended priority queue</li>
<li>double hashing</li>
<li>double left rotation</li>
<li>Double Metaphone</li>
<li>double right rotation</li>
<li>doubly chained tree</li>
<li>doubly ended queue</li>
<li>doubly linked list</li>
<li>Dragon curve</li>
<li>dual graph</li>
<li>dual linear program</li>
<li>Dutch national flag</li>
<li>dyadic tree</li>
<li>dynamic array</li>
<li>dynamic data structure</li>
<li>dynamic hashing</li>
<li>dynamic programming</li>
<li>dynamization transformation</li>
</ul>
<h2>E</h2>
<ul>
<li>edge</li>
<li>edge coloring</li>
<li>edge connectivity</li>
<li>edge crossing</li>
<li>edge-weighted graph</li>
<li>edit distance</li>
<li>edit operation</li>
<li>edit script</li>
<li>8 queens</li>
<li>elastic-bucket trie</li>
<li>element uniqueness</li>
<li>end-of-string</li>
<li>enfilade</li>
<li>epidemic algorithm</li>
<li>Euclidean algorithm</li>
<li>Euclidean distance</li>
<li>Euclidean Steiner tree</li>
<li>Euclidean traveling salesman problem</li>
<li>Euclid's algorithm</li>
<li>Euler cycle</li>
<li>Eulerian graph</li>
<li>Eulerian path</li>
<li>exact string matching</li>
<li>EXCELL (extendible cell)</li>
<li>exchange sort</li>
<li>exclusive or</li>
<li>exclusive read, concurrent write (ERCW)</li>
<li>exclusive read, exclusive write (EREW)</li>
<li>exhaustive search</li>
<li>existential state</li>
<li>expandable hashing</li>
<li>expander graph</li>
<li>exponential</li>
<li>extended binary tree</li>
<li>extended Euclidean algorithm</li>
<li>extended k-d tree</li>
<li>extendible hashing</li>
<li>external index</li>
<li>external memory algorithm</li>
<li>external memory data structure</li>
<li>external merge</li>
<li>external merge sort</li>
<li>external node</li>
<li>external quicksort</li>
<li>external radix sort</li>
<li>external sort</li>
<li>extrapolation search</li>
<li>extremal</li>
<li>extreme point</li>
</ul>
<h2>F</h2>
<ul>
<li>facility location</li>
<li>factor (see substring)</li>
<li>factorial</li>
<li>fast fourier transform (FFT)</li>
<li>fathoming</li>
<li>feasible region</li>
<li>feasible solution</li>
<li>feedback edge set</li>
<li>feedback vertex set</li>
<li>Ferguson–Forcade algorithm</li>
<li>Fibonacci number</li>
<li>Fibonacci search</li>
<li>Fibonacci tree</li>
<li>Fibonacci heap</li>
<li>filial-heir chain</li>
<li>Find</li>
<li>find kth least element</li>
<li>finitary tree</li>
<li>finite Fourier transform (discrete Fourier transform)</li>
<li>finite state automaton</li>
<li>finite state machine</li>
<li>finite state machine minimization</li>
<li>finite state transducer</li>
<li>first child-next sibling binary tree</li>
<li>first come, first served</li>
<li>first-in, first-out (FIFO)</li>
<li>fixed-grid method</li>
<li>flash sort</li>
<li>flow</li>
<li>flow conservation</li>
<li>flow function</li>
<li>flow network</li>
<li>Floyd–Warshall algorithm</li>
<li>Ford–Bellman algorithm</li>
<li>Ford–Fulkerson algorithm</li>
<li>forest</li>
<li>forest editing problem</li>
<li>formal language</li>
<li>formal methods</li>
<li>formal verification</li>
<li>forward index</li>
<li>fractal</li>
<li>fractional knapsack problem</li>
<li>fractional solution</li>
<li>free edge</li>
<li>free list</li>
<li>free tree</li>
<li>free vertex</li>
<li>frequency count heuristic</li>
<li>full array</li>
<li>full binary tree</li>
<li>full inverted index</li>
<li>fully dynamic graph problem</li>
<li>fully persistent data structure</li>
<li>fully polynomial approximation scheme</li>
<li>function (programming)</li>
<li>function (mathematics)</li>
<li>functional data structure</li>
</ul>
<h2>G</h2>
<ul>
<li>Galil–Giancarlo</li>
<li>Galil–Seiferas</li>
<li>gamma function</li>
<li>GBD-tree</li>
<li>geometric optimization problem</li>
<li>global optimum</li>
<li>gnome sort</li>
<li>goobi</li>
<li>graph</li>
<li>graph coloring</li>
<li>graph concentration</li>
<li>graph drawing</li>
<li>graph isomorphism</li>
<li>graph partition</li>
<li>Gray code</li>
<li>greatest common divisor (GCD)</li>
<li>greedy algorithm</li>
<li>greedy heuristic</li>
<li>grid drawing</li>
<li>grid file</li>
<li>Grover's algorithm</li>
</ul>
<h2>H</h2>
<ul>
<li>halting problem</li>
<li>Hamiltonian cycle</li>
<li>Hamiltonian path</li>
<li>Hamming distance</li>
<li>Harter–Highway dragon</li>
<li>hash function</li>
<li>hash heap</li>
<li>hash table</li>
<li>hash table delete</li>
<li>Hausdorff distance</li>
<li>hB-tree</li>
<li>head</li>
<li>heap</li>
<li>heapify</li>
<li>heap property</li>
<li>heapsort</li>
<li>heaviest common subsequence</li>
<li>height</li>
<li>height-balanced binary search tree</li>
<li>height-balanced tree</li>
<li>heuristic</li>
<li>hidden Markov model</li>
<li>highest common factor</li>
<li>Hilbert curve</li>
<li>histogram sort</li>
<li>homeomorphic</li>
<li>horizontal visibility map</li>
<li>Horner's rule</li>
<li>Horspool</li>
<li>Huffman encoding</li>
<li>Hungarian algorithm</li>
<li>hybrid algorithm</li>
<li>hyperedge</li>
<li>hypergraph</li>
</ul>
<h2>I</h2>
<ul>
<li>Identity function</li>
<li>ideal merge</li>
<li>implication</li>
<li>implies</li>
<li>in-branching</li>
<li>inclusion-exclusion principle</li>
<li>inclusive or</li>
<li>incompressible string</li>
<li>incremental algorithm</li>
<li>in-degree</li>
<li>independent set (graph theory)</li>
<li>index file</li>
<li>information theoretic bound</li>
<li>in-order traversal</li>
<li>in-place sort</li>
<li>insertion sort</li>
<li>instantaneous description</li>
<li>integer linear program</li>
<li>integer multi-commodity flow</li>
<li>integer polyhedron</li>
<li>interactive proof system</li>
<li>interior-based representation</li>
<li>internal node</li>
<li>internal sort</li>
<li>interpolation search</li>
<li>interpolation-sequential search</li>
<li>interpolation sort</li>
<li>intersection (set theory)</li>
<li>interval tree</li>
<li>intractable</li>
<li>introsort</li>
<li>introspective sort</li>
<li>inverse Ackermann function</li>
<li>inverted file index</li>
<li>inverted index</li>
<li>irreflexive</li>
<li>isomorphic</li>
<li>iteration</li>
</ul>
<h2>J</h2>
<ul>
<li>Jaro–Winkler distance</li>
<li>Johnson's algorithm</li>
<li>Johnson–Trotter algorithm</li>
<li>J sort</li>
<li>JSort</li>
<li>jump list</li>
<li>jump search</li>
</ul>
<h2>K</h2>
<ul>
<li>Karmarkar's algorithm</li>
<li>Karnaugh map</li>
<li>Karp–Rabin string search algorithm</li>
<li>Karp reduction</li>
<li>k-ary heap</li>
<li>k-ary Huffman encoding</li>
<li>k-ary tree</li>
<li>k-clustering</li>
<li>k-coloring</li>
<li>k-connected graph</li>
<li>k-d-B-tree</li>
<li>k-dimensional</li>
<li>K-dominant match</li>
<li>k-d tree</li>
<li>key</li>
<li>KMP</li>
<li>KmpSkip Search</li>
<li>knapsack problem</li>
<li>knight's tour</li>
<li>Knuth–Morris–Pratt algorithm</li>
<li>Königsberg bridges problem</li>
<li>Kolmogorov complexity</li>
<li>Kraft's inequality</li>
<li>Kripke structure</li>
<li>Kruskal's algorithm</li>
<li>kth order Fibonacci numbers</li>
<li>kth shortest path</li>
<li>kth smallest element</li>
<li>KV diagram</li>
<li>k-way merge</li>
<li>k-way merge sort</li>
<li>k-way tree</li>
</ul>
<h2>L</h2>
<ul>
<li>labeled graph</li>
<li>language</li>
<li>last-in, first-out (LIFO)</li>
<li>Las Vegas algorithm</li>
<li>lattice (group)</li>
<li>layered graph</li>
<li>LCS</li>
<li>leaf</li>
<li>least common multiple (LCM)</li>
<li>leftist tree</li>
<li>left rotation</li>
<li>Lempel–Ziv–Welch (LZW)</li>
<li>level-order traversal</li>
<li>Levenshtein distance</li>
<li>lexicographical order</li>
<li>linear</li>
<li>linear congruential generator</li>
<li>linear hash</li>
<li>linear insertion sort</li>
<li>linear order</li>
<li>linear probing</li>
<li>linear probing sort</li>
<li>linear product</li>
<li>linear program</li>
<li>linear quadtree</li>
<li>linear search</li>
<li>link</li>
<li>linked list</li>
<li>list</li>
<li>list contraction</li>
<li>little-o notation</li>
<li>Lm distance</li>
<li>load factor (computer science)</li>
<li>local alignment</li>
<li>local optimum</li>
<li>logarithm, logarithmic scale</li>
<li>longest common subsequence</li>
<li>longest common substring</li>
<li>Lotka's law</li>
<li>lower bound</li>
<li>lower triangular matrix</li>
<li>lowest common ancestor</li>
<li>l-reduction</li>
</ul>
<h2>M</h2>
<ul>
<li>Malhotra–Kumar–Maheshwari blocking flow (ru.)</li>
<li>Manhattan distance</li>
<li>many-one reduction</li>
<li>Markov chain</li>
<li>marriage problem (see assignment problem)</li>
<li>Master theorem</li>
<li>matched edge</li>
<li>matched vertex</li>
<li>matching (graph theory)</li>
<li>matrix</li>
<li>matrix-chain multiplication problem</li>
<li>max-heap property</li>
<li>maximal independent set</li>
<li>maximally connected component</li>
<li>Maximal Shift</li>
<li>maximum bipartite matching</li>
<li>maximum-flow problem</li>
<li>MAX-SNP</li>
<li>Mealy machine</li>
<li>mean</li>
<li>median</li>
<li>meld (data structures)</li>
<li>memoization</li>
<li>merge algorithm</li>
<li>merge sort</li>
<li>meromorphic function</li>
<li>metaheuristic</li>
<li>metaphone</li>
<li>midrange</li>
<li>Miller–Rabin primality test</li>
<li>min-heap property</li>
<li>minimal perfect hashing</li>
<li>minimum bounding box (MBB)</li>
<li>minimum cut</li>
<li>minimum path cover</li>
<li>minimum spanning tree</li>
<li>minimum vertex cut</li>
<li>mixed integer linear program</li>
<li>mode</li>
<li>model checking</li>
<li>model of computation</li>
<li>moderately exponential</li>
<li>MODIFIND</li>
<li>monotone priority queue</li>
<li>monotonically decreasing</li>
<li>monotonically increasing</li>
<li>Monte Carlo algorithm</li>
<li>Moore machine</li>
<li>Morris-Pratt</li>
<li>move (finite-state machine transition)</li>
<li>move-to-front heuristic</li>
<li>move-to-root heuristic</li>
<li>multi-commodity flow</li>
<li>multigraph</li>
<li>multilayer grid file</li>
<li>multiplication method</li>
<li>multiprefix</li>
<li>multiprocessor model</li>
<li>multiset</li>
<li>multi suffix tree</li>
<li>multiway decision</li>
<li>multiway merge</li>
<li>multiway search tree</li>
<li>multiway tree</li>
<li>Munkres' assignment algorithm</li>
</ul>
<h2>N</h2>
<ul>
<li>naive string search</li>
<li>nand</li>
<li>n-ary function</li>
<li>NC</li>
<li>NC many-one reducibility</li>
<li>nearest neighbor search</li>
<li>negation</li>
<li>network flow (see flow network)</li>
<li>network flow problem</li>
<li>next state</li>
<li>NIST</li>
<li>node</li>
<li>nonbalanced merge</li>
<li>nonbalanced merge sort</li>
<li>nondeterministic</li>
<li>nondeterministic algorithm</li>
<li>nondeterministic finite automaton</li>
<li>nondeterministic finite state machine (NFA)</li>
<li>nondeterministic finite tree automaton (NFTA)</li>
<li>nondeterministic polynomial time</li>
<li>nondeterministic tree automaton</li>
<li>nondeterministic Turing machine</li>
<li>nonterminal node</li>
<li>nor</li>
<li>not</li>
<li>Not So Naive</li>
<li>NP</li>
<li>NP-complete</li>
<li>NP-complete language</li>
<li>NP-hard</li>
<li>n queens</li>
<li>nullary function</li>
<li>null tree</li>
<li>NYSIIS</li>
</ul>
<h2>O</h2>
<ul>
<li>objective function</li>
<li>occurrence</li>
<li>octree</li>
<li>offline algorithm</li>
<li>offset (computer science)</li>
<li>omega</li>
<li>omicron</li>
<li>one-based indexing</li>
<li>one-dimensional</li>
<li>online algorithm</li>
<li>open addressing</li>
<li>optimal</li>
<li>optimal cost</li>
<li>optimal hashing</li>
<li>optimal merge</li>
<li>optimal mismatch</li>
<li>optimal polygon triangulation problem</li>
<li>optimal polyphase merge</li>
<li>optimal polyphase merge sort</li>
<li>optimal solution</li>
<li>optimal triangulation problem</li>
<li>optimal value</li>
<li>optimization problem</li>
<li>or</li>
<li>oracle set</li>
<li>oracle tape</li>
<li>oracle Turing machine</li>
<li>Orders of approximation</li>
<li>ordered array</li>
<li>ordered binary decision diagram (OBDD)</li>
<li>ordered linked list</li>
<li>ordered tree</li>
<li>order preserving hash</li>
<li>order preserving minimal perfect hashing</li>
<li>oriented acyclic graph</li>
<li>oriented graph</li>
<li>oriented tree</li>
<li>orthogonal drawing</li>
<li>orthogonal lists</li>
<li>orthogonally convex rectilinear polygon</li>
<li>oscillating merge sort</li>
<li>out-branching</li>
<li>out-degree</li>
<li>overlapping subproblems</li>
</ul>
<h2>P</h2>
<ul>
<li>packing (see set packing)</li>
<li>padding argument</li>
<li>pagoda</li>
<li>pairing heap</li>
<li>PAM (point access method)</li>
<li>parallel computation thesis</li>
<li>parallel prefix computation</li>
<li>Parallel Random Access Machine (PRAM)</li>
<li>parametric searching</li>
<li>parent</li>
<li>partial function</li>
<li>partially decidable problem</li>
<li>partially dynamic graph problem</li>
<li>partially ordered set</li>
<li>partially persistent data structure</li>
<li>partial order</li>
<li>partial recursive function</li>
<li>partition (set theory)</li>
<li>passive data structure</li>
<li>patience sorting</li>
<li>path (graph theory)</li>
<li>path cover</li>
<li>path system problem</li>
<li>Patricia tree</li>
<li>pattern</li>
<li>pattern element</li>
<li>P-complete</li>
<li>PCP</li>
<li>Peano curve</li>
<li>Pearson's hash</li>
<li>perfect binary tree</li>
<li>perfect hashing</li>
<li>perfect k-ary tree</li>
<li>perfect matching</li>
<li>perfect shuffle</li>
<li>performance guarantee</li>
<li>performance ratio</li>
<li>permutation</li>
<li>persistent data structure</li>
<li>phonetic coding</li>
<li>pile (data structure)</li>
<li>pipelined divide and conquer</li>
<li>planar graph</li>
<li>planarization</li>
<li>planar straight-line graph</li>
<li>PLOP-hashing</li>
<li>point access method</li>
<li>pointer jumping</li>
<li>pointer machine</li>
<li>poissonization</li>
<li>polychotomy</li>
<li>polyhedron</li>
<li>polylogarithmic</li>
<li>polynomial</li>
<li>polynomial-time approximation scheme (PTAS)</li>
<li>polynomial hierarchy</li>
<li>polynomial time</li>
<li>polynomial-time Church–Turing thesis</li>
<li>polynomial-time reduction</li>
<li>polyphase merge</li>
<li>polyphase merge sort</li>
<li>polytope</li>
<li>poset</li>
<li>postfix traversal</li>
<li>Post machine (see Post–Turing machine)</li>
<li>postman's sort</li>
<li>postorder traversal</li>
<li>Post's correspondence problem</li>
<li>potential function (see potential method)</li>
<li>predicate</li>
<li>prefix</li>
<li>prefix code</li>
<li>prefix computation</li>
<li>prefix sum</li>
<li>prefix traversal</li>
<li>preorder traversal</li>
<li>primary clustering</li>
<li>primitive recursive</li>
<li>Prim's algorithm</li>
<li>principle of optimality</li>
<li>priority queue</li>
<li>prisoner's dilemma</li>
<li>PRNG</li>
<li>probabilistic algorithm</li>
<li>probabilistically checkable proof</li>
<li>probabilistic Turing machine</li>
<li>probe sequence</li>
<li>Procedure (computer science)</li>
<li>process algebra</li>
<li>proper (see proper subset)</li>
<li>proper binary tree</li>
<li>proper coloring</li>
<li>proper subset</li>
<li>property list</li>
<li>prune and search</li>
<li>pseudo-random number generator</li>
<li>pth order Fibonacci numbers</li>
<li>P-tree</li>
<li>purely functional language</li>
<li>pushdown automaton (PDA)</li>
<li>pushdown transducer</li>
<li>p-way merge sort</li>
</ul>
<h2>Q</h2>
<ul>
<li>qm sort</li>
<li>q sort</li>
<li>quadratic probing</li>
<li>quadtree</li>
<li>quadtree complexity theorem</li>
<li>quad trie</li>
<li>quantum computation</li>
<li>queue</li>
<li>quick search</li>
<li>quicksort</li>
</ul>
<h2>R</h2>
<ul>
<li>Rabin–Karp string search algorithm</li>
<li>radix quicksort</li>
<li>radix sort</li>
<li>ragged matrix</li>
<li>Raita algorithm</li>
<li>random access machine</li>
<li>random number generation</li>
<li>randomization</li>
<li>randomized algorithm</li>
<li>randomized binary search tree</li>
<li>randomized complexity</li>
<li>randomized polynomial time</li>
<li>randomized rounding</li>
<li>randomized search tree</li>
<li>Randomized-Select</li>
<li>random number generator</li>
<li>random sampling</li>
<li>range (function)</li>
<li>range sort</li>
<li>Rank (graph theory)</li>
<li>Ratcliff/Obershelp pattern recognition</li>
<li>reachable</li>
<li>rebalance</li>
<li>recognizer</li>
<li>rectangular matrix</li>
<li>rectilinear</li>
<li>rectilinear Steiner tree</li>
<li>recurrence equations</li>
<li>recurrence relation</li>
<li>recursion</li>
<li>recursion termination</li>
<li>recursion tree</li>
<li>recursive (computer science)</li>
<li>recursive data structure</li>
<li>recursive doubling</li>
<li>recursive language</li>
<li>recursively enumerable language</li>
<li>recursively solvable</li>
<li>red-black tree</li>
<li>reduced basis</li>
<li>reduced digraph</li>
<li>reduced ordered binary decision diagram (ROBDD)</li>
<li>reduction</li>
<li>reflexive relation</li>
<li>regular decomposition</li>
<li>rehashing</li>
<li>relation (mathematics)</li>
<li>relational structure</li>
<li>relative performance guarantee</li>
<li>relaxation</li>
<li>relaxed balance</li>
<li>rescalable</li>
<li>restricted universe sort</li>
<li>result cache</li>
<li>Reverse Colussi</li>
<li>Reverse Factor</li>
<li>R-file</li>
<li>Rice's method</li>
<li>right rotation</li>
<li>right-threaded tree</li>
<li>root</li>
<li>root balance</li>
<li>rooted tree</li>
<li>rotate left</li>
<li>rotate right</li>
<li>rotation</li>
<li>rough graph</li>
<li>RP</li>
<li>R+-tree</li>
<li>R*-tree</li>
<li>R-tree</li>
<li>run time</li>
</ul>
<h2>S</h2>
<ul>
<li>saguaro stack</li>
<li>saturated edge</li>
<li>SBB tree</li>
<li>scan</li>
<li>scapegoat tree</li>
<li>search algorithm</li>
<li>search tree</li>
<li>search tree property</li>
<li>secant search</li>
<li>secondary clustering</li>
<li>memory segment</li>
<li>Select algorithm</li>
<li>select and partition</li>
<li>selection problem</li>
<li>selection sort</li>
<li>select kth element</li>
<li>select mode</li>
<li>self-loop</li>
<li>self-organizing heuristic</li>
<li>self-organizing list</li>
<li>self-organizing sequential search</li>
<li>semidefinite programming</li>
<li>separate chaining hashing</li>
<li>separation theorem</li>
<li>sequential search</li>
<li>Set (computer science)</li>
<li>set cover</li>
<li>set packing</li>
<li>shadow heap</li>
<li>shadow merge</li>
<li>shadow merge insert</li>
<li>shaker sort</li>
<li>Shannon–Fano coding</li>
<li>shared memory</li>
<li>Shell sort</li>
<li>Shift-Or</li>
<li>Shor's algorithm</li>
<li>shortcutting</li>
<li>shortest common supersequence</li>
<li>shortest common superstring</li>
<li>shortest path</li>
<li>shortest spanning tree</li>
<li>shuffle</li>
<li>shuffle sort</li>
<li>sibling</li>
<li>Sierpiński curve</li>
<li>Sierpinski triangle</li>
<li>sieve of Eratosthenes</li>
<li>sift up</li>
<li>signature</li>
<li>Simon's algorithm</li>
<li>simple merge</li>
<li>simple path</li>
<li>simple uniform hashing</li>
<li>simplex communication</li>
<li>simulated annealing</li>
<li>simulation theorem</li>
<li>single-destination shortest-path problem</li>
<li>single-pair shortest-path problem</li>
<li>single program multiple data</li>
<li>single-source shortest-path problem</li>
<li>singly linked list</li>
<li>singularity analysis</li>
<li>sink</li>
<li>sinking sort</li>
<li>skd-tree</li>
<li>skew symmetry</li>
<li>skip list</li>
<li>skip search</li>
<li>slope selection</li>
<li>Smith algorithm</li>
<li>Smith–Waterman algorithm</li>
<li>smoothsort</li>
<li>solvable problem</li>
<li>sort algorithm</li>
<li>sorted array</li>
<li>sorted list</li>
<li>sort in place</li>
<li>sort merge</li>
<li>soundex</li>
<li>space-constructible function</li>
<li>spanning tree</li>
<li>sparse graph</li>
<li>sparse matrix</li>
<li>sparsification</li>
<li>sparsity</li>
<li>spatial access method</li>
<li>spectral test</li>
<li>splay tree</li>
<li>SPMD</li>
<li>square matrix</li>
<li>square root</li>
<li>SST (shortest spanning tree)</li>
<li>stable</li>
<li>stack (data structure)</li>
<li>stack tree</li>
<li>star-shaped polygon</li>
<li>start state</li>
<li>state</li>
<li>state machine</li>
<li>state transition</li>
<li>static data structure</li>
<li>static Huffman encoding</li>
<li>s-t cut</li>
<li>st-digraph</li>
<li>Steiner minimum tree</li>
<li>Steiner point</li>
<li>Steiner ratio</li>
<li>Steiner tree</li>
<li>Steiner vertex</li>
<li>Steinhaus–Johnson–Trotter algorithm</li>
<li>Stirling's approximation</li>
<li>Stirling's formula</li>
<li>stooge sort</li>
<li>straight-line drawing</li>
<li>strand sort</li>
<li>strictly decreasing</li>
<li>strictly increasing</li>
<li>strictly lower triangular matrix</li>
<li>strictly upper triangular matrix</li>
<li>string</li>
<li>string editing problem</li>
<li>string matching</li>
<li>string matching on ordered alphabets</li>
<li>string matching with errors</li>
<li>string matching with mismatches</li>
<li>string searching</li>
<li>strip packing</li>
<li>strongly connected component</li>
<li>strongly connected graph</li>
<li>strongly NP-hard</li>
<li>subadditive ergodic theorem</li>
<li>subgraph isomorphism</li>
<li>sublinear time algorithm</li>
<li>subsequence</li>
<li>subset</li>
<li>substring</li>
<li>subtree</li>
<li>suffix</li>
<li>suffix array</li>
<li>suffix automaton</li>
<li>suffix tree</li>
<li>superimposed code</li>
<li>superset</li>
<li>supersink</li>
<li>supersource</li>
<li>symmetric relation</li>
<li>symmetrically linked list</li>
<li>symmetric binary B-tree</li>
<li>symmetric set difference</li>
<li>symmetry breaking</li>
<li>symmetric min max heap</li>
</ul>
<h2>T</h2>
<ul>
<li>tail</li>
<li>tail recursion</li>
<li>target</li>
<li>temporal logic</li>
<li>terminal (see Steiner tree)</li>
<li>terminal node</li>
<li>ternary search</li>
<li>ternary search tree (TST)</li>
<li>text searching</li>
<li>theta</li>
<li>threaded binary tree</li>
<li>threaded tree</li>
<li>three-dimensional</li>
<li>three-way merge sort</li>
<li>three-way radix quicksort</li>
<li>time-constructible function</li>
<li>time/space complexity</li>
<li>top-down radix sort</li>
<li>top-down tree automaton</li>
<li>top-node</li>
<li>topological order</li>
<li>topological sort</li>
<li>topology tree</li>
<li>total function</li>
<li>totally decidable language</li>
<li>totally decidable problem</li>
<li>totally undecidable problem</li>
<li>total order</li>
<li>tour</li>
<li>tournament</li>
<li>towers of Hanoi</li>
<li>tractable problem</li>
<li>transducer</li>
<li>transition (see finite-state machine)</li>
<li>transition function (of a finite-state machine or Turing machine)</li>
<li>transitive relation</li>
<li>transitive closure</li>
<li>transitive reduction</li>
<li>transpose sequential search</li>
<li>travelling salesman problem (TSP)</li>
<li>treap</li>
<li>tree</li>
<li>tree automaton</li>
<li>tree contraction</li>
<li>tree editing problem</li>
<li>tree sort</li>
<li>tree transducer</li>
<li>tree traversal</li>
<li>triangle inequality</li>
<li>triconnected graph</li>
<li>trie</li>
<li>trinary function</li>
<li>tripartition</li>
<li>Turbo-BM</li>
<li>Turbo Reverse Factor</li>
<li>Turing machine</li>
<li>Turing reduction</li>
<li>Turing transducer</li>
<li>twin grid file</li>
<li>two-dimensional</li>
<li>two-level grid file</li>
<li>2-3-4 tree</li>
<li>2-3 tree</li>
<li>Two Way algorithm</li>
<li>two-way linked list</li>
<li>two-way merge sort</li>
</ul>
<h2>U</h2>
<ul>
<li>unary function</li>
<li>unbounded knapsack problem (UKP)</li>
<li>uncomputable function</li>
<li>uncomputable problem</li>
<li>undecidable language</li>
<li>undecidable problem</li>
<li>undirected graph</li>
<li>uniform circuit complexity</li>
<li>uniform circuit family</li>
<li>uniform hashing</li>
<li>uniform matrix</li>
<li>union</li>
<li>union of automata</li>
<li>universal hashing</li>
<li>universal state</li>
<li>universal Turing machine</li>
<li>universe</li>
<li>unsolvable problem</li>
<li>unsorted list</li>
<li>upper triangular matrix</li>
</ul>
<h2>V</h2>
<ul>
<li>van Emde Boas priority queue</li>
<li>vehicle routing problem</li>
<li>Veitch diagram</li>
<li>Venn diagram</li>
<li>vertex</li>
<li>vertex coloring</li>
<li>vertex connectivity</li>
<li>vertex cover</li>
<li>vertical visibility map</li>
<li>virtual hashing</li>
<li>visibility map</li>
<li>visible (geometry)</li>
<li>Viterbi algorithm</li>
<li>VP-tree</li>
<li>VRP (vehicle routing problem)</li>
</ul>
<h2>W</h2>
<ul>
<li>walk</li>
<li>weak cluster</li>
<li>weak-heap</li>
<li>weak-heap sort</li>
<li>weight-balanced tree</li>
<li>weighted, directed graph</li>
<li>weighted graph</li>
<li>window</li>
<li>witness</li>
<li>work-depth model</li>
<li>work-efficient</li>
<li>work-preserving</li>
<li>worst case</li>
<li>worst-case cost</li>
<li>worst-case minimum access</li>
</ul>
<h2>X</h2>
<ul>
<li>xor</li>
</ul>
<h2>Y</h2>
<ul>
<li>Yule–Simon distribution</li>
</ul>
<h2>Z</h2>
<ul>
<li>Zeller's congruence</li>
<li>0-ary function</li>
<li>0-based indexing</li>
<li>0/1 knapsack problem</li>
<li>Zhu–Takaoka string matching algorithm</li>
<li>Zipfian distribution</li>
<li>Zipf's law</li>
<li>Zipper (data structure)</li>
<li>ZPP</li>
</ul>
<h1>List of terms relating to algorithms and data structures</h1>
<p>The NIST Dictionary of Algorithms and Data Structures is a reference work maintained by the U.S. National Institute of Standards and Technology. It defines a large number of <b>terms relating to algorithms and data structures</b>. For algorithms and data structures not necessarily mentioned here, see list of algorithms and list of data structures.</p>
<p>This list of terms was originally derived from the index of that document, and is in the public domain, as it was compiled by a Federal Government employee as part of a Federal Government work. Some of the terms defined are:</p>
<p><br></p>
<ul>
<li>Top</li>
<li>0–9</li>
<li>A</li>
<li>B</li>
<li>C</li>
<li>D</li>
<li>E</li>
<li>F</li>
<li>G</li>
<li>H</li>
<li>I</li>
<li>J</li>
<li>K</li>
<li>L</li>
<li>M</li>
<li>N</li>
<li>O</li>
<li>P</li>
<li>Q</li>
<li>R</li>
<li>S</li>
<li>T</li>
<li>U</li>
<li>V</li>
<li>W</li>
<li>X</li>
<li>Y</li>
<li>Z</li>
</ul>
<h2>A</h2>
<ul>
<li>absolute performance guarantee</li>
<li>abstract data type (ADT)</li>
<li>(a,b)-tree</li>
<li>accepting state</li>
<li>Ackermann's function</li>
<li>active data structure</li>
<li>acyclic directed graph</li>
<li>adaptive heap sort</li>
<li>adaptive Huffman coding</li>
<li>adaptive k-d tree</li>
<li>adaptive sort</li>
<li>address-calculation sort</li>
<li>adjacency-list representation</li>
<li>adjacency-matrix representation</li>
<li>adversary</li>
<li>algorithm</li>
<li>algorithm BSTW</li>
<li>algorithm FGK</li>
<li>algorithmic efficiency</li>
<li>algorithmically solvable</li>
<li>algorithm V</li>
<li>all pairs shortest path</li>
<li>alphabet</li>
<li>Alpha Skip Search algorithm</li>
<li>alternating path</li>
<li>alternating Turing machine</li>
<li>alternation</li>
<li>American flag sort</li>
<li>amortized cost</li>
<li>ancestor</li>
<li>and</li>
<li>ANSI</li>
<li>antichain</li>
<li>antisymmetric relation</li>
<li>AP</li>
<li>Apostolico–Crochemore</li>
<li>Apostolico–Giancarlo algorithm</li>
<li>approximate string matching</li>
<li>approximation algorithm</li>
<li>arborescence</li>
<li>arithmetic coding</li>
<li>array</li>
<li>array index</li>
<li>array merging</li>
<li>array search</li>
<li>articulation point</li>
<li>assignment problem</li>
<li>association list</li>
<li>associative</li>
<li>associative array</li>
<li>asymptotically tight bound</li>
<li>asymptotic bound</li>
<li>asymptotic lower bound</li>
<li>asymptotic space complexity</li>
<li>asymptotic time complexity</li>
<li>asymptotic upper bound</li>
<li>augmenting path</li>
<li>automaton</li>
<li>average case</li>
<li>average-case cost</li>
<li>AVL tree</li>
<li>axiomatic semantics</li>
</ul>
<h2>B</h2>
<ul>
<li>backtracking</li>
<li>bag</li>
<li>Baillie-PSW primality test</li>
<li>balanced binary search tree</li>
<li>balanced binary tree</li>
<li>balanced k-way merge sort</li>
<li>balanced merge sort</li>
<li>balanced multiway merge</li>
<li>balanced multiway tree</li>
<li>balanced quicksort</li>
<li>balanced tree</li>
<li>balanced two-way merge sort</li>
<li>BANG file</li>
<li>Batcher sort</li>
<li>Baum Welch algorithm</li>
<li>BB α tree</li>
<li>BDD</li>
<li>BD-tree</li>
<li>Bellman–Ford algorithm</li>
<li>Benford's law</li>
<li>best case</li>
<li>best-case cost</li>
<li>best-first search</li>
<li>biconnected component</li>
<li>biconnected graph</li>
<li>bidirectional bubble sort</li>
<li>big-O notation</li>
<li>binary function</li>
<li>binary GCD algorithm</li>
<li>binary heap</li>
<li>binary insertion sort</li>
<li>binary knapsack problem</li>
<li>binary priority queue</li>
<li>binary relation</li>
<li>binary search</li>
<li>binary search tree</li>
<li>binary tree</li>
<li>binary tree representation of trees</li>
<li>bingo sort</li>
<li>binomial heap</li>
<li>binomial tree</li>
<li>bin packing problem</li>
<li>bin sort</li>
<li>bintree</li>
<li>bipartite graph</li>
<li>bipartite matching</li>
<li>bisector</li>
<li>bitonic sort</li>
<li>bit vector</li>
<li>Bk tree</li>
<li>block</li>
<li>block addressing index</li>
<li>blocking flow</li>
<li>block search</li>
<li>Bloom filter</li>
<li>blossom (graph theory)</li>
<li>bogosort</li>
<li>boogol</li>
<li>boolean</li>
<li>boolean expression</li>
<li>boolean function</li>
<li>bottleneck traveling salesman</li>
<li>bottom-up tree automaton</li>
<li>boundary-based representation</li>
<li>bounded error probability in polynomial time</li>
<li>bounded queue</li>
<li>bounded stack</li>
<li>Bounding volume hierarchy, also referred to as bounding volume tree (BV-tree, BVT)</li>
<li>Boyer–Moore string search algorithm</li>
<li>Boyer–Moore–Horspool algorithm</li>
<li>bozo sort</li>
<li>B+ tree</li>
<li>BPP (complexity)</li>
<li>Bradford's law</li>
<li>branch (as in control flow)</li>
<li>branch (as in revision control)</li>
<li>branch and bound</li>
<li>breadth-first search</li>
<li>Bresenham's algorithm</li>
<li>brick sort</li>
<li>bridge</li>
<li>British Museum algorithm</li>
<li>brute force attack</li>
<li>brute force search</li>
<li>brute force string search</li>
<li>brute force string search with mismatches</li>
<li>BSP-tree</li>
<li>B*-tree</li>
<li>B-tree</li>
<li>bubble sort</li>
<li>bucket</li>
<li>bucket array</li>
<li>bucketing method</li>
<li>bucket sort</li>
<li>bucket trie</li>
<li>buddy system</li>
<li>buddy tree</li>
<li>build-heap</li>
<li>Burrows–Wheeler transform (BWT)</li>
<li>busy beaver</li>
<li>Byzantine generals</li>
</ul>
<h2>C</h2>
<ul>
<li>cactus stack</li>
<li>Calculus of Communicating Systems (CCS)</li>
<li>calendar queue</li>
<li>candidate consistency testing</li>
<li>candidate verification</li>
<li>canonical complexity class</li>
<li>capacitated facility location</li>
<li>capacity</li>
<li>capacity constraint</li>
<li>cartesian tree</li>
<li>cascade merge sort</li>
<li>caverphone</li>
<li>Cayley–Purser algorithm</li>
<li>C curve</li>
<li>cell probe model</li>
<li>cell tree</li>
<li>cellular automaton</li>
<li>centroid</li>
<li>certificate</li>
<li>chain (order theory)</li>
<li>chaining (algorithm)</li>
<li>child</li>
<li>Chinese postman problem</li>
<li>Chinese remainder theorem</li>
<li>Christofides algorithm</li>
<li>Christofides heuristic</li>
<li>chromatic index</li>
<li>chromatic number</li>
<li>Church–Turing thesis</li>
<li>circuit</li>
<li>circuit complexity</li>
<li>circuit value problem</li>
<li>circular list</li>
<li>circular queue</li>
<li>clique</li>
<li>clique problem</li>
<li>clustering (see hash table)</li>
<li>clustering free</li>
<li>coalesced hashing</li>
<li>coarsening</li>
<li>cocktail shaker sort</li>
<li>codeword</li>
<li>coding tree</li>
<li>collective recursion</li>
<li>collision</li>
<li>collision resolution scheme</li>
<li>Colussi</li>
<li>combination</li>
<li>comb sort</li>
<li>Communicating Sequential Processes</li>
<li>commutative</li>
<li>compact DAWG</li>
<li>compact trie</li>
<li>comparison sort</li>
<li>competitive analysis</li>
<li>competitive ratio</li>
<li>complement</li>
<li>complete binary tree</li>
<li>complete graph</li>
<li>completely connected graph</li>
<li>complete tree</li>
<li>complexity</li>
<li>complexity class</li>
<li>computable</li>
<li>concave function</li>
<li>concurrent flow</li>
<li>concurrent read, concurrent write</li>
<li>concurrent read, exclusive write</li>
<li>configuration</li>
<li>confluently persistent data structure</li>
<li>conjunction</li>
<li>connected components</li>
<li>connected graph</li>
<li>co-NP</li>
<li>constant function</li>
<li>continuous knapsack problem</li>
<li>Cook reduction</li>
<li>Cook's theorem</li>
<li>counting sort</li>
<li>covering</li>
<li>CRCW</li>
<li>Crew (algorithm)</li>
<li>critical path problem</li>
<li>CSP (communicating sequential processes)</li>
<li>CSP (constraint satisfaction problem)</li>
<li>CTL</li>
<li>cuckoo hashing</li>
<li>cut (graph theory)</li>
<li>cut (logic programming)</li>
<li>cutting plane</li>
<li>cutting stock problem</li>
<li>cutting theorem</li>
<li>cut vertex</li>
<li>cycle</li>
<li>cycle sort</li>
<li>cyclic redundancy check (CRC)</li>
</ul>
<h2>D</h2>
<ul>
<li>D-adjacent</li>
<li>DAG shortest paths</li>
<li>Damerau–Levenshtein distance</li>
<li>data structure</li>
<li>decidable</li>
<li>decidable language</li>
<li>decimation</li>
<li>decision problem</li>
<li>decision tree</li>
<li>decomposable searching problem</li>
<li>degree</li>
<li>dense graph</li>
<li>depoissonization</li>
<li>depth</li>
<li>depth-first search (DFS)</li>
<li>deque</li>
<li>derangement</li>
<li>descendant (see tree structure)</li>
<li>deterministic</li>
<li>deterministic algorithm</li>
<li>deterministic finite automata string search</li>
<li>deterministic finite automaton (DFA)</li>
<li>deterministic finite state machine</li>
<li>deterministic finite tree automaton</li>
<li>deterministic pushdown automaton (DPDA)</li>
<li>deterministic tree automaton</li>
<li>Deutsch–Jozsa algorithm</li>
<li>DFS forest</li>
<li>DFTA</li>
<li>diagonalization argument</li>
<li>diameter</li>
<li>dichotomic search</li>
<li>dictionary</li>
<li>diet (see <i>discrete interval encoding tree</i> below)</li>
<li>difference (set theory)</li>
<li>digital search tree</li>
<li>digital tree</li>
<li>digraph</li>
<li>Dijkstra's algorithm</li>
<li>diminishing increment sort</li>
<li>dining philosophers</li>
<li>direct chaining hashing</li>
<li>directed acyclic graph (DAG)</li>
<li>directed acyclic word graph (DAWG)</li>
<li>directed graph</li>
<li>discrete interval encoding tree</li>
<li>discrete p-center</li>
<li>disjoint set</li>
<li>disjunction</li>
<li>distributed algorithm</li>
<li>distributional complexity</li>
<li>distribution sort</li>
<li>divide and conquer algorithm</li>
<li>divide and marriage before conquest</li>
<li>division method</li>
<li>Data domain</li>
<li>don't care</li>
<li>Doomsday rule</li>
<li>double-direction bubble sort</li>
<li>double-ended priority queue</li>
<li>double hashing</li>
<li>double left rotation</li>
<li>Double Metaphone</li>
<li>double right rotation</li>
<li>doubly chained tree</li>
<li>doubly ended queue</li>
<li>doubly linked list</li>
<li>Dragon curve</li>
<li>dual graph</li>
<li>dual linear program</li>
<li>Dutch national flag</li>
<li>dyadic tree</li>
<li>dynamic array</li>
<li>dynamic data structure</li>
<li>dynamic hashing</li>
<li>dynamic programming</li>
<li>dynamization transformation</li>
</ul>
<h2>E</h2>
<ul>
<li>edge</li>
<li>edge coloring</li>
<li>edge connectivity</li>
<li>edge crossing</li>
<li>edge-weighted graph</li>
<li>edit distance</li>
<li>edit operation</li>
<li>edit script</li>
<li>8 queens</li>
<li>elastic-bucket trie</li>
<li>element uniqueness</li>
<li>end-of-string</li>
<li>enfilade</li>
<li>epidemic algorithm</li>
<li>Euclidean algorithm</li>
<li>Euclidean distance</li>
<li>Euclidean Steiner tree</li>
<li>Euclidean traveling salesman problem</li>
<li>Euclid's algorithm</li>
<li>Euler cycle</li>
<li>Eulerian graph</li>
<li>Eulerian path</li>
<li>exact string matching</li>
<li>EXCELL (extendible cell)</li>
<li>exchange sort</li>
<li>exclusive or</li>
<li>exclusive read, concurrent write (ERCW)</li>
<li>exclusive read, exclusive write (EREW)</li>
<li>exhaustive search</li>
<li>existential state</li>
<li>expandable hashing</li>
<li>expander graph</li>
<li>exponential</li>
<li>extended binary tree</li>
<li>extended Euclidean algorithm</li>
<li>extended k-d tree</li>
<li>extendible hashing</li>
<li>external index</li>
<li>external memory algorithm</li>
<li>external memory data structure</li>
<li>external merge</li>
<li>external merge sort</li>
<li>external node</li>
<li>external quicksort</li>
<li>external radix sort</li>
<li>external sort</li>
<li>extrapolation search</li>
<li>extremal</li>
<li>extreme point</li>
</ul>
<h2>F</h2>
<ul>
<li>facility location</li>
<li>factor (see substring)</li>
<li>factorial</li>
<li>fast fourier transform (FFT)</li>
<li>fathoming</li>
<li>feasible region</li>
<li>feasible solution</li>
<li>feedback edge set</li>
<li>feedback vertex set</li>
<li>Ferguson–Forcade algorithm</li>
<li>Fibonacci number</li>
<li>Fibonacci search</li>
<li>Fibonacci tree</li>
<li>Fibonacci heap</li>
<li>filial-heir chain</li>
<li>Find</li>
<li>find kth least element</li>
<li>finitary tree</li>
<li>finite Fourier transform (discrete Fourier transform)</li>
<li>finite state automaton</li>
<li>finite state machine</li>
<li>finite state machine minimization</li>
<li>finite state transducer</li>
<li>first child-next sibling binary tree</li>
<li>first come, first served</li>
<li>first-in, first-out (FIFO)</li>
<li>fixed-grid method</li>
<li>flash sort</li>
<li>flow</li>
<li>flow conservation</li>
<li>flow function</li>
<li>flow network</li>
<li>Floyd–Warshall algorithm</li>
<li>Ford–Bellman algorithm</li>
<li>Ford–Fulkerson algorithm</li>
<li>forest</li>
<li>forest editing problem</li>
<li>formal language</li>
<li>formal methods</li>
<li>formal verification</li>
<li>forward index</li>
<li>fractal</li>
<li>fractional knapsack problem</li>
<li>fractional solution</li>
<li>free edge</li>
<li>free list</li>
<li>free tree</li>
<li>free vertex</li>
<li>frequency count heuristic</li>
<li>full array</li>
<li>full binary tree</li>
<li>full inverted index</li>
<li>fully dynamic graph problem</li>
<li>fully persistent data structure</li>
<li>fully polynomial approximation scheme</li>
<li>function (programming)</li>
<li>function (mathematics)</li>
<li>functional data structure</li>
</ul>
<h2>G</h2>
<ul>
<li>Galil–Giancarlo</li>
<li>Galil–Seiferas</li>
<li>gamma function</li>
<li>GBD-tree</li>
<li>geometric optimization problem</li>
<li>global optimum</li>
<li>gnome sort</li>
<li>goobi</li>
<li>graph</li>
<li>graph coloring</li>
<li>graph concentration</li>
<li>graph drawing</li>
<li>graph isomorphism</li>
<li>graph partition</li>
<li>Gray code</li>
<li>greatest common divisor (GCD)</li>
<li>greedy algorithm</li>
<li>greedy heuristic</li>
<li>grid drawing</li>
<li>grid file</li>
<li>Grover's algorithm</li>
</ul>
<h2>H</h2>
<ul>
<li>halting problem</li>
<li>Hamiltonian cycle</li>
<li>Hamiltonian path</li>
<li>Hamming distance</li>
<li>Harter–Highway dragon</li>
<li>hash function</li>
<li>hash heap</li>
<li>hash table</li>
<li>hash table delete</li>
<li>Hausdorff distance</li>
<li>hB-tree</li>
<li>head</li>
<li>heap</li>
<li>heapify</li>
<li>heap property</li>
<li>heapsort</li>
<li>heaviest common subsequence</li>
<li>height</li>
<li>height-balanced binary search tree</li>
<li>height-balanced tree</li>
<li>heuristic</li>
<li>hidden Markov model</li>
<li>highest common factor</li>
<li>Hilbert curve</li>
<li>histogram sort</li>
<li>homeomorphic</li>
<li>horizontal visibility map</li>
<li>Horner's rule</li>
<li>Horspool</li>
<li>Huffman encoding</li>
<li>Hungarian algorithm</li>
<li>hybrid algorithm</li>
<li>hyperedge</li>
<li>hypergraph</li>
</ul>
<h2>I</h2>
<ul>
<li>Identity function</li>
<li>ideal merge</li>
<li>implication</li>
<li>implies</li>
<li>in-branching</li>
<li>inclusion-exclusion principle</li>
<li>inclusive or</li>
<li>incompressible string</li>
<li>incremental algorithm</li>
<li>in-degree</li>
<li>independent set (graph theory)</li>
<li>index file</li>
<li>information theoretic bound</li>
<li>in-order traversal</li>
<li>in-place sort</li>
<li>insertion sort</li>
<li>instantaneous description</li>
<li>integer linear program</li>
<li>integer multi-commodity flow</li>
<li>integer polyhedron</li>
<li>interactive proof system</li>
<li>interior-based representation</li>
<li>internal node</li>
<li>internal sort</li>
<li>interpolation search</li>
<li>interpolation-sequential search</li>
<li>interpolation sort</li>
<li>intersection (set theory)</li>
<li>interval tree</li>
<li>intractable</li>
<li>introsort</li>
<li>introspective sort</li>
<li>inverse Ackermann function</li>
<li>inverted file index</li>
<li>inverted index</li>
<li>irreflexive</li>
<li>isomorphic</li>
<li>iteration</li>
</ul>
<h2>J</h2>
<ul>
<li>Jaro–Winkler distance</li>
<li>Johnson's algorithm</li>
<li>Johnson–Trotter algorithm</li>
<li>J sort</li>
<li>JSort</li>
<li>jump list</li>
<li>jump search</li>
</ul>
<h2>K</h2>
<ul>
<li>Karmarkar's algorithm</li>
<li>Karnaugh map</li>
<li>Karp–Rabin string search algorithm</li>
<li>Karp reduction</li>
<li>k-ary heap</li>
<li>k-ary Huffman encoding</li>
<li>k-ary tree</li>
<li>k-clustering</li>
<li>k-coloring</li>
<li>k-connected graph</li>
<li>k-d-B-tree</li>
<li>k-dimensional</li>
<li>K-dominant match</li>
<li>k-d tree</li>
<li>key</li>
<li>KMP</li>
<li>KmpSkip Search</li>
<li>knapsack problem</li>
<li>knight's tour</li>
<li>Knuth–Morris–Pratt algorithm</li>
<li>Königsberg bridges problem</li>
<li>Kolmogorov complexity</li>
<li>Kraft's inequality</li>
<li>Kripke structure</li>
<li>Kruskal's algorithm</li>
<li>kth order Fibonacci numbers</li>
<li>kth shortest path</li>
<li>kth smallest element</li>
<li>KV diagram</li>
<li>k-way merge</li>
<li>k-way merge sort</li>
<li>k-way tree</li>
</ul>
<h2>L</h2>
<ul>
<li>labeled graph</li>
<li>language</li>
<li>last-in, first-out (LIFO)</li>
<li>Las Vegas algorithm</li>
<li>lattice (group)</li>
<li>layered graph</li>
<li>LCS</li>
<li>leaf</li>
<li>least common multiple (LCM)</li>
<li>leftist tree</li>
<li>left rotation</li>
<li>Lempel–Ziv–Welch (LZW)</li>
<li>level-order traversal</li>
<li>Levenshtein distance</li>
<li>lexicographical order</li>
<li>linear</li>
<li>linear congruential generator</li>
<li>linear hash</li>
<li>linear insertion sort</li>
<li>linear order</li>
<li>linear probing</li>
<li>linear probing sort</li>
<li>linear product</li>
<li>linear program</li>
<li>linear quadtree</li>
<li>linear search</li>
<li>link</li>
<li>linked list</li>
<li>list</li>
<li>list contraction</li>
<li>little-o notation</li>
<li>Lm distance</li>
<li>load factor (computer science)</li>
<li>local alignment</li>
<li>local optimum</li>
<li>logarithm, logarithmic scale</li>
<li>longest common subsequence</li>
<li>longest common substring</li>
<li>Lotka's law</li>
<li>lower bound</li>
<li>lower triangular matrix</li>
<li>lowest common ancestor</li>
<li>l-reduction</li>
</ul>
<h2>M</h2>
<ul>
<li>Malhotra–Kumar–Maheshwari blocking flow (ru.)</li>
<li>Manhattan distance</li>
<li>many-one reduction</li>
<li>Markov chain</li>
<li>marriage problem (see assignment problem)</li>
<li>Master theorem</li>
<li>matched edge</li>
<li>matched vertex</li>
<li>matching (graph theory)</li>
<li>matrix</li>
<li>matrix-chain multiplication problem</li>
<li>max-heap property</li>
<li>maximal independent set</li>
<li>maximally connected component</li>
<li>Maximal Shift</li>
<li>maximum bipartite matching</li>
<li>maximum-flow problem</li>
<li>MAX-SNP</li>
<li>Mealy machine</li>
<li>mean</li>
<li>median</li>
<li>meld (data structures)</li>
<li>memoization</li>
<li>merge algorithm</li>
<li>merge sort</li>
<li>meromorphic function</li>
<li>metaheuristic</li>
<li>metaphone</li>
<li>midrange</li>
<li>Miller–Rabin primality test</li>
<li>min-heap property</li>
<li>minimal perfect hashing</li>
<li>minimum bounding box (MBB)</li>
<li>minimum cut</li>
<li>minimum path cover</li>
<li>minimum spanning tree</li>
<li>minimum vertex cut</li>
<li>mixed integer linear program</li>
<li>mode</li>
<li>model checking</li>
<li>model of computation</li>
<li>moderately exponential</li>
<li>MODIFIND</li>
<li>monotone priority queue</li>
<li>monotonically decreasing</li>
<li>monotonically increasing</li>
<li>Monte Carlo algorithm</li>
<li>Moore machine</li>
<li>Morris-Pratt</li>
<li>move (finite-state machine transition)</li>
<li>move-to-front heuristic</li>
<li>move-to-root heuristic</li>
<li>multi-commodity flow</li>
<li>multigraph</li>
<li>multilayer grid file</li>
<li>multiplication method</li>
<li>multiprefix</li>
<li>multiprocessor model</li>
<li>multiset</li>
<li>multi suffix tree</li>
<li>multiway decision</li>
<li>multiway merge</li>
<li>multiway search tree</li>
<li>multiway tree</li>
<li>Munkres' assignment algorithm</li>
</ul>
<h2>N</h2>
<ul>
<li>naive string search</li>
<li>nand</li>
<li>n-ary function</li>
<li>NC</li>
<li>NC many-one reducibility</li>
<li>nearest neighbor search</li>
<li>negation</li>
<li>network flow (see flow network)</li>
<li>network flow problem</li>
<li>next state</li>
<li>NIST</li>
<li>node</li>
<li>nonbalanced merge</li>
<li>nonbalanced merge sort</li>
<li>nondeterministic</li>
<li>nondeterministic algorithm</li>
<li>nondeterministic finite automaton</li>
<li>nondeterministic finite state machine (NFA)</li>
<li>nondeterministic finite tree automaton (NFTA)</li>
<li>nondeterministic polynomial time</li>
<li>nondeterministic tree automaton</li>
<li>nondeterministic Turing machine</li>
<li>nonterminal node</li>
<li>nor</li>
<li>not</li>
<li>Not So Naive</li>
<li>NP</li>
<li>NP-complete</li>
<li>NP-complete language</li>
<li>NP-hard</li>
<li>n queens</li>
<li>nullary function</li>
<li>null tree</li>
<li>NYSIIS</li>
</ul>
<h2>O</h2>
<ul>
<li>objective function</li>
<li>occurrence</li>
<li>octree</li>
<li>offline algorithm</li>
<li>offset (computer science)</li>
<li>omega</li>
<li>omicron</li>
<li>one-based indexing</li>
<li>one-dimensional</li>
<li>online algorithm</li>
<li>open addressing</li>
<li>optimal</li>
<li>optimal cost</li>
<li>optimal hashing</li>
<li>optimal merge</li>
<li>optimal mismatch</li>
<li>optimal polygon triangulation problem</li>
<li>optimal polyphase merge</li>
<li>optimal polyphase merge sort</li>
<li>optimal solution</li>
<li>optimal triangulation problem</li>
<li>optimal value</li>
<li>optimization problem</li>
<li>or</li>
<li>oracle set</li>
<li>oracle tape</li>
<li>oracle Turing machine</li>
<li>Orders of approximation</li>
<li>ordered array</li>
<li>ordered binary decision diagram (OBDD)</li>
<li>ordered linked list</li>
<li>ordered tree</li>
<li>order preserving hash</li>
<li>order preserving minimal perfect hashing</li>
<li>oriented acyclic graph</li>
<li>oriented graph</li>
<li>oriented tree</li>
<li>orthogonal drawing</li>
<li>orthogonal lists</li>
<li>orthogonally convex rectilinear polygon</li>
<li>oscillating merge sort</li>
<li>out-branching</li>
<li>out-degree</li>
<li>overlapping subproblems</li>
</ul>
<h2>P</h2>
<ul>
<li>packing (see set packing)</li>
<li>padding argument</li>
<li>pagoda</li>
<li>pairing heap</li>
<li>PAM (point access method)</li>
<li>parallel computation thesis</li>
<li>parallel prefix computation</li>
<li>Parallel Random Access Machine (PRAM)</li>
<li>parametric searching</li>
<li>parent</li>
<li>partial function</li>
<li>partially decidable problem</li>
<li>partially dynamic graph problem</li>
<li>partially ordered set</li>
<li>partially persistent data structure</li>
<li>partial order</li>
<li>partial recursive function</li>
<li>partition (set theory)</li>
<li>passive data structure</li>
<li>patience sorting</li>
<li>path (graph theory)</li>
<li>path cover</li>
<li>path system problem</li>
<li>Patricia tree</li>
<li>pattern</li>
<li>pattern element</li>
<li>P-complete</li>
<li>PCP</li>
<li>Peano curve</li>
<li>Pearson's hash</li>
<li>perfect binary tree</li>
<li>perfect hashing</li>
<li>perfect k-ary tree</li>
<li>perfect matching</li>
<li>perfect shuffle</li>
<li>performance guarantee</li>
<li>performance ratio</li>
<li>permutation</li>
<li>persistent data structure</li>
<li>phonetic coding</li>
<li>pile (data structure)</li>
<li>pipelined divide and conquer</li>
<li>planar graph</li>
<li>planarization</li>
<li>planar straight-line graph</li>
<li>PLOP-hashing</li>
<li>point access method</li>
<li>pointer jumping</li>
<li>pointer machine</li>
<li>poissonization</li>
<li>polychotomy</li>
<li>polyhedron</li>
<li>polylogarithmic</li>
<li>polynomial</li>
<li>polynomial-time approximation scheme (PTAS)</li>
<li>polynomial hierarchy</li>
<li>polynomial time</li>
<li>polynomial-time Church–Turing thesis</li>
<li>polynomial-time reduction</li>
<li>polyphase merge</li>
<li>polyphase merge sort</li>
<li>polytope</li>
<li>poset</li>
<li>postfix traversal</li>
<li>Post machine (see Post–Turing machine)</li>
<li>postman's sort</li>
<li>postorder traversal</li>
<li>Post's correspondence problem</li>
<li>potential function (see potential method)</li>
<li>predicate</li>
<li>prefix</li>
<li>prefix code</li>
<li>prefix computation</li>
<li>prefix sum</li>
<li>prefix traversal</li>
<li>preorder traversal</li>
<li>primary clustering</li>
<li>primitive recursive</li>
<li>Prim's algorithm</li>
<li>principle of optimality</li>
<li>priority queue</li>
<li>prisoner's dilemma</li>
<li>PRNG</li>
<li>probabilistic algorithm</li>
<li>probabilistically checkable proof</li>
<li>probabilistic Turing machine</li>
<li>probe sequence</li>
<li>Procedure (computer science)</li>
<li>process algebra</li>
<li>proper (see proper subset)</li>
<li>proper binary tree</li>
<li>proper coloring</li>
<li>proper subset</li>
<li>property list</li>
<li>prune and search</li>
<li>pseudo-random number generator</li>
<li>pth order Fibonacci numbers</li>
<li>P-tree</li>
<li>purely functional language</li>
<li>pushdown automaton (PDA)</li>
<li>pushdown transducer</li>
<li>p-way merge sort</li>
</ul>
<h2>Q</h2>
<ul>
<li>qm sort</li>
<li>q sort</li>
<li>quadratic probing</li>
<li>quadtree</li>
<li>quadtree complexity theorem</li>
<li>quad trie</li>
<li>quantum computation</li>
<li>queue</li>
<li>quick search</li>
<li>quicksort</li>
</ul>
<h2>R</h2>
<ul>
<li>Rabin–Karp string search algorithm</li>
<li>radix quicksort</li>
<li>radix sort</li>
<li>ragged matrix</li>
<li>Raita algorithm</li>
<li>random access machine</li>
<li>random number generation</li>
<li>randomization</li>
<li>randomized algorithm</li>
<li>randomized binary search tree</li>
<li>randomized complexity</li>
<li>randomized polynomial time</li>
<li>randomized rounding</li>
<li>randomized search tree</li>
<li>Randomized-Select</li>
<li>random number generator</li>
<li>random sampling</li>
<li>range (function)</li>
<li>range sort</li>
<li>Rank (graph theory)</li>
<li>Ratcliff/Obershelp pattern recognition</li>
<li>reachable</li>
<li>rebalance</li>
<li>recognizer</li>
<li>rectangular matrix</li>
<li>rectilinear</li>
<li>rectilinear Steiner tree</li>
<li>recurrence equations</li>
<li>recurrence relation</li>
<li>recursion</li>
<li>recursion termination</li>
<li>recursion tree</li>
<li>recursive (computer science)</li>
<li>recursive data structure</li>
<li>recursive doubling</li>
<li>recursive language</li>
<li>recursively enumerable language</li>
<li>recursively solvable</li>
<li>red-black tree</li>
<li>reduced basis</li>
<li>reduced digraph</li>
<li>reduced ordered binary decision diagram (ROBDD)</li>
<li>reduction</li>
<li>reflexive relation</li>
<li>regular decomposition</li>
<li>rehashing</li>
<li>relation (mathematics)</li>
<li>relational structure</li>
<li>relative performance guarantee</li>
<li>relaxation</li>
<li>relaxed balance</li>
<li>rescalable</li>
<li>restricted universe sort</li>
<li>result cache</li>
<li>Reverse Colussi</li>
<li>Reverse Factor</li>
<li>R-file</li>
<li>Rice's method</li>
<li>right rotation</li>
<li>right-threaded tree</li>
<li>root</li>
<li>root balance</li>
<li>rooted tree</li>
<li>rotate left</li>
<li>rotate right</li>
<li>rotation</li>
<li>rough graph</li>
<li>RP</li>
<li>R+-tree</li>
<li>R*-tree</li>
<li>R-tree</li>
<li>run time</li>
</ul>
<h2>S</h2>
<ul>
<li>saguaro stack</li>
<li>saturated edge</li>
<li>SBB tree</li>
<li>scan</li>
<li>scapegoat tree</li>
<li>search algorithm</li>
<li>search tree</li>
<li>search tree property</li>
<li>secant search</li>
<li>secondary clustering</li>
<li>memory segment</li>
<li>Select algorithm</li>
<li>select and partition</li>
<li>selection problem</li>
<li>selection sort</li>
<li>select kth element</li>
<li>select mode</li>
<li>self-loop</li>
<li>self-organizing heuristic</li>
<li>self-organizing list</li>
<li>self-organizing sequential search</li>
<li>semidefinite programming</li>
<li>separate chaining hashing</li>
<li>separation theorem</li>
<li>sequential search</li>
<li>Set (computer science)</li>
<li>set cover</li>
<li>set packing</li>
<li>shadow heap</li>
<li>shadow merge</li>
<li>shadow merge insert</li>
<li>shaker sort</li>
<li>Shannon–Fano coding</li>
<li>shared memory</li>
<li>Shell sort</li>
<li>Shift-Or</li>
<li>Shor's algorithm</li>
<li>shortcutting</li>
<li>shortest common supersequence</li>
<li>shortest common superstring</li>
<li>shortest path</li>
<li>shortest spanning tree</li>
<li>shuffle</li>
<li>shuffle sort</li>
<li>sibling</li>
<li>Sierpiński curve</li>
<li>Sierpinski triangle</li>
<li>sieve of Eratosthenes</li>
<li>sift up</li>
<li>signature</li>
<li>Simon's algorithm</li>
<li>simple merge</li>
<li>simple path</li>
<li>simple uniform hashing</li>
<li>simplex communication</li>
<li>simulated annealing</li>
<li>simulation theorem</li>
<li>single-destination shortest-path problem</li>
<li>single-pair shortest-path problem</li>
<li>single program multiple data</li>
<li>single-source shortest-path problem</li>
<li>singly linked list</li>
<li>singularity analysis</li>
<li>sink</li>
<li>sinking sort</li>
<li>skd-tree</li>
<li>skew symmetry</li>
<li>skip list</li>
<li>skip search</li>
<li>slope selection</li>
<li>Smith algorithm</li>
<li>Smith–Waterman algorithm</li>
<li>smoothsort</li>
<li>solvable problem</li>
<li>sort algorithm</li>
<li>sorted array</li>
<li>sorted list</li>
<li>sort in place</li>
<li>sort merge</li>
<li>soundex</li>
<li>space-constructible function</li>
<li>spanning tree</li>
<li>sparse graph</li>
<li>sparse matrix</li>
<li>sparsification</li>
<li>sparsity</li>
<li>spatial access method</li>
<li>spectral test</li>
<li>splay tree</li>
<li>SPMD</li>
<li>square matrix</li>
<li>square root</li>
<li>SST (shortest spanning tree)</li>
<li>stable</li>
<li>stack (data structure)</li>
<li>stack tree</li>
<li>star-shaped polygon</li>
<li>start state</li>
<li>state</li>
<li>state machine</li>
<li>state transition</li>
<li>static data structure</li>
<li>static Huffman encoding</li>
<li>s-t cut</li>
<li>st-digraph</li>
<li>Steiner minimum tree</li>
<li>Steiner point</li>
<li>Steiner ratio</li>
<li>Steiner tree</li>
<li>Steiner vertex</li>
<li>Steinhaus–Johnson–Trotter algorithm</li>
<li>Stirling's approximation</li>
<li>Stirling's formula</li>
<li>stooge sort</li>
<li>straight-line drawing</li>
<li>strand sort</li>
<li>strictly decreasing</li>
<li>strictly increasing</li>
<li>strictly lower triangular matrix</li>
<li>strictly upper triangular matrix</li>
<li>string</li>
<li>string editing problem</li>
<li>string matching</li>
<li>string matching on ordered alphabets</li>
<li>string matching with errors</li>
<li>string matching with mismatches</li>
<li>string searching</li>
<li>strip packing</li>
<li>strongly connected component</li>
<li>strongly connected graph</li>
<li>strongly NP-hard</li>
<li>subadditive ergodic theorem</li>
<li>subgraph isomorphism</li>
<li>sublinear time algorithm</li>
<li>subsequence</li>
<li>subset</li>
<li>substring</li>
<li>subtree</li>
<li>suffix</li>
<li>suffix array</li>
<li>suffix automaton</li>
<li>suffix tree</li>
<li>superimposed code</li>
<li>superset</li>
<li>supersink</li>
<li>supersource</li>
<li>symmetric relation</li>
<li>symmetrically linked list</li>
<li>symmetric binary B-tree</li>
<li>symmetric set difference</li>
<li>symmetry breaking</li>
<li>symmetric min max heap</li>
</ul>
<h2>T</h2>
<ul>
<li>tail</li>
<li>tail recursion</li>
<li>target</li>
<li>temporal logic</li>
<li>terminal (see Steiner tree)</li>
<li>terminal node</li>
<li>ternary search</li>
<li>ternary search tree (TST)</li>
<li>text searching</li>
<li>theta</li>
<li>threaded binary tree</li>
<li>threaded tree</li>
<li>three-dimensional</li>
<li>three-way merge sort</li>
<li>three-way radix quicksort</li>
<li>time-constructible function</li>
<li>time/space complexity</li>
<li>top-down radix sort</li>
<li>top-down tree automaton</li>
<li>top-node</li>
<li>topological order</li>
<li>topological sort</li>
<li>topology tree</li>
<li>total function</li>
<li>totally decidable language</li>
<li>totally decidable problem</li>
<li>totally undecidable problem</li>
<li>total order</li>
<li>tour</li>
<li>tournament</li>
<li>towers of Hanoi</li>
<li>tractable problem</li>
<li>transducer</li>
<li>transition (see finite-state machine)</li>
<li>transition function (of a finite-state machine or Turing machine)</li>
<li>transitive relation</li>
<li>transitive closure</li>
<li>transitive reduction</li>
<li>transpose sequential search</li>
<li>travelling salesman problem (TSP)</li>
<li>treap</li>
<li>tree</li>
<li>tree automaton</li>
<li>tree contraction</li>
<li>tree editing problem</li>
<li>tree sort</li>
<li>tree transducer</li>
<li>tree traversal</li>
<li>triangle inequality</li>
<li>triconnected graph</li>
<li>trie</li>
<li>trinary function</li>
<li>tripartition</li>
<li>Turbo-BM</li>
<li>Turbo Reverse Factor</li>
<li>Turing machine</li>
<li>Turing reduction</li>
<li>Turing transducer</li>
<li>twin grid file</li>
<li>two-dimensional</li>
<li>two-level grid file</li>
<li>2-3-4 tree</li>
<li>2-3 tree</li>
<li>Two Way algorithm</li>
<li>two-way linked list</li>
<li>two-way merge sort</li>
</ul>
<h2>U</h2>
<ul>
<li>unary function</li>
<li>unbounded knapsack problem (UKP)</li>
<li>uncomputable function</li>
<li>uncomputable problem</li>
<li>undecidable language</li>
<li>undecidable problem</li>
<li>undirected graph</li>
<li>uniform circuit complexity</li>
<li>uniform circuit family</li>
<li>uniform hashing</li>
<li>uniform matrix</li>
<li>union</li>
<li>union of automata</li>
<li>universal hashing</li>
<li>universal state</li>
<li>universal Turing machine</li>
<li>universe</li>
<li>unsolvable problem</li>
<li>unsorted list</li>
<li>upper triangular matrix</li>
</ul>
<h2>V</h2>
<ul>
<li>van Emde Boas priority queue</li>
<li>vehicle routing problem</li>
<li>Veitch diagram</li>
<li>Venn diagram</li>
<li>vertex</li>
<li>vertex coloring</li>
<li>vertex connectivity</li>
<li>vertex cover</li>
<li>vertical visibility map</li>
<li>virtual hashing</li>
<li>visibility map</li>
<li>visible (geometry)</li>
<li>Viterbi algorithm</li>
<li>VP-tree</li>
<li>VRP (vehicle routing problem)</li>
</ul>
<h2>W</h2>
<ul>
<li>walk</li>
<li>weak cluster</li>
<li>weak-heap</li>
<li>weak-heap sort</li>
<li>weight-balanced tree</li>
<li>weighted, directed graph</li>
<li>weighted graph</li>
<li>window</li>
<li>witness</li>
<li>work-depth model</li>
<li>work-efficient</li>
<li>work-preserving</li>
<li>worst case</li>
<li>worst-case cost</li>
<li>worst-case minimum access</li>
</ul>
<h2>X</h2>
<ul>
<li>xor</li>
</ul>
<h2>Y</h2>
<ul>
<li>Yule–Simon distribution</li>
</ul>
<h2>Z</h2>
<ul>
<li>Zeller's congruence</li>
<li>0-ary function</li>
<li>0-based indexing</li>
<li>0/1 knapsack problem</li>
<li>Zhu–Takaoka string matching algorithm</li>
<li>Zipfian distribution</li>
<li>Zipf's law</li>
<li>Zipper (data structure)</li>
<li>ZPP</li>
</ul>
</body>
</html>