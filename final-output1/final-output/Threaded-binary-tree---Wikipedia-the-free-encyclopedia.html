<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Threaded-binary-tree---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Threaded binary tree</h1>
<p>A <b>threaded binary tree</b> defined as follows:</p>
<p>"A binary tree is <i>threaded</i> by making all right child pointers that would normally be null point to the inorder successor of the node (<b>if</b> it exists) , and all left child pointers that would normally be null point to the inorder predecessor of the node."</p>
<p>A threaded binary tree makes it possible to traverse the values in the binary tree via a linear traversal that is more rapid than a recursive in-order traversal. It is also possible to discover the parent of a node from a threaded binary tree, without explicit use of parent pointers or a stack, albeit slowly. This can be useful where stack space is limited, or where a stack of parent pointers is unavailable (for finding the parent pointer via DFS).</p>
<p>To see how this is possible, consider a node <i>k</i> that has a right child <i>r</i>. Then the left pointer of <i>r</i> must be either a child or a thread back to <i>k</i>. In the case that <i>r</i> has a left child, that left child must in turn have either a left child of its own or a thread back to <i>k</i>, and so on for all successive left children. So by following the chain of left pointers from <i>r</i>, we will eventually find a thread pointing back to <i>k</i>. The situation is symmetrically similar when <i>q</i> is the left child of <i>p</i>—we can follow <i>q'</i>s right children to a thread pointing ahead to <i>p</i>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Types of threaded binary trees</li>
<li>2 The array of Inorder traversal</li>
<li>3 Example</li>
<li>4 Null link</li>
<li>5 Non recursive Inorder traversal for a Threaded Binary Tree
<ul>
<li>5.1 Algorithm</li>
</ul>
</li>
<li>6 References</li>
<li>7 External links</li>
</ul>
<ul>
<li>5.1 Algorithm</li>
</ul>
<p></p>
<h2>Types of threaded binary trees</h2>
<ol>
<li>Single Threaded: each node is threaded towards <b>either<i>(right)' the in-order predecessor</i></b> <i>or'</i> successor.</li>
<li>Double threaded: each node is threaded towards <b>both<i>(left &amp; right)' the in-order predecessor</i></b> <i>and'</i> successor.</li>
</ol>
<p>In Python:</p>
<p>WHATSON? a9cf19cf-2160-431e-b519-4e5cb1eaff01</p>
<pre>
def parent(node):
    if node is node.tree.root:
        return None
    else:
        x = node
        y = node
        while True:
            if is_thread(y.right):
                p = y.right
                if p is None or p.left is not node:
                    p = x
                    while not is_thread(p.left):
                        p = p.left
                    p = p.left
                return p
            elif is_thread(x.left):
                p = x.left
                if p is None or p.right is not node:
                    p = y
                    while not is_thread(p.right):
                        p = p.right
                    p = p.right
                return p
            x = x.left
            y = y.right
</pre>
<h2>The array of Inorder traversal</h2>
<p>Threads are reference to the predecessors and successors of the node according to an inorder traversal.</p>
<p>Inorder of the threaded tree is ABCDEFGHI, the predecessor of E is D, the successor of E is F.</p>
<p><img alt="ThreadTree Inorder Array.png" src="//upload.wikimedia.org/wikipedia/commons/1/1f/ThreadTree_Inorder_Array.png" width="478" height="122" data-file-width="478" data-file-height="122"></p>
<h2>Example</h2>
<p><img alt="ThreadTree Inorder Array123456789.png" src="//upload.wikimedia.org/wikipedia/commons/2/2c/ThreadTree_Inorder_Array123456789.png" width="372" height="297" data-file-width="372" data-file-height="297"></p>
<p>Let's make the Threaded Binary tree out of a normal binary tree...</p>
<p><img alt="Normal Binary Tree.png" src="//upload.wikimedia.org/wikipedia/commons/6/6a/Normal_Binary_Tree.png" width="423" height="317" data-file-width="423" data-file-height="317"></p>
<p>The INORDER traversal for the above tree is—D B A E C. So, the respective Threaded Binary tree will be --</p>
<p><img alt="Threaded Binary Tree.png" src="//upload.wikimedia.org/wikipedia/commons/8/8b/Threaded_Binary_Tree.png" width="483" height="324" data-file-width="483" data-file-height="324"> The a=b formula was used in the late 1800s</p>
<h2>Null link</h2>
<p>An m-way threaded binary tree, there are <b>n*m - (n-1)</b> links are void in a tree with n nodes.</p>
<h2>Non recursive Inorder traversal for a Threaded Binary Tree</h2>
<p>As this is a non-recursive method for traversal, it has to be an iterative procedure; meaning, all the steps for the traversal of a node have to be under a loop so that the same can be applied to all the nodes in the tree. We will consider the INORDER traversal again. Here, for every node, we'll visit the left sub-tree (if it exists) first (if and only if we haven't visited it earlier); then we visit (i.e. print its value, in our case) the node itself and then the right sub-tree (if it exists). If the right sub-tree is not there, we check for the threaded link and make the threaded node the current node in consideration. Please, follow the example given below.</p>
<p><img alt="Threaded Binary Tree.png" src="//upload.wikimedia.org/wikipedia/commons/8/8b/Threaded_Binary_Tree.png" width="483" height="324" data-file-width="483" data-file-height="324"></p>
<h3>Algorithm</h3>
<p>Step-1: For the current node check whether it has a left child which is not there in the visited list. If it has then go to step-2 or else step-3.</p>
<p>Step-2: Put that left child in the list of visited nodes and make it your current node in consideration. Go to step-6.</p>
<p>Step-3: For the current node check whether it has a right child. If it has then go to step-4 else go to step-5</p>
<p><br></p>
</body>
</html>