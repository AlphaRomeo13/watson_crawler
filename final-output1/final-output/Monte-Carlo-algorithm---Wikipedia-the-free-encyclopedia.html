<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Monte-Carlo-algorithm---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Monte Carlo algorithm</h1>
<p>In computing, a <b>Monte Carlo algorithm</b> is a randomized algorithm whose running time is deterministic, but whose output may be incorrect with a certain (typically small) probability.</p>
<p>The related class of Las Vegas algorithms are also randomized, but in a different way: they take an amount of time that varies randomly, but always produce the correct answer. A Monte Carlo algorithm can be converted into a Las Vegas algorithm whenever there exists a procedure to verify that the output produced by the algorithm is indeed correct. If so, then the resulting Las Vegas algorithm is merely to repeatedly run the Monte Carlo algorithm until one of the runs produces an output that can be verified to be correct.</p>
<p>The name refers to the grand casino in the Principality of Monaco at Monte Carlo, which is well-known around the world as an icon of gambling.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 One-sided vs two-sided error</li>
<li>2 Amplification</li>
<li>3 Complexity classes</li>
<li>4 Applications in computational number theory</li>
<li>5 See also</li>
<li>6 References</li>
</ul>
<p></p>
<h2>One-sided vs two-sided error</h2>
<p>Whereas the answer returned by a deterministic algorithm is always expected to be correct, this is not the case for Monte Carlo algorithms. For decision problems, these algorithms are generally classified as either <b>false</b>-biased or <b>true</b>-biased. A <b>false</b>-biased Monte Carlo algorithm is always correct when it returns <b>false</b>; a <b>true</b>-biased algorithm is always correct when it returns <b>true</b>. While this describes algorithms with <i>one-sided errors</i>, others might have no bias; these are said to have <i>two-sided errors</i>. The answer they provide (either <b>true</b> or <b>false</b>) will be incorrect, or correct, with some bounded probability.</p>
<p>For instance, the Solovay–Strassen primality test is used to determine whether a given number is a prime number. It always answers <b>true</b> for prime number inputs; for composite inputs, it answers <b>false</b> with probability at least ½ and <b>true</b> with probability at most ½. Thus, <b>false</b> answers from the algorithm are certain to be correct, whereas the <b>true</b> answers remain uncertain; this is said to be a <i>½-correct false-biased algorithm</i>.</p>
<h2>Amplification</h2>
<p>For a Monte Carlo algorithm with one-sided errors, the failure probability can be reduced (and the success probability amplified) by running the algorithm <i>k</i> times. Consider again the Solovay–Strassen algorithm which is <i>½-correct false-biased</i>. One may run this algorithm multiple times returning a <b>false</b> answer if it reaches a <b>false</b> response within <i>k</i> iterations, and otherwise returning <b>true</b>. Thus, if the number is prime then the answer is always correct, and if the number is composite then the answer is correct with probability at least 1−(1−½) = 1−2.</p>
<p>For Monte Carlo decision algorithms with two-sided error, the failure probability may again be reduced by running the algorithm <i>k</i> times and returning the majority function of the answers.</p>
<h2>Complexity classes</h2>
<p>The complexity class BPP describes decision problems that can be solved by polynomial-time Monte Carlo algorithms with a bounded probability of two-sided errors, and the complexity class RP describes problems that can be solved by a Monte Carlo algorithm with a bounded probability of one-sided error: if the correct answer is no, the algorithm always says so, but it may answer no incorrectly for some instances where the correct answer is yes. In contrast, the complexity class ZPP describes problems solvable by polynomial expected time Las Vegas algorithms. ZPP ⊆ RP ⊆ BPP, but it is not known whether any of these complexity classes is distinct from each other; that is, Monte Carlo algorithms may have more computational power than Las Vegas algorithms, but this has not been proven. Another complexity class, PP, describes decision problems with a polynomial-time Monte Carlo algorithm that is more accurate than flipping a coin but where the error probability cannot be bounded away from ½.</p>
<h2>Applications in computational number theory</h2>
<p>Well-known Monte Carlo algorithms include the Solovay–Strassen primality test, the Baillie-PSW primality test, the Miller–Rabin primality test, and certain fast variants of the Schreier–Sims algorithm in computational group theory.</p>
<h2>See also</h2>
<ul>
<li>Monte Carlo methods, algorithms used in physical simulation and computational statistics based on taking random samples</li>
<li>Atlantic City algorithm</li>
<li>Las Vegas algorithm</li>
</ul>
</body>
</html>