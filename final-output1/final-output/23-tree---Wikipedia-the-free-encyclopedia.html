<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>23-tree---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>2–3 tree</h1>
<p>In computer science, a <b>2–3 tree</b> is a tree data structure, where every node with children (internal node) has either two children (2-node) and one data element or three children (3-nodes) and two data elements. Nodes on the outside of the tree (leaf nodes) have no children and one or two data elements. 2−3 trees were invented by John Hopcroft in 1970.</p>
<ul>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/3a/2-3-4_tree_2-node.svg/110px-2-3-4_tree_2-node.svg.png" width="110" height="95" data-file-width="168" data-file-height="145"></div>
</div>
<div class="gallerytext">
<p>2 node</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:29px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/4a/2-3-4-tree_3-node.svg/120px-2-3-4-tree_3-node.svg.png" width="120" height="67" data-file-width="258" data-file-height="145"></div>
</div>
<div class="gallerytext">
<p>3 node</p>
</div>
</div>
</li>
</ul>
<p>2 node</p>
<p>3 node</p>
<p>2–3 trees are an isometry of AA trees, meaning that they are equivalent data structures. In other words, for every 2–3 tree, there exists at least one AA tree with data elements in the same order. 2–3 trees are balanced, meaning that each right, center, and left subtree contains the same or close to the same amount of data.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Properties</li>
<li>2 Non-leaf nodes</li>
<li>3 Operations
<ul>
<li>3.1 Insertion</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<ul>
<li>3.1 Insertion</li>
</ul>
<p></p>
<h2>Properties</h2>
<ul>
<li>Every non-leaf is a 2-node or a 3-node. A 2-node contains one data item and has two children. A 3-node contains two data items and has 3 children.</li>
<li>All leaves are at the same level (the bottom level)</li>
<li>All data is kept in sorted order</li>
<li>Every leaf node will contain 1 or 2 fields.</li>
</ul>
<h2>Non-leaf nodes</h2>
<p>These contain one or two fields which indicate the range of values in its subtrees. If a node has two children, it will have one field; if the node has three children, it will have two fields. Each non-leaf node will contain a value in field 1 which is greater than the largest item in its left sub-tree, but less than or equal to the smallest item in its right sub-tree (or center sub-tree, if it has three children). If that node has three children, field 2 contains a value which is greater than the largest value in the center sub-tree, but less than or equal to the smallest item in its right sub-tree. The purpose of these values is to direct a search function to the correct sub-tree and eventually to the correct data node.</p>
<h2>Operations</h2>
<h3>Insertion</h3>
<p>Insertion works by searching for the proper location of the key and adds it there. If the node becomes a 4-node then the node is split int two 2-nodes and the middle key is moved up to the parent. The diagram illustrates the process.</p>
<h2>See also</h2>
<ul>
<li>2–3–4 tree</li>
</ul>
<ul>
<li>Finger tree</li>
</ul>
<ul>
<li>2–3 heap</li>
</ul>
<ul>
<li>(a,b)-tree</li>
</ul>
</body>
</html>