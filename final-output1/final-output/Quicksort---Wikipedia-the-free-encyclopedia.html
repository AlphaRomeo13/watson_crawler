<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Quicksort---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Quicksort</h1>
<p><b>Quicksort</b>, or <b>partition-exchange sort</b>, is a sorting algorithm developed by Tony Hoare that, on average, makes O(<i>n</i> log <i>n</i>) comparisons to sort <i>n</i> items. In the worst case, it makes O(<i>n</i>) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(<i>n</i> log <i>n</i>) algorithms. Additionally, quicksort's sequential and localized memory references work well with a cache. Quicksort is a comparison sort and, in efficient implementations, is not a stable sort. Quicksort can be implemented with an in-place partitioning algorithm, so the entire sort can be done with only O(log <i>n</i>) additional space used by the stack during the recursion.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Algorithm
<ul>
<li>2.1 Implementation issues
<ul>
<li>2.1.1 Choice of pivot</li>
<li>2.1.2 Repeated elements</li>
<li>2.1.3 Optimizations</li>
<li>2.1.4 Parallelization</li>
</ul>
</li>
</ul>
</li>
<li>3 Formal analysis
<ul>
<li>3.1 Average-case analysis using discrete probability</li>
<li>3.2 Average-case analysis using recurrences
<ul>
<li>3.2.1 Solving the recurrence using mathematical induction</li>
</ul>
</li>
<li>3.3 Analysis of randomized quicksort</li>
<li>3.4 Space complexity</li>
</ul>
</li>
<li>4 Relation to other algorithms
<ul>
<li>4.1 Selection-based pivoting</li>
<li>4.2 Variants</li>
<li>4.3 Generalization</li>
</ul>
</li>
<li>5 See also</li>
<li>6 Notes</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>2.1 Implementation issues
<ul>
<li>2.1.1 Choice of pivot</li>
<li>2.1.2 Repeated elements</li>
<li>2.1.3 Optimizations</li>
<li>2.1.4 Parallelization</li>
</ul>
</li>
</ul>
<ul>
<li>2.1.1 Choice of pivot</li>
<li>2.1.2 Repeated elements</li>
<li>2.1.3 Optimizations</li>
<li>2.1.4 Parallelization</li>
</ul>
<ul>
<li>3.1 Average-case analysis using discrete probability</li>
<li>3.2 Average-case analysis using recurrences
<ul>
<li>3.2.1 Solving the recurrence using mathematical induction</li>
</ul>
</li>
<li>3.3 Analysis of randomized quicksort</li>
<li>3.4 Space complexity</li>
</ul>
<ul>
<li>3.2.1 Solving the recurrence using mathematical induction</li>
</ul>
<ul>
<li>4.1 Selection-based pivoting</li>
<li>4.2 Variants</li>
<li>4.3 Generalization</li>
</ul>
<p></p>
<h2>History</h2>
<p>The quicksort algorithm was developed in 1960 by Tony Hoare while in the Soviet Union, as a visiting student at Moscow State University. At that time, Hoare worked in a project on machine translation for the National Physical Laboratory. He developed the algorithm in order to sort the words to be translated, to make them more easily matched to an already-sorted Russian-to-English dictionary that was stored on magnetic tape.</p>
<p>Quicksort gained widespread adoption, appearing, for example, in Unix as the default library sort function, hence it lent its name to the C standard library function <code>qsort</code> and in the reference implementation of Java. It was analyzed extensively by Robert Sedgewick, who wrote his Ph.D. thesis about the algorithm and suggested several improvements.</p>
<h2>Algorithm</h2>
<p>Quicksort is a divide and conquer algorithm. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.</p>
<p>The steps are:</p>
<ol>
<li>Pick an element, called a <b>pivot</b>, from the array.</li>
<li>Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the <b>partition</b> operation.</li>
<li>Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</li>
</ol>
<p>The base case of the recursion is arrays of size zero or one, which never need to be sorted. In pseudocode, a quicksort that sorts elements i through k (inclusive) of an array A can be expressed compactly as</p>
<p>WHATSON? 297b6bd7-e08d-47de-bdfc-b6d3118800eb</p>
<pre>
quicksort(A, i, k):
  if i &lt; k:
    p := partition(A, i, k)
    quicksort(A, i, p - 1)
    quicksort(A, p + 1, k)
</pre>
<p>Sorting the entire array is accomplished by calling <code>quicksort(A, 1, length(A))</code>. The <code>partition</code> operation is step 2 from the description in English, above. It can be defined as:</p>
<p>WHATSON? 997b9a31-3352-467e-b00b-f31030968245</p>
<pre>
  <i>// left is the index of the leftmost element of the subarray</i>
  <i>// right is the index of the rightmost element of the subarray (inclusive)</i>
  <i>// number of elements in subarray = right-left+1</i>
  partition(array, left, right)
     pivotIndex := choosePivot(array, left, right)
     pivotValue := array[pivotIndex]
     swap array[pivotIndex] and array[right]
     storeIndex := left
     <b>for</b> i <b>from</b> left <b>to</b> right - 1
         <b>if</b> array[i] &lt; pivotValue
             swap array[i] and array[storeIndex]
             storeIndex := storeIndex + 1
     swap array[storeIndex] and array[right]  // <i>Move pivot to its final place</i>
     <b>return</b> storeIndex
</pre>
<p>This is the in-place partition algorithm. It partitions the portion of the array between indexes <i>left</i> and <i>right</i>, inclusively, by moving all elements less than or equal <code>array[pivotIndex]</code> before the pivot, and the greater elements after it. In the process it also finds the final position for the pivot element, which it returns. It temporarily moves the pivot element to the end of the subarray, so that it doesn't get in the way. Because it only uses exchanges, the final list has the same elements as the original list. Notice that an element may be exchanged multiple times before reaching its final place. Also, in case of pivot duplicates in the input array, they can be spread across the right subarray, in any order. This doesn't represent a partitioning failure, as further sorting will reposition and finally "glue" them together.</p>
<p>This form of the partition algorithm is not the original form; multiple variations can be found in various textbooks, such as versions not having the storeIndex. However, this form is probably the easiest to understand.</p>
<p>Each recursive call to the combined <i>quicksort</i> function reduces the size of the array being sorted by at least one element, since in each invocation the element at <i>pivotNewIndex</i> is placed in its final position. Therefore, this algorithm is guaranteed to terminate after at most <i>n</i> recursive calls. However, since <i>partition</i> reorders elements within a partition, this version of quicksort is not a stable sort.</p>
<h3>Implementation issues</h3>
<h4>Choice of pivot</h4>
<p>In very early versions of quicksort, the leftmost element of the partition would often be chosen as the pivot element. Unfortunately, this causes worst-case behavior on already sorted arrays, which is a rather common use-case. The problem was easily solved by choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the median of the first, middle and last element of the partition for the pivot (as recommended by Sedgewick). This "median of three" rule counters the case of sorted (or reverse-sorted) input, and gives a better estimate of the optimal pivot (the true median) than selecting any single element, when no information about the ordering of the input is known.</p>
<p>Selecting a pivot element is also complicated by the existence of integer overflow. If the boundary indices of the subarray being sorted are sufficiently large, the naïve expression for the middle index, <i>(left + right)/2</i>, will cause overflow and provide an invalid pivot index. This can be overcome by using, for example, <i>left + (right-left)/2</i> to index the middle element, at the cost of more complex arithmetic. Similar issues arise in some other methods of selecting the pivot element.</p>
<h4>Repeated elements</h4>
<p>With a partitioning algorithm such as the one described above (even with one that chooses good pivot values), quicksort exhibits poor performance for inputs that contain many repeated elements. The problem is clearly apparent when all the input elements are equal: at each recursion, the left partition is empty (no input values are less than the pivot), and the right partition has only decreased by one element (the pivot is removed). Consequently, the algorithm takes quadratic time to sort an array of equal values.</p>
<p>To solve this quicksort equivalent of the Dutch national flag problem, an alternative linear-time partition routine can be used that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. (Bentley and McIlroy call this a "fat partition" and note that it was already implemented in the <code>qsort</code> of Version 7 Unix.) The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted. In pseudocode, the quicksort algorithm becomes</p>
<p>WHATSON? 39996a74-80fb-4e38-b4d6-f645df35ac87</p>
<pre>
<b>function</b> quicksort(A, lo, hi)
    if lo &lt; hi
        p = pivot(A, lo, hi)
        left, right = partition(A, p, lo, hi)  // note: multiple return values
        quicksort(A, lo, left)
        quicksort(A, right, hi)
</pre>
<p>The best case for the algorithm now occurs when all elements are equal (or are chosen from a small set of <i>k</i> ≪ <i>n</i> elements). In the case of all equal elements, the modified quicksort will perform at most two recursive calls on empty subarrays and thus finish in linear time.</p>
<h4>Optimizations</h4>
<p>Two other important optimizations, also suggested by Sedgewick and widely used in practice are:</p>
<h1>Quicksort</h1>
<ul>
<li>To make sure at most O(log N) space is used, recurse first into the smaller side of the partition, then use a tail call to recurse into the other.</li>
<li>Use insertion sort, which has a smaller constant factor and is thus faster on small arrays, for invocations on small arrays (i.e. where the length is less than a threshold <i>k</i> determined experimentally). This can be implemented by simply stopping the recursion when less than <i>k</i> elements are left, leaving the entire array <i>k</i>-sorted: each element will be at most <i>k</i> positions away from its final position. Then, a single insertion sort pass finishes the sort in O(<i>k</i>×<i>n</i>) time. A separate insertion sort of each small segment as they are identified adds the overhead of starting and stopping many small sorts, but avoids wasting effort comparing keys across the many segment boundaries, which keys will be in order due to the workings of the quicksort process.</li>
</ul>
<h4>Parallelization</h4>
<p>Quicksort's divide-and-conquer formulation makes it amenable to parallelization using task parallelism. The partitioning step is accomplished through the use of a parallel prefix sum algorithm to compute an index for each array element in its section of the partitioned array. Given an array of size n, the partitioning step performs O(<i>n</i>) work in <i>O</i>(log <i>n</i>) time and requires O(<i>n</i>) additional scratch space. After the array has been partitioned, the two partitions can be sorted recursively in parallel. Assuming an ideal choice of pivots, parallel quicksort sorts an array of size n in O(<i>n</i> log <i>n</i>) work in O(log² <i>n</i>) time using O(<i>n</i>) additional space.</p>
<p><b>Quicksort</b>, or <b>partition-exchange sort</b>, is a sorting algorithm developed by Tony Hoare that, on average, makes O(<i>n</i> log <i>n</i>) comparisons to sort <i>n</i> items. In the worst case, it makes O(<i>n</i>) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(<i>n</i> log <i>n</i>) algorithms. Additionally, quicksort's sequential and localized memory references work well with a cache. Quicksort is a comparison sort and, in efficient implementations, is not a stable sort. Quicksort can be implemented with an in-place partitioning algorithm, so the entire sort can be done with only O(log <i>n</i>) additional space used by the stack during the recursion.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Algorithm
<ul>
<li>2.1 Implementation issues
<ul>
<li>2.1.1 Choice of pivot</li>
<li>2.1.2 Repeated elements</li>
<li>2.1.3 Optimizations</li>
<li>2.1.4 Parallelization</li>
</ul>
</li>
</ul>
</li>
<li>3 Formal analysis
<ul>
<li>3.1 Average-case analysis using discrete probability</li>
<li>3.2 Average-case analysis using recurrences
<ul>
<li>3.2.1 Solving the recurrence using mathematical induction</li>
</ul>
</li>
<li>3.3 Analysis of randomized quicksort</li>
<li>3.4 Space complexity</li>
</ul>
</li>
<li>4 Relation to other algorithms
<ul>
<li>4.1 Selection-based pivoting</li>
<li>4.2 Variants</li>
<li>4.3 Generalization</li>
</ul>
</li>
<li>5 See also</li>
<li>6 Notes</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>2.1 Implementation issues
<ul>
<li>2.1.1 Choice of pivot</li>
<li>2.1.2 Repeated elements</li>
<li>2.1.3 Optimizations</li>
<li>2.1.4 Parallelization</li>
</ul>
</li>
</ul>
<ul>
<li>2.1.1 Choice of pivot</li>
<li>2.1.2 Repeated elements</li>
<li>2.1.3 Optimizations</li>
<li>2.1.4 Parallelization</li>
</ul>
<ul>
<li>3.1 Average-case analysis using discrete probability</li>
<li>3.2 Average-case analysis using recurrences
<ul>
<li>3.2.1 Solving the recurrence using mathematical induction</li>
</ul>
</li>
<li>3.3 Analysis of randomized quicksort</li>
<li>3.4 Space complexity</li>
</ul>
<ul>
<li>3.2.1 Solving the recurrence using mathematical induction</li>
</ul>
<ul>
<li>4.1 Selection-based pivoting</li>
<li>4.2 Variants</li>
<li>4.3 Generalization</li>
</ul>
<p></p>
<p>Quicksort has some disadvantages when compared to alternative sorting algorithms, like merge sort, which complicate its efficient parallelization. The depth of quicksort's divide-and-conquer tree directly impacts the algorithm's scalability, and this depth is highly dependent on the algorithm's choice of pivot. Additionally, it is difficult to parallelize the partitioning step efficiently in-place. The use of scratch space simplifies the partitioning step, but increases the algorithm's memory footprint and constant overheads.</p>
<p>Other more sophisticated parallel sorting algorithms can achieve even better time bounds. For example, in 1991 David Powers described a parallelized quicksort (and a related radix sort) that can operate in <i>O</i>(log <i>n</i>) time on a CRCW PRAM with n processors by performing partitioning implicitly.</p>
<h2>Formal analysis</h2>
<h3>Average-case analysis using discrete probability</h3>
<p>To sort an array of n distinct elements, quicksort takes <i>O</i>(<i>n</i> log <i>n</i>) time in expection, averaged over all <i>n</i>! permutations of n elements with equal probability. Why? For a start, it is not hard to see that the partition operation takes <i>O</i>(<i>n</i>) time.</p>
<p>In the most unbalanced case, each time we perform a partition we divide the list into two sublists of size 0 and <i>n</i> − 1 (for example, if all elements of the array are equal). This means each recursive call processes a list of size one less than the previous list. Consequently, we can make <i>n</i> − 1 nested calls before we reach a list of size 1. This means that the call tree is a linear chain of <i>n</i> − 1 nested calls. The ith call does <i>O</i>(<i>n</i> − <i>i</i>) work to do the partition, and <img class="mwe-math-fallback-image-inline tex" alt="\textstyle\sum_{i=0}^n (n-i) = O(n^2)" src="//upload.wikimedia.org/math/e/1/1/e111b6dc31c7dbec42f0c2d1ba7a2a12.png">, so in that case Quicksort takes <i>O</i>(<i>n</i>²) time. That is the worst case: given knowledge of which comparisons are performed by the sort, there are adaptive algorithms that are effective at generating worst-case input for quicksort on-the-fly, regardless of the pivot selection strategy.</p>
<p>In the most balanced case, each time we perform a partition we divide the list into two nearly equal pieces. This means each recursive call processes a list of half the size. Consequently, we can make only log₂ <i>n</i> nested calls before we reach a list of size 1. This means that the depth of the call tree is log₂ <i>n</i>. But no two calls at the same level of the call tree process the same part of the original list; thus, each level of calls needs only <i>O</i>(<i>n</i>) time all together (each call has some constant overhead, but since there are only <i>O</i>(<i>n</i>) calls at each level, this is subsumed in the <i>O</i>(<i>n</i>) factor). The result is that the algorithm uses only <i>O</i>(<i>n</i> log <i>n</i>) time.</p>
<h2>History</h2>
<p>The quicksort algorithm was developed in 1960 by Tony Hoare while in the Soviet Union, as a visiting student at Moscow State University. At that time, Hoare worked in a project on machine translation for the National Physical Laboratory. He developed the algorithm in order to sort the words to be translated, to make them more easily matched to an already-sorted Russian-to-English dictionary that was stored on magnetic tape.</p>
<p>Quicksort gained widespread adoption, appearing, for example, in Unix as the default library sort function, hence it lent its name to the C standard library function <code>qsort</code> and in the reference implementation of Java. It was analyzed extensively by Robert Sedgewick, who wrote his Ph.D. thesis about the algorithm and suggested several improvements.</p>
<h2>Algorithm</h2>
<p>Quicksort is a divide and conquer algorithm. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.</p>
<p>In fact, it's not necessary to be perfectly balanced; even if each pivot splits the elements with 75% on one side and 25% on the other side (or any other fixed fraction), the call depth is still limited to <img class="mwe-math-fallback-image-inline tex" alt="\log_{4/3} n" src="//upload.wikimedia.org/math/3/a/0/3a0d4c27ba300db6cd5d410c3f9b7e8f.png">, so the total running time is still <i>O</i>(<i>n</i> log <i>n</i>).</p>
<p>So what happens on average? If the pivot has rank somewhere in the middle 50 percent, that is, between the 25th percentile and the 75th percentile, then it splits the elements with at least 25% and at most 75% on each side. If we could consistently choose a pivot from the two middle 50 percent, we would only have to split the list at most <img class="mwe-math-fallback-image-inline tex" alt="\log_{4/3} n" src="//upload.wikimedia.org/math/3/a/0/3a0d4c27ba300db6cd5d410c3f9b7e8f.png"> times before reaching lists of size 1, yielding an <i>O</i>(<i>n</i> log <i>n</i>) algorithm.</p>
<p>When the input is a random permutation, the pivot has a random rank, and so it is not guaranteed to be in the middle 50 percent. However, when we start from a random permutation, in each recursive call the pivot has a random rank in its list, and so it is in the middle 50 percent about half the time. That is good enough. Imagine that you flip a coin: heads means that the rank of the pivot is in the middle 50 percent, tail means that it isn't. Imagine that you are flipping a coin over and over until you get k heads. Although this could take a long time, on average only 2<i>k</i> flips are required, and the chance that you won't get k heads after 100<i>k</i> flips is highly improbable (this can be made rigorous using Chernoff bounds). By the same argument, Quicksort's recursion will terminate on average at a call depth of only <img class="mwe-math-fallback-image-inline tex" alt="2 \log_{4/3} n" src="//upload.wikimedia.org/math/3/d/2/3d234c4ebae608bf6bc34ef8e0b39b92.png">. But if its average call depth is <i>O</i>(log <i>n</i>), and each level of the call tree processes at most n elements, the total amount of work done on average is the product, <i>O</i>(<i>n</i> log <i>n</i>). Note that the algorithm does not have to verify that the pivot is in the middle half—if we hit it any constant fraction of the times, that is enough for the desired complexity.</p>
<h3>Average-case analysis using recurrences</h3>
<p>An alternative approach is to set up a recurrence relation for the <i>T</i>(<i>n</i>) factor, the time needed to sort a list of size n. In the most unbalanced case, a single quicksort call involves <i>O</i>(<i>n</i>) work plus two recursive calls on lists of size 0 and <i>n</i>−1, so the recurrence relation is</p>
<p>This is the same relation as for insertion sort and selection sort, and it solves to worst case <i>T</i>(<i>n</i>) = <i>O</i>(<i>n</i>²).</p>
<p>In the most balanced case, a single quicksort call involves <i>O</i>(<i>n</i>) work plus two recursive calls on lists of size <i>n</i>/2, so the recurrence relation is</p>
<p>The master theorem tells us that <i>T</i>(<i>n</i>) = <i>O</i>(<i>n</i> log <i>n</i>).</p>
<p>The outline of a formal proof of the <i>O</i>(<i>n</i> log <i>n</i>) expected time complexity follows. Assume that there are no duplicates as duplicates could be handled with linear time pre- and post-processing, or considered cases easier than the analyzed. When the input is a random permutation, the rank of the pivot is uniform random from 0 to <i>n</i> − 1. Then the resulting parts of the partition have sizes i and <i>n</i> − <i>i</i> − 1, and i is uniform random from 0 to <i>n</i> − 1. So, averaging over all possible splits and noting that the number of comparisons for the partition is <i>n</i> − 1, the average number of comparisons over all permutations of the input sequence can be estimated accurately by solving the recurrence relation:</p>
<p>Solving the recurrence gives <i>C</i>(<i>n</i>) = 2<i>n</i> ln <i>n</i> ≈ 1.39<i>n</i> log₂ <i>n</i>.</p>
<p>This means that, on average, quicksort performs only about 39% worse than in its best case. In this sense it is closer to the best case than the worst case. Also note that a comparison sort cannot use less than log₂(<i>n</i>!) comparisons on average to sort n items (as explained in the article Comparison sort) and in case of large n, Stirling's approximation yields log₂(<i>n</i>!) ≈ <i>n</i>(log₂ <i>n</i> − log₂ <i>e</i>), so quicksort is not much worse than an ideal comparison sort. This fast average runtime is another reason for quicksort's practical dominance over other sorting algorithms.</p>
<h4>Solving the recurrence using mathematical induction</h4>
<p><img class="mwe-math-fallback-image-inline tex" alt="T(1) = c " src="//upload.wikimedia.org/math/6/1/d/61df5d0379892e303032104079ac04e7.png"></p>
<p><img class="mwe-math-fallback-image-inline tex" alt="
\begin{align}
T(n) &amp; = \frac{1}{n} \sum_{i=1}^{n} (T(i-1)+T(n-i)) + dn \\
     &amp; = \frac{2}{n} \sum_{i=1}^{n-1} T(i) + dn
\end{align}
" src="//upload.wikimedia.org/math/5/9/f/59fa8ec0a795b3f25b79a0885ecfa604.png"></p>
<p><b>Assertion</b> A(m) : <img class="mwe-math-fallback-image-inline tex" alt="T(m) \le a m \log m + b" src="//upload.wikimedia.org/math/f/1/c/f1caaba4558998bce564a165cf1bcad8.png"> for all <i>m</i> ≥ 1<br>
<b>Base case</b> A(0) : Holds for <i>b</i> ≥ <i>c</i><br>
<b>Induction step</b> : Assuming <i>A</i>(<i>m</i>) holds for all <i>m</i>&lt;<i>n</i>, we have to prove <i>A</i>(<i>n</i>).</p>
<p><img class="mwe-math-fallback-image-inline tex" alt="
\begin{align}
T(n) &amp; \le  \frac{2}{n} \sum_{i=1}^{n-1} \left(a i \log i + b \right) + dn \\
     &amp; \le  \frac{2}{n} \left(\sum_{i=1}^{n-1} a i \log i \right) + 2b + dn \\
     &amp; =    \frac{2}{n} \left(\sum_{i=1}^{n/2} a i \log i + \sum_{i=n/2+1}^{n-1}(a i \log i) \right) + 2b + dn \\
     &amp; \le  \frac{2}{n} \left(\sum_{i=1}^{n/2} a i \log (n/2) + \sum_{i=n/2+1}^{n-1} a i \log n \right)+ 2b + dn \\
     &amp; =    \frac{2}{n} \left(\sum_{i=1}^{n-1} a i \log n - \sum_{i=1}^{n/2} ai \right)+ 2b + dn \\
     &amp; =    \frac{2}{n} \left(\frac{n(n-1)}{2} (a \log n) - \frac{n/2(n/2 + 1)}{2}(a) \right) + 2b +dn \\
     &amp; \le  a(n-1)\log n - \frac{n}{4}(a) + 2b + dn \\
     &amp; =    a n \log n + b - \frac{n}{4}(a) + b + dn \\
     &amp; \le  a n \log n + b \ \textrm{ for } \ a &gt; 4(b+d)
\end{align}
" src="//upload.wikimedia.org/math/7/2/b/72be45fc60b1b4e8df48923bcaa86dd6.png"></p>
<p>The steps are:</p>
<ol>
<li>Pick an element, called a <b>pivot</b>, from the array.</li>
<li>Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the <b>partition</b> operation.</li>
<li>Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</li>
</ol>
<p>The base case of the recursion is arrays of size zero or one, which never need to be sorted. In pseudocode, a quicksort that sorts elements i through k (inclusive) of an array A can be expressed compactly as</p>
<p>WHATSON? 56fc270c-dc81-487e-ad4d-14fdf9448901</p>
<pre>
quicksort(A, i, k):
  if i &lt; k:
    p := partition(A, i, k)
    quicksort(A, i, p - 1)
    quicksort(A, p + 1, k)
</pre>
<p>Sorting the entire array is accomplished by calling <code>quicksort(A, 1, length(A))</code>. The <code>partition</code> operation is step 2 from the description in English, above. It can be defined as:</p>
<p>WHATSON? efa1c4af-9d43-4138-82ae-a6c102c3e7ad</p>
<pre>
  <i>// left is the index of the leftmost element of the subarray</i>
  <i>// right is the index of the rightmost element of the subarray (inclusive)</i>
  <i>// number of elements in subarray = right-left+1</i>
  partition(array, left, right)
     pivotIndex := choosePivot(array, left, right)
     pivotValue := array[pivotIndex]
     swap array[pivotIndex] and array[right]
     storeIndex := left
     <b>for</b> i <b>from</b> left <b>to</b> right - 1
         <b>if</b> array[i] &lt; pivotValue
             swap array[i] and array[storeIndex]
             storeIndex := storeIndex + 1
     swap array[storeIndex] and array[right]  // <i>Move pivot to its final place</i>
     <b>return</b> storeIndex
</pre>
<p>This is the in-place partition algorithm. It partitions the portion of the array between indexes <i>left</i> and <i>right</i>, inclusively, by moving all elements less than or equal <code>array[pivotIndex]</code> before the pivot, and the greater elements after it. In the process it also finds the final position for the pivot element, which it returns. It temporarily moves the pivot element to the end of the subarray, so that it doesn't get in the way. Because it only uses exchanges, the final list has the same elements as the original list. Notice that an element may be exchanged multiple times before reaching its final place. Also, in case of pivot duplicates in the input array, they can be spread across the right subarray, in any order. This doesn't represent a partitioning failure, as further sorting will reposition and finally "glue" them together.</p>
<p>This form of the partition algorithm is not the original form; multiple variations can be found in various textbooks, such as versions not having the storeIndex. However, this form is probably the easiest to understand.</p>
<p>Each recursive call to the combined <i>quicksort</i> function reduces the size of the array being sorted by at least one element, since in each invocation the element at <i>pivotNewIndex</i> is placed in its final position. Therefore, this algorithm is guaranteed to terminate after at most <i>n</i> recursive calls. However, since <i>partition</i> reorders elements within a partition, this version of quicksort is not a stable sort.</p>
<h3>Implementation issues</h3>
<h4>Choice of pivot</h4>
<p>In very early versions of quicksort, the leftmost element of the partition would often be chosen as the pivot element. Unfortunately, this causes worst-case behavior on already sorted arrays, which is a rather common use-case. The problem was easily solved by choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the median of the first, middle and last element of the partition for the pivot (as recommended by Sedgewick). This "median of three" rule counters the case of sorted (or reverse-sorted) input, and gives a better estimate of the optimal pivot (the true median) than selecting any single element, when no information about the ordering of the input is known.</p>
<p>Selecting a pivot element is also complicated by the existence of integer overflow. If the boundary indices of the subarray being sorted are sufficiently large, the naïve expression for the middle index, <i>(left + right)/2</i>, will cause overflow and provide an invalid pivot index. This can be overcome by using, for example, <i>left + (right-left)/2</i> to index the middle element, at the cost of more complex arithmetic. Similar issues arise in some other methods of selecting the pivot element.</p>
<h4>Repeated elements</h4>
<h3>Analysis of randomized quicksort</h3>
<p>Using the same analysis, one can show that randomized quicksort has the desirable property that, for any input, it requires only <i>O</i>(<i>n</i> log <i>n</i>) expected time (averaged over all choices of pivots). However, there also exists a combinatorial proof.</p>
<p>To each execution of quicksort corresponds the following binary search tree (BST): the initial pivot is the root node; the pivot of the left half is the root of the left subtree, the pivot of the right half is the root of the right subtree, and so on. The number of comparisons of the execution of quicksort equals the number of comparisons during the construction of the BST by a sequence of insertions. So, the average number of comparisons for randomized quicksort equals the average cost of constructing a BST when the values inserted <img class="mwe-math-fallback-image-inline tex" alt="(x_1,x_2,...,x_n)" src="//upload.wikimedia.org/math/f/8/5/f85bf746c842098c40eff42587e12dab.png"> form a random permutation.</p>
<p>Consider a BST created by insertion of a sequence <img class="mwe-math-fallback-image-inline tex" alt="(x_1,x_2,...,x_n)" src="//upload.wikimedia.org/math/f/8/5/f85bf746c842098c40eff42587e12dab.png"> of values forming a random permutation. Let C denote the cost of creation of the BST. We have <img class="mwe-math-fallback-image-inline tex" alt="C=\sum_i \sum_{j&lt;i} c_{i,j}" src="//upload.wikimedia.org/math/8/9/e/89e6347270cd7dd0a1bcae262a4705fd.png">, where <img class="mwe-math-fallback-image-inline tex" alt="c_{i,j}" src="//upload.wikimedia.org/math/9/2/e/92e822addd4c1d7ce4e6ca59c1504af4.png"> is an binary random variable expressing whether during the insertion of <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> there was a comparison to <img class="mwe-math-fallback-image-inline tex" alt="x_j" src="//upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png">.</p>
<p>By linearity of expectation, the expected value <img class="mwe-math-fallback-image-inline tex" alt="\mathbb{E}[C]" src="//upload.wikimedia.org/math/a/e/a/aea6c2c766ea417ff0e9309ea6d00108.png"> of C is <img class="mwe-math-fallback-image-inline tex" alt="\mathbb{E}[C]= \sum_i \sum_{j&lt;i} \operatorname{Pr}(c_{i,j})" src="//upload.wikimedia.org/math/e/9/e/e9e3daeedefe7f2599f69cb193760659.png">.</p>
<p>Fix i and <i>j</i>&lt;<i>i</i>. The values <img class="mwe-math-fallback-image-inline tex" alt="{x_1,x_2,...,x_j}" src="//upload.wikimedia.org/math/9/c/2/9c226db01772e0a4dde4c25d6f2dcaa4.png">, once sorted, define <i>j</i>+1 intervals. The core structural observation is that <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> is compared to <img class="mwe-math-fallback-image-inline tex" alt="x_j" src="//upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png"> in the algorithm if and only if <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> falls inside one of the two intervals adjacent to <img class="mwe-math-fallback-image-inline tex" alt="x_j" src="//upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png">.</p>
<p>Observe that since <img class="mwe-math-fallback-image-inline tex" alt="(x_1,x_2,...,x_n)" src="//upload.wikimedia.org/math/f/8/5/f85bf746c842098c40eff42587e12dab.png"> is a random permutation, <img class="mwe-math-fallback-image-inline tex" alt="(x_1,x_2,...,x_j,x_i)" src="//upload.wikimedia.org/math/e/d/b/edb30fd71d643c22949ecb7b6f2a2516.png"> is also a random permutation, so the probability that <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> is adjacent to <img class="mwe-math-fallback-image-inline tex" alt="x_j" src="//upload.wikimedia.org/math/f/4/b/f4bb95e27d8505366199bb81f2b75b6f.png"> is exactly <img class="mwe-math-fallback-image-inline tex" alt="\frac{2}{j+1}" src="//upload.wikimedia.org/math/c/8/2/c82262e43afb93e7fa78b6a9c363d767.png">.</p>
<p>We end with a short calculation: <img class="mwe-math-fallback-image-inline tex" alt="\mathbb{E}[C] = \sum_i \sum_{j&lt;i} \frac{2}{j+1} = O(\sum_i \log i)=O(n \log n)." src="//upload.wikimedia.org/math/e/1/9/e192ea53bcdaa0230710afcf4977ba14.png"></p>
<p>With a partitioning algorithm such as the one described above (even with one that chooses good pivot values), quicksort exhibits poor performance for inputs that contain many repeated elements. The problem is clearly apparent when all the input elements are equal: at each recursion, the left partition is empty (no input values are less than the pivot), and the right partition has only decreased by one element (the pivot is removed). Consequently, the algorithm takes quadratic time to sort an array of equal values.</p>
<p>To solve this quicksort equivalent of the Dutch national flag problem, an alternative linear-time partition routine can be used that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. (Bentley and McIlroy call this a "fat partition" and note that it was already implemented in the <code>qsort</code> of Version 7 Unix.) The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted. In pseudocode, the quicksort algorithm becomes</p>
<p>WHATSON? 96a4bcb3-1a79-4b47-b253-7c14c7fc92df</p>
<pre>
<b>function</b> quicksort(A, lo, hi)
    if lo &lt; hi
        p = pivot(A, lo, hi)
        left, right = partition(A, p, lo, hi)  // note: multiple return values
        quicksort(A, lo, left)
        quicksort(A, right, hi)
</pre>
<p>The best case for the algorithm now occurs when all elements are equal (or are chosen from a small set of <i>k</i> ≪ <i>n</i> elements). In the case of all equal elements, the modified quicksort will perform at most two recursive calls on empty subarrays and thus finish in linear time.</p>
<h3>Space complexity</h3>
<p>The space used by quicksort depends on the version used.</p>
<p>The in-place version of quicksort has a space complexity of <i>O</i>(log <i>n</i>), even in the worst case, when it is carefully implemented using the following strategies:</p>
<ul>
<li>in-place partitioning is used. This unstable partition requires <i>O</i>(1) space.</li>
<li>After partitioning, the partition with the fewest elements is (recursively) sorted first, requiring at most <i>O</i>(log <i>n</i>) space. Then the other partition is sorted using tail recursion or iteration, which doesn't add to the call stack. This idea, as discussed above, was described by R. Sedgewick, and keeps the stack depth bounded by <i>O</i>(log <i>n</i>).</li>
</ul>
<p>Quicksort with in-place and unstable partitioning uses only constant additional space before making any recursive call. Quicksort must store a constant amount of information for each nested recursive call. Since the best case makes at most <i>O</i>(log <i>n</i>) nested recursive calls, it uses <i>O</i>(log <i>n</i>) space. However, without Sedgewick's trick to limit the recursive calls, in the worst case quicksort could make <i>O</i>(<i>n</i>) nested recursive calls and need <i>O</i>(<i>n</i>) auxiliary space.</p>
<p>From a bit complexity viewpoint, variables such as <i>left</i> and <i>right</i> do not use constant space; it takes <i>O</i>(log <i>n</i>) bits to index into a list of n items. Because there are such variables in every stack frame, quicksort using Sedgewick's trick requires <i>O</i>((log <i>n</i>)²) bits of space. This space requirement isn't too terrible, though, since if the list contained distinct elements, it would need at least <i>O</i>(<i>n</i> log <i>n</i>) bits of space.</p>
<p>Another, less common, not-in-place, version of quicksort uses <i>O</i>(<i>n</i>) space for working storage and can implement a stable sort. The working storage allows the input array to be easily partitioned in a stable manner and then copied back to the input array for successive recursive calls. Sedgewick's optimization is still appropriate.</p>
<h2>Relation to other algorithms</h2>
<p>Quicksort is a space-optimized version of the binary tree sort. Instead of inserting items sequentially into an explicit tree, quicksort organizes them concurrently into a tree that is implied by the recursive calls. The algorithms make exactly the same comparisons, but in a different order. An often desirable property of a sorting algorithm is stability - that is the order of elements that compare equal is not changed, allowing controlling order of multikey tables (e.g. directory or folder listings) in a natural way. This property is hard to maintain for in situ (or in place) quicksort (that uses only constant additional space for pointers and buffers, and logN additional space for the management of explicit or implicit recursion). For variant quicksorts involving extra memory due to representations using pointers (e.g. lists or trees) or files (effectively lists), it is trivial to maintain stability. The more complex, or disk-bound, data structures tend to increase time cost, in general making increasing use of virtual memory or disk.</p>
<p>The most direct competitor of quicksort is heapsort. Heapsort's worst-case running time is always <i>O</i>(<i>n</i> log <i>n</i>). But, heapsort is assumed to be on average somewhat slower than standard in-place quicksort. This is still debated and in research, with some publications indicating the opposite. Introsort is a variant of quicksort that switches to heapsort when a bad case is detected to avoid quicksort's worst-case running time.</p>
<h4>Optimizations</h4>
<p>Two other important optimizations, also suggested by Sedgewick and widely used in practice are:</p>
<ul>
<li>To make sure at most O(log N) space is used, recurse first into the smaller side of the partition, then use a tail call to recurse into the other.</li>
<li>Use insertion sort, which has a smaller constant factor and is thus faster on small arrays, for invocations on small arrays (i.e. where the length is less than a threshold <i>k</i> determined experimentally). This can be implemented by simply stopping the recursion when less than <i>k</i> elements are left, leaving the entire array <i>k</i>-sorted: each element will be at most <i>k</i> positions away from its final position. Then, a single insertion sort pass finishes the sort in O(<i>k</i>×<i>n</i>) time. A separate insertion sort of each small segment as they are identified adds the overhead of starting and stopping many small sorts, but avoids wasting effort comparing keys across the many segment boundaries, which keys will be in order due to the workings of the quicksort process.</li>
</ul>
<h4>Parallelization</h4>
<p>Quicksort's divide-and-conquer formulation makes it amenable to parallelization using task parallelism. The partitioning step is accomplished through the use of a parallel prefix sum algorithm to compute an index for each array element in its section of the partitioned array. Given an array of size n, the partitioning step performs O(<i>n</i>) work in <i>O</i>(log <i>n</i>) time and requires O(<i>n</i>) additional scratch space. After the array has been partitioned, the two partitions can be sorted recursively in parallel. Assuming an ideal choice of pivots, parallel quicksort sorts an array of size n in O(<i>n</i> log <i>n</i>) work in O(log² <i>n</i>) time using O(<i>n</i>) additional space.</p>
<p>Quicksort also competes with mergesort, another recursive sort algorithm but with the benefit of worst-case <i>O</i>(<i>n</i> log <i>n</i>) running time. Mergesort is a stable sort, unlike standard in-place quicksort and heapsort, and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media such as disk storage or network attached storage. Although quicksort can easily be implemented as a stable sort using linked lists, it will often suffer from poor pivot choices without random access. The main disadvantage of mergesort is that, when operating on arrays, efficient implementations require <i>O</i>(<i>n</i>) auxiliary space, whereas the variant of quicksort with in-place partitioning and tail recursion uses only <i>O</i>(log <i>n</i>) space. (Note that when operating on linked lists, mergesort only requires a small, constant amount of auxiliary storage.)</p>
<p>Bucket sort with two buckets is very similar to quicksort; the pivot in this case is effectively the value in the middle of the value range, which does well on average for uniformly distributed inputs.</p>
<h3>Selection-based pivoting</h3>
<p>A selection algorithm chooses the <i>k</i>th smallest of a list of numbers; this is an easier problem in general than sorting. One simple but effective selection algorithm works nearly in the same manner as quicksort, and is accordingly known as quickselect. The difference is that instead of making recursive calls on both sublists, it only makes a single tail-recursive call on the sublist which contains the desired element. This change lowers the average complexity to linear or <i>O</i>(<i>n</i>) time, which is optimal for selection, but worst-case time is still <i>O</i>(<i>n</i>).</p>
<p>A variant of quickselect, the median of medians algorithm, chooses pivots more carefully, ensuring that the pivots are near the middle of the data (between the 30th and 70th percentiles), and thus has guaranteed linear time – worst-case <i>O</i>(<i>n</i>). This same pivot strategy can be used to construct a variant of quickselect (median of medians quicksort) with worst-case <i>O</i>(<i>n</i>) time. However, the overhead of choosing the pivot is significant, so this is generally not used in practice.</p>
<p>More abstractly, given a worst-case <i>O</i>(<i>n</i>) selection algorithm, one can use it to find the ideal pivot (the median) at every step of quicksort, producing a variant with worst-case <i>O</i>(<i>n</i> log <i>n</i>) running time. In practical implementations this variant is considerably slower on average, but it is of theoretical interest, showing how an optimal selection algorithm can yield an optimal sorting algorithm.</p>
<h3>Variants</h3>
<h3>Generalization</h3>
<p>Richard Cole and David C. Kandathil, in 2004, discovered a one-parameter family of sorting algorithms, called partition sorts, which on average (with all input orderings equally likely) perform at most <img class="mwe-math-fallback-image-inline tex" alt="n\log n + {O}(n)" src="//upload.wikimedia.org/math/5/a/2/5a23e7dfa462feb5e91069482af8c7aa.png"> comparisons (close to the information theoretic lower bound) and <img class="mwe-math-fallback-image-inline tex" alt="{\Theta}(n\log n)" src="//upload.wikimedia.org/math/a/c/1/ac1dd5350b6aef9761f4f8d40e52d6df.png"> operations; at worst they perform <img class="mwe-math-fallback-image-inline tex" alt="{\Theta}(n\log^2 n)" src="//upload.wikimedia.org/math/9/e/2/9e2fb9a58c7862df0eb6141edf75d1de.png"> comparisons (and also operations); these are in-place, requiring only additional <img class="mwe-math-fallback-image-inline tex" alt="{O}(\log n)" src="//upload.wikimedia.org/math/b/d/6/bd6050c2618cfa91378c68d57b6caa3d.png"> space. Practical efficiency and smaller variance in performance were demonstrated against optimised quicksorts (of Sedgewick and Bentley-McIlroy).</p>
<h2>See also</h2>
<p>Quicksort has some disadvantages when compared to alternative sorting algorithms, like merge sort, which complicate its efficient parallelization. The depth of quicksort's divide-and-conquer tree directly impacts the algorithm's scalability, and this depth is highly dependent on the algorithm's choice of pivot. Additionally, it is difficult to parallelize the partitioning step efficiently in-place. The use of scratch space simplifies the partitioning step, but increases the algorithm's memory footprint and constant overheads.</p>
<p>Other more sophisticated parallel sorting algorithms can achieve even better time bounds. For example, in 1991 David Powers described a parallelized quicksort (and a related radix sort) that can operate in <i>O</i>(log <i>n</i>) time on a CRCW PRAM with n processors by performing partitioning implicitly.</p>
<h2>Formal analysis</h2>
<h3>Average-case analysis using discrete probability</h3>
<p>To sort an array of n distinct elements, quicksort takes <i>O</i>(<i>n</i> log <i>n</i>) time in expection, averaged over all <i>n</i>! permutations of n elements with equal probability. Why? For a start, it is not hard to see that the partition operation takes <i>O</i>(<i>n</i>) time.</p>
<ul>
<li>Introsort</li>
<li>Flashsort</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> Steven S. Skiena (27 April 2011). <i>The Algorithm Design Manual</i>. Springer. p. 129. ISBN 978-1-84800-069-8. Retrieved 27 November 2012. </li>
<li><b>^</b> "Data structures and algorithm: Quicksort". Auckland University. </li>
<li><b>^</b> Shustek, L. (2009). "Interview: An interview with C.A.R. Hoare". <i>Comm. ACM</i> <b>52</b> (3): 38–41. doi:10.1145/1467247.1467261.  edit</li>
<li>^     Bentley, Jon L.; McIlroy, M. Douglas (1993). "Engineering a sort function". <i>Software—Practice and Experience</i> <b>23</b> (11): 1249–1265. doi:10.1002/spe.4380231105. </li>
<li><b>^</b> Cormen, Thomas H.; Leiserson, Charles E., Rivest, Ronald L., Stein, Clifford (2009) [1990]. <i>Introduction to Algorithms</i> (3rd ed.). MIT Press and McGraw-Hill. ISBN 0-262-03384-4. </li>
<li>^   Sedgewick, Robert (1 September 1998). <i>Algorithms In C: Fundamentals, Data Structures, Sorting, Searching, Parts 1-4</i> (3 ed.). Pearson Education. ISBN 978-81-317-1291-7. Retrieved 27 November 2012. </li>
<li><b>^</b> qsort.c in GNU libc: [1], [2]</li>
<li><b>^</b> http://www.ugrad.cs.ubc.ca/~cs260/chnotes/ch6/Ch6CovCompiled.html</li>
<li><b>^</b> Jon Bentley (1999). <i>Programming Pearls</i>. Addison-Wesley Professional. </li>
<li><b>^</b> Umut A. Acar, Guy E Blelloch, Margaret Reid-Miller, and Kanat Tangwongsan, Quicksort and Sorting Lower Bounds, <i>Parallel and Sequential Data Structures and Algorithms</i>. 2013.</li>
<li><b>^</b> Miller, Russ; Boxer, Laurence (2000). <i>Algorithms sequential &amp; parallel: a unified approach</i>. Prentice Hall. ISBN 978-0-13-086373-7. Retrieved 27 November 2012. </li>
<li><b>^</b> David M. W. Powers, Parallelized Quicksort and Radixsort with Optimal Speedup, <i>Proceedings of International Conference on Parallel Computing Technologies</i>. Novosibirsk. 1991.</li>
<li><b>^</b> McIlroy, M. D. (1999). "A killer adversary for quicksort". <i>Software: Practice and Experience</i> <b>29</b> (4): 341–237. doi:10.1002/(SICI)1097-024X(19990410)29:4&lt;341::AID-SPE237&gt;3.3.CO;2-I.  edit</li>
<li><b>^</b> Sedgewick, R. (1978). "Implementing Quicksort programs". <i>Comm. ACM</i> <b>21</b> (10): 847–857. doi:10.1145/359619.359631.  edit</li>
<li><b>^</b> Hsieh, Paul (2004). "Sorting revisited.". www.azillionmonkeys.com. Retrieved 26 April 2010. </li>
<li><b>^</b> MacKay, David (1 December 2005). "Heapsort, Quicksort, and Entropy". users.aims.ac.za/~mackay. Retrieved 26 April 2010. </li>
<li><b>^</b> Wild, Sebastian; Nebel, Markus E. (2012). "Average case analysis of Java 7's dual pivot quicksort". European Symposium on Algorithms. arXiv:1310.7409. </li>
<li><b>^</b> http://permalink.gmane.org/gmane.comp.java.openjdk.core-libs.devel/2628</li>
<li><b>^</b> "Arrays". <i>Java Platform SE 7</i>. Oracle. Retrieved 4 September 2014. </li>
<li><b>^</b> David M. W. Powers, Parallel Unification: Practical Complexity, Australasian Computer Architecture Workshop, Flinders University, January 1995</li>
<li><b>^</b> Richard Cole, David C. Kandathil: "The average case analysis of Partition sorts", European Symposium on Algorithms, 14–17 September 2004, Bergen, Norway. Published: Lecture Notes in Computer Science 3221, Springer Verlag, pp. 240-251.</li>
</ol>
</body>
</html>