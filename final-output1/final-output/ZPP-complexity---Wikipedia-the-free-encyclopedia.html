<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ZPP-complexity---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>ZPP (complexity)</h1>
<p>In complexity theory, <b>ZPP</b> (zero-error probabilistic polynomial time) is the complexity class of problems for which a probabilistic Turing machine exists with these properties:</p>
<ul>
<li>It always returns the correct YES or NO answer.</li>
<li>The running time is polynomial in expectation for every input.</li>
</ul>
<p>In other words, if the algorithm is allowed to flip a truly-random coin while it is running, it will always return the correct answer and, for a problem of size <i>n</i>, there is some polynomial <i>p</i>(<i>n</i>) such that the average running time will be less than <i>p</i>(<i>n</i>), even though it might occasionally be much longer. Such an algorithm is called a Las Vegas algorithm.</p>
<p>Alternatively, <b>ZPP</b> can be defined as the class of problems for which a probabilistic Turing machine exists with these properties:</p>
<ul>
<li>It always runs in polynomial time.</li>
<li>It returns an answer YES, NO or DO NOT KNOW.</li>
<li>The answer is always either DO NOT KNOW or the correct answer.</li>
<li>It returns DO NOT KNOW with probability at most 1/2 (and the correct answer otherwise).</li>
</ul>
<p>The two definitions are equivalent.</p>
<p>The definition of <b>ZPP</b> is based on probabilistic Turing machines, but, for clarity, note that other complexity classes based on them include <b>BPP</b> and <b>RP</b>. The class <b>BQP</b> is based on another machine with randomness: the quantum computer.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Intersection definition</li>
<li>2 Witness and proof</li>
<li>3 Connection to other classes</li>
<li>4 External links</li>
</ul>
<p></p>
<h2>Intersection definition</h2>
<p>The class <b>ZPP</b> is exactly equal to the intersection of the classes <b>RP</b> and <b>co-RP</b>. This is often taken to be the definition of <b>ZPP</b>. To show this, first note that every problem which is in <i>both</i> <b>RP</b> and <b>co-RP</b> has a Las Vegas algorithm as follows:</p>
<ul>
<li>Suppose we have a language L recognized by both the <b>RP</b> algorithm A and the (possibly completely different) <b>co-RP</b> algorithm B.</li>
<li>Given an input in L, run A on the input for one step. If it returns YES, the answer must be YES. Otherwise, run B on the input for one step. If it returns NO, the answer must be NO. If neither occurs, repeat this step.</li>
</ul>
<p>Note that only one machine can ever give a wrong answer, and the chance of that machine giving the wrong answer during each repetition is at most 50%. This means that the chance of reaching the <i>k</i>th round shrinks exponentially in <i>k</i>, showing that the expected running time is polynomial. This shows that <b>RP</b> intersect <b>co-RP</b> is contained in <b>ZPP</b>.</p>
<p>To show that <b>ZPP</b> is contained in <b>RP</b> intersect <b>co-RP</b>, suppose we have a Las Vegas algorithm C to solve a problem. We can then construct the following <b>RP</b> algorithm:</p>
<ul>
<li>Run C for at least <i>double</i> its expected running time. If it gives an answer, give that answer. If it doesn't give any answer before we stop it, give NO.</li>
</ul>
<p>By Markov's Inequality, the chance that it will yield an answer before we stop it is 1/2. This means the chance we'll give the wrong answer on a YES instance, by stopping and yielding NO, is only 1/2, fitting the definition of an <b>RP</b> algorithm. The <b>co-RP</b> algorithm is identical, except that it gives YES if C "times out".</p>
<h2>Witness and proof</h2>
<p>The classes <b>NP</b>, <b>RP</b> and <b>ZPP</b> can be thought of in terms of proof of membership in a set.</p>
<p><b>Definition:</b> A <i>verifier</i> V for a set X is a Turing machine such that:</p>
<ul>
<li>if <i>x</i> is in <i>X</i> then there exists a string <i>w</i> such that <i>V</i>(<i>x</i>,<i>w</i>) accepts;</li>
<li>if <i>x</i> is not in <i>X</i>, then for all strings <i>w</i>, <i>V</i>(<i>x</i>,<i>w</i>) rejects.</li>
</ul>
<p>The string <i>w</i> can be thought of as the proof of membership. In the case of short proofs (of length bounded by a polynomial in the size of the input) which can be efficiently verified (<i>V</i> is a polynomial-time deterministic Turing machine), the string <i>w</i> is called a <i>witness</i>.</p>
<p><b>Notes:</b></p>
<ul>
<li>The definition is very asymmetric. The proof of x being in X is a single string. The proof of x not being in X is the collection of all strings, none of which is a proof of membership.</li>
<li>The availability of witness is uniform. For all x in X there must be a witness. It is not the case where certain x in X are too difficult to verify, whereas most are not.</li>
<li>The witness needn't be a traditionally construed proof. If V is a probabilistic Turing machine which could possibly accept x if x is in X, then the proof is the string of coin flips which leads the machine, by luck, intuition, or genius, to accepting <i>x</i>.</li>
<li>The co- concept is a proof of non-membership, or membership in the complement set.</li>
</ul>
<p>The classes <b>NP</b>, <b>RP</b> and <b>ZPP</b> are sets which have witnesses for membership. The class <b>NP</b> requires only that witnesses exist. They may be very rare. Of the 2 possible strings, with <i>f</i> a polynomial, only one need cause the verifier to accept (if x is in X. If x is not in X, no string will cause the verifier to accept).</p>
<p>For the classes <b>RP</b> and <b>ZPP</b> any string chosen at random will likely be a witness.</p>
<p>The corresponding co-classes have witness for non-membership. In particular, <b>co-RP</b> is the class of sets for which, if x is not in X, any randomly chosen string is likely to be a witness for non-membership. <b>ZPP</b> is the class of sets for which any random string is likely to be a witness of x in X, or x not in X, which ever the case may be.</p>
<p>Connecting this definition with other definitions of <b>RP</b>, <b>co-RP</b> and <b>ZPP</b> is easy. The probabilistic polynomial-time Turing Machine <i>V*<sub>w</sub></i>(<i>x</i>) corresponds to the deterministic polynomial-time Turing Machine <i>V</i>(<i>x</i>, <i>w</i>) by replacing the random tape of <i>V*</i> with a second input tape for V on which is written the sequence of coin flips. By selecting the witness as a random string, the verifier is a probabilistic polynomial-time Turing Machine whose probability of accepting x when x is in <i>X</i> is large (greater than 1/2, say), but zero if <i>x</i> ∉ <i>X</i> (for <b>RP</b>); of rejecting x when x is not in X is large but zero if <i>x</i> ∈ <i>X</i> (for <b>co-RP</b>); and of correctly accepting or rejecting <i>x</i> as a member of <i>X</i> is large, but zero of incorrectly accepting or rejecting x (for <b>ZPP</b>).</p>
<p>By repeated random selection of a possible witness, the large probability that a random string is a witness gives an expected polynomial time algorithm for accepting or rejecting an input. Conversely, if the Turing Machine is expected polynomial-time (for any given x), then a considerable fraction of the runs must be polynomial-time bounded, and the coin sequence used in such a run will be a witness.</p>
<p><b>ZPP</b> should be contrasted with <b>BPP</b>. The class <b>BPP</b> does not require witnesses, although witnesses are sufficient (hence <b>BPP</b> contains <b>RP</b>, <b>co-RP</b> and <b>ZPP</b>). A <b>BPP</b> language has V(x,w) accept on a (clear) majority of strings w if x is in X, and conversely reject on a (clear) majority of strings w if x is not in <i>X</i>. No single string w need be definitive, and therefore they cannot in general be considered proofs or witnesses.</p>
<h2>Connection to other classes</h2>
<p>Since <b>ZPP</b> = <b>RP</b> ∩ <b>coRP</b>, <b>ZPP</b> is obviously contained in both <b>RP</b> and <b>coRP</b>.</p>
<p>The class <b>P</b> is contained in <b>ZPP</b>, and some computer scientists have conjectured that <b>P</b> = <b>ZPP</b>, i.e., every Las Vegas algorithm has a deterministic polynomial-time equivalent.</p>
<p>A proof for <b>ZPP</b> = <b>EXPTIME</b> would imply that <b>P</b> ≠ <b>ZPP</b>, as <b>P</b> ≠ <b>EXPTIME</b> (see time hierarchy theorem).</p>
<h2>External links</h2>
<ul>
<li><i>Complexity Zoo</i>: ZPP Class ZPP</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<ul>
<li>DLOGTIME</li>
<li>AC</li>
<li>ACC</li>
<li>TC</li>
<li>L</li>
<li>SL</li>
<li>RL</li>
<li>NL</li>
<li>NC</li>
<li>SC</li>
<li>CC</li>
<li>P
<ul>
<li>P-complete</li>
</ul>
</li>
<li><strong class="selflink">ZPP</strong></li>
<li>RP</li>
<li>BPP</li>
<li>BQP</li>
</ul>
<ul>
<li>P-complete</li>
</ul>
<ul>
<li>UP</li>
<li>NP
<ul>
<li>NP-complete</li>
<li>NP-hard</li>
<li>co-NP</li>
<li>co-NP-complete</li>
</ul>
</li>
<li>AM</li>
<li>PH</li>
<li>⊕P</li>
<li>PP</li>
<li>#P
<ul>
<li>#P-complete</li>
</ul>
</li>
<li>IP</li>
<li>PSPACE
<ul>
<li>PSPACE-complete</li>
</ul>
</li>
</ul>
<ul>
<li>NP-complete</li>
<li>NP-hard</li>
<li>co-NP</li>
<li>co-NP-complete</li>
</ul>
<ul>
<li>#P-complete</li>
</ul>
<ul>
<li>PSPACE-complete</li>
</ul>
<ul>
<li>EXPTIME</li>
<li>NEXPTIME</li>
<li>EXPSPACE</li>
<li>ELEMENTARY</li>
<li>PR</li>
<li>R</li>
<li>RE</li>
<li>ALL</li>
</ul>
<ul>
<li>Polynomial hierarchy</li>
<li>Exponential hierarchy</li>
<li>Grzegorczyk hierarchy</li>
<li>Arithmetical hierarchy</li>
<li>Boolean hierarchy</li>
</ul>
<ul>
<li>DTIME</li>
<li>NTIME</li>
<li>DSPACE</li>
<li>NSPACE</li>
<li>Probabilistically checkable proof</li>
<li>Interactive proof system</li>
</ul>
</body>
</html>