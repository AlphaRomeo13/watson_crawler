<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Block-programming---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Block (programming)</h1>
<ul>
<li>Action</li>
<li>Agent-oriented</li>
<li>Aspect-oriented</li>
<li>Automata-based</li>
<li>Concurrent computing
<ul>
<li>Relativistic programming</li>
</ul>
</li>
<li>Data-driven</li>
<li>Declarative (contrast: Imperative)
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
</li>
<li>End-user programming</li>
<li>Event-driven
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
</li>
<li>Expression-oriented</li>
<li>Feature-oriented</li>
<li>Function-level (contrast: Value-level)</li>
<li>Generic</li>
<li>Imperative (contrast: Declarative)
<ul>
<li>Procedural</li>
</ul>
</li>
<li>Language-oriented
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
</li>
<li>Metaprogramming
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
</li>
<li>Non-structured (contrast: Structured)
<ul>
<li>Array</li>
</ul>
</li>
<li>Nondeterministic</li>
<li>Parallel computing
<ul>
<li>Process-oriented</li>
</ul>
</li>
<li>Point-free style
<ul>
<li>Concatenative</li>
</ul>
</li>
<li>Semantic</li>
<li>Structured (contrast: Non-structured)
<ul>
<li><strong class="selflink">Block-structured</strong></li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
</li>
<li>Value-level (contrast: Function-level)</li>
<li>Probabilistic</li>
<li>Concept</li>
</ul>
<ul>
<li>Relativistic programming</li>
</ul>
<ul>
<li>Constraint</li>
<li>Dataflow
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
</li>
<li>Functional
<ul>
<li>Functional logic</li>
</ul>
</li>
<li>Logic
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
</li>
<li>Relational</li>
</ul>
<ul>
<li>Flow-based</li>
<li>Cell-oriented (spreadsheets)</li>
<li>Reactive</li>
</ul>
<ul>
<li>Functional logic</li>
</ul>
<ul>
<li>Abductive logic</li>
<li>Answer set</li>
<li>Constraint logic</li>
<li>Functional logic</li>
<li>Inductive logic</li>
</ul>
<ul>
<li>Service-oriented</li>
<li>Time-driven</li>
</ul>
<ul>
<li>Procedural</li>
</ul>
<ul>
<li>Natural language programming</li>
<li>Discipline-specific</li>
<li>Domain-specific</li>
<li>Grammar-oriented
<ul>
<li>Dialecting</li>
</ul>
</li>
<li>Intentional</li>
</ul>
<ul>
<li>Dialecting</li>
</ul>
<ul>
<li>Automatic</li>
<li>Reflective
<ul>
<li>Attribute-oriented</li>
</ul>
</li>
<li>Homoiconic</li>
<li>Template
<ul>
<li>Policy-based</li>
</ul>
</li>
</ul>
<ul>
<li>Attribute-oriented</li>
</ul>
<ul>
<li>Policy-based</li>
</ul>
<ul>
<li>Array</li>
</ul>
<ul>
<li>Process-oriented</li>
</ul>
<ul>
<li>Concatenative</li>
</ul>
<ul>
<li><strong class="selflink">Block-structured</strong></li>
<li>Modular (contrast: Monolithic)</li>
<li>Object-oriented (OOP)
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
</li>
<li>Recursive</li>
</ul>
<ul>
<li>By separation of concerns:
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
</li>
<li>Class-based</li>
<li>Prototype-based</li>
</ul>
<ul>
<li>Aspect-oriented</li>
<li>Role-oriented</li>
<li>Subject-oriented</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computer programming, a <b>block</b> is a section of code which is grouped together. Blocks consist of one or more declarations and statements. A programming language that permits the creation of blocks, including blocks nested within other blocks, is called a <b>block-structured programming language</b>. Blocks are fundamental to structured programming, where control structures are formed from blocks.</p>
<p>The function of blocks in programming is to enable groups of statements to be treated as if they were one statement, and to narrow the lexical scope of variables, procedures and functions declared in a block so that they do not conflict with variables having the same name used elsewhere in a program for different purposes. In a block-structured programming language, the names of variables and other objects such as procedures which are declared in outer blocks are visible inside other inner blocks, unless they are shadowed by an object of the same name.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Syntax</li>
<li>3 Limitations</li>
<li>4 Basic semantics</li>
<li>5 See also</li>
<li>6 References</li>
</ul>
<p></p>
<h2>History</h2>
<p>Ideas of block structure were developed in the 1950s during the development of the first autocodes, and were formalized in the Algol 58 and Algol 60 reports. Algol 58 introduced the notion of the "compound statement", which was related solely to control flow. The subsequent <i>Revised Report</i> which described the syntax and semantics of Algol 60 introduced the notion of a block and block scope, with a block consisting of " A sequence of declarations followed by a sequence of statements and enclosed between begin and end..." in which "[e]very declaration appears in a block in this way and is valid only for that block."</p>
<h2>Syntax</h2>
<p>Blocks use different syntax in different languages. Two broad families are:</p>
<ul>
<li>the ALGOL family in which blocks are delimited by the keywords "<code>begin</code>" and "<code>end</code>"</li>
<li>the C family in which blocks are delimited by curly braces - "<code>{</code>" and "<code>}</code>"</li>
</ul>
<p>Some other techniques used are:</p>
<ul>
<li>parentheses - "<code>(</code>" and "<code>)</code>", as in batch language</li>
<li>indentation, as in Python</li>
<li>s-expressions with a syntactic keyword such as <code>lambda</code> or <code>let</code> (as in the Lisp family)</li>
</ul>
<h2>Limitations</h2>
<p>Some languages which support blocks with variable declarations do not fully support all declarations; for instance many C-derived languages do not permit a function definition within a block (nested functions). And unlike its ancestor Algol, Pascal does not support the use of blocks with their own declarations inside the begin and end of an existing block, only compound statements enabling sequences of statements to be grouped together in <b>if</b>, <b>while</b>, <b>repeat</b> and other control statements.</p>
<h2>Basic semantics</h2>
<p>The semantic meaning of a block is twofold. Firstly, it provides the programmer with a way of creating arbitrarily large and complex structures which can be treated as units. Secondly it enables the programmer to limit the scope of variables and sometimes other objects that have been declared.</p>
<p>In primitive languages such as early Fortran and Basic, there were a few built-in statement types, and little or no means of extending them in a structured manner. For instance until 1978 standard Fortran had no "block if" statement, so to write a standard-complying code to implement simple decisions the programmer had to resort to gotos.</p>
<p>WHATSON? b7d0f3f9-122d-444e-a639-2496304eeab4</p>
<pre>
C     LANGUAGE: ANSI STANDARD FORTRAN 66
C     INITIALIZE VALUES TO BE CALCULATED
      PAYSTX = .FALSE.
      PAYSST = .FALSE.
      TAX = 0.0
      SUPTAX = 0.0
C     SKIP TAX DEDUCTION IF EMPLOYEE EARNS LESS THAN TAX THRESHOLD
      IF (WAGES .LE. TAXTHR) GOTO 100
      PAYSTX = .TRUE.
      TAX = (WAGES - TAXTHR) * BASCRT
C     SKIP SUPERTAX DEDUCTION IF EMPLOYEE EARNS LESS THAN SUPERTAX THRESHOLD
      IF (WAGES .LE. SUPTHR) GOTO 100
      PAYSST = .TRUE.
      SUPTAX = (WAGES - SUPTHR) * SUPRAT
  100 TAXED = WAGES - TAX - SUPTAX
</pre>
<p>Even in this very brief Fortran fragment, written to the Fortran 66 standard, it is not easy to see the structure of the program, because that structure is not reflected in the language. Without careful study it is not easy to see the circumstances in which a given statement is executed.</p>
<p>Blocks allow the programmer to treat a group of statements as a unit, and the default values which had to appear in initialization in this style of programming can, with a block structure, be placed closer to the decision:</p>
<p>WHATSON? 9cd70cbc-a321-486d-adbd-7de6a035dc66</p>
<pre>
    { Language: Jensen and Wirth Pascal }
    if wages &gt; tax_threshold then
        begin
        paystax := true;
        tax := (wages - tax_threshold) * tax_rate
        { The block structure makes it easier to see how the code could
          be refactored for clarity, and also makes it easier to do,
          because the structure of the inner conditional can easily be moved
          out of the outer conditional altogether and the effects of doing
          so are easily predicted. }
        if wages &gt; supertax_threshold then
            begin
            pays_supertax := true;
            supertax := (wages - supertax_threshold) * supertax_rate
            end
        else begin
            pays_supertax := false;
            supertax := 0
            end
        end
    else begin
        paystax := false; pays_supertax := false;
        tax := 0; supertax := 0
        end;
    taxed := wages - tax - supertax;
</pre>
<p>Use of blocks in the above fragment of Pascal enables the programmer to be clearer about what he intends, and to combine the resulting blocks into a nested hierarchy of conditional statements. The structure of the code reflects the programmer's thinking more closely, making it easier to understand and modify.</p>
<p>From looking at the above code the programmer can easily see that he can make the source code even clearer by taking the inner if statement out of the outer one altogether, placing the two blocks one after the other to be executed consecutively. Semantically there is little difference in this case, and the use of block structure, supported by indenting for readability, makes it easy for the programmer to refactor the code.</p>
<p>In primitive languages, variables had broad scope. For instance, an integer variable called IEMPNO might be used in one part of a Fortran subroutine to denote an employee social security number (ssn), but during maintenance work on the same subroutine, a programmer might accidentally use the same variable, IEMPNO, for a different purpose, and this could result in a bug that was difficult to trace. Block structure makes it easier for programmers to control scope to a minute level.</p>
<p>WHATSON? d518defd-7932-4223-a83d-bffe22a13deb</p>
<pre>
;; Language: R5RS Standard Scheme
(let ((empno (ssn-of employee-name)))
  (while (is-manager empno)
    (let ((employees (length (underlings-of empno))))
      (printf "~a has ~a employees working under him:~%" employee-name employees)
      (for-each
        (lambda(empno)
          ;; Within this lambda expression the variable empno refers to the ssn
          ;; of an underling.  The variable empno in the outer expression,
          ;; referring to the manager's ssn, is shadowed.
          (printf "Name: ~a, role: ~a~%"
                  (name-of empno)
                  (role-of empno)))
        (underlings-of empno)))))
</pre>
<p>In the above Scheme fragment, empno is used to identify both the manager and his underlings each by their respective ssn, but because the underling ssn is declared within an inner block it does not interact with the variable of the same name that contains the manager's ssn. In practice considerations of clarity would probably lead the programmer to choose distinct variable names, but he has the choice and it is more difficult for him to inadvertently introduce a bug.</p>
<h2>See also</h2>
<ul>
<li>Basic block</li>
<li>Block scope</li>
<li>Closure (computer science)</li>
<li>Control flow</li>
</ul>
</body>
</html>