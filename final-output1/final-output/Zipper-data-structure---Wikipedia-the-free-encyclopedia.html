<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Zipper-data-structure---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Zipper (data structure)</h1>
<p>A <b>zipper</b> is a technique of representing an aggregate data structure so that it is convenient for writing programs that traverse the structure arbitrarily and update its contents, especially in purely functional programming languages. The zipper was described by Gérard Huet in 1997. It includes and generalizes the gap buffer technique sometimes used with arrays.</p>
<p>The zipper technique is general in the sense that it can be adapted to lists, trees, and other recursively defined data structures. Such modified data structures are usually referred to as "a tree with zipper" or "a list with zipper" to emphasize that the structure is conceptually a tree or list, while the zipper is a detail of the implementation.</p>
<p>A layman's explanation for a tree with zipper would be an ordinary computer filesystem with operations to go to parent (often <code>cd ..</code>), and the possibility to go downwards (<code>cd subdirectory</code>). The zipper is the pointer to the current path. Behind the scenes the zippers are efficient when making (functional) changes to a data structure, where a new, slightly changed, data structure is returned from an edit operation (instead of making a change in the current data structure).</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Example: Bidirectional list traversal</li>
<li>2 Uses</li>
<li>3 Zipper contexts and differentiation</li>
<li>4 Alternatives and extensions
<ul>
<li>4.1 Direct modification</li>
<li>4.2 Generic zipper</li>
</ul>
</li>
<li>5 References</li>
<li>6 Further reading</li>
<li>7 External links</li>
</ul>
<ul>
<li>4.1 Direct modification</li>
<li>4.2 Generic zipper</li>
</ul>
<p></p>
<h2>Example: Bidirectional list traversal</h2>
<p>Many common data structures in computer science can be expressed as the structure generated by a few primitive constructor operations or observer operations. These include the structure of finite lists, which can be generated by two operations:</p>
<ul>
<li>Empty: Constructs an empty list</li>
<li>Insert(x, L): Constructs a list by inserting value x in front of list L</li>
</ul>
<p>The list [1, 2, 3] is then constructed as Insert(1, Insert(2, Insert(3, Empty))). It is possible to describe the location of a value in a list as the number of steps from the front of the list to that value. More formally, a location is the number of additional Insert operations used to construct the whole list, after a particular value was inserted.</p>
<p>A context for a location in the list is constructed by recording not just the number of Insert operations, but all of the other information about them—namely, the values that were inserted. These are represented in a separate list that is reversed from the order of the original data structure. Specifically, the context of "3" in the list [1, 2, 3] is represented as [2, 1]. A list with a zipper represents the entire structure, and a location within the structure. This is a pair consisting of the location's context, and the part of the structure that begins at the location. The list [1, 2, 3, 4] with a reference to the "3" is represented as ([2, 1], [3, 4]).</p>
<p>With the list represented this way, it is easy to define efficient operations that move the location forward or backward and manipulate the list at that location, for example by inserting or removing items. Similarly, applying the zipper transformation to a tree makes it easy to insert or remove values at a particular location in the tree.</p>
<h2>Uses</h2>
<p>The zipper is often used where there is some concept of 'focus' or of moving around in some set of data, since its semantics reflect that of moving around but in a functional non-destructive manner.</p>
<p>The zipper has been used in</p>
<ul>
<li>Xmonad, to manage focus and placement of windows</li>
<li>Huet's papers cover a structural editor based on zippers and a theorem prover</li>
<li>A filesystem (ZipperFS) written in Haskell offering "...transactional semantics; undo of any file and directory operation; snapshots; statically guaranteed the strongest, repeatable read, isolation mode for clients; pervasive copy-on-write for files and directories; built-in traversal facility; and just the right behavior for cyclic directory references."</li>
<li>Clojure has extensive support for zippers. </li>
</ul>
<h2>Zipper contexts and differentiation</h2>
<p>It has been shown that the type of the items in the context list produced by the zipper transformation is the "derivative" of the original type in a sense that is related to differentiation in calculus by decategorification. Most datatypes are constructed from products and sums of datatypes; any given datatype looks like a polynomial or a Taylor series, and the representation of the type of context items looks like the derivative of that polynomial or series. In a recursive datatype like a list or a tree, the derivative is taken with respect to the recursion variable.</p>
<p>Consider a recursive data structure like a binary tree labeled by data of type A.</p>
<p>That is, a tree is either empty, or a triple consisting of a value of type <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> and two subtrees of type <img class="mwe-math-fallback-image-inline tex" alt="R" src="//upload.wikimedia.org/math/e/1/e/e1e1d3d40573127e9ee0480caf1283d6.png">. The datatype of the context is</p>
<p>By taking the fixed point <img class="mwe-math-fallback-image-inline tex" alt="R = T(A, R)," src="//upload.wikimedia.org/math/4/0/6/406f05649dba77f9e48f870c917a2d5a.png"> we find that a zipper for a tree consists of a "path" and a downward subtree, where a path is a context list of triples consisting of</p>
<ul>
<li>a value for the root of the tree (type A)</li>
<li>a choice of left or right subtree in which to find the hole (type 2), and</li>
<li>the value of the other subtree (type R).</li>
</ul>
<p>In general, then, a zipper for a datatype <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> parameterized by some other type <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> and a recursion variable <img class="mwe-math-fallback-image-inline tex" alt="R" src="//upload.wikimedia.org/math/e/1/e/e1e1d3d40573127e9ee0480caf1283d6.png"> consists of two parts: a context list with items of type <img class="mwe-math-fallback-image-inline tex" alt="\frac{d T(A, R)}{dR}|_{R = T(A, R)}" src="//upload.wikimedia.org/math/5/0/c/50cd6fc0d4543e8e12c46509dd385b81.png"> and a copy of the downward substructure <img class="mwe-math-fallback-image-inline tex" alt="T(A,R)|_{R = T(A,R)}." src="//upload.wikimedia.org/math/4/2/c/42c7f3922d1f9533100436e235acefdb.png"></p>
<h2>Alternatives and extensions</h2>
<h3>Direct modification</h3>
<p>In a non-purely-functional programming language, it may be more convenient to simply traverse the original data structure and modify it directly (perhaps after deep cloning it, to avoid affecting other code that might hold a reference to it).</p>
<h3>Generic zipper</h3>
<p>The Generic Zipper is a technique to achieve the same goal as the conventional zipper by capturing the state of the traversal in a continuation while visiting each node. (The Haskell code given in the reference uses generic programming to generate a traversal function for any data structure, but this is optional – any suitable traversal function can be used.)</p>
<p>However, the Generic Zipper involves inversion of control, so some uses of it require a state machine (or equivalent) to keep track of what to do next.</p>
</body>
</html>