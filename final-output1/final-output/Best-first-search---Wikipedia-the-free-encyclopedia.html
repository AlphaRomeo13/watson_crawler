<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Best-first-search---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Best-first search</h1>
<ul>
<li>α–β</li>
<li>A*</li>
<li>B*</li>
<li>Backtracking</li>
<li>Beam</li>
<li>Bellman–Ford</li>
<li><strong class="selflink">Best-first</strong></li>
<li>Bidirectional</li>
<li>Borůvka</li>
<li>Branch &amp; bound</li>
<li>BFS</li>
<li>British Museum</li>
<li>D*</li>
<li>DFS</li>
<li>Depth-limited</li>
<li>Dijkstra</li>
<li>Edmonds</li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Hill climbing</li>
<li>IDA*</li>
<li>Iterative deepening</li>
<li>Johnson</li>
<li>Jump point</li>
<li>Kruskal</li>
<li>Lexicographic BFS</li>
<li>Prim</li>
<li>SMA*</li>
<li>Uniform-cost</li>
</ul>
<ul>
<li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li>
</ul>
<ul>
<li>Dynamic programming</li>
<li>Graph traversal</li>
<li>Tree traversal</li>
<li>Search games</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p><b>Best-first search</b> is a search algorithm which explores a graph by expanding the most promising node chosen according to a specified rule.</p>
<p>Judea Pearl described best-first search as estimating the promise of node <i>n</i> by a "heuristic evaluation function <img class="mwe-math-fallback-image-inline tex" alt="f(n)" src="//upload.wikimedia.org/math/a/8/9/a8988ce0f88f5292aa28b6e49f114d45.png"> which, in general, may depend on the description of <i>n</i>, the description of the goal, the information gathered by the search up to that point, and most important, on any extra knowledge about the problem domain."</p>
<p>Some authors have used "best-first search" to refer specifically to a search with a heuristic that attempts to predict how close the end of a path is to a solution, so that paths which are judged to be closer to a solution are extended first. This specific type of search is called <b>greedy best-first search</b>.</p>
<p>Efficient selection of the current best candidate for extension is typically implemented using a priority queue.</p>
<p>The A* search algorithm is an example of best-first search, as is B*. Best-first algorithms are often used for path finding in combinatorial search. (Note that neither A* nor B* is a greedy best-first search as they incorporate the distance from start in addition to estimated distances to the goal.)</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Algorithm</li>
<li>2 Greedy BFS</li>
<li>3 See also</li>
<li>4 References</li>
<li>5 External links</li>
</ul>
<p></p>
<h2>Algorithm</h2>
<p>An algorithm implementing best-first search follows.</p>
<p>WHATSON? f47826a9-dca8-4e41-b0cd-fc263a5e7521</p>
<pre>
OPEN = [initial state]
while OPEN is not empty or until a goal is found
do
 1. Remove the best node from OPEN, call it n.
 2. If n is the goal state, backtrace path to n (through recorded parents) and return path.
 3. Create n's successors.
 4. Evaluate each successor, add it to OPEN, and record its parent.
done
</pre>
<p>Note that this version of the algorithm is not <i>complete</i>, i.e. it does not always find a possible path between two nodes, even if there is one. For example, it gets stuck in a loop if it arrives at a dead end, that is a node with the only successor being its parent. It would then go back to its parent, add the dead-end successor to the <code>OPEN</code> list again, and so on.</p>
<p>The following version extends the algorithm to use an additional <code>CLOSED</code> list, containing all nodes that have been evaluated and will not be looked at again. As this will avoid any node being evaluated twice, it is not subject to infinite loops.</p>
<p>WHATSON? e9cce681-3782-4d2d-bd89-7900cc15ae55</p>
<pre>
OPEN = [initial state]
CLOSED = []
while OPEN is not empty
do
 1. Remove the best node from OPEN, call it n, add it to CLOSED.
 2. If n is the goal state, backtrace path to n (through recorded parents) and return path.
 3. Create n's successors.
 4. For each successor do:
       a. If it is not in CLOSED and it is not in OPEN: evaluate it, add it to OPEN, and record its parent.
       b. Otherwise, if this new path is better than previous one, change its recorded parent.
          i.  If it is not in OPEN add it to OPEN.
          ii. Otherwise, adjust its priority in OPEN using this new evaluation.
done
</pre>
<p>Also note that the given pseudo code of both versions just terminates when no path is found. An actual implementation would of course require special handling of this case.</p>
<h2>Greedy BFS</h2>
<p>Using a greedy algorithm, expand the first successor of the parent. After a successor is generated:</p>
<ol>
<li>If the successor's heuristic is better than its parent, the successor is set at the front of the queue (with the parent reinserted directly behind it), and the loop restarts.</li>
<li>Else, the successor is inserted into the queue (in a location determined by its heuristic value). The procedure will evaluate the remaining successors (if any) of the parent.</li>
</ol>
<h2>See also</h2>
<ul>
<li>Beam search</li>
<li>A* search algorithm</li>
<li>Dijkstra's algorithm</li>
</ul>
</body>
</html>