<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Computation-tree-logic---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Computation tree logic</h1>
<p><b>Computation tree logic (CTL)</b> is a branching-time logic, meaning that its model of time is a tree-like structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized. It is used in formal verification of software or hardware artifacts, typically by software applications known as model checkers which determine if a given artifact possesses safety or liveness properties. For example, CTL can specify that when some initial condition is satisfied (e.g., all program variables are positive or no cars on a highway straddle two lanes), then all possible executions of a program avoid some undesirable condition (e.g., dividing a number by zero or two cars colliding on a highway). In this example, the safety property could be verified by a model checker that explores all possible transitions out of program states satisfying the initial condition and ensures that all such executions satisfy the property. Computation tree logic is in a class of temporal logics that includes linear temporal logic (LTL). Although there are properties expressible in only one of CTL and LTL, all properties expressible in either logic can also be expressed in CTL*.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Syntax of CTL</li>
<li>2 Operators
<ul>
<li>2.1 Logical operators</li>
<li>2.2 Temporal operators</li>
<li>2.3 Minimal set of operators</li>
</ul>
</li>
<li>3 Semantics of CTL
<ul>
<li>3.1 Definition</li>
<li>3.2 Characterisation of CTL</li>
<li>3.3 Semantic equivalences</li>
</ul>
</li>
<li>4 Examples</li>
<li>5 Relations with other logics</li>
<li>6 See also</li>
<li>7 References</li>
<li>8 External links</li>
</ul>
<ul>
<li>2.1 Logical operators</li>
<li>2.2 Temporal operators</li>
<li>2.3 Minimal set of operators</li>
</ul>
<ul>
<li>3.1 Definition</li>
<li>3.2 Characterisation of CTL</li>
<li>3.3 Semantic equivalences</li>
</ul>
<p></p>
<h2>Syntax of CTL</h2>
<p>The language of well formed formulas for CTL is generated by the following grammar:</p>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> ranges over a set of atomic formulas. Not all of these connectives are needed – for example, <img class="mwe-math-fallback-image-inline tex" alt="\{\neg, \and, \mbox{AX}, \mbox{AU}, \mbox{EU}\}" src="//upload.wikimedia.org/math/3/a/c/3ac1a67e249b64d6aea1fd0793ed4656.png"> comprises a complete set of connectives, and the others can be defined using them.</p>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\mbox{A}" src="//upload.wikimedia.org/math/b/7/0/b708048376ee72602c6369d3f5f301db.png"> means 'along All paths' <i>(Inevitably)</i></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\mbox{E}" src="//upload.wikimedia.org/math/a/f/1/af11b311d7927699716bf16ad1b5f871.png"> means 'along at least (there Exists) one path' <i>(possibly)</i></li>
</ul>
<p>For example, the following is a well-formed CTL formula:</p>
<p>The following is not a well-formed CTL formula:</p>
<p>The problem with this string is that <img class="mwe-math-fallback-image-inline tex" alt="U" src="//upload.wikimedia.org/math/4/c/6/4c614360da93c0a041b22e537de151eb.png"> can occur only when paired with an <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> or an <img class="mwe-math-fallback-image-inline tex" alt="E" src="//upload.wikimedia.org/math/3/a/3/3a3ea00cfc35332cedf6e5e9a32e94da.png">. It uses atomic propositions as its building blocks to make statements about the states of a system. CTL then combines these propositions into formulas using logical operators and temporal logics.</p>
<h2>Operators</h2>
<h3>Logical operators</h3>
<p>The logical operators are the usual ones: <img class="mwe-math-fallback-image-inline tex" alt="\neg,\or,\and,\Rightarrow" src="//upload.wikimedia.org/math/5/6/b/56b82cfaa064032a7a924b4537f7d709.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\Leftrightarrow" src="//upload.wikimedia.org/math/0/1/4/014cced2b73c22eb88cdc6901afb0c9d.png">. Along with these operators CTL formulas can also make use of the boolean constants true and false.</p>
<h3>Temporal operators</h3>
<p>The temporal operators are the following:</p>
<ul>
<li>Quantifiers over paths
<ul>
<li><b>A</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>A</b>ll: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold on all paths starting from the current state.</li>
<li><b>E</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>E</b>xists: there exists at least one path starting from the current state where <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> holds.</li>
</ul>
</li>
<li>Path-specific quantifiers
<ul>
<li><b>X</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – Ne<b>x</b>t: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold at the next state (this operator is sometimes noted <b>N</b> instead of <b>X</b>).</li>
<li><b>G</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>G</b>lobally: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold on the entire subsequent path.</li>
<li><b>F</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>F</b>inally: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> eventually has to hold (somewhere on the subsequent path).</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> <b>U</b> <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> – <b>U</b>ntil: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold <i>at least</i> until at some position <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> holds. This implies that <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> will be verified in the future.</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> <b>W</b> <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> – <b>W</b>eak until: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold until <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> holds. The difference with <b>U</b> is that there is no guarantee that <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> will ever be verified. The <b>W</b> operator is sometimes called "unless".</li>
</ul>
</li>
</ul>
<ul>
<li><b>A</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>A</b>ll: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold on all paths starting from the current state.</li>
<li><b>E</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>E</b>xists: there exists at least one path starting from the current state where <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> holds.</li>
</ul>
<ul>
<li><b>X</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – Ne<b>x</b>t: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold at the next state (this operator is sometimes noted <b>N</b> instead of <b>X</b>).</li>
<li><b>G</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>G</b>lobally: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold on the entire subsequent path.</li>
<li><b>F</b> <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> – <b>F</b>inally: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> eventually has to hold (somewhere on the subsequent path).</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> <b>U</b> <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> – <b>U</b>ntil: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold <i>at least</i> until at some position <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> holds. This implies that <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> will be verified in the future.</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> <b>W</b> <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> – <b>W</b>eak until: <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> has to hold until <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> holds. The difference with <b>U</b> is that there is no guarantee that <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> will ever be verified. The <b>W</b> operator is sometimes called "unless".</li>
</ul>
<p>In CTL*, the temporal operators can be freely mixed. In CTL, the operator must always be grouped in two: one path operator followed by a state operator. See the examples below. CTL* is strictly more expressive than CTL.</p>
<h3>Minimal set of operators</h3>
<p>In CTL there is a minimal set of operators. All CTL formulas can be transformed to use only those operators. This is useful in model checking. One minimal set of operators is: {true, <img class="mwe-math-fallback-image-inline tex" alt="\or, \neg" src="//upload.wikimedia.org/math/2/e/8/2e8f3e078bc6d8d5fb7615fbb6f0a773.png">, <b>EG</b>, <b>EU</b>, <b>EX</b>}.</p>
<p>Some of the transformation used for temporal operator are:</p>
<ul>
<li><b>EF</b><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> == <b>E</b>[true<b>U</b>(<img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">)] ( because <b>F</b><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> == [true<b>U</b>(<img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">)] )</li>
<li><b>AX</b><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> == <img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><b>EX</b>(<img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">)</li>
<li><b>AG</b><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> == <img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><b>EF</b>(<img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">) == <img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"> <b>E</b>[true<b>U</b>(<img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">)]</li>
<li><b>AF</b><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> == <b>A</b>[true<b>U</b><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">] == <img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><b>EG</b>(<img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">)</li>
<li><b>A</b>[<img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"><b>U</b><img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png">] == <img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png">( <b>E</b>[(<img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png">)<b>U</b><img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png">(<img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"><img class="mwe-math-fallback-image-inline tex" alt="\or" src="//upload.wikimedia.org/math/5/a/d/5addb134385e47a2efa484f6306e75a1.png"><img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png">)] <img class="mwe-math-fallback-image-inline tex" alt="\or" src="//upload.wikimedia.org/math/5/a/d/5addb134385e47a2efa484f6306e75a1.png"> <b>EG</b>(<img class="mwe-math-fallback-image-inline tex" alt="\neg" src="//upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png"><img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png">) )</li>
</ul>
<h2>Semantics of CTL</h2>
<h3>Definition</h3>
<p>CTL formulae are interpreted over Transition Systems. A transition system is a triple <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{M}=(S,\rightarrow,L)" src="//upload.wikimedia.org/math/5/1/9/519f3dfa998d953bf1e1c37b880f3a8b.png">, where <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> is a set of states, <img class="mwe-math-fallback-image-inline tex" alt="\rightarrow \subseteq S \times S" src="//upload.wikimedia.org/math/9/7/6/976262be775ee7273a33b43808e6e9d7.png"> is a transition relation, assumed to be serial, i.e. every state has at least one successor, and <img class="mwe-math-fallback-image-inline tex" alt="L" src="//upload.wikimedia.org/math/d/2/0/d20caec3b48a1eef164cb4ca81ba2587.png"> is a labelling function, assigning propositional letters to states. Let <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{M}=(S,\rightarrow,L)" src="//upload.wikimedia.org/math/5/1/9/519f3dfa998d953bf1e1c37b880f3a8b.png"> be such a transition model</p>
<p>Then the relation of semantic entailment <img class="mwe-math-fallback-image-inline tex" alt="(\mathcal{M}, s \models \phi)" src="//upload.wikimedia.org/math/9/c/9/9c97905faec1bba293f1e8c438b92918.png"> is defined by structural induction on <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png">:</p>
<ol>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models \top \Big) \Leftrightarrow \Big( (\mathcal{M}, s) \not\models \bot \Big)" src="//upload.wikimedia.org/math/1/c/3/1c3c4f588c72babf1d36731261b2cf82.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models p \Big) \Leftrightarrow \Big( p \in L(s) \Big)" src="//upload.wikimedia.org/math/1/0/2/1024fe169c2129425862846041a579ad.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models \neg\phi \Big) \Leftrightarrow \Big( (\mathcal{M}, s) \not\models \phi \Big)" src="//upload.wikimedia.org/math/e/9/a/e9a5b5a81ad82d114e076d3725af11cd.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models \phi_1 \land \phi_2 \Big) \Leftrightarrow \Big( \big((\mathcal{M}, s) \models \phi_1 \big) \land \big((\mathcal{M}, s) \models \phi_2 \big) \Big)" src="//upload.wikimedia.org/math/b/a/d/badbcdb47dc453ca7b80c9667bd73c26.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models \phi_1 \lor \phi_2 \Big) \Leftrightarrow \Big( \big((\mathcal{M}, s) \models \phi_1 \big) \lor \big((\mathcal{M}, s) \models \phi_2 \big) \Big)" src="//upload.wikimedia.org/math/4/5/7/457affc0caf981dddc4f3797d43dc399.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models \phi_1 \Rightarrow \phi_2 \Big) \Leftrightarrow \Big( \big((\mathcal{M}, s) \not\models \phi_1 \big) \lor \big((\mathcal{M}, s) \models \phi_2 \big) \Big)" src="//upload.wikimedia.org/math/2/9/8/298768d41aeb1823171ad53bff4eb211.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\bigg( (\mathcal{M}, s) \models \phi_1 \Leftrightarrow \phi_2 \bigg) \Leftrightarrow \bigg( \Big( \big((\mathcal{M}, s) \models \phi_1 \big) \land \big((\mathcal{M}, s) \models \phi_2 \big) \Big) \lor \Big( \neg \big((\mathcal{M}, s) \models \phi_1 \big) \land \neg \big((\mathcal{M}, s) \models \phi_2 \big) \Big) \bigg)" src="//upload.wikimedia.org/math/7/5/8/75851ac7467d6b393221f4045f6d7a4c.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models AX\phi \Big) \Leftrightarrow \Big( \forall \langle s \rightarrow s_1 \rangle \big( (\mathcal{M}, s_1) \models \phi \big) \Big)" src="//upload.wikimedia.org/math/4/b/9/4b9d63ef85e1071969ae99ec3378d55e.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models EX\phi \Big) \Leftrightarrow \Big( \exists \langle s \rightarrow s_1 \rangle \big( (\mathcal{M}, s_1) \models \phi \big) \Big)" src="//upload.wikimedia.org/math/3/9/d/39d832a9248bce974174a8ee547b0572.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models AG\phi \Big) \Leftrightarrow \Big( \forall \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \forall i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)" src="//upload.wikimedia.org/math/6/6/b/66bfd4a29e7a656192ce57ee6423ff03.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models EG\phi \Big) \Leftrightarrow \Big( \exists \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \forall i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)" src="//upload.wikimedia.org/math/6/1/e/61e61e16a30e1d6a96b00a5aaeba40ef.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models AF\phi \Big) \Leftrightarrow \Big( \forall \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)" src="//upload.wikimedia.org/math/8/f/4/8f46eb551fb11c7c2ba643753e4495f5.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\Big( (\mathcal{M}, s) \models EF\phi \Big) \Leftrightarrow \Big( \exists \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)" src="//upload.wikimedia.org/math/9/c/c/9cc044c74f2840bd43051c5bb45d9b2c.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\bigg( (\mathcal{M}, s) \models A[\phi_1 U \phi_2] \bigg) \Leftrightarrow \bigg( \forall \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \Big( \big( (\mathcal{M}, s_i) \models \phi_2 \big) \land \big( \forall (j &lt; i) (\mathcal{M}, s_j) \models \phi_1 \big) \Big) \bigg)" src="//upload.wikimedia.org/math/6/8/8/688e0b25337128b166e8b21b492df891.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\bigg( (\mathcal{M}, s) \models E[\phi_1 U \phi_2] \bigg) \Leftrightarrow \bigg( \exists \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \Big( \big( (\mathcal{M}, s_i) \models \phi_2 \big) \land \big( \forall (j &lt; i) (\mathcal{M}, s_j) \models \phi_1 \big) \Big) \bigg)" src="//upload.wikimedia.org/math/3/8/8/3881786637b813067edbf55aafbbd8c5.png"></li>
</ol>
<h3>Characterisation of CTL</h3>
<p>Rules 10–15 above refer to computation paths in models and are what ultimately characterise the "Computation Tree"; they are assertions about the nature of the infinitely deep computation tree rooted at the given state <img class="mwe-math-fallback-image-inline tex" alt="s" src="//upload.wikimedia.org/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png">.</p>
<h3>Semantic equivalences</h3>
<p>The formulae <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\psi" src="//upload.wikimedia.org/math/1/9/d/19df1c2726ed43128440c1157f72a937.png"> are said to be semantically equivalent if any state in any model which satisfies one also satisfies the other. This is denoted <img class="mwe-math-fallback-image-inline tex" alt="\phi \equiv \psi" src="//upload.wikimedia.org/math/4/f/d/4fdbeb0d280863369900fc81a2a8d087.png"></p>
<p>It can be seen that A and E are duals, being universal and existential computation path quantifiers respectively: <img class="mwe-math-fallback-image-inline tex" alt="\neg A\phi \equiv E \neg \phi " src="//upload.wikimedia.org/math/e/a/9/ea9a6ec9fe2b1de82b30992053b3d3d0.png">.</p>
<p>Furthermore so are G and F.</p>
<p>Hence an instance of De Morgan's Laws can be formulated in CTL:</p>
<p>It can be shown using such identities that a subset of the CTL temporal connectives is adequate if it contains <img class="mwe-math-fallback-image-inline tex" alt="EU" src="//upload.wikimedia.org/math/f/2/e/f2e6e3b9bff59f293f0e9019a1ecabc5.png">, at least one of <img class="mwe-math-fallback-image-inline tex" alt="\{AX,EX\}" src="//upload.wikimedia.org/math/5/2/a/52ad59b81e3b79041bbf26300db6ef0c.png"> and at least one of <img class="mwe-math-fallback-image-inline tex" alt="\{EG,AF,AU\}" src="//upload.wikimedia.org/math/0/3/7/037342e71c300f6ba4b66ba429a1906e.png"> and the boolean connectives.</p>
<p>The important equivalences below are called the expansion laws; they allow to unfold the verification of a CTL connective towards its successors in time.</p>
<h2>Examples</h2>
<p>Let "P" mean "I like chocolate" and Q mean "It's warm outside."</p>
<ul>
<li><b>AG</b>.P</li>
</ul>
<ul>
<li><b>EF</b>.P</li>
</ul>
<ul>
<li><b>AF</b>.<b>EG</b>.P</li>
</ul>
<ul>
<li><b>EG</b>.<b>AF</b>.P</li>
</ul>
<p>The two following examples show the difference between CTL and CTL*, as they allow for the until operator to not be qualified with any path operator (<b>A</b> or <b>E</b>):</p>
<ul>
<li><b>AG</b>(P<b>U</b>Q)</li>
</ul>
<ul>
<li><b>EF</b>((<b>EX</b>.P)<b>U</b>(<b>AG</b>.Q))</li>
</ul>
<h2>Relations with other logics</h2>
<p>Computation tree logic (CTL) is a subset of CTL* as well as of the modal µ calculus. CTL is also a fragment of Alur, Henzinger and Kupferman's Alternating-time Temporal Logic (ATL).</p>
<p>Computation tree logic (CTL) and Linear temporal logic (LTL) are both a subset of CTL*. CTL and LTL are not equivalent and they have a common subset, which is a proper subset of both CTL and LTL.</p>
<ul>
<li><b>FG</b>.P exists in LTL but not in CTL.</li>
<li><b>AG</b>(P<img class="mwe-math-fallback-image-inline tex" alt="\Rightarrow" src="//upload.wikimedia.org/math/d/f/0/df09aea884019cb88a2957126faba316.png">((<b>EX</b>.Q)<img class="mwe-math-fallback-image-inline tex" alt="\land" src="//upload.wikimedia.org/math/9/c/a/9cae4437756a15b8e44ec23e07fb1f65.png">(<b>EX</b>¬Q))) exists in CTL but not in LTL.</li>
</ul>
<h2>See also</h2>
<ul>
<li>Probabilistic CTL</li>
<li>Fair Computational tree logic</li>
<li>Linear temporal logic</li>
</ul>
</body>
</html>