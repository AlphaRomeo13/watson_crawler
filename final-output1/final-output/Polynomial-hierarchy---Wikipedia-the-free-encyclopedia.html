<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Polynomial-hierarchy---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Polynomial hierarchy</h1>
<p>In computational complexity theory, the <b>polynomial hierarchy</b> (sometimes called the <b>polynomial-time hierarchy</b>) is a hierarchy of complexity classes that generalize the classes P, NP and co-NP to oracle machines. It is a resource-bounded counterpart to the arithmetical hierarchy and analytical hierarchy from mathematical logic.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Definitions</li>
<li>2 Relations between classes in the polynomial hierarchy</li>
<li>3 Properties</li>
<li>4 Problems in the polynomial hierarchy</li>
<li>5 See also</li>
<li>6 References</li>
</ul>
<p></p>
<h2>Definitions</h2>
<p>There are multiple equivalent definitions of the classes of the polynomial hierarchy.</p>
<ol>
<li>For the oracle definition of the polynomial hierarchy, define
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt="\Delta_0^{\rm P} := \Sigma_0^{\rm P} := \Pi_0^{\rm P} := \mbox{P}," src="//upload.wikimedia.org/math/f/6/1/f616e0fb5afe34f605b9636474fc6abb.png"></dd>
</dl>
<p>where P is the set of decision problems solvable in polynomial time. Then for i ≥ 0 define</p>
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt="\Delta_{i+1}^{\rm P} := \mbox{P}^{\Sigma_i^{\rm P}}" src="//upload.wikimedia.org/math/8/0/a/80a91f96d34adeecbe43c3f70b05dcac.png"></dd>
<dd><img class="mwe-math-fallback-image-inline tex" alt="\Sigma_{i+1}^{\rm P} := \mbox{NP}^{\Sigma_i^{\rm P}}" src="//upload.wikimedia.org/math/a/4/e/a4ed584d82367a9260f56a0fabdf57db.png"></dd>
<dd><img class="mwe-math-fallback-image-inline tex" alt="\Pi_{i+1}^{\rm P} := \mbox{coNP}^{\Sigma_i^{\rm P}}" src="//upload.wikimedia.org/math/2/c/b/2cb9eb4b1c076049036185eb48b6577d.png"></dd>
</dl>
where A is the set of decision problems solvable by a Turing machine in class A augmented by an oracle for some complete problem in class B. For example, <img class="mwe-math-fallback-image-inline tex" alt=" \Sigma_1^{\rm P} = {\rm NP}, \Pi_1^{\rm P} = {\rm coNP} " src="//upload.wikimedia.org/math/f/6/5/f65a704b6b60db8e75f426ccb8c78b46.png">, and <img class="mwe-math-fallback-image-inline tex" alt=" \Delta_2^{\rm P} = {\rm P^{NP}} " src="//upload.wikimedia.org/math/f/a/6/fa6f9c3cea4734bbeade39764cdd3d16.png"> is the class of problems solvable in polynomial time with an oracle for some NP-complete problem.</li>
<li>For the existential/universal definition of the polynomial hierarchy, let <img class="mwe-math-fallback-image-inline tex" alt="L" src="//upload.wikimedia.org/math/d/2/0/d20caec3b48a1eef164cb4ca81ba2587.png"> be a language (i.e. a decision problem, a subset of {0,1}), let <img class="mwe-math-fallback-image-inline tex" alt="p" src="//upload.wikimedia.org/math/8/3/8/83878c91171338902e0fe0fb97a8c47a.png"> be a polynomial, and define
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \exists^p L := \left\{ x \in \{0,1\}^* \ \left| \ \left( \exists w \in \{0,1\}^{\leq p(|x|)} \right) \langle x,w \rangle \in L \right. \right\}, " src="//upload.wikimedia.org/math/a/4/4/a44c30d7fc308e06638f3590b1938585.png"></dd>
</dl>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="\langle x,w \rangle \in \{0,1\}^*" src="//upload.wikimedia.org/math/f/5/d/f5d2d017b72fe29f96ae8d530b86ab18.png"> is some standard encoding of the pair of binary strings <i>x</i> and <i>w</i> as a single binary string. <i>L</i> represents a set of ordered pairs of strings, where the first string <i>x</i> is a member of <img class="mwe-math-fallback-image-inline tex" alt="\exists^p L" src="//upload.wikimedia.org/math/1/5/9/159fe73252f27ae69fd3c7c4fc33fc83.png">, and the second string <i>w</i> is a "short" (<img class="mwe-math-fallback-image-inline tex" alt="|w| \leq p(|x|) " src="//upload.wikimedia.org/math/9/0/e/90ea38182a1817a2ed3ca0a7df511c93.png">) witness testifying that <i>x</i> is a member of <img class="mwe-math-fallback-image-inline tex" alt="\exists^p L" src="//upload.wikimedia.org/math/1/5/9/159fe73252f27ae69fd3c7c4fc33fc83.png">. In other words, <img class="mwe-math-fallback-image-inline tex" alt="x \in \exists^p L" src="//upload.wikimedia.org/math/9/b/d/9bd0bce66b0434c469b1313716ea4719.png"> if and only if there exists a short witness <i>w</i> such that <img class="mwe-math-fallback-image-inline tex" alt=" \langle x,w \rangle \in L " src="//upload.wikimedia.org/math/8/4/c/84cd59aad068ae84299febe5d1ef3916.png">. Similarly, define</p>
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \forall^p L := \left\{ x \in \{0,1\}^* \ \left| \ \left( \forall w \in \{0,1\}^{\leq p(|x|)} \right) \langle x,w \rangle \in L \right. \right\} " src="//upload.wikimedia.org/math/7/5/b/75bb3a23772404c1c059683383873c10.png"></dd>
</dl>
<p>Note that De Morgan's Laws hold: <img class="mwe-math-fallback-image-inline tex" alt=" \left( \exists^p L \right)^{\rm c} = \forall^p L^{\rm c} " src="//upload.wikimedia.org/math/f/b/6/fb6ae34c8c247f07be7e3fa9717a48ab.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" \left( \forall^p L \right)^{\rm c} = \exists^p L^{\rm c} " src="//upload.wikimedia.org/math/3/d/0/3d0984c3dbfdc239fe19da3ac1b700ed.png">, where <i>L</i> is the complement of <i>L</i>.</p>
<p>Let <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{C}" src="//upload.wikimedia.org/math/9/8/c/98c20e34c90ebe87fa78ddb2b83977fd.png"> be a class of languages. Extend these operators to work on whole classes of languages by the definition</p>
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt="\exists^{\rm P} \mathcal{C} := \left\{\exists^p L \ | \ p \mbox{ is a polynomial and } L \in \mathcal{C} \right\}" src="//upload.wikimedia.org/math/8/4/b/84b43dc6afdfedbf7b32dad4cc786c0f.png"></dd>
<dd><img class="mwe-math-fallback-image-inline tex" alt="\forall^{\rm P} \mathcal{C} := \left\{\forall^p L \ | \ p \mbox{ is a polynomial and } L \in \mathcal{C} \right\}" src="//upload.wikimedia.org/math/e/e/d/eedf6e002fdc1e3efdab98c5858a83c4.png"></dd>
</dl>
<p>Again, De Morgan's Laws hold: <img class="mwe-math-fallback-image-inline tex" alt=" {\rm co} \exists^{\rm P} \mathcal{C} = \forall^{\rm P} {\rm co} \mathcal{C} " src="//upload.wikimedia.org/math/a/9/3/a9360c13ffe3c596ebd51db818c15c0f.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" {\rm co} \forall^{\rm P} \mathcal{C} = \exists^{\rm P} {\rm co} \mathcal{C} " src="//upload.wikimedia.org/math/9/4/8/948f81fd7473671100a35a8c6a9a7303.png">, where <img class="mwe-math-fallback-image-inline tex" alt="{\rm co}\mathcal{C} = \left\{ L^c | L \in \mathcal{C} \right\}" src="//upload.wikimedia.org/math/a/2/6/a26e83f3dcb05d7863660f462d716fd3.png">.</p>
<p>The classes <b>NP</b> and <b>co-NP</b> can be defined as <img class="mwe-math-fallback-image-inline tex" alt=" {\rm NP} = \exists^{\rm P} {\rm P} " src="//upload.wikimedia.org/math/4/8/6/4866fca6e9f3b6227d364587a5465ee7.png">, and <img class="mwe-math-fallback-image-inline tex" alt=" {\rm coNP} = \forall^{\rm P} {\rm P} " src="//upload.wikimedia.org/math/5/5/d/55d3a088467dcc21aec359f92411f09d.png">, where <b>P</b> is the class of all feasibly (polynomial-time) decidable languages. The polynomial hierarchy can be defined recursively as</p>
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \Sigma_0^{\rm P} := \Pi_0^{\rm P} := {\rm P} " src="//upload.wikimedia.org/math/d/a/6/da69cd9b3b7d000ad4315277bc67946e.png"></dd>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \Sigma_{k+1}^{\rm P} := \exists^{\rm P} \Pi_k^{\rm P} " src="//upload.wikimedia.org/math/2/7/d/27d659a2b3870969c4334197f5540ec4.png"></dd>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \Pi_{k+1}^{\rm P} := \forall^{\rm P} \Sigma_k^{\rm P} " src="//upload.wikimedia.org/math/d/5/1/d519563dec53053eacb1055ff3b01a29.png"></dd>
</dl>
<p>Note that <img class="mwe-math-fallback-image-inline tex" alt=" {\rm NP} = \Sigma_1^{\rm P} " src="//upload.wikimedia.org/math/8/d/8/8d819bfface816eeeabc7c357daa6c8f.png">, and <img class="mwe-math-fallback-image-inline tex" alt=" {\rm coNP} = \Pi_1^{\rm P} " src="//upload.wikimedia.org/math/9/d/9/9d91bc5490704b72a5bac6f8028d732e.png">.</p>
This definition reflects the close connection between the polynomial hierarchy and the arithmetical hierarchy, where <b>R</b> and <b>RE</b> play roles analogous to <b>P</b> and <b>NP</b>, respectively. The analytic hierarchy is also defined in a similar way to give a hierarchy of subsets of the real numbers.</li>
<li>An equivalent definition in terms of alternating Turing machines defines <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_k^{\rm P}" src="//upload.wikimedia.org/math/b/4/a/b4a4d18c5af15da6cf250cf4d5c19cf3.png"> (respectively, <img class="mwe-math-fallback-image-inline tex" alt="\Pi_k^{\rm P}" src="//upload.wikimedia.org/math/6/6/c/66cfc9437da7812dddef1740a85734b8.png">) as the set of decision problems solvable in polynomial time on an alternating Turing machine with <img class="mwe-math-fallback-image-inline tex" alt="k" src="//upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"> alternations starting in an existential (respectively, universal) state.</li>
</ol>
<p>where P is the set of decision problems solvable in polynomial time. Then for i ≥ 0 define</p>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="\langle x,w \rangle \in \{0,1\}^*" src="//upload.wikimedia.org/math/f/5/d/f5d2d017b72fe29f96ae8d530b86ab18.png"> is some standard encoding of the pair of binary strings <i>x</i> and <i>w</i> as a single binary string. <i>L</i> represents a set of ordered pairs of strings, where the first string <i>x</i> is a member of <img class="mwe-math-fallback-image-inline tex" alt="\exists^p L" src="//upload.wikimedia.org/math/1/5/9/159fe73252f27ae69fd3c7c4fc33fc83.png">, and the second string <i>w</i> is a "short" (<img class="mwe-math-fallback-image-inline tex" alt="|w| \leq p(|x|) " src="//upload.wikimedia.org/math/9/0/e/90ea38182a1817a2ed3ca0a7df511c93.png">) witness testifying that <i>x</i> is a member of <img class="mwe-math-fallback-image-inline tex" alt="\exists^p L" src="//upload.wikimedia.org/math/1/5/9/159fe73252f27ae69fd3c7c4fc33fc83.png">. In other words, <img class="mwe-math-fallback-image-inline tex" alt="x \in \exists^p L" src="//upload.wikimedia.org/math/9/b/d/9bd0bce66b0434c469b1313716ea4719.png"> if and only if there exists a short witness <i>w</i> such that <img class="mwe-math-fallback-image-inline tex" alt=" \langle x,w \rangle \in L " src="//upload.wikimedia.org/math/8/4/c/84cd59aad068ae84299febe5d1ef3916.png">. Similarly, define</p>
<p>Note that De Morgan's Laws hold: <img class="mwe-math-fallback-image-inline tex" alt=" \left( \exists^p L \right)^{\rm c} = \forall^p L^{\rm c} " src="//upload.wikimedia.org/math/f/b/6/fb6ae34c8c247f07be7e3fa9717a48ab.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" \left( \forall^p L \right)^{\rm c} = \exists^p L^{\rm c} " src="//upload.wikimedia.org/math/3/d/0/3d0984c3dbfdc239fe19da3ac1b700ed.png">, where <i>L</i> is the complement of <i>L</i>.</p>
<p>Let <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{C}" src="//upload.wikimedia.org/math/9/8/c/98c20e34c90ebe87fa78ddb2b83977fd.png"> be a class of languages. Extend these operators to work on whole classes of languages by the definition</p>
<p>Again, De Morgan's Laws hold: <img class="mwe-math-fallback-image-inline tex" alt=" {\rm co} \exists^{\rm P} \mathcal{C} = \forall^{\rm P} {\rm co} \mathcal{C} " src="//upload.wikimedia.org/math/a/9/3/a9360c13ffe3c596ebd51db818c15c0f.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" {\rm co} \forall^{\rm P} \mathcal{C} = \exists^{\rm P} {\rm co} \mathcal{C} " src="//upload.wikimedia.org/math/9/4/8/948f81fd7473671100a35a8c6a9a7303.png">, where <img class="mwe-math-fallback-image-inline tex" alt="{\rm co}\mathcal{C} = \left\{ L^c | L \in \mathcal{C} \right\}" src="//upload.wikimedia.org/math/a/2/6/a26e83f3dcb05d7863660f462d716fd3.png">.</p>
<p>The classes <b>NP</b> and <b>co-NP</b> can be defined as <img class="mwe-math-fallback-image-inline tex" alt=" {\rm NP} = \exists^{\rm P} {\rm P} " src="//upload.wikimedia.org/math/4/8/6/4866fca6e9f3b6227d364587a5465ee7.png">, and <img class="mwe-math-fallback-image-inline tex" alt=" {\rm coNP} = \forall^{\rm P} {\rm P} " src="//upload.wikimedia.org/math/5/5/d/55d3a088467dcc21aec359f92411f09d.png">, where <b>P</b> is the class of all feasibly (polynomial-time) decidable languages. The polynomial hierarchy can be defined recursively as</p>
<p>Note that <img class="mwe-math-fallback-image-inline tex" alt=" {\rm NP} = \Sigma_1^{\rm P} " src="//upload.wikimedia.org/math/8/d/8/8d819bfface816eeeabc7c357daa6c8f.png">, and <img class="mwe-math-fallback-image-inline tex" alt=" {\rm coNP} = \Pi_1^{\rm P} " src="//upload.wikimedia.org/math/9/d/9/9d91bc5490704b72a5bac6f8028d732e.png">.</p>
<h2>Relations between classes in the polynomial hierarchy</h2>
<p>The definitions imply the relations:</p>
<p>Unlike the arithmetic and analytic hierarchies, whose inclusions are known to be proper, it is an open question whether any of these inclusions are proper, though it is widely believed that they all are. If any <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_k^{\rm P} = \Sigma_{k+1}^{\rm P}" src="//upload.wikimedia.org/math/0/f/5/0f5fdd3adc647aafc1e29a163d4aea31.png">, or if any <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_k^{\rm P} = \Pi_{k}^{\rm P}" src="//upload.wikimedia.org/math/f/6/3/f63f40bd86bbba7b9e17dbce93bb75ad.png">, then the hierarchy <i>collapses to level k</i>: for all <img class="mwe-math-fallback-image-inline tex" alt="i &gt; k" src="//upload.wikimedia.org/math/5/2/b/52b67fd288c710b1b8dbdfe1ef98b9b6.png">, <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_i^{\rm P} = \Sigma_k^{\rm P}" src="//upload.wikimedia.org/math/2/5/4/25447e8d48f1931362a58153e4729e45.png">. In particular, if P = NP, then the hierarchy collapses completely.</p>
<p>The union of all classes in the polynomial hierarchy is the complexity class <b>PH</b>.</p>
<h2>Properties</h2>
<p>The polynomial hierarchy is an analogue (at much lower complexity) of the exponential hierarchy and arithmetical hierarchy.</p>
<p>It is known that PH is contained within PSPACE, but it is not known whether the two classes are equal. One useful reformulation of this problem is that PH = PSPACE if and only if second-order logic over finite structures gains no additional power from the addition of a transitive closure operator.</p>
<p>If the polynomial hierarchy has any complete problems, then it has only finitely many distinct levels. Since there are PSPACE-complete problems, we know that if PSPACE = PH, then the polynomial hierarchy must collapse, since a PSPACE-complete problem would be a <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_{k}^{\rm P}" src="//upload.wikimedia.org/math/a/4/b/a4b7a002b5ff7b20cb51b61caec6143d.png">-complete problem for some <i>k</i>.</p>
<p>Each class in the polynomial hierarchy contains <img class="mwe-math-fallback-image-inline tex" alt="\leq_{\rm m}^{\rm P}" src="//upload.wikimedia.org/math/2/c/3/2c3b98758aa3be2c650f104c39f2170f.png">-complete problems (problems complete under polynomial-time many-one reductions). Furthermore, each class in the polynomial hierarchy is <i>closed under <img class="mwe-math-fallback-image-inline tex" alt="\leq_{\rm m}^{\rm P}" src="//upload.wikimedia.org/math/2/c/3/2c3b98758aa3be2c650f104c39f2170f.png">-reductions</i>: meaning that for a class <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{C}" src="//upload.wikimedia.org/math/9/8/c/98c20e34c90ebe87fa78ddb2b83977fd.png"> in the hierarchy and a language <img class="mwe-math-fallback-image-inline tex" alt="L \in \mathcal{C}" src="//upload.wikimedia.org/math/7/5/c/75ceb029949481784ae0a16d594b6949.png">, if <img class="mwe-math-fallback-image-inline tex" alt="A \leq_{\rm m}^{\rm P} L" src="//upload.wikimedia.org/math/6/8/e/68ec1b05238118d5553be5f83a972513.png">, then <img class="mwe-math-fallback-image-inline tex" alt="A \in \mathcal{C}" src="//upload.wikimedia.org/math/3/b/1/3b19a6b272daa1474b1589509d97216b.png"> as well. These two facts together imply that if <img class="mwe-math-fallback-image-inline tex" alt="K_i" src="//upload.wikimedia.org/math/8/5/0/8507937d8ce1123d9d3540357d09a0c8.png"> is a complete problem for <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_{i}^{\rm P}" src="//upload.wikimedia.org/math/e/1/3/e1358d9389d1e25f0603c2bab1a53a87.png">, then <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_{i+1}^{\rm P} = \left( \Sigma_{i}^{\rm P} \right)^{K_i}" src="//upload.wikimedia.org/math/a/c/4/ac4e9fe260c5343d156075d83616e66e.png">, and <img class="mwe-math-fallback-image-inline tex" alt="\Pi_{i+1}^{\rm P} = \left( \Pi_{i}^{\rm P} \right)^{K_i^{\rm c}}" src="//upload.wikimedia.org/math/3/a/1/3a192752303d2aadbcd2833c2f41017f.png">. For instance, <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_{2}^{\rm P} = {\rm NP}^{\rm SAT}" src="//upload.wikimedia.org/math/5/7/4/57412eb4fbc7179b7d087cd57d6eb82e.png">. In other words, if a language is defined based on some oracle in <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{C}" src="//upload.wikimedia.org/math/9/8/c/98c20e34c90ebe87fa78ddb2b83977fd.png">, then we can assume that it is defined based on a complete problem for <img class="mwe-math-fallback-image-inline tex" alt="\mathcal{C}" src="//upload.wikimedia.org/math/9/8/c/98c20e34c90ebe87fa78ddb2b83977fd.png">. Complete problems therefore act as "representatives" of the class for which they are complete.</p>
<p>Sipser–Lautemann theorem states that the class BPP is contained in second level of polynomial hierarchy.</p>
<p>Kannan's theorem states that for any <i>k</i>, <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_2" src="//upload.wikimedia.org/math/6/2/5/625b3a2d947b48af8b445bb4549b02c6.png"> is not contained in <b>SIZE</b>(n).</p>
<p>Toda's theorem states that the polynomial hierarchy is contained in P.</p>
<h2>Problems in the polynomial hierarchy</h2>
<ul>
<li>An example of a natural problem in <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_2^{\rm P}" src="//upload.wikimedia.org/math/5/d/7/5d7d055bc17d64561aa1161ea4c02298.png"> is <i>circuit minimization</i>: given a number <i>k</i> and a circuit <i>A</i> computing a Boolean function <i>f</i>, determine if there is a circuit with at most <i>k</i> gates that computes the same function <i>f</i>. Let <img class="mwe-math-fallback-image-inline tex" alt=" \mathcal{C} " src="//upload.wikimedia.org/math/1/9/2/1923743cb649c1b1f7abfdb2dac3caf2.png"> be the set of all boolean circuits. The language
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" L = \left\{ \langle A,k,B,x \rangle \in \mathcal{C} \times \mathbb{N} \times \mathcal{C} \times \{0,1\}^*  
\left|
B \mbox{ has at most } k \mbox{ gates, and } A(x)=B(x) 
\right.
\right\} " src="//upload.wikimedia.org/math/7/b/2/7b2344f0499d08727e14eb695ef59f0c.png"></dd>
</dl>
<p>is decidable in polynomial time. The language</p>
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \mathit{CM} = \left\{ \langle A,k \rangle \in \mathcal{C} \times \mathbb{N} 
\left| 
\begin{matrix}
\mbox{there exists a circuit } B \mbox{ with at most } k \mbox{ gates } \\
\mbox{ such that } A \mbox{ and } B \mbox{ compute the same function} 
\end{matrix}
\right.
\right\} " src="//upload.wikimedia.org/math/f/7/6/f767c2c1ff56094966cdd4d7869f9bd6.png"></dd>
</dl>
is the circuit minimization language. <img class="mwe-math-fallback-image-inline tex" alt=" \mathit{CM} \in \Sigma_2^P (= \exists^{\rm P} \forall^{\rm P} {\rm P}) " src="//upload.wikimedia.org/math/9/5/3/95360f5d9ce174f43939c8ed0662f949.png"> because <img class="mwe-math-fallback-image-inline tex" alt="L" src="//upload.wikimedia.org/math/d/2/0/d20caec3b48a1eef164cb4ca81ba2587.png"> is decidable in polynomial time and because, given <img class="mwe-math-fallback-image-inline tex" alt=" \langle A,k \rangle " src="//upload.wikimedia.org/math/1/2/d/12db36fa00e5189329653086c52f7f4f.png">, <img class="mwe-math-fallback-image-inline tex" alt=" \langle A,k \rangle \in \mathit{CM}" src="//upload.wikimedia.org/math/4/5/e/45e99cdad3c171b74db03d79d32a0d4f.png"> if and only if <i>there exists</i> a circuit <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png"> such that <i>for all</i> inputs <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png">, <img class="mwe-math-fallback-image-inline tex" alt=" \langle A,k,B,x \rangle \in L " src="//upload.wikimedia.org/math/8/2/d/82d276407b2990a6bea865884406eb08.png">.</li>
<li>A complete problem for <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_k^{\rm P}" src="//upload.wikimedia.org/math/b/4/a/b4a4d18c5af15da6cf250cf4d5c19cf3.png"> is <b>satisfiability for quantified Boolean formulas with <i>k</i> alternations of quantifiers</b> (abbreviated <b>QBF<sub>k</sub></b> or <b>QSAT<sub>k</sub></b>). This is the version of the boolean satisfiability problem for <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_k^{\rm P}" src="//upload.wikimedia.org/math/b/4/a/b4a4d18c5af15da6cf250cf4d5c19cf3.png">. In this problem, we are given a Boolean formula <i>f</i> with variables partitioned into <i>k</i> sets <i>X<sub>1</sub></i>, ..., <i>X<sub>k</sub></i>. We have to determine if it is true that
<dl>
<dd><img class="mwe-math-fallback-image-inline tex" alt=" \exists X_1 \forall X_2 \exists X_3 \ldots f" src="//upload.wikimedia.org/math/3/5/6/3565f89b0cf23350d43540097fa70794.png"></dd>
</dl>
<p>That is, is there an assignment of values to variables in <i>X<sub>1</sub></i> such that, for all assignments of values in <i>X<sub>2</sub></i>, there exists an assignment of values to variables in <i>X<sub>3</sub></i>, ... <i>f</i> is true?</p>
The variant above is complete for <img class="mwe-math-fallback-image-inline tex" alt="\Sigma_k^{\rm P}" src="//upload.wikimedia.org/math/b/4/a/b4a4d18c5af15da6cf250cf4d5c19cf3.png">. The variant in which the first quantifier is "for all", the second is "exists", etc., is complete for <img class="mwe-math-fallback-image-inline tex" alt="\Pi_k^{\rm P}" src="//upload.wikimedia.org/math/6/6/c/66cfc9437da7812dddef1740a85734b8.png">.</li>
</ul>
<p>is decidable in polynomial time. The language</p>
<p>That is, is there an assignment of values to variables in <i>X<sub>1</sub></i> such that, for all assignments of values in <i>X<sub>2</sub></i>, there exists an assignment of values to variables in <i>X<sub>3</sub></i>, ... <i>f</i> is true?</p>
<h2>See also</h2>
<ul>
<li>EXPTIME</li>
<li>Exponential hierarchy</li>
</ul>
</body>
</html>