<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Model-of-computation---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Model of computation</h1>
<p>In computability theory and computational complexity theory, a <b>model of computation</b> is the definition of the set of allowable operations used in computation and their respective costs. It is used for measuring the complexity of an algorithm in execution time and or memory space: by assuming a certain model of computation, it is possible to analyze the computational resources required or to discuss the limitations of algorithms or computers.</p>
<p>Some examples of models include Turing machines, finite state machines, recursive functions, lambda calculus, combinatory logic, and abstract rewriting systems.</p>
<p>In the field of runtime analysis of algorithms, it is common to specify a computational model in terms of <i>primitive operations</i> allowed which have unit cost, or simply <b>unit-cost operations</b>. A commonly used example is the random access machine, which has unit cost for read and write access to all of its memory cells. In this respect, it differs from the above mentioned Turing machine model.</p>
<p>In <i>model-driven engineering</i>, the model of computation explains how the behaviour of the whole system is the result of the behaviour of each of its components.</p>
<p>There are many models of computation, differing in the set of admissible operations and their computations cost. They fall into the following broad categories: abstract machine and models equivalent to it (e.g. lambda calculus is equivalent to the Turing machine), used in proofs of computability and upper bounds on computational complexity of algorithms, and decision tree models, used in proofs of lower bounds on computational complexity of algorithmic problems.</p>
<p>A key point which is often overlooked is that published lower bounds for problems are often given for a model of computation that is more restricted than the set of operations that one could use in practice and therefore there may be algorithms that are faster than what would naively be thought possible.</p>
<h2>See also</h2>
<ul>
<li>Stack machine (0-operand machine)</li>
<li>Accumulator machine (1-operand machine)</li>
<li>Register machine (2,3,... operand machine)</li>
<li>Random access machine</li>
<li>Cell-probe model</li>
</ul>
</body>
</html>