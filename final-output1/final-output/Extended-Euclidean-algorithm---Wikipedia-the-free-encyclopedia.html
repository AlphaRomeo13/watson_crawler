<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Extended-Euclidean-algorithm---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Extended Euclidean algorithm</h1>
<p>In arithmetic and computer programming, the <b>extended Euclidean algorithm</b> is an extension to the Euclidean algorithm, which computes, besides the greatest common divisor of integers <i>a</i> and <i>b</i>, the coefficients of Bézout's identity, that is integers <i>x</i> and <i>y</i> such that</p>
<p>It allows one to compute also, with almost no extra cost, the quotients of <i>a</i> and <i>b</i> by their greatest common divisor.</p>
<p><b>Extended Euclidean algorithm</b> refers also to a very similar algorithm for computing the polynomial greatest common divisor and the coefficients of Bézout's identity of two univariate polynomials.</p>
<p>The extended Euclidean algorithm is particularly useful when <i>a</i> and <i>b</i> are coprime, since <i>x</i> is the modular multiplicative inverse of <i>a</i> modulo <i>b</i>, and <i>y</i> is the modular multiplicative inverse of <i>b</i> modulo <i>a</i>. Similarly, the polynomial extended Euclidean algorithm allows one to compute the multiplicative inverse in algebraic field extensions and, in particular in finite fields of non prime order. It follows that both extended Euclidean algorithms are widely used in cryptography. In particular, the computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Description of the algorithm
<ul>
<li>1.1 Example</li>
<li>1.2 Proof</li>
</ul>
</li>
<li>2 Polynomial extended Euclidean algorithm</li>
<li>3 Pseudocode</li>
<li>4 Simplification of fractions</li>
<li>5 Computing multiplicative inverses in modular structures
<ul>
<li>5.1 Modular integers</li>
<li>5.2 Simple algebraic field extensions
<ul>
<li>5.2.1 Example</li>
</ul>
</li>
</ul>
</li>
<li>6 The case of more than two numbers</li>
<li>7 See also</li>
<li>8 References</li>
<li>9 External links</li>
</ul>
<ul>
<li>1.1 Example</li>
<li>1.2 Proof</li>
</ul>
<ul>
<li>5.1 Modular integers</li>
<li>5.2 Simple algebraic field extensions
<ul>
<li>5.2.1 Example</li>
</ul>
</li>
</ul>
<ul>
<li>5.2.1 Example</li>
</ul>
<p></p>
<h2>Description of the algorithm</h2>
<p>The standard Euclidean algorithm proceeds by a succession of Euclidean divisions whose quotients are not used, only the <i>remainders</i> are kept. For the extended algorithm, the successive quotients are used. More precisely, the standard Euclidean algorithm with <i>a</i> and <i>b</i> as input, consists of computing a sequence <img class="mwe-math-fallback-image-inline tex" alt="q_1,\ldots, q_k" src="//upload.wikimedia.org/math/5/9/a/59a1d2672e2b5e02c8b9973afc06bbc0.png"> of quotients and a sequence <img class="mwe-math-fallback-image-inline tex" alt="r_0,\ldots, r_{k+1}" src="//upload.wikimedia.org/math/d/4/c/d4c1746a0e0106e6aa85ac9413878e15.png"> of remainders such that</p>
<p>It is the main property of Euclidean division that the inequalities on the right define uniquely <img class="mwe-math-fallback-image-inline tex" alt="r_{i+1}" src="//upload.wikimedia.org/math/0/4/8/04828dc3ba651583d7fb9695d5f58e0b.png"> from <img class="mwe-math-fallback-image-inline tex" alt="r_{i-1}" src="//upload.wikimedia.org/math/f/0/f/f0fd7349a796f122ad38d7ba5c5e3776.png"> and <img class="mwe-math-fallback-image-inline tex" alt="r_{i}." src="//upload.wikimedia.org/math/0/5/9/05966af49ba10dda4b864d3bc5bfae10.png"></p>
<p>The computation stops when one reaches a remainder <img class="mwe-math-fallback-image-inline tex" alt="r_{k+1}" src="//upload.wikimedia.org/math/b/7/c/b7cd126376264b6e27ba639456adf357.png"> which is zero; the greatest common divisor is then the last non zero remainder <img class="mwe-math-fallback-image-inline tex" alt="r_{k}." src="//upload.wikimedia.org/math/b/7/a/b7a895ab7611285b950bb7aaf46532ef.png"></p>
<p>The extended Euclidean algorithm proceeds similarly, but adds two other sequences defined by</p>
<p>The computation stops also when <img class="mwe-math-fallback-image-inline tex" alt="r_{k+1}=0" src="//upload.wikimedia.org/math/0/8/9/089a6bc91b6142560e09d91e77604a7e.png"> and gives</p>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="r_{k}" src="//upload.wikimedia.org/math/e/2/6/e26e3ea026de177d26dec35408c5b4a5.png"> is the greatest common divisor of the input <img class="mwe-math-fallback-image-inline tex" alt="a=r_{0}" src="//upload.wikimedia.org/math/f/6/d/f6def2847c239a8edbeeb5c81b189e94.png"> and <img class="mwe-math-fallback-image-inline tex" alt="b=r_{1}." src="//upload.wikimedia.org/math/4/c/0/4c0919514f1915ba2b21758245d120d1.png"></li>
<li>The Bézout coefficients are <img class="mwe-math-fallback-image-inline tex" alt="s_{k}" src="//upload.wikimedia.org/math/9/e/6/9e632b270f891efad763b61233ee7773.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_{k}," src="//upload.wikimedia.org/math/1/0/5/105e43981854dc4ab44067d1365409f2.png"> that is <img class="mwe-math-fallback-image-inline tex" alt="GCD(a,b)=r_{k}=as_k+bt_k" src="//upload.wikimedia.org/math/8/2/0/8207080705f82b81b3bc279b818dbf43.png"></li>
<li>The quotients of <i>a</i> and <i>b</i> by their greatest common divisor are given by <img class="mwe-math-fallback-image-inline tex" alt="s_{k+1}=\pm\frac{b}{GCD(a,b)}" src="//upload.wikimedia.org/math/2/f/5/2f52787f4d782796a31b934c4276faf7.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_{k+1}=\pm\frac{a}{GCD(a,b)}" src="//upload.wikimedia.org/math/7/4/e/74e16901639fc415ce9e7e6de519c93d.png"></li>
</ul>
<p>Moreover, if <i>a</i> and <i>b</i> are both positive, we have</p>
<p>This means that the pair of Bézout's coefficients provided by the extended Euclidean algorithm is one of the two minimal pairs of Bézout coefficients.</p>
<h3>Example</h3>
<p>The following table shows how the extended Euclidean algorithm proceeds with input 240 and 46. The greatest common divisor is the last non zero entry, 2 in the column "remainder". The computation stops at row 6, because the remainder in it is 0. Bézout coefficients appear in the last two entries of the second-to-last row. In fact, it is easy to verify that -9 × 240 + 47 × 46 = 2. Finally the last two entries 23 and -120 of the last row are, up to the sign, the quotients of the input 46 and 240 by the greatest common divisor 2.</p>
<h3>Proof</h3>
<p>As <img class="mwe-math-fallback-image-inline tex" alt=" 0\le r_{i+1}&lt;|r_i|, " src="//upload.wikimedia.org/math/3/8/8/388e9f45966e65a15b1dccfbf87ffe38.png"> the sequence of the <img class="mwe-math-fallback-image-inline tex" alt=" r_i " src="//upload.wikimedia.org/math/b/e/d/bedcf2f74ea8e1f0f46880c0c79592ff.png"> is a decreasing sequence nonnegative integers (from <i>i</i> = 2 on). Thus it must stop with some <img class="mwe-math-fallback-image-inline tex" alt=" r_{k+1}=0. " src="//upload.wikimedia.org/math/8/e/9/8e99f96fb1540dc6fbc3ec0941835229.png"> This proves that the algorithm stops eventually.</p>
<p>As <img class="mwe-math-fallback-image-inline tex" alt=" r_{i+1}= r_{i-1} - r_i q_i," src="//upload.wikimedia.org/math/a/b/7/ab7a19d93d08f17072a3b9322ef2771a.png"> the greatest common divisors are the same for <img class="mwe-math-fallback-image-inline tex" alt=" (r_{i-1}, r_i)" src="//upload.wikimedia.org/math/f/9/1/f91045cf3dcbb51b90249f19e6404184.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" (r_{i}, r_{i+1})." src="//upload.wikimedia.org/math/d/5/7/d570584399c5a08c11f0ea34a4714a1a.png"> This shows that the greatest common divisor of the input <img class="mwe-math-fallback-image-inline tex" alt=" a=r_0, b=r_1 " src="//upload.wikimedia.org/math/f/a/8/fa8bcd70075728507da3d686b90addb1.png"> is the same as that of <img class="mwe-math-fallback-image-inline tex" alt=" r_k, r_{k+1}=0. " src="//upload.wikimedia.org/math/d/a/5/da59a8d6bde44f77c7abe5301acc7cca.png"> This proves that <img class="mwe-math-fallback-image-inline tex" alt=" r_k " src="//upload.wikimedia.org/math/a/0/4/a041fdbdd6e46c600bb414c2eef84c73.png"> is the greatest common divisor of <i>a</i> and <i>b</i>. (Until this point, the proof is the same as that of the classical Euclidean algorithm.)</p>
<p>As <img class="mwe-math-fallback-image-inline tex" alt=" a=r_0" src="//upload.wikimedia.org/math/6/d/9/6d903a15b2b9b2ea710d6d603e9cf9a7.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" b=r_1," src="//upload.wikimedia.org/math/2/2/7/2271be41ce11265d40505574ae85f305.png"> we have <img class="mwe-math-fallback-image-inline tex" alt="as_i+bt_i=r_i" src="//upload.wikimedia.org/math/0/1/6/0162ce7dc93ff8fd5d8101e02e361a39.png"> for <i>i</i> = 0 and 1. The relation follows by induction for all <img class="mwe-math-fallback-image-inline tex" alt="i&gt;1" src="//upload.wikimedia.org/math/d/4/2/d4225df29ee5efd68caf20614f27c22f.png">: <img class="mwe-math-fallback-image-inline tex" alt="r_{i+1} = r_{i-1} - r_i q_i = (as_{i-1}+bt_{i-1}) - (as_i+bt_i)q_i = (as_{i-1}-as_iq_i) + (bt_{i-1}-bt_iq_i) = as_{i+1}+bt_{i+1}." src="//upload.wikimedia.org/math/2/9/0/2904fa2c1553831a1bf1f055e05c81c6.png"> Thus <img class="mwe-math-fallback-image-inline tex" alt="s_k" src="//upload.wikimedia.org/math/1/3/7/137425aeae8e33d918f4007ec7afe7e3.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_k" src="//upload.wikimedia.org/math/f/e/2/fe2da1c2e9dc0358c2102f5a1d5c406a.png"> are Bézout coefficients.</p>
<p>Let us consider the matrix</p>
<p>The recurrence relation may be rewritten in matrix form</p>
<p>The matrix <img class="mwe-math-fallback-image-inline tex" alt=" A_1" src="//upload.wikimedia.org/math/e/2/8/e283f48f6f3d4077546b2b697c3eebad.png"> is the identity matrix and its determinant is one. The determinant of the rightmost matrix in the preceding formula is -1. It follows that the determinant of <img class="mwe-math-fallback-image-inline tex" alt=" A_i" src="//upload.wikimedia.org/math/e/8/a/e8aaf87d9a5c35b14cfbc370d3fd7b21.png"> is <img class="mwe-math-fallback-image-inline tex" alt="(-1)^{i-1}." src="//upload.wikimedia.org/math/e/b/f/ebfb0930f5cbde5c8ef37608c1d9cb8c.png"> In particular, for <i>i</i> = <i>k</i> + 1, we have <img class="mwe-math-fallback-image-inline tex" alt=" s_k t_{k+1}-t_k s_{k+1} = (-1)^k. " src="//upload.wikimedia.org/math/f/2/c/f2c6bf5272aa4a2e8b456709294f8fad.png"> Viewing this as a Bézout's identity, this shows that <img class="mwe-math-fallback-image-inline tex" alt=" s_{k+1}" src="//upload.wikimedia.org/math/6/d/1/6d1512199314aeb47ee41ea9e4e6e407.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" t_{k+1}" src="//upload.wikimedia.org/math/0/9/1/09136221d02111c2a3ce7d4a141a0a19.png"> are coprime. The relation <img class="mwe-math-fallback-image-inline tex" alt="as_{k+1}+bt_{k+1}=0" src="//upload.wikimedia.org/math/9/9/8/9989a2aba79e72f15bf5713201279a31.png"> that has been proved above and Euclid's lemma shows that <img class="mwe-math-fallback-image-inline tex" alt=" s_{k+1}" src="//upload.wikimedia.org/math/6/d/1/6d1512199314aeb47ee41ea9e4e6e407.png"> divides <i>b</i> and <img class="mwe-math-fallback-image-inline tex" alt=" t_{k+1}" src="//upload.wikimedia.org/math/0/9/1/09136221d02111c2a3ce7d4a141a0a19.png"> divides <i>a</i>. As they are coprime, they are, up to their sign the quotients of <i>b</i> and <i>a</i> by their greatest common divisor.</p>
<h2>Polynomial extended Euclidean algorithm</h2>
<p>For univariate polynomials with coefficients in a field, everything works in a similar way, Euclidean division, Bézout's identity and extended Euclidean algorithm. The first difference is that, in the Euclidean division and the algorithm, the inequality <img class="mwe-math-fallback-image-inline tex" alt="0\le r_{i+1}&lt;|r_i|" src="//upload.wikimedia.org/math/8/5/e/85e597c7a6047a6ab2cbab84db3202ad.png"> has to be replaced by an inequality on the degrees <img class="mwe-math-fallback-image-inline tex" alt="\deg r_{i+1}&lt;\deg r_i." src="//upload.wikimedia.org/math/7/a/c/7ac42ce47f81914335151a6591438110.png"> Otherwise, everything which precedes in this article remains the same, simply by replacing integers by polynomials.</p>
<p>A second difference lies in the bound on the size of the Bézout coefficients provided by the extended Euclidean algorithm, which is more accurate in the polynomial case, leading to the following theorem.</p>
<p><i>If a and b are two nonzero polynomials, then the extended Euclidean algorithm produces the unique pair of polynomials</i> (<i>s</i>, <i>t</i>) <i>such that</i></p>
<p><i>and</i></p>
<p>A third difference is that, in the polynomial case, the greatest common divisor is defined only up to the multiplication by a non zero constant. There are several ways to define the greatest common divisor unambiguously.</p>
<p>In mathematics, it is common to require that the greatest common divisor be a monic polynomial. To get this, it suffices to divide every element of the output by the leading coefficient of <img class="mwe-math-fallback-image-inline tex" alt="r_{k}." src="//upload.wikimedia.org/math/b/7/a/b7a895ab7611285b950bb7aaf46532ef.png"> This allows that, if <i>a</i> and <i>b</i> are coprime, one gets 1 in the right-hand side of Bézout's inequality. Otherwise, one may get any non-zero constant. In computer algebra, the polynomials have commonly integers coefficients, and this way of normalizing the greatest common divisor introduces too many fractions to be convenient.</p>
<p>The second way to normalize the greatest common divisor in the case of polynomials with integers coefficients is to divide every output by the content of <img class="mwe-math-fallback-image-inline tex" alt="r_{k}," src="//upload.wikimedia.org/math/2/4/3/2439071c87b721ada0fa7c966bcc1a2c.png"> to get a primitive greatest common divisor. If the input polynomials are coprime, this normalization provides also a greatest common divisor equal to 1. The drawback of this approach is that a lot of fractions should be computed and simplified during the computation.</p>
<p>A third approach consists in extending the algorithm of subresultant pseudo-remainder sequences in a way that is similar to the extension of the Euclidean algorithm to the extended Euclidean algorithm. This allows that, when starting with polynomials with integer coefficients, all polynomials that are computed have integer coefficients. Moreover, every computed remainder <img class="mwe-math-fallback-image-inline tex" alt="r_i" src="//upload.wikimedia.org/math/b/e/d/bedcf2f74ea8e1f0f46880c0c79592ff.png"> is a subresultant polynomial. In particular, if the input polynomials are coprime, then the Bézout's identity becomes</p>
<p>where <img class="mwe-math-fallback-image-inline tex" alt="\operatorname{Res}(a,b)" src="//upload.wikimedia.org/math/6/2/e/62ea7a495f64101733c4ec10baf05d2f.png"> denotes the resultant of <i>a</i> and <i>b</i>. In this form of Bézout's identity there is no denominator in the formula. If one divides everything by the resultant one gets the classical Bézout's identity, with an explicit common denominator for the rational numbers that appear in it.</p>
<h2>Pseudocode</h2>
<p>To implement the algorithm that is described above, one should first remark that only the two last values of the indexed variables are needed at each step. Thus, for saving memory, each indexed variable must be replaced by only two variables.</p>
<p>For simplicity, the following algorithm (and the other algorithms in this article) uses parallel assignments. In a programming language which does not have this feature, the parallel assignments need to be simulated with an auxiliary variable. For example, the first one,</p>
<p>WHATSON? bb76cf21-0871-484f-9293-3e58968d0600</p>
<pre>
(old_r, r) := (r, old_r - quotient *r)
</pre>
<p>is equivalent with</p>
<p>WHATSON? 7ea33bf2-68a6-4417-abbc-a87abb71dd2d</p>
<pre>
prov := r;
r := old_r - quotient * prov;
old_r := prov;
</pre>
<p>and similarly for the other parallel assignments. This leads to the following code:</p>
<p>WHATSON? 55526fa1-2a5c-4b45-8939-9777ff17f028</p>
<pre>
<b>function</b> extended_gcd(a, b)
    s := 0;    old_s := 1
    t := 1;    old_t := 0
    r := b;    old_r := a
    <b>while</b> r ≠ 0
        quotient := old_r <b>div</b> r
        (old_r, r) := (r, old_r - quotient * r)
        (old_s, s) := (s, old_s - quotient * s)
        (old_t, t) := (t, old_t - quotient * t)       
    <b>output</b> "Bézout coefficients:", (old_s, old_t)
    <b>output</b> "greatest common divisor:", old_r
    <b>output</b> "quotients by the gcd:", (t, s)
</pre>
<p>It should be noted that the quotients of <i>a</i> and <i>b</i> by their greatest common divisor, which are output, may have an incorrect sign. This is easy to correct at the end of the computation, but has not been done here for simplifying the code. Similarly, if either <i>a</i> or <i>b</i> is zero and the other is negative, the greatest common divisor that is output is negative, and all the signs of the output must be changed.</p>
<h2>Simplification of fractions</h2>
<p>A fraction <img class="mwe-math-fallback-image-inline tex" alt="\frac{a}{b}" src="//upload.wikimedia.org/math/b/d/4/bd4e4fc402cfad741450ee345fef4a60.png"> is in canonical simplified form if <i>a</i> and <i>b</i> are coprime and <i>b</i> is positive. This canonical simplified form can be obtained by replacing the three <b>output</b> lines of the preceding pseudo code by</p>
<p>WHATSON? 7f7c4da2-e8d4-4e63-98ad-54c7cf1d1fb4</p>
<pre>
<b>if</b> s = 0 <b>then output</b> "Division by zero"
<b>if</b> s = 1 <b>then output</b> <img class="mwe-math-fallback-image-inline tex" alt="-t" src="//upload.wikimedia.org/math/b/7/c/b7cc4b6b2b8c0f37377b5cc259385de0.png">     (<i>Optional line, for avoiding output like <img class="mwe-math-fallback-image-inline tex" alt="\frac{-t}{1}" src="//upload.wikimedia.org/math/c/8/b/c8b2832f45bb2c4c59c73386ac5bf890.png"></i>
<b>else if</b> s &gt; 0 <b>then output</b> <img class="mwe-math-fallback-image-inline tex" alt="\frac{-t}{s}" src="//upload.wikimedia.org/math/7/4/9/749949042bb64c8416c8bfc9389f362c.png">
<b>else return</b>  <img class="mwe-math-fallback-image-inline tex" alt="\frac{t}{-s}" src="//upload.wikimedia.org/math/7/e/f/7ef25e4992445b60e22427a17f6e01fc.png">
</pre>
<p>The proof of this algorithm relies on the fact that <i>s</i> and <i>t</i> are two coprime integers such that <i>as</i> + <i>bt</i> = 0, and thus <img class="mwe-math-fallback-image-inline tex" alt="\frac{a}{b} = -\frac{t}{s}" src="//upload.wikimedia.org/math/f/1/a/f1ab329a08d7303c18dc4d2e9f3fa568.png">. To get the canonical simplified form, it suffices to move the minus sign for having a positive denominator.</p>
<p>If <i>b</i> divides <i>a</i> evenly, the algorithm executes only one iteration, and we have <i>s</i> = 1 at the end of the algorithm. It the only case where the output is an integer.</p>
<h2>Computing multiplicative inverses in modular structures</h2>
<p>Extended Euclidean algorithm is the basic tool for computing multiplicative inverses in modular structures, typically the modular integers and the algebraic field extensions. An important instance of the latter case are the finite fields of non-prime order.</p>
<h3>Modular integers</h3>
<p>If <i>n</i> is a positive integer, the ring <b>Z</b>/<i>n</i><b>Z</b> may be identified with the set {0, 1, ..., <i>n</i>-1} of the remainders of Euclidean division by <i>n</i>, the addition and the multiplication consisting in taking the remainder by <i>n</i> of the result of the addition and the multiplication of integers. An element <i>a</i> of <b>Z</b>/<i>n</i><b>Z</b> has a multiplicative inverse (that is, it is a unit) if it is coprime to <i>n</i>. In particular, if <i>n</i> is prime, <i>a</i> has a multiplicative inverse if it is not zero (modulo <i>n</i>). Thus <b>Z</b>/<i>n</i><b>Z</b> is a field if and only if <i>n</i> is prime.</p>
<p>Bézout's identity asserts that <i>a</i> and <i>n</i> are coprime if and only if there exist integers <i>s</i> and <i>t</i> such that</p>
<p>Reducing this identity modulo <i>n</i> gives</p>
<p>Thus <i>t</i>, or, more exactly, the remainder of the division of <i>t</i> by <i>n</i>, is the multiplicative inverse of <i>a</i> modulo <i>n</i>.</p>
<p>To adapt the extended Euclidean algorithm to this problem, one should remark that the Bézout coefficient of <i>n</i> is not needed, and thus does not need to be computed. Also, for getting a result which is positive and lower than <i>n</i>, one may use the fact that the integer <i>t</i> provided by the algorithm satisfies |<i>t</i>| &lt; <i>n</i>. That is, if <i>t</i> &lt; 0, one must add <i>n</i> to it at the end. This results in the pseudocode, in which the input <i>n</i> is an integer larger than 1.</p>
<p>WHATSON? a1d0dc8d-a70e-4ec2-bbe6-1f46c1646488</p>
<pre>
<b>function</b> inverse(a, n)
    t := 0;     newt := 1;    
    r := n;     newr := a;    
    <b>while</b> newr ≠ 0
        quotient := r <b>div</b> newr
        (t, newt) := (newt, t - quotient * newt) 
        (r, newr) := (newr, r - quotient * newr)
    <b>if</b> r &gt; 1 then <b>return</b> "a is not invertible"
    <b>if</b> t &lt; 0 <b>then</b> t := t + n
    <b>return</b> t
</pre>
<h3>Simple algebraic field extensions</h3>
<p>Extended Euclidean algorithm is also the main tool for computing multiplicative inverses in simple algebraic field extensions. An important case, widely used in cryptography and coding theory is that of finite fields of non-prime order. In fact, if <i>p</i> is a prime number, and <i>q</i> = <i>p</i>, the field of order <i>q</i> is a simple algebraic extension of the prime field of <i>p</i> elements, generated by a root of an irreducible polynomial of degree <i>d</i>.</p>
<p>A simple algebraic extension <i>L</i> of a field <i>K</i>, generated by the root of an irreducible polynomial <i>p</i> of degree <i>d</i> may be identified to the quotient ring <img class="mwe-math-fallback-image-inline tex" alt="K[X]/\langle p\rangle," src="//upload.wikimedia.org/math/6/b/b/6bb6187fcc7cc5cac1ca42cae4d6fe7e.png">, and its elements are in bijective correspondence with the polynomials of degree less than <i>d</i>. The addition in <i>L</i> is the addition of polynomials. The multiplication in <i>L</i> is the remainder of the Euclidean division by <i>p</i> of the product of polynomials. Thus, to complete the arithmetic in <i>L</i>, it remains only to define how to compute multiplicative inverses. This is done by the extended Euclidean algorithm.</p>
<p>The algorithm is very similar to that provided above for computing the modular multiplicative inverse. There are two main differences: firstly the last but one line is not needed, because the Bézout coefficient that is provided has always a degree less than <i>d</i>. Secondly, the greatest common divisor which is provided, when the input polynomials are coprime, may be any non zero element of <i>K</i>; this Bézout coefficient (a polynomial generally of positive degree) has thus to be multiplied by the inverse of this element of <i>K</i>. In the pseudocode which follows, <i>p</i> is a polynomial of degree greater than one, and <i>a</i> is a polynomial. Moreover, <b>div</b> is an auxiliary function that computes the quotient of the Euclidean division.</p>
<p>WHATSON? 69994b69-06f8-4fb1-9c6f-2da95f85efa8</p>
<pre>
<b>function</b> inverse(a, p)
    t := 0;     newt := 1;    
    r := p;     newr := a;    
    <b>while</b> newr ≠ 0
        quotient := r <b>div</b> newr
        (r, newr) := (newr, r - quotient * newr)
        (t, newt) := (newt, t - quotient * newt) 
    <b>if</b> degree(r) &gt; 0 then 
        <b>return</b> "Either p is not irreducible or a is a multiple of p"
    <b>return</b> (1/r) * t
</pre>
<h4>Example</h4>
<p>For example, if the polynomial used to define the finite field GF(2) is <i>p</i> = <i>x</i> + <i>x</i> + <i>x</i> + <i>x</i> + 1, and <i>a</i> = <i>x</i> + <i>x</i> + <i>x</i> + 1 is the element whose inverse is desired, then performing the algorithm results in the computation described in the following table. Let us recall that in fields of order 2, one has -<i>z</i> = <i>z</i> and <i>z</i> + <i>z</i> = 0 for every element <i>z</i> in the field). Note also that 1 being the only nonzero element of GF(2), the adjustment in the last line of the pseudocode is not needed.</p>
<p>Thus, the inverse is <i>x</i> + <i>x</i> + <i>x</i> + <i>x</i>, as can be confirmed by multiplying the two elements together, and taking the remainder by <i>p</i> of the result.</p>
<h2>The case of more than two numbers</h2>
<p>One can handle the case of more than two numbers iteratively. First we show that <img class="mwe-math-fallback-image-inline tex" alt="\gcd(a,b,c) = \gcd(\gcd(a,b),c)" src="//upload.wikimedia.org/math/a/3/3/a335e998a940b7d26318c40fea742881.png">. To prove this let <img class="mwe-math-fallback-image-inline tex" alt="d=\gcd(a,b,c)" src="//upload.wikimedia.org/math/4/a/3/4a3aaedfc3012c94cb7efd403ef77aa7.png">. By definition of gcd <img class="mwe-math-fallback-image-inline tex" alt="d" src="//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png"> is a divisor of <img class="mwe-math-fallback-image-inline tex" alt="a" src="//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png"> and <img class="mwe-math-fallback-image-inline tex" alt="b" src="//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png">. Thus <img class="mwe-math-fallback-image-inline tex" alt="\gcd(a,b)=k d" src="//upload.wikimedia.org/math/9/2/5/92594b5fec415935f2b3ffbbce424ad8.png"> for some <img class="mwe-math-fallback-image-inline tex" alt="k" src="//upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png">. Similarly <img class="mwe-math-fallback-image-inline tex" alt="d" src="//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png"> is a divisor of <img class="mwe-math-fallback-image-inline tex" alt="c" src="//upload.wikimedia.org/math/4/a/8/4a8a08f09d37b73795649038408b5f33.png"> so <img class="mwe-math-fallback-image-inline tex" alt="c=jd" src="//upload.wikimedia.org/math/6/0/f/60f7057202d85c52c278ab3017935197.png"> for some <img class="mwe-math-fallback-image-inline tex" alt="j" src="//upload.wikimedia.org/math/3/6/3/363b122c528f54df4a0446b6bab05515.png">. Let <img class="mwe-math-fallback-image-inline tex" alt="u=\gcd(k,j)" src="//upload.wikimedia.org/math/f/2/c/f2c8ca87df00f982f6a522da064f3b7a.png">. By our construction of <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png">, <img class="mwe-math-fallback-image-inline tex" alt="ud | a,b,c" src="//upload.wikimedia.org/math/6/7/c/67c3694c7bc3d925c23d299b9159f27e.png"> but since <img class="mwe-math-fallback-image-inline tex" alt="d" src="//upload.wikimedia.org/math/8/2/7/8277e0910d750195b448797616e091ad.png"> is the greatest divisor <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> is a unit. And since <img class="mwe-math-fallback-image-inline tex" alt="ud=\gcd(gcd(a,b),c)" src="//upload.wikimedia.org/math/f/1/4/f14e6e4738b474ca0af7b3a4d0c48de0.png"> the result is proven.</p>
<p>So if <img class="mwe-math-fallback-image-inline tex" alt="na + mb = \gcd(a,b)" src="//upload.wikimedia.org/math/b/e/a/bea73f0ee55857025ab315bf79f5d062.png"> then there are <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> and <img class="mwe-math-fallback-image-inline tex" alt="y" src="//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png"> such that <img class="mwe-math-fallback-image-inline tex" alt="x\gcd(a,b) + yc = \gcd(a,b,c)" src="//upload.wikimedia.org/math/c/4/8/c487c323d545da7bfbb46eb582415b2e.png"> so the final equation will be</p>
<p>So then to apply to n numbers we use induction</p>
<p>with the equations following directly.</p>
<h2>See also</h2>
<ul>
<li>Euclidean domain</li>
<li>Linear congruence theorem</li>
</ul>
</body>
</html>