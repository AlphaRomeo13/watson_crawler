<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Grovers-algorithm---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Grover's algorithm</h1>
<p><b>Grover's algorithm</b> is a quantum algorithm for searching an unsorted database with <i>N</i> entries in <i>O</i>(<i>N</i>) time and using <i>O</i>(log <i>N</i>) storage space (see big O notation). Lov Grover formulated it in 1996.</p>
<p>In models of classical computation, searching an unsorted database cannot be done in less than linear time (so merely searching through every item is optimal). Grover's algorithm illustrates that in the quantum model searching can be done faster than this; in fact its time complexity <i>O</i>(<i>N</i>) is asymptotically the fastest possible for searching an unsorted database in the <i>linear</i> quantum model. It provides a quadratic speedup, unlike other quantum algorithms, which may provide exponential speedup over their classical counterparts. However, even quadratic speedup is considerable when <i>N</i> is large. Unsorted search speeds of up to constant time are achievable in the <i>nonlinear</i> quantum model.</p>
<p>Like many quantum algorithms, Grover's algorithm is probabilistic in the sense that it gives the correct answer with high probability. The probability of failure can be decreased by repeating the algorithm. (An example of a deterministic quantum algorithm is the Deutsch-Jozsa algorithm, which always produces the correct answer.)</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Applications</li>
<li>2 Setup</li>
<li>3 Algorithm steps</li>
<li>4 The first iteration</li>
<li>5 Description of <i>U<sub>ω</sub></i></li>
<li>6 Geometric proof of correctness</li>
<li>7 Algebraic proof of correctness</li>
<li>8 Extension to space with multiple targets</li>
<li>9 Quantum partial search</li>
<li>10 Optimality</li>
<li>11 Applicability and Limitations</li>
<li>12 See also</li>
<li>13 Notes</li>
<li>14 References</li>
<li>15 External links</li>
</ul>
<p></p>
<h2>Applications</h2>
<p>Although the purpose of Grover's algorithm is usually described as "searching a database", it may be more accurate to describe it as "inverting a function". Roughly speaking, if we have a function <i>y=f(x)</i> that can be evaluated on a quantum computer, this algorithm allows us to calculate <i>x</i> when given <i>y</i>. Inverting a function is related to the searching of a database because we could come up with a function that produces a particular value of <i>y</i> if <i>x</i> matches a desired entry in a database, and another value of <i>y</i> for other values of <i>x</i>.</p>
<p>Grover's algorithm can also be used for estimating the mean and median of a set of numbers, and for solving the Collision problem. The algorithm can be further optimized if there is more than one matching entry and the number of matches is known beforehand.</p>
<h2>Setup</h2>
<p>Consider an unsorted database with <i>N</i> entries. The algorithm requires an <i>N</i>-dimensional state space <i>H</i>, which can be supplied by <i>n</i>=log<sub>2</sub> <i>N</i> qubits. Consider the problem of determining the index of the database entry which satisfies some search criterion. Let <i>f</i> be the function which maps database entries to <i>0</i> or <i>1</i>, where <i>f(ω)=1</i> if and only if <i>ω</i> satisfies the search criterion. We are provided with (quantum black box) access to a subroutine in the form of a unitary operator, <i>U<sub>ω</sub></i>, which acts as follows (for the <i>ω</i> for which <i>f(ω)=1</i>):</p>
<p>Our goal is to identify the index <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png">.</p>
<h2>Algorithm steps</h2>
<p>The steps of Grover's algorithm are given as follows. Let <img class="mwe-math-fallback-image-inline tex" alt="|s\rangle" src="//upload.wikimedia.org/math/8/5/0/8507ccb5f7965a355163714b3c7492fd.png"> denote the uniform superposition over all states</p>
<p>Then the operator</p>
<p>is known as the Grover diffusion operator.</p>
<p>Here is the algorithm:</p>
<ol>
<li>Initialize the system to the state<br>
<img class="mwe-math-fallback-image-inline tex" alt="|s\rang = \frac{1}{\sqrt{N}} \sum_{x=1}^{N} |x\rang " src="//upload.wikimedia.org/math/1/3/4/13420954dfe20fdf5c5ba4fc0e33b12b.png"></li>
<li>Perform the following "Grover iteration" <i>r(N)</i> times. The function <i>r(N),</i> which is asymptotically <i>O(N)</i>, is described below.
<ol>
<li>Apply the operator <img class="mwe-math-fallback-image-inline tex" alt="U_\omega" src="//upload.wikimedia.org/math/6/c/0/6c0425d6399a3f437b5b7fa6e246545d.png">.</li>
<li>Apply the operator <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png">.</li>
</ol>
</li>
<li>Perform the measurement Ω. The measurement result will be λ<sub>ω</sub> with probability approaching 1 for N≫1. From λ<sub>ω</sub>, ω may be obtained.</li>
</ol>
<ol>
<li>Apply the operator <img class="mwe-math-fallback-image-inline tex" alt="U_\omega" src="//upload.wikimedia.org/math/6/c/0/6c0425d6399a3f437b5b7fa6e246545d.png">.</li>
<li>Apply the operator <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png">.</li>
</ol>
<h2>The first iteration</h2>
<p>A preliminary observation, in parallel with our definition</p>
<p>is that <i>U<sub>ω</sub></i> can be expressed in an alternate way:</p>
<p>To prove this it suffices to check how <i>U<sub>ω</sub></i> acts on basis states:</p>
<p>The following computations show what happens in the first iteration:</p>
<p>After application of the two operators ( <img class="mwe-math-fallback-image-inline tex" alt="U_\omega" src="//upload.wikimedia.org/math/6/c/0/6c0425d6399a3f437b5b7fa6e246545d.png"> and <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png"> ), the amplitude of the searched-for element has increased from <img class="mwe-math-fallback-image-inline tex" alt=" \left| \lang \omega | s \rang \right|^2 = 1/N" src="//upload.wikimedia.org/math/5/a/9/5a94052e263363836189a5262760079b.png"> to <img class="mwe-math-fallback-image-inline tex" alt=" \left| \lang \omega | U_s U_\omega s \rang \right|^2  \approx 9/N" src="//upload.wikimedia.org/math/6/0/1/601f3faf3e22aaef557a4a2e9c27e961.png">.</p>
<h2>Description of <i>U<sub>ω</sub></i></h2>
<p>Grover's algorithm requires a "quantum oracle" operator <img class="mwe-math-fallback-image-inline tex" alt="U_{\omega}" src="//upload.wikimedia.org/math/8/2/3/82315f0e9eaacda91b78fd5d65369a35.png"> which can recognize solutions to the search problem and give them a negative sign. In order to keep the search algorithm general, we will leave the inner workings of the oracle as a black box, but will explain how the sign is flipped. The oracle contains a function <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png"> which returns <img class="mwe-math-fallback-image-inline tex" alt="f(x) = 1" src="//upload.wikimedia.org/math/5/4/6/546e912f7f43b2233ac97a4ecf33883e.png"> if <img class="mwe-math-fallback-image-inline tex" alt="|x\rang" src="//upload.wikimedia.org/math/c/5/e/c5e33a535eb6e21bcdf77047b23a3539.png"> is a solution to the search problem and <img class="mwe-math-fallback-image-inline tex" alt="f(x) = 0" src="//upload.wikimedia.org/math/f/d/0/fd05d8d90456c441c8f10641bd8576bc.png"> otherwise. The oracle is a unitary operator which operates on two qubits, the index qubit <img class="mwe-math-fallback-image-inline tex" alt="|x\rang" src="//upload.wikimedia.org/math/c/5/e/c5e33a535eb6e21bcdf77047b23a3539.png"> and the oracle qubit <img class="mwe-math-fallback-image-inline tex" alt="|q\rang" src="//upload.wikimedia.org/math/2/9/e/29e0963cb628d2dae47e2bf8315b1882.png">:</p>
<p>As usual, <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> denotes addition modulo 2. The operation flips the oracle qubit if <img class="mwe-math-fallback-image-inline tex" alt="f(x) = 1" src="//upload.wikimedia.org/math/5/4/6/546e912f7f43b2233ac97a4ecf33883e.png"> and leaves it alone otherwise. In Grover's algorithm we want to flip the sign of the state <img class="mwe-math-fallback-image-inline tex" alt="|x\rang" src="//upload.wikimedia.org/math/c/5/e/c5e33a535eb6e21bcdf77047b23a3539.png"> if it labels a solution. This is achieved by setting the oracle qubit in the state <img class="mwe-math-fallback-image-inline tex" alt="(|0\rang - |1\rang)/\sqrt{2}" src="//upload.wikimedia.org/math/a/f/0/af0db0aa5785318d9c88cf5bfc5a8a9e.png">, which is flipped to <img class="mwe-math-fallback-image-inline tex" alt="(|1\rang - |0\rang)/ \sqrt{2}" src="//upload.wikimedia.org/math/1/2/5/125a42d359a587eaa06751568ad9141f.png"> if <img class="mwe-math-fallback-image-inline tex" alt="|x\rang" src="//upload.wikimedia.org/math/c/5/e/c5e33a535eb6e21bcdf77047b23a3539.png"> is a solution:</p>
<p>We regard <img class="mwe-math-fallback-image-inline tex" alt="|x\rang" src="//upload.wikimedia.org/math/c/5/e/c5e33a535eb6e21bcdf77047b23a3539.png"> as flipped, thus the oracle qubit is not changed, so by convention the oracle qubits are usually not mentioned in the specification of Grover's algorithm. Thus the operation of the oracle <img class="mwe-math-fallback-image-inline tex" alt="U_{\omega}" src="//upload.wikimedia.org/math/8/2/3/82315f0e9eaacda91b78fd5d65369a35.png"> is simply written as:</p>
<h2>Geometric proof of correctness</h2>
<p>Consider the plane spanned by <img class="mwe-math-fallback-image-inline tex" alt="|s\rang" src="//upload.wikimedia.org/math/8/5/0/8507ccb5f7965a355163714b3c7492fd.png"> and <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png">; equivalently, the plane spanned by <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png"> and the perpendicular ket <img class="mwe-math-fallback-image-inline tex" alt="|s'\rang = \frac{1}{\sqrt{N - 1}}\sum_{x \neq \omega} |x\rang" src="//upload.wikimedia.org/math/e/a/e/eae7d469dd318cb713b223dfd785d454.png">. We will consider the first iteration, acting on the initial ket <img class="mwe-math-fallback-image-inline tex" alt="|s\rang" src="//upload.wikimedia.org/math/8/5/0/8507ccb5f7965a355163714b3c7492fd.png">. Since <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png"> is one of the basis vectors in <img class="mwe-math-fallback-image-inline tex" alt="|s\rang" src="//upload.wikimedia.org/math/8/5/0/8507ccb5f7965a355163714b3c7492fd.png"> the overlap is</p>
<p>In geometric terms, the angle <img class="mwe-math-fallback-image-inline tex" alt="\theta/2" src="//upload.wikimedia.org/math/5/d/c/5dc3a103b72cc55292069f4caad757e6.png"> between <img class="mwe-math-fallback-image-inline tex" alt="|s\rang" src="//upload.wikimedia.org/math/8/5/0/8507ccb5f7965a355163714b3c7492fd.png"> and <img class="mwe-math-fallback-image-inline tex" alt="|s'\rang" src="//upload.wikimedia.org/math/c/7/0/c70f0a1f5220f672d3b93f4e2d47dde5.png"> is given by:</p>
<p>The operator <img class="mwe-math-fallback-image-inline tex" alt="U_{\omega}" src="//upload.wikimedia.org/math/8/2/3/82315f0e9eaacda91b78fd5d65369a35.png"> is a reflection at the hyperplane orthogonal to <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png"> for vectors in the plane spanned by <img class="mwe-math-fallback-image-inline tex" alt="|s'\rang" src="//upload.wikimedia.org/math/c/7/0/c70f0a1f5220f672d3b93f4e2d47dde5.png"> and <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png">; i.e. it acts as a reflection across <img class="mwe-math-fallback-image-inline tex" alt="|s'\rang" src="//upload.wikimedia.org/math/c/7/0/c70f0a1f5220f672d3b93f4e2d47dde5.png">. The operator <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png"> is a reflection through <img class="mwe-math-fallback-image-inline tex" alt="|s\rang" src="//upload.wikimedia.org/math/8/5/0/8507ccb5f7965a355163714b3c7492fd.png">. Therefore, the state vector remains in the plane spanned by <img class="mwe-math-fallback-image-inline tex" alt="|s'\rang" src="//upload.wikimedia.org/math/c/7/0/c70f0a1f5220f672d3b93f4e2d47dde5.png"> and <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png"> after each application of the operators <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png"> and <img class="mwe-math-fallback-image-inline tex" alt="U_{\omega}" src="//upload.wikimedia.org/math/8/2/3/82315f0e9eaacda91b78fd5d65369a35.png">, and it is straightforward to check that the operator <img class="mwe-math-fallback-image-inline tex" alt="U_s U_{\omega}" src="//upload.wikimedia.org/math/0/0/d/00dddcfaf9187f537173b70efe58fd77.png"> of each Grover iteration step rotates the state vector by an angle of <img class="mwe-math-fallback-image-inline tex" alt="\theta = 2\arcsin \frac{1}{\sqrt{N}}  " src="//upload.wikimedia.org/math/7/5/6/7563a2518d74ce62f7d99d461cb27fba.png">.</p>
<p>We need to stop when the state vector passes close to <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png">; after this, subsequent iterations rotate the state vector <i>away</i> from <img class="mwe-math-fallback-image-inline tex" alt="|\omega\rang" src="//upload.wikimedia.org/math/4/d/d/4dd09178cafc3ffd71217e813f93462c.png">, reducing the probability of obtaining the correct answer. The exact probability of measuring the correct answer is:</p>
<p>where <i>r</i> is the (integer) number of Grover iterations. The earliest time that we get a near-optimal measurement is therefore <img class="mwe-math-fallback-image-inline tex" alt="r \approx \pi \sqrt{N} / 4" src="//upload.wikimedia.org/math/6/c/5/6c5a81865529814092493f18b04c8d2c.png">.</p>
<h2>Algebraic proof of correctness</h2>
<p>To complete the algebraic analysis we need to find out what happens when we repeatedly apply <img class="mwe-math-fallback-image-inline tex" alt="U_s U_\omega" src="//upload.wikimedia.org/math/6/b/3/6b3049d48b65697a75a0e7ed18805aae.png">. A natural way to do this is by eigenvalue analysis of a matrix. Notice that during the entire computation, the state of the algorithm is a linear combination of <img class="mwe-math-fallback-image-inline tex" alt="s" src="//upload.wikimedia.org/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\omega" src="//upload.wikimedia.org/math/4/d/1/4d1b7b74aba3cfabd624e898d86b4602.png">. We can write the action of <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png"> and <img class="mwe-math-fallback-image-inline tex" alt="U_\omega" src="//upload.wikimedia.org/math/6/c/0/6c0425d6399a3f437b5b7fa6e246545d.png"> in the space spanned by <img class="mwe-math-fallback-image-inline tex" alt="\{|s\rang, |\omega\rang\}" src="//upload.wikimedia.org/math/1/7/9/179290543f786cb0b0db85acfbb5474b.png"> as:</p>
<p>So in the basis <img class="mwe-math-fallback-image-inline tex" alt="\{ |\omega\rang, |s\rang \}" src="//upload.wikimedia.org/math/8/3/a/83abe858a582fb7bd8f4b0ebda62991d.png"> (which is neither orthogonal nor a basis of the whole space) the action <img class="mwe-math-fallback-image-inline tex" alt="U_sU_\omega" src="//upload.wikimedia.org/math/6/b/3/6b3049d48b65697a75a0e7ed18805aae.png"> of applying <img class="mwe-math-fallback-image-inline tex" alt="U_\omega" src="//upload.wikimedia.org/math/6/c/0/6c0425d6399a3f437b5b7fa6e246545d.png"> followed by <img class="mwe-math-fallback-image-inline tex" alt="U_s" src="//upload.wikimedia.org/math/1/e/a/1ead6866e77cbd73ff639b8bdeb28e0f.png"> is given by the matrix</p>
<p>This matrix happens to have a very convenient Jordan form. If we define <img class="mwe-math-fallback-image-inline tex" alt="t = \arcsin(1/\sqrt{N})" src="//upload.wikimedia.org/math/0/b/e/0bed268b33b85dd093705cac24eb5677.png">, it is</p>
<p>It follows that <i>r</i>th power of the matrix (corresponding to <i>r</i> iterations) is</p>
<p>Using this form we can use trigonometric identities to compute the probability of observing <i>ω</i> after <i>r</i> iterations mentioned in the previous section,</p>
<p>Alternatively, one might reasonably imagine that a near-optimal time to distinguish would be when the angles <i>2rt</i> and <i>-2rt</i> are as far apart as possible, which corresponds to <img class="mwe-math-fallback-image-inline tex" alt="2rt \approx \pi/2" src="//upload.wikimedia.org/math/1/d/8/1d88f05484279f28700fa1fd72ff9592.png"> or <img class="mwe-math-fallback-image-inline tex" alt="r = \pi/4t = \pi/4\arcsin(1/\sqrt{N}) \approx \pi\sqrt{N}/4" src="//upload.wikimedia.org/math/8/e/1/8e1c796d88f0f9d6fd5c7fc612d9f2cc.png">. Then the system is in state</p>
<p>A short calculation now shows that the observation yields the correct answer <i>ω</i> with error <i>O(1/N)</i>.</p>
<h2>Extension to space with multiple targets</h2>
<p>If, instead of 1 matching entry, there are <i>k</i> matching entries, the same algorithm works but the number of iterations must be <i>π(N/k)/4</i> instead of <i>πN/4</i>. There are several ways to handle the case if <i>k</i> is unknown. For example, one could run Grover's algorithm several times, with</p>
<p>iterations. For any <i>k</i>, one of the iterations will find a matching entry with a sufficiently high probability. The total number of iterations is at most</p>
<p>which is still O(<i>N</i>). It can be shown that this can be improved. If the number of marked items is <i>k</i>, where <i>k</i> is unknown, there is an algorithm that finds the solution in <img class="mwe-math-fallback-image-inline tex" alt="\sqrt{N/k}" src="//upload.wikimedia.org/math/e/7/2/e72efe7bbb8fc9c24b8a503d954fbc44.png"> queries. This fact is used in order to solve the collision problem.</p>
<h2>Quantum partial search</h2>
<p>A modification of Grover's algorithm called quantum partial search was described by Grover and Radhakrishnan in 2004. In partial search, one is not interested in finding the exact address of the target item, only the first few digits of the address. Equivalently, we can think of "chunking" the search space into blocks, and then asking "in which block is the target item?". In many applications, such a search yields enough information if the target address contains the information wanted. For instance, to use the example given by L.K. Grover, if one has a list of students organized by class rank, we may only be interested in whether a student is in the lower 25%, 25-50%, 50-70% or 75-100% percentile.</p>
<p>To describe partial search, we consider a database separated into <img class="mwe-math-fallback-image-inline tex" alt="K" src="//upload.wikimedia.org/math/a/5/f/a5f3c6a11b03839d46af9fb43c97c188.png"> blocks, each of size <img class="mwe-math-fallback-image-inline tex" alt="b = N/K" src="//upload.wikimedia.org/math/8/4/9/8492b653e78528ddc2f2460933b0d067.png">. Obviously, the partial search problem is easier. Consider the approach we would take classically - we pick one block at random, and then perform a normal search through the rest of the blocks (in set theory language, the complement). If we don't find the target, then we know it's in the block we didn't search. The average number of iterations drops from <img class="mwe-math-fallback-image-inline tex" alt="N/2" src="//upload.wikimedia.org/math/0/e/8/0e871a79d98cb1c7563b39b89aaf6153.png"> to <img class="mwe-math-fallback-image-inline tex" alt="(N-b)/2" src="//upload.wikimedia.org/math/8/5/9/859e87fdd2890ef6c9dca2df5a27b6ef.png">.</p>
<p>Grover's algorithm requires <img class="mwe-math-fallback-image-inline tex" alt="\pi/4\sqrt{N}" src="//upload.wikimedia.org/math/b/e/1/be14c712c1409794c9ac488c249b9532.png"> iterations. Partial search will be faster by a numerical factor which depends on the number of blocks <img class="mwe-math-fallback-image-inline tex" alt="K" src="//upload.wikimedia.org/math/a/5/f/a5f3c6a11b03839d46af9fb43c97c188.png">. Partial search uses <img class="mwe-math-fallback-image-inline tex" alt="n_1" src="//upload.wikimedia.org/math/c/a/2/ca28d2957bcfd844805dfd1c339dfc2f.png"> global iterations and <img class="mwe-math-fallback-image-inline tex" alt="n_2" src="//upload.wikimedia.org/math/2/7/e/27e7b1346e011cf2896a04df87832534.png"> local iterations. The global Grover operator is designated <img class="mwe-math-fallback-image-inline tex" alt="G_1" src="//upload.wikimedia.org/math/6/6/8/668ec86dfe5be1ed6e29ff4743264698.png"> and the local Grover operator is designated <img class="mwe-math-fallback-image-inline tex" alt="G_2" src="//upload.wikimedia.org/math/2/1/d/21deb5c93cef58f00f9ba61cc69e997f.png">.</p>
<p>The global Grover operator acts on the blocks. Essentially, it is given as follows:</p>
<ol>
<li>Perform <img class="mwe-math-fallback-image-inline tex" alt="j_1" src="//upload.wikimedia.org/math/c/5/4/c54d08f45cdf264f219cc6186e938d63.png"> standard Grover iterations on the entire database.</li>
<li>Perform <img class="mwe-math-fallback-image-inline tex" alt="j_2" src="//upload.wikimedia.org/math/7/d/a/7dac011accb55a5d04158d0e592179ee.png"> local Grover iterations. A local Grover iteration is a direct sum of Grover iterations over each block.</li>
<li>Perform one standard Grover iteration</li>
</ol>
<p>The optimal values of <img class="mwe-math-fallback-image-inline tex" alt="j_1" src="//upload.wikimedia.org/math/c/5/4/c54d08f45cdf264f219cc6186e938d63.png"> and <img class="mwe-math-fallback-image-inline tex" alt="j_2" src="//upload.wikimedia.org/math/7/d/a/7dac011accb55a5d04158d0e592179ee.png"> are discussed in the paper by Grover and Radhakrishnan. One might also wonder what happens if one applies successive partial searches at different levels of "resolution". This idea was studied in detail by Korepin and Xu, who called it binary quantum search. They proved that it is not in fact any faster than performing a single partial search.</p>
<h2>Optimality</h2>
<p>It is known that Grover's algorithm is optimal. That is, any algorithm that accesses the database only by using the operator U<sub>ω</sub> must apply U<sub>ω</sub> at least as many times as Grover's algorithm. This result is important in understanding the limits of quantum computation. If the Grover's search problem was solvable with <i>log N</i> applications of U<sub>ω</sub>, that would imply that NP is contained in BQP, by transforming problems in NP into Grover-type search problems. The optimality of Grover's algorithm suggests (but does not prove) that NP is not contained in BQP.</p>
<p>The number of iterations for <i>k</i> matching entries, <i>π(N/k)/4</i>, is also optimal.</p>
<h2>Applicability and Limitations</h2>
<p>When applications of Grover's algorithm are considered, it should be emphasized that the database is not represented explicitly. Instead, an oracle is invoked to evaluate an item by its index. Reading a full data-base item by item and converting it into such a representation may take a lot longer than Grover's search. To account for such effects, Grover's algorithm can be viewed as solving an equation or satisfying a constraint. In such applications, the oracle is a way to check the constraint and is not related to the search algorithm. This separation usually prevents algorithmic optimizations, whereas conventional search algorithms often rely on such optimizations and avoid exhaustive search. These and other considerations about using Grover's algorithm are discussed in </p>
<h2>See also</h2>
<ul>
<li>Amplitude amplification</li>
<li>Shor's algorithm</li>
</ul>
<h2>Notes</h2>
<ol>
<li>^   Bennett C.H., Bernstein E., Brassard G., Vazirani U., <i>The strengths and weaknesses of quantum computation</i>. SIAM Journal on Computing 26(5): 1510–1523 (1997). Shows the optimality of Grover's algorithm.</li>
<li><b>^</b> Meyer, D.A. and Wong, T.G. <i>Nonlinear Quantum Search Using the Gross-Pitaevskii Equation.</i></li>
<li>^   Michel Boyer; Gilles Brassard; Peter Høyer; Alain Tapp (1998), <i>Fortsch. Phys.</i> <b>46</b>: 493–506, arXiv:quant-ph/9605034, Bibcode:1998ForPh..46..493B, doi:10.1002/(SICI)1521-3978(199806)46:4/5&amp;lt;493::AID-PROP493&amp;gt;3.0.CO;2-P </li>
<li><b>^</b> Andris Ambainis (2004), <i>Quantum search algorithms</i>, <i>SIGACT News</i> <b>35</b> (2): 22–35, arXiv:quant-ph/0504012, Bibcode:2005quant.ph..4012A, doi:10.1145/992287.992296 </li>
<li><b>^</b> L.K. Grover and J. Radhakrishnan,<i>Is partial quantum search of a database any easier?</i>. quant-ph/0407122</li>
<li><b>^</b> Viamontes G.F.; Markov I.L.; Hayes J.P. (2005), <i>Is Quantum Search Practical?</i>, <i>IEEE/AIP Computing in Science and Engineering</i> <b>7</b> (3): 62–70 </li>
</ol>
</body>
</html>