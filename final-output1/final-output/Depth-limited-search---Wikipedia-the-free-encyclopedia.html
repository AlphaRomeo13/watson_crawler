<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Depth-limited-search---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Depth-limited search</h1>
<ul>
<li>α–β</li>
<li>A*</li>
<li>B*</li>
<li>Backtracking</li>
<li>Beam</li>
<li>Bellman–Ford</li>
<li>Best-first</li>
<li>Bidirectional</li>
<li>Borůvka</li>
<li>Branch &amp; bound</li>
<li>BFS</li>
<li>British Museum</li>
<li>D*</li>
<li>DFS</li>
<li><strong class="selflink">Depth-limited</strong></li>
<li>Dijkstra</li>
<li>Edmonds</li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Hill climbing</li>
<li>IDA*</li>
<li>Iterative deepening</li>
<li>Johnson</li>
<li>Jump point</li>
<li>Kruskal</li>
<li>Lexicographic BFS</li>
<li>Prim</li>
<li>SMA*</li>
<li>Uniform-cost</li>
</ul>
<ul>
<li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li>
</ul>
<ul>
<li>Dynamic programming</li>
<li>Graph traversal</li>
<li>Tree traversal</li>
<li>Search games</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>In computer science <b>depth-limited search</b> is an algorithm to explore the vertices of a graph. It is a modification of depth-first search and is used for example in the iterative deepening depth-first search algorithm.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 General</li>
<li>2 Algorithm (informal)</li>
<li>3 Pseudocode</li>
<li>4 Properties
<ul>
<li>4.1 Space complexity</li>
<li>4.2 Time complexity</li>
<li>4.3 Completeness</li>
<li>4.4 Optimality</li>
</ul>
</li>
<li>5 Literature</li>
</ul>
<ul>
<li>4.1 Space complexity</li>
<li>4.2 Time complexity</li>
<li>4.3 Completeness</li>
<li>4.4 Optimality</li>
</ul>
<p></p>
<h2>General</h2>
<p>Like the normal depth-first search, depth-limited search is an uninformed search. It works exactly like depth-first search, but avoids its drawbacks regarding completeness by imposing a maximum limit on the depth of the search. Even if the search could still expand a vertex beyond that depth, it will not do so and thereby it will not follow infinitely deep paths or get stuck in cycles. Therefore depth-limited search will find a solution if it is within the depth limit, which guarantees at least completeness on all graphs.</p>
<h2>Algorithm (informal)</h2>
<ol>
<li>Determine the vertex where the search should start and assign the maximum search depth</li>
<li>Check if the current vertex is the goal state
<ul>
<li>If not: Do nothing</li>
<li>If yes: return</li>
</ul>
</li>
<li>Check if the current vertex is within the maximum search depth
<ul>
<li>If not: Do nothing</li>
<li>If yes:
<ol>
<li>Expand the vertex and save all of its successors in a stack</li>
<li>Call DLS recursively for all vertices of the stack and go back to Step 2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>If not: Do nothing</li>
<li>If yes: return</li>
</ul>
<ul>
<li>If not: Do nothing</li>
<li>If yes:
<ol>
<li>Expand the vertex and save all of its successors in a stack</li>
<li>Call DLS recursively for all vertices of the stack and go back to Step 2</li>
</ol>
</li>
</ul>
<ol>
<li>Expand the vertex and save all of its successors in a stack</li>
<li>Call DLS recursively for all vertices of the stack and go back to Step 2</li>
</ol>
<h2>Pseudocode</h2>
<p>WHATSON? 8690f2e4-cf55-486a-a939-ea90ff58b5b7</p>
<pre>
<b>DLS</b>(node, goal, depth) {
  if ( depth &gt;= 0 ) {
    if ( node == goal )
      return node

    for each child in expand(node)
      <b>DLS</b>(child, goal, depth-1)
  }
}
</pre>
<h2>Properties</h2>
<h3>Space complexity</h3>
<p>Since depth-limited search internally uses depth-first search, the space complexity is equivalent to that of normal depth-first search.</p>
<h3>Time complexity</h3>
<p>Since depth-limited search internally uses depth-first-search, the time complexity is equivalent to that of normal depth-first search, and is O(<img class="mwe-math-fallback-image-inline tex" alt=" \vert V \vert + \vert E \vert " src="//upload.wikimedia.org/math/7/1/c/71c05e889ae93db2913d00d94f634b8d.png">) where <img class="mwe-math-fallback-image-inline tex" alt=" \vert V \vert " src="//upload.wikimedia.org/math/0/e/0/0e023d3ec0c14433b1c9c3303e0ed5d1.png"> stands for the number of vertices and <img class="mwe-math-fallback-image-inline tex" alt=" \vert E \vert " src="//upload.wikimedia.org/math/e/4/c/e4ce0b3316dfd763e5401c160d6ede65.png"> for the number of edges in the explored graph. Note that depth-limited search does not explore the entire graph, but just the part that lies within the specified bound.</p>
<h3>Completeness</h3>
<p>Even though depth-limited search cannot follow infinitely long paths, nor can it get stuck in cycles, in general the algorithm is not complete since it does not find any solution that lies beyond the given search depth. But if the maximum search depth is chosen to be greater than the depth of a solution the algorithm becomes complete.</p>
<h3>Optimality</h3>
<p>Depth-limited search is not optimal. It still has the problem of depth-first search that it first explores one path to its end, thereby possibly finding a solution that is more expensive than some solution in another path.</p>
<h2>Literature</h2>
<ul>
<li>Russell, Stuart J.; Norvig, Peter (2003), <i>Artificial Intelligence: A Modern Approach</i> (2nd ed.), Upper Saddle River, New Jersey: Prentice Hall, ISBN 0-13-790395-2 </li>
</ul>
</body>
</html>