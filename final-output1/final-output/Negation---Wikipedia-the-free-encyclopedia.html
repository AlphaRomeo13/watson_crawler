<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Negation---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Negation</h1>
<p>In logic, <b>negation</b>, also called <b>logical complement</b>, is an operation that takes a proposition <i>p</i> to another proposition "not <i>p</i>", written <i>¬p</i>, which is interpreted intuitively as being true when <i>p</i> is false and false when <i>p</i> is true. Negation is thus a unary (single-argument) logical connective. It may be applied as an operation on propositions, truth values, or semantic values more generally. In classical logic, negation is normally identified with the truth function that takes <i>truth</i> to <i>falsity</i> and vice versa. In intuitionistic logic, according to the Brouwer–Heyting–Kolmogorov interpretation, the negation of a proposition <i>p</i> is the proposition whose proofs are the refutations of <i>p</i>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Definition</li>
<li>2 Notation</li>
<li>3 Properties
<ul>
<li>3.1 Double negation</li>
<li>3.2 Distributivity</li>
<li>3.3 Linearity</li>
<li>3.4 Self dual</li>
</ul>
</li>
<li>4 Rules of inference</li>
<li>5 Programming</li>
<li>6 Kripke semantics</li>
<li>7 See also</li>
<li>8 References</li>
<li>9 Further reading</li>
<li>10 External links</li>
</ul>
<ul>
<li>3.1 Double negation</li>
<li>3.2 Distributivity</li>
<li>3.3 Linearity</li>
<li>3.4 Self dual</li>
</ul>
<p></p>
<h2>Definition</h2>
<p>No agreement exists as to the possibility of defining negation, as to its logical status, function, and meaning, as to its field of applicability..., and as to the interpretation of the negative judgment, (F.H. Heinemann 1944).</p>
<p><i>Classical negation</i> is an operation on one logical value, typically the value of a proposition, that produces a value of <i>true</i> when its operand is false and a value of <i>false</i> when its operand is true. So, if statement <i>A</i> is true, then <i>¬A</i> (pronounced "not A") would therefore be false; and conversely, if <i>¬A</i> is true, then <i>A</i> would be false.</p>
<p>The truth table of <i>¬p</i> is as follows:</p>
<p>Classical negation can be defined in terms of other logical operations. For example, ¬<i>p</i> can be defined as <i>p</i> → <i>F</i>, where "→" is logical consequence and <i>F</i> is absolute falsehood. Conversely, one can define <i>F</i> as <i>p</i> &amp; ¬<i>p</i> for any proposition <i>p</i>, where "&amp;" is logical conjunction. The idea here is that any contradiction is false. While these ideas work in both classical and intuitionistic logic, they do not work in Brazilian logic, where contradictions are not necessarily false. But in classical logic, we get a further identity: <i>p</i> → <i>q</i> can be defined as ¬<i>p</i> ∨ <i>q</i>, where "∨" is logical disjunction: "not <i>p</i>, or <i>q</i>".</p>
<p>Algebraically, classical negation corresponds to complementation in a Boolean algebra, and intuitionistic negation to pseudocomplementation in a Heyting algebra. These algebras provide a semantics for classical and intuitionistic logic respectively.</p>
<h2>Notation</h2>
<p>The negation of a proposition <i>p</i> is notated in different ways in various contexts of discussion and fields of application. Among these variants are the following:</p>
<p>In Set Theory \ is also used to indicate 'not member of': U \ A is the set of all members of U that are not members of A.</p>
<p>No matter how it is notated or symbolized, the negation ¬<i>p</i> / −<i>p</i> can be read as "it is not the case that <i>p</i>", "not that <i>p</i>", or usually more simply (though not grammatically) as "not <i>p</i>".</p>
<h2>Properties</h2>
<h3>Double negation</h3>
<p>Within a system of classical logic, double negation, that is, the negation of the negation of a proposition <i>p</i>, is logically equivalent to <i>p</i>. Expressed in symbolic terms, ¬¬<i>p</i> ⇔ <i>p</i>. In intuitionistic logic, a proposition implies its double negation but not conversely. This marks one important difference between classical and intuitionistic negation. Algebraically, classical negation is called an involution of period two.</p>
<p>However, in intuitionistic logic we do have the equivalence of ¬¬¬<i>p</i> and ¬<i>p</i>. Moreover, in the propositional case, a sentence is classically provable if its double negation is intuitionistically provable. This result is known as Glivenko's theorem.</p>
<h3>Distributivity</h3>
<p>De Morgan's laws provide a way of distributing negation over disjunction and conjunction :</p>
<h3>Linearity</h3>
<p>In Boolean algebra, a linear function is one such that:</p>
<p>If there exists a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n</sub> <img class="mwe-math-fallback-image-inline tex" alt="\in" src="//upload.wikimedia.org/math/8/c/2/8c20c78b364ed5dbadd49e5b997aa1cc.png"> {0,1} such that f(b<sub>1</sub>, ..., b<sub>n</sub>) = a<sub>0</sub> ⊕ (a<sub>1</sub> <img class="mwe-math-fallback-image-inline tex" alt="\land" src="//upload.wikimedia.org/math/9/c/a/9cae4437756a15b8e44ec23e07fb1f65.png"> b<sub>1</sub>) ⊕ ... ⊕ (a<sub>n</sub> <img class="mwe-math-fallback-image-inline tex" alt="\land" src="//upload.wikimedia.org/math/9/c/a/9cae4437756a15b8e44ec23e07fb1f65.png"> b<sub>n</sub>), for all b<sub>1</sub>, ..., b<sub>n</sub> <img class="mwe-math-fallback-image-inline tex" alt="\in" src="//upload.wikimedia.org/math/8/c/2/8c20c78b364ed5dbadd49e5b997aa1cc.png"> {0,1}.</p>
<p>Another way to express this is that each variable always makes a difference in the truth-value of the operation or it never makes a difference. Negation is a linear logical operator.</p>
<h3>Self dual</h3>
<p>In Boolean algebra a self dual function is one such that:</p>
<p>f(a<sub>1</sub>, ..., a<sub>n</sub>) = ~f(~a<sub>1</sub>, ..., ~a<sub>n</sub>) for all a<sub>1</sub>, ..., a<sub>n</sub> <img class="mwe-math-fallback-image-inline tex" alt="\in" src="//upload.wikimedia.org/math/8/c/2/8c20c78b364ed5dbadd49e5b997aa1cc.png"> {0,1}. Negation is a self dual logical operator.</p>
<h2>Rules of inference</h2>
<p>There are a number of equivalent ways to formulate rules for negation. One usual way to formulate classical negation in a natural deduction setting is to take as primitive rules of inference <i>negation introduction</i> (from a derivation of <i>p</i> to both <i>q</i> and ¬<i>q</i>, infer ¬<i>p</i>; this rule also being called <i>reductio ad absurdum</i>), <i>negation elimination</i> (from <i>p</i> and ¬<i>p</i> infer q; this rule also being called <i>ex falso quodlibet</i>), and <i>double negation elimination</i> (from ¬¬<i>p</i> infer <i>p</i>). One obtains the rules for intuitionistic negation the same way but by excluding double negation elimination.</p>
<p>Negation introduction states that if an absurdity can be drawn as conclusion from <i>p</i> then <i>p</i> must not be the case (i.e. <i>p</i> is false (classically) or refutable (intuitionistically) or etc.). Negation elimination states that anything follows from an absurdity. Sometimes negation elimination is formulated using a primitive absurdity sign ⊥. In this case the rule says that from <i>p</i> and ¬<i>p</i> follows an absurdity. Together with double negation elimination one may infer our originally formulated rule, namely that anything follows from an absurdity.</p>
<p>Typically the intuitionistic negation ¬<i>p</i> of <i>p</i> is defined as <i>p</i>→⊥. Then negation introduction and elimination are just special cases of implication introduction (conditional proof) and elimination (modus ponens). In this case one must also add as a primitive rule <i>ex falso quodlibet</i>.</p>
<h2>Programming</h2>
<p>As in mathematics, negation is used in computer science to construct logical statements.</p>
<p>WHATSON? 67e37062-43d2-4b65-93da-99318e3dc3dd</p>
<pre>
    if (!(r == t))
    {
         /*...statements executed when r does NOT equal t...*/
    }
</pre>
<p>The "<code>!</code>" signifies logical NOT in B, C, and languages with a C-inspired syntax such as C++, Java, JavaScript, Perl, and PHP. "<code>NOT</code>" is the operator used in ALGOL 60, BASIC, and languages with an ALGOL- or BASIC-inspired syntax such as Pascal, Ada, Eiffel and Seed7. Some languages (C++, Perl, etc.) provide more than one operator for negation. A few languages like PL/I and Ratfor use <code>¬</code> for negation. Some modern computers and operating systems will display <code>¬</code> as <code>!</code> on files encoded in ASCII. Most modern languages allow the above statement to be shortened from <code>if (!(r == t))</code> to <code>if (r != t)</code>, which allows sometimes, when the compiler/interpreter is not able to optimize it, faster programs.</p>
<p>In computer science there is also <i>bitwise negation</i>. This takes the value given and switches all the binary 1s to 0s and 0s to 1s. See bitwise operation. This is often used to create ones' complement or "<code>~</code>" in C or C++ and two's complement (just simplified to "<code>-</code>" or the negative sign since this is equivalent to taking the arithmetic negative value of the number) as it basically creates the opposite (negative value equivalent) or mathematical complement of the value (where both values are added together they create a whole).</p>
<p>To get the absolute (positive equivalent) value of a given integer the following would work as the "<code>-</code>" changes it from negative to positive (it is negative because "<code>x &lt; 0</code>" yields true)</p>
<p>WHATSON? 61e2b07f-8dea-49af-bbd2-f709b2263f90</p>
<pre>
    unsigned int abs(int x)
    {
        if (x &lt; 0)
            return -x;
        else
            return x;
    }
</pre>
<p>To demonstrate logical negation:</p>
<p>WHATSON? e3f49932-e45b-4072-b9bd-e06bf9360e6d</p>
<pre>
    unsigned int abs(int x)
    {
        if (!(x &lt; 0))
            return x;
        else
            return -x;
    }
</pre>
<p>Inverting the condition and reversing the outcomes produces code that is logically equivalent to the original code, i.e. will have identical results for any input (note that depending on the compiler used, the actual instructions performed by the computer may differ).</p>
<p>This convention occasionally surfaces in written speech, as computer-related slang for <i>not</i>. The phrase <code>!voting</code>, for example, means "not voting".</p>
<h2>Kripke semantics</h2>
<p>In Kripke semantics where the semantic values of formulae are sets of possible worlds, negation can be taken to mean set-theoretic complementation. (See also possible world semantics.)</p>
<h2>See also</h2>
<ul>
<li>Logical conjunction</li>
<li>Logical disjunction</li>
<li>NOT gate</li>
<li>Bitwise NOT</li>
<li>Ampheck</li>
<li>Apophasis</li>
<li>Cyclic negation</li>
<li>Double negative elimination</li>
<li>Grammatical polarity</li>
<li>Negation (linguistics)</li>
<li>Negation as failure</li>
<li>Square of opposition</li>
<li>Binary opposition</li>
</ul>
</body>
</html>