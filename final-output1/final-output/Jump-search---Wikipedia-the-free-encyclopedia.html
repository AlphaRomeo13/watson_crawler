<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Jump-search---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Jump search</h1>
<p>In computer science, a <b>jump search</b> or <b>block search</b> refers to a search algorithm for ordered lists. It works by first checking all items <i>L</i><sub><i>km</i></sub>, where <img class="mwe-math-fallback-image-inline tex" alt="k \in \mathbb{N}" src="//upload.wikimedia.org/math/0/3/f/03fb00bac111ffad9dcbe228e73f28db.png"> and <i>m</i> is the block size, until an item is found that is larger than the search key. To find the exact position of the search key in the list a linear search is performed on the sublist <i>L</i><sub>[(<i>k</i>-1)<i>m</i>, <i>km</i>]</sub>.</p>
<p>The optimal value of <i>m</i> is √<i>n</i>, where <i>n</i> is the length of the list <i>L</i>. Because both steps of the algorithm look at, at most, √<i>n</i> items the algorithm runs in O(√<i>n</i>) time. This is better than a linear search, but worse than a binary search. The advantage over the latter is that a jump search only needs to jump backwards once, while a binary can jump backwards up to log <i>n</i> times. This can be important if a jumping backwards takes significantly more time than jumping forward.</p>
<p>The algorithm can be modified by performing multiple levels of jump search on the sublists, before finally performing the linear search. For an <i>k</i>-level jump search the optimum block size <i>m</i><sub><i>l</i></sub> for the <i>l</i> level (counting from 1) is <i>n</i>. The modified algorithm will perform <i>k</i> backward jumps and runs in O(<i>kn</i>) time.</p>
<h2>Implementation</h2>
<p>WHATSON? ceaa2213-f9f0-4f23-ac30-d5ad934539a2</p>
<pre>
<b>Algorithm</b> JumpSeach
  Input: An ordered list <i>L</i>, its length <i>n</i> and a search key <i>s</i>.
  Output: The position of <i>s</i> in <i>L</i>, or <b>nothing</b> if <i>s</i> is not in <i>L</i>.

  <i>a</i> ← 0
  <i>b</i> ← ⌊√<i>n</i>⌋

  <b>while</b> <i>L</i><sub>min(<i>b</i>,<i>n</i>)-1</sub> &lt; <i>s</i> <b>do</b>
    <i>a</i> ← <i>b</i>
    <i>b</i> ← <i>b</i> + ⌊√<i>n</i>⌋
    <b>if</b> <i>a</i> ≥ <i>n</i> <b>then</b>
      <b>return</b> <b>nothing</b>

  <b>while</b> <i>L</i><sub><i>a</i></sub> &lt; <i>s</i> <b>do</b>
    <i>a</i> ← <i>a</i> + 1
    <b>if</b> <i>a</i> = min(<i>b</i>,<i>n</i>)
      <b>return</b> <b>nothing</b>

  <b>if</b> <i>L</i><sub><i>a</i></sub> = <i>s</i> <b>then</b>
    <b>return</b> <i>a</i>
  <b>else</b>
    <b>return</b> <b>nothing</b>
</pre>
<h2>See also</h2>
<ul>
<li>Jump list</li>
<li>Interpolation search</li>
<li>Linear search - runs in O(<i>n</i>) time, only looks forward</li>
<li>Binary search - runs in O(log <i>n</i>) time, looks both forward and backward</li>
</ul>
</body>
</html>