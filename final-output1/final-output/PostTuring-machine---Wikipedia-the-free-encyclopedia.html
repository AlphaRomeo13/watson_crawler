<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PostTuring-machine---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Post–Turing machine</h1>
<p>A <b>Post–Turing machine</b> is a "program formulation" of an especially simple type of Turing machine, comprising a variant of Emil Post's Turing-equivalent model of computation described below. (Post's model and Turing's model, though very similar to one another, were developed independently. Turing's paper was received for publication in May 1936, followed by Post's in October.) A Post–Turing machine uses a binary alphabet, an infinite sequence of binary storage locations, and a primitive programming language with instructions for bi-directional movement among the storage locations and alteration of their contents one at a time. The names "Post–Turing program" and "Post–Turing machine" were used by Martin Davis in 1973–1974 (Davis 1973, p. 69ff). Later in 1980, Davis used the name "Turing–Post program" (Davis, in Steen p. 241).</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 1936: Post model</li>
<li>2 1947: Post's formal reduction of the Turing 5-tuples to 4-tuples</li>
<li>3 1954, 1957: Wang model</li>
<li>4 1974: first Davis model</li>
<li>5 1978 second Davis model</li>
<li>6 1994 (2nd Edition) Davis–Sigal–Weyuker's Post–Turing program model</li>
<li>7 Examples of the Post–Turing machine
<ul>
<li>7.1 Atomizing Turing quintuples into a sequence of Post–Turing instructions</li>
<li>7.2 2-state Busy Beaver</li>
<li>7.3 Two state busy beaver followed by "tape cleanup"</li>
</ul>
</li>
<li>8 Example: Multiply 3 × 4 with a Post–Turing machine</li>
<li>9 Footnotes</li>
<li>10 References</li>
</ul>
<ul>
<li>7.1 Atomizing Turing quintuples into a sequence of Post–Turing instructions</li>
<li>7.2 2-state Busy Beaver</li>
<li>7.3 Two state busy beaver followed by "tape cleanup"</li>
</ul>
<p></p>
<h2>1936: Post model</h2>
<p>In his 1936 paper "Finite combinatory processes—formulation 1" (which can be found on page 289 of <i>The Undecidable</i>), Emil Post described a model of extreme simplicity which he conjectured is "logically equivalent to recursiveness", and which was later proved to be so. The quotes in the following are from this paper.</p>
<p>Post's model of a computation differs from the Turing-machine model in a further "atomization" of the acts a human "computer" would perform during a computation.</p>
<p>Post's model employs a "symbol space" consisting of a "two-way infinite sequence of spaces or boxes", each box capable of being in either of two possible conditions, namely "marked" (as by a single vertical stroke) and "unmarked" (empty). Initially, finitely-many of the boxes are marked, the rest being unmarked. A "worker" is then to move among the boxes, being in and operating in only one box at a time, according to a fixed finite "set of directions" (instructions), which are numbered in order (1,2,3,...,n). Beginning at a box "singled out as the starting point", the worker is to follow the set of instructions one at a time, beginning with instruction 1.</p>
<p>The instructions may require the worker to perform the following "basic acts" or "operations":</p>
<p>Specifically, the <i>i</i>  "direction" (instruction) given to the worker is to be one of the following forms:</p>
<p>(The above indented text and italics are as in the original.) Post remarks that this formulation is "in its initial stages" of development, and mentions several possibilities for "greater flexibility" in its final "definitive form", including</p>
<h2>1947: Post's formal reduction of the Turing 5-tuples to 4-tuples</h2>
<p>As briefly mentioned in the article Turing machine, Post, in his paper of 1947 (<i>Recursive Unsolvability of a Problem of Thue</i>) atomized the Turing 5-tuples to 4-tuples:</p>
<p>Like Turing he defined erasure as printing a symbol "S0". And so his model admitted quadruplets of only three types (cf p. 294 <i>Undecidable</i>):</p>
<p>At this time he was still retaining the Turing state-machine convention – he had not formalized the notion of an assumed <i>sequential</i> execution of steps until a specific test of a symbol "branched" the execution elsewhere.</p>
<h2>1954, 1957: Wang model</h2>
<p>For an even further reduction – to only four instructions – of the Wang model presented here see Wang B-machine.</p>
<p>Wang (1957, but presented to the ACM in 1954) is often cited (cf Minsky (1967) p. 200) as the source of the "program formulation" of binary-tape Turing machines using numbered instructions from the set</p>
<p>where <i>sequential execution</i> is assumed, and Post's single "if ... then ... else" has been "atomised" into two "if ... then ..." statements. (Here '1' and '0' are used where Wang used "marked" and "unmarked", respectively, and the initial tape is assumed to contain only '0's except for finitely-many '1's.)</p>
<p>Wang noted the following:</p>
<ul>
<li>"Since there is no separate instruction for halt (stop), it is understood that the machine will stop when it has arrived at a stage that the program contains no instruction telling the machine what to do next." (p. 65)</li>
<li>"In contrast with Turing who uses a one-way infinite tape that has a beginning, we are following Post in the use of a 2-way infinite tape." (p. 65)</li>
<li>Unconditional gotos are easily derived from the above instructions, so "we can freely use them too". (p. 84)</li>
</ul>
<p>Any binary-tape Turing machine is readily converted to an equivalent "Wang program" using the above instructions.</p>
<p><br></p>
<h2>1974: first Davis model</h2>
<p>Martin Davis was an undergraduate student of Emil Post's. Along with Stephen Kleene he completed his PhD under Alonzo Church (Davis (2000) 1st and 2nd footnotes p. 188).</p>
<p>The following model he presented in a series of lectures to the Courant Institute at NYU in 1973–1974. This is the model to which Davis formally applied the name "Post–Turing machine" with its "Post–Turing language". The instructions are assumed to be executed sequentially (Davis 1974, p. 71):</p>
<p>Note that there is no "halt" or "stop".</p>
<h2>1978 second Davis model</h2>
<p>The following model appears as an essay <i>What is a computation?</i> in Steen pages 241–267. For some reason Davis has renamed his model a "Turing–Post machine" (with one back-sliding on page 256.)</p>
<p>In the following model Davis assigns the numbers "1" to Post's "mark/slash" and "0" to the blank square. To quote Davis: "We are now ready to introduce the Turing–Post Programming Language. In this language there are seven kinds of instructions:</p>
<p>"A Turing–Post program is then a list of instructions, each of which is of one of these seven kinds. Of course in an actual program the letter <i>i</i> in a step of either the fifth or sixth kind must replaced with a definite (positive whole) number." (Davis in Steen, p. 247).</p>
<ul>
<li>Confusion arises if one does not realize that a "blank" tape is actually printed with all zeroes — there is no "blank".</li>
<li>Splits Post's "GO TO" ("branch" or "jump") instruction into two, thus creating a larger (but easier-to-use) instruction set of seven rather than Post's six instructions.</li>
<li>Does not mention that instructions PRINT 1, PRINT 0, GO RIGHT and GO LEFT imply that, after execution, the "computer" must go to the next step in numerical sequence.</li>
</ul>
<h2>1994 (2nd Edition) Davis–Sigal–Weyuker's Post–Turing program model</h2>
<p>"Although the formulation of Turing we have presented is closer in spirit to that originally given by Emil Post, it was Turing's analysis of the computation that has made this formulation seem so appropriate. This language has played a fundamental role in theoretical computer science." (Davis et al. (1994) p. 129)</p>
<p>This model allows for the printing of multiple symbols. The model allows for B (blank) instead of S<sub>0</sub>. The tape is infinite in both directions. Either the head or the tape moves, but their definitions of RIGHT and LEFT always specify the same outcome in either case (Turing used the same convention).</p>
<p>Note that only one type of "jump" – a conditional GOTO – is specified; for an unconditional jump a string of GOTO's must test each symbol.</p>
<p>This model reduces to the binary { 0, 1 } versions presented above, as shown here:</p>
<h2>Examples of the Post–Turing machine</h2>
<h3>Atomizing Turing quintuples into a sequence of Post–Turing instructions</h3>
<p>The following "reduction" (decomposition, atomizing) method – from 2-symbol Turing 5-tuples to a sequence of 2-symbol Post–Turing instructions – can be found in Minsky (1961). He states that this reduction to "a <i>program</i> ... a sequence of <i>Instructions</i>" is in the spirit of Hao Wang's B-machine (italics in original, cf Minsky (1961) p. 439).</p>
<p>(Minsky's reduction to what he calls "a sub-routine" results in 5 rather than 7 Post–Turing instructions. He did not atomize Wi0: "Write symbol Si0; go to new state Mi0", and Wi1: "Write symbol Si1; go to new state Mi1". The following method further atomizes Wi0 and Wi1; in all other respects the methods are identical.)</p>
<p>This reduction of Turing 5-tuples to Post–Turing instructions may not result in an "efficient" Post–Turing program, but it will be faithful to the original Turing-program.</p>
<p>In the following example, each Turing 5-tuple of the 2-state busy beaver converts into</p>
<p>for a total of 1 + 2 + 1 + 2 + 1 = 7 instructions per Turing-state.</p>
<p>For example, the 2-state busy beaver's "A" Turing-state, written as two lines of 5-tuples, is:</p>
<p>The table represents just a single Turing "instruction", but we see that it consists of two lines of 5-tuples, one for the case "tape symbol under head = 1", the other for the case "tape symbol under head = 0". Turing observed (Undecidable, p. 119) that the left-two columns – "m-configuration" and "symbol" – represent the machine's current "configuration" – its state including both Tape and Table at that instant – and the last three columns are its subsequent "behavior". As the machine cannot be in two "states" at once, the machine must "branch" to either one configuration or the other:</p>
<p>After the "configuration branch" (J1 xxx) or (J0 xxx) the machine follows one of the two subsequent "behaviors". We list these two behaviors on one line, and number (or label) them sequentially (uniquely). Beneath each jump (branch, go to) we place its jump-to "number" (address, location):</p>
<p>Per the Post–Turing machine conventions each of the Print, Erase, Left, and Right instructions consist of two actions:</p>
<p>And per the Post–Turing machine conventions the conditional "jumps" J0xxx, J1xxx consist of two actions:</p>
<p>And per the Post–Turing machine conventions the unconditional "jump" Jxxx consists of a single action, or if we want to regularize the 2-action sequence:</p>
<p>Which, and how many, jumps are necessary? The unconditional jump <b>J</b>xxx is simply <b>J0</b> followed immediately by <b>J1</b> (or vice versa). Wang (1957) also demonstrates that only one conditional jump is required, i.e. either <b>J0</b>xxx or <b>J1</b>xxx. However, with this restriction the machine becomes difficult to write instructions for. Often only two are used, i.e.</p>
<p>but the use of all three { <b>J0</b>xxx, <b>J1</b>xxx, <b>J</b>xxx } does eliminate extra instructions. In the 2-state Busy Beaver example that we use only { <b>J1</b>xxx, <b>J</b>xxx }.</p>
<h3>2-state Busy Beaver</h3>
<p>The mission of the busy beaver is to print as many ones as possible before halting. The "Print" instruction writes a 1, the "Erase" instruction (not used in this example) writes a 0 (i.e. it is the same as P0). The tape moves "Left" or "Right" (i.e. the "head" is stationary).</p>
<p>State table for a 2-state Turing-machine busy beaver:</p>
<p>Instructions for the Post–Turing version of a 2-state busy beaver: observe that all the instructions are on the same line and in sequence. This is a significant departure from the "Turing" version and is in the same format as what is called a "computer program":</p>
<p>Alternately, we might write the table as a string. The use of "parameter separators" ":" and instruction-separators "," are entirely our choice and do not appear in the model. There are no conventions (but see Booth (1967) p. 374, and Boolos and Jeffrey (1974, 1999) p. 23), for some useful ideas of how to combine state diagram conventions with the instructions – i.e. to use arrows to indicate the destination of the jumps). In the example immediately below, the instructions are <i>sequential</i> starting from "1", and the parameters/"operands" are considered part of their instructions/"opcodes":</p>
<p>The state diagram of a two-state busy beaver (little drawing, right-hand corner) converts to the equivalent Post–Turing machine with the substitution of 7 Post–Turing instructions per "Turing" state. The HALT instruction adds the 15th state: <img alt="2-state Busy Beaver run on a P–T machine" src="//upload.wikimedia.org/wikipedia/en/thumb/3/35/State_diagram_2_state_busy_beaver_2_.JPG/900px-State_diagram_2_state_busy_beaver_2_.JPG" width="900" height="550" srcset="//upload.wikimedia.org/wikipedia/en/thumb/3/35/State_diagram_2_state_busy_beaver_2_.JPG/1350px-State_diagram_2_state_busy_beaver_2_.JPG 1.5x, //upload.wikimedia.org/wikipedia/en/3/35/State_diagram_2_state_busy_beaver_2_.JPG 2x" data-file-width="1358" data-file-height="830"></p>
<p>A "run" of the 2-state busy beaver with all the intermediate steps of the Post–Turing machine shown:</p>
<p><img alt="2-state Busy Beaver run on a P–T machine" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/4d/2_state_busy_beaver.JPG/900px-2_state_busy_beaver.JPG" width="900" height="549" srcset="//upload.wikimedia.org/wikipedia/commons/4/4d/2_state_busy_beaver.JPG 1.5x, //upload.wikimedia.org/wikipedia/commons/4/4d/2_state_busy_beaver.JPG 2x" data-file-width="1345" data-file-height="820"></p>
<h3>Two state busy beaver followed by "tape cleanup"</h3>
<p>The following is a two-state Turing busy beaver with additional instructions 15–20 to demonstrate the use of "Erase", J0, etc. These will erase the 1's written by the busy beaver:</p>
<p>Additional Post–Turing instructions 15 through 20 erase the symbols created by the busy beaver. These "atomic" instructions are more "efficient" than their Turing-state equivalents (of 7 Post–Turing instructions). To accomplish the same task a Post–Turing machine will (usually) require fewer Post–Turing states than a Turing-machine, because (i) a jump (go-to) can occur to any Post–Turing instruction (e.g. P, E, L, R) within the Turing-state, (ii) a grouping of move-instructions such as L, L, L, P are possible, etc.:</p>
<p><img alt="2-state Busy Beaver followed by tape-erase, as run on a P–T machine" src="//upload.wikimedia.org/wikipedia/en/thumb/0/0f/State_diagram_2_state_busy_beaver_.JPG/900px-State_diagram_2_state_busy_beaver_.JPG" width="900" height="547" srcset="//upload.wikimedia.org/wikipedia/en/0/0f/State_diagram_2_state_busy_beaver_.JPG 1.5x, //upload.wikimedia.org/wikipedia/en/0/0f/State_diagram_2_state_busy_beaver_.JPG 2x" data-file-width="1348" data-file-height="820"></p>
<p><img alt="2-state Busy Beaver followed by tape-erase, as run on a P-T machine" src="//upload.wikimedia.org/wikipedia/commons/thumb/8/89/2_state_busy_beaver_2.JPG/900px-2_state_busy_beaver_2.JPG" width="900" height="547" srcset="//upload.wikimedia.org/wikipedia/commons/8/89/2_state_busy_beaver_2.JPG 1.5x, //upload.wikimedia.org/wikipedia/commons/8/89/2_state_busy_beaver_2.JPG 2x" data-file-width="1348" data-file-height="820"></p>
<h2>Example: Multiply 3 × 4 with a Post–Turing machine</h2>
<p>This example is a reference to show how a "multiply" computation would proceed on a single-tape, 2-symbol { blank, 1 } Post–Turing machine model.</p>
<p>This particular "multiply" algorithm is recursive through two loops. The head moves. It starts to the far left (the top) of the string of unary marks representing <b>a'</b> :</p>
<ul>
<li>Move head far right. Establish (i.e. "clear") register <b>c</b> by placing a single blank and then a mark to the right of <b>b</b></li>
<li><b>a_loop</b>: Move head right once, test for the bottom of <b>a'</b> (a blank). If blank then done else erase mark;</li>
<li>Move head right to <b>b'</b> . Move head right once past the top mark of <b>b'</b> ;</li>
<li><b>b_loop</b>: If head is at the bottom of <b>b'</b> (a blank) then move head to far left of <b>a'</b> , else:</li>
</ul>
<ul>
<li>Erase a mark to locate counter (a blank) in <b>b'</b> .</li>
<li>Increment <b>c'</b> : Move head right to top of <b>c'</b> and increment <b>c'</b> .</li>
<li>Move head left to the counter inside <b>b'</b> ,</li>
<li>Repair counter: print a mark in the blank counter.</li>
<li>Decrement <b>b'</b> −count: Move head right once.</li>
<li>Return to b_loop.</li>
</ul>
<h2>Footnotes</h2>
<p><b>^</b> <b>a:</b> <b>Difference between Turing- and Post–Turing machine models</b></p>
<p>In his chapter XIII <i>Computable Functions</i>, Kleene adopts the Post model; Kleene's model uses a blank and one symbol "tally mark ¤" (Kleene p. 358), a "treatment closer in some respects to Post 1936. Post 1936 considered computation with a 2-way infinite tape and only 1 symbol" (Kleene p. 361). Kleene observes that Post's treatment provided a further reduction to "atomic acts" (Kleene p. 357) of "the Turing act" (Kleene p. 379). As described by Kleene "The Turing act" is the combined 3 (time-sequential) actions specified on a line in a Turing table: (i) print-symbol/erase/do-nothing followed by (ii) move-tape-left/move-tape-right/do-nothing followed by (iii) test-tape-go-to-next-instruction: e.g. "s1Rq1" means "Print symbol "¤", then move tape right, then if tape symbol is "¤" then go to state q1". (See Kleene's example P. 358).</p>
<p>Kleene observes that Post atomized these 3-actions further into two types of 2-actions. The first type is a "print/erase" action, the second is a "move tape left/right action": (1.i) print-symbol/erase/do-nothing followed by (1.ii) test-tape-go-to-next-instruction, OR (2.ii) move-tape-left/move-tape-right/do-nothing followed by (2.ii) test-tape-go-to-next-instruction.</p>
<p>But Kleene observes that while</p>
<p>In fact Post's treatment (1936) is ambiguous; both (1.1) and (2.1) could be followed by "(.ii) go to next instruction in numerical sequence". This represents a further atomization into three types of instructions: (1) print-symbol/erase/do-nothing then go-to-next-instruction-in-numerical-sequence, (2) move-tape-left/move-tape-right/do-nothing then go-to-next-instruction-in-numerical-sequence (3)test-tape then go-to-instruction-xxx-else-go-to-next-instruction-in-numerical-sequence.<br></p>
</body>
</html>