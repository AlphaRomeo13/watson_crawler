<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Discrete-event-simulation---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Discrete event simulation</h1>
<p>In the field of simulation, a <b>discrete-event simulation (DES)</b>, models the operation of a system as a discrete sequence of events in time. Each event occurs at a particular instant in time and marks a change of state in the system. Between consecutive events, no change in the system is assumed to occur; thus the simulation can directly jump in time from one event to the next.</p>
<p>This contrasts with continuous simulation in which the simulation continuously tracks the system dynamics over time. Instead of being event-based, this is called an activity-based simulation; time is broken up into small time slices and the system state is updated according to the set of activities happening in the time slice. Because discrete-event simulations do not have to simulate every time slice, they can typically run much faster than the corresponding continuous simulation.</p>
<p>Another alternative to event-based simulation is process-based simulation. In this approach, each activity in a system corresponds to a separate process, where a process is typically simulated by a thread in the simulation program. In this case, the discrete events, which are generated by threads, would cause other threads to sleep, wake, and update the system state.</p>
<p>A more recent method is the three-phased approach to discrete event simulation (Pidd, 1998). In this approach, the first phase is to jump to the next chronological event. The second phase is to execute all events that unconditionally occur at that time (these are called B-events). The third phase is to execute all events that conditionally occur at that time (these are called C-events). The three phase approach is a refinement of the event-based approach in which simultaneous events are ordered so as to make the most efficient use of computer resources. The three-phase approach is used by a number of commercial simulation software packages, but from the user's point of view, the specifics of the underlying simulation method are generally hidden.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Example</li>
<li>2 Components of a discrete-event simulation
<ul>
<li>2.1 State</li>
<li>2.2 Clock</li>
<li>2.3 Events list</li>
<li>2.4 Random-number generators</li>
<li>2.5 Statistics</li>
<li>2.6 Ending condition</li>
</ul>
</li>
<li>3 Simulation engine logic
<ul>
<li>3.1 Start</li>
<li>3.2 “Do loop” or “while loop”</li>
<li>3.3 End</li>
</ul>
</li>
<li>4 Common uses
<ul>
<li>4.1 Diagnosing process issues
<ul>
<li>4.1.1 Hospital applications</li>
</ul>
</li>
<li>4.2 Lab test performance improvement ideas</li>
<li>4.3 Evaluating capital investment decisions</li>
<li>4.4 Network simulators</li>
</ul>
</li>
<li>5 See also</li>
<li>6 References</li>
<li>7 Further reading</li>
</ul>
<ul>
<li>2.1 State</li>
<li>2.2 Clock</li>
<li>2.3 Events list</li>
<li>2.4 Random-number generators</li>
<li>2.5 Statistics</li>
<li>2.6 Ending condition</li>
</ul>
<ul>
<li>3.1 Start</li>
<li>3.2 “Do loop” or “while loop”</li>
<li>3.3 End</li>
</ul>
<ul>
<li>4.1 Diagnosing process issues
<ul>
<li>4.1.1 Hospital applications</li>
</ul>
</li>
<li>4.2 Lab test performance improvement ideas</li>
<li>4.3 Evaluating capital investment decisions</li>
<li>4.4 Network simulators</li>
</ul>
<ul>
<li>4.1.1 Hospital applications</li>
</ul>
<p></p>
<h2>Example</h2>
<p>A common exercise in learning how to build discrete-event simulations is to model a queue, such as customers arriving at a bank to be served by a teller. In this example, the system entities are <b>Customer-queue</b> and <b>Tellers</b>. The system events are <b>Customer-Arrival</b> and <b>Customer-Departure</b>. (The event of <b>Teller-Begins-Service</b> can be part of the logic of the arrival and departure events.) The system states, which are changed by these events, are <b>Number-of-Customers-in-the-Queue</b> (an integer from 0 to n) and <b>Teller-Status</b> (busy or idle). The random variables that need to be characterized to model this system stochastically are <b>Customer-Interarrival-Time</b> and <b>Teller-Service-Time</b>. An agent-based framework for performance modeling of an optimistic parallel discrete event simulator is another example for a discrete event simulation.</p>
<h2>Components of a discrete-event simulation</h2>
<p>In addition to the logic of what happens when system events occur, discrete event simulations include the following:</p>
<h3>State</h3>
<p>A system state is a set of variables that captures the salient properties of the system to be studied. The state trajectory overtime S(t) can mathematically represented by a step function whose values change in correspondence of discrete events.</p>
<h3>Clock</h3>
<p>The simulation must keep track of the current simulation time, in whatever measurement units are suitable for the system being modeled. In discrete-event simulations, as opposed to real-time simulations, time ‘hops’ because events are instantaneous – the clock skips to the next event start time as the simulation proceeds.</p>
<h3>Events list</h3>
<p>The simulation maintains at least one list of simulation events. This is sometimes called the <i>pending event set</i> because it lists events that are pending as a result of previously simulated event but have yet to be simulated themselves. An event is described by the time at which it occurs and a type, indicating the code that will be used to simulate that event. It is common for the event code to be parametrized, in which case, the event description also contains parameters to the event code.</p>
<p>When events are instantaneous, activities that extend over time are modeled as sequences of events. Some simulation frameworks allow the time of an event to be specified as an interval, giving the start time and the end time of each event.</p>
<p>Single-threaded simulation engines based on instantaneous events have just one current event. In contrast, multi-threaded simulation engines and simulation engines supporting an interval-based event model may have multiple current events. In both cases, there are significant problems with synchronization between current events.</p>
<p>The pending event set is typically organized as a priority queue, sorted by event time. That is, regardless of the order in which events are added to the event set, they are removed in strictly chronological order. Several general-purpose priority queue algorithms have proven effective for discrete-event simulation, most notably, the splay tree. More recent alternatives include skip lists, <i>calendar queues</i>. and <i>ladder queues</i>.</p>
<p>Typically, events are scheduled dynamically as the simulation proceeds. For example, in the bank example noted above, the event CUSTOMER-ARRIVAL at time t would, if the CUSTOMER_QUEUE was empty and TELLER was idle, include the creation of the subsequent event CUSTOMER-DEPARTURE to occur at time t+s, where s is a number generated from the SERVICE-TIME distribution.</p>
<h3>Random-number generators</h3>
<p>The simulation needs to generate random variables of various kinds, depending on the system model. This is accomplished by one or more Pseudorandom number generators. The use of pseudo-random numbers as opposed to true random numbers is a benefit should a simulation need a rerun with exactly the same behavior.</p>
<p>One of the problems with the random number distributions used in discrete-event simulation is that the steady-state distributions of event times may not be known in advance. As a result, the initial set of events placed into the pending event set will not have arrival times representative of the steady-state distribution. This problem is typically solved by bootstrapping the simulation model. Only a limited effort is made to assign realistic times to the initial set of pending events. These events, however, schedule additional events, and with time, the distribution of event times approaches its steady state. This is called <i>bootstrapping</i> the simulation model. In gathering statistics from the running model, it is important to either disregard events that occur before the steady state is reached or to run the simulation for long enough that the bootstrapping behavior is overwhelmed by steady-state behavior. (This use of the term <i>bootstrapping</i> can be contrasted with its use in both statistics and computing.)</p>
<h3>Statistics</h3>
<p>The simulation typically keeps track of the system's statistics, which quantify the aspects of interest. In the bank example, it is of interest to track the mean waiting times. In a simulation model, performance metrics are not analytically derived from probability distributions, but rather as averages over replications, that is different runs of the model. Confidence intervals are usually constructed to help assess the quality of the output.</p>
<h3>Ending condition</h3>
<p>Because events are bootstrapped, theoretically a discrete-event simulation could run forever. So the simulation designer must decide when the simulation will end. Typical choices are “at time t” or “after processing n number of events” or, more generally, “when statistical measure X reaches the value x”.</p>
<h2>Simulation engine logic</h2>
<p>The main loop of a discrete-event simulation is something like this:</p>
<h3>Start</h3>
<ul>
<li>Initialize Ending Condition to FALSE.</li>
<li>Initialize system state variables.</li>
<li>Initialize Clock (usually starts at simulation time zero).</li>
<li>Schedule an initial event (i.e., put some initial event into the Events List).</li>
</ul>
<h3>“Do loop” or “while loop”</h3>
<p>While (Ending Condition is FALSE) then do the following:</p>
<ul>
<li>Set clock to next event time.</li>
<li>Do next event and remove from the Events List.</li>
<li>Update statistics.</li>
</ul>
<h3>End</h3>
<ul>
<li>Generate statistical report.</li>
</ul>
<h2>Common uses</h2>
<h3>Diagnosing process issues</h3>
<p>Simulation approaches are particularly well equipped to help users diagnose issues in complex environments. The Goal (Theory of Constraints) illustrates the importance of understanding bottlenecks in a system. Only process ‘improvements’ at the bottlenecks will actually improve the overall system. In many organizations bottlenecks become hidden by excess inventory, overproduction, variability in processes and variability in routing or sequencing. By accurately documenting the system inside a simulation model it is possible to gain a bird’s eye view of the entire system.</p>
<p>A working model of a system allows management to understand performance drivers. A simulation can be built to include any number of performance indicators such as worker utilization, on-time delivery rate, scrap rate, cash cycles, and so on.</p>
<h4>Hospital applications</h4>
<p>An operating theater is generally shared between several surgical disciplines. Through better understanding the nature of these procedures it may be possible to increase the patient throughput. Example: If a heart surgery takes on average four hours, changing an operating room schedule from eight available hours to nine will not increase patient throughput. On the other hand, if a hernia procedure takes on average twenty minutes providing an extra hour may also not yield any increased throughput if the capacity and average time spent in the recovery room is not considered.</p>
<h3>Lab test performance improvement ideas</h3>
<p>Many systems improvement ideas are built on sound principles, proven methodologies (Lean, Six Sigma, TQM, etc.) yet fail to improve the overall system. A simulation model allows the user to understand and test a performance improvement idea in the context of the overall system.</p>
<h3>Evaluating capital investment decisions</h3>
<p>Simulation modeling is commonly used to model potential investments. Through modeling investments decision-makers can make informed decisions and evaluate potential alternatives.</p>
<h3>Network simulators</h3>
<p>Discrete event simulation is used in computer network to simulate new protocols for different network traffic scenarios before deployment.</p>
<h2>See also</h2>
<p>System modeling approaches:</p>
<ul>
<li>Finite-state machine and a special case, Markov chain</li>
<li>Stochastic process and a special case, Markov process</li>
<li>Queueing theory and in particular birth-death process</li>
<li>Discrete Event System Specification</li>
<li>Transaction-level modeling (TLM)</li>
</ul>
<p>Computational techniques:</p>
<ul>
<li>Computer experiment</li>
<li>Computer simulation</li>
<li>Monte Carlo method</li>
<li>Variance reduction</li>
<li>Pseudo random number generator</li>
</ul>
<p>Software:</p>
<ul>
<li>List of computer simulation software</li>
<li>List of discrete event simulation software</li>
</ul>
<p>Disciplines:</p>
<ul>
<li>Industrial engineering</li>
<li>Network simulation</li>
</ul>
</body>
</html>