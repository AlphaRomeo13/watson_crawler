<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Hilbert-curve---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Hilbert curve</h1>
<p>A <b>Hilbert curve</b> (also known as a <b>Hilbert space-filling curve</b>) is a continuous fractal space-filling curve first described by the German mathematician David Hilbert in 1891, as a variant of the space-filling Peano curves discovered by Giuseppe Peano in 1890.</p>
<p>Because it is space-filling, its Hausdorff dimension is <img class="mwe-math-fallback-image-inline tex" alt="2" src="//upload.wikimedia.org/math/c/8/1/c81e728d9d4c2f636f067f89cc14862c.png"> (precisely, its image is the unit square, whose dimension is 2 in any definition of dimension; its graph is a compact set homeomorphic to the closed unit interval, with Hausdorff dimension 2).</p>
<p><img class="mwe-math-fallback-image-inline tex" alt="H_n" src="//upload.wikimedia.org/math/8/3/e/83ebf1e52c0751dae18d910f74dc3818.png"> is the <img class="mwe-math-fallback-image-inline tex" alt=" n " src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">th approximation to the limiting curve. The Euclidean length of <img class="mwe-math-fallback-image-inline tex" alt=" H_n " src="//upload.wikimedia.org/math/8/3/e/83ebf1e52c0751dae18d910f74dc3818.png"> is <img class="mwe-math-fallback-image-inline tex" alt="\textstyle 2^n - {1 \over 2^n} " src="//upload.wikimedia.org/math/5/c/0/5c0435892998d75d20bd7147b3a102aa.png">, i.e., it grows exponentially with <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">, while at the same time always being bounded by a square with a finite area.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Images</li>
<li>2 Applications and mapping algorithms</li>
<li>3 Representation as Lindenmayer system</li>
<li>4 Other implementations</li>
<li>5 See also</li>
<li>6 Notes</li>
<li>7 External links</li>
</ul>
<p></p>
<h2>Images</h2>
<ul>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Hilbert_curve_1.svg/120px-Hilbert_curve_1.svg.png" width="120" height="120" data-file-width="512" data-file-height="512"></div>
</div>
<div class="gallerytext">
<p>Hilbert curve, first order</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Hilbert_curve_2.svg/120px-Hilbert_curve_2.svg.png" width="120" height="120" data-file-width="512" data-file-height="512"></div>
</div>
<div class="gallerytext">
<p>Hilbert curves, first and second orders</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/06/Hilbert_curve_3.svg/120px-Hilbert_curve_3.svg.png" width="120" height="120" data-file-width="512" data-file-height="512"></div>
</div>
<div class="gallerytext">
<p>Hilbert curves, first to third orders</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/7/75/Hilbert.png/120px-Hilbert.png" width="120" height="120" data-file-width="316" data-file-height="316"></div>
</div>
<div class="gallerytext">
<p>Hilbert curve, construction color-coded</p>
</div>
</div>
</li>
</ul>
<p>Hilbert curve, first order</p>
<p>Hilbert curves, first and second orders</p>
<p>Hilbert curves, first to third orders</p>
<p>Hilbert curve, construction color-coded</p>
<ul>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/67/Hilbert512.gif/120px-Hilbert512.gif" width="120" height="120" data-file-width="370" data-file-height="370"></div>
</div>
<div class="gallerytext">
<p>Hilbert curve in three dimensions</p>
</div>
</div>
</li>
<li>
<div style="width: 155px">
<div class="thumb" style="width: 150px;">
<div style="margin:15px auto;"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/13/Hilbert3d-step3.png/119px-Hilbert3d-step3.png" width="119" height="120" data-file-width="375" data-file-height="377"></div>
</div>
<div class="gallerytext">
<p>3-D Hilbert curve with color showing progression</p>
</div>
</div>
</li>
</ul>
<p>Hilbert curve in three dimensions</p>
<p>3-D Hilbert curve with color showing progression</p>
<h2>Applications and mapping algorithms</h2>
<p>Both the true Hilbert curve and its discrete approximations are useful because they give a mapping between 1D and 2D space that fairly well preserves locality. If (<i>x</i>,<i>y</i>) are the coordinates of a point within the unit square, and <i>d</i> is the distance along the curve when it reaches that point, then points that have nearby <i>d</i> values will also have nearby (<i>x</i>,<i>y</i>) values. The converse can't always be true. There will sometimes be points where the (<i>x</i>,<i>y</i>) coordinates are close but their <i>d</i> values are far apart, as is inevitable when mapping from a 2D space to a 1D space.</p>
<p>Because of this locality property, the Hilbert curve is widely used in computer science. For example, the range of IP addresses used by computers can be mapped into a picture using the Hilbert curve. Code to generate the image would map from 2D to 1D to find the color of each pixel, and the Hilbert curve is sometimes used because it keeps nearby IP addresses close to each other in the picture. A grayscale photograph can be converted to a dithered black and white image using thresholding, with the leftover amount from each pixel added to the next pixel along the Hilbert curve. Code to do this would map from 1D to 2D, and the Hilbert curve is sometimes used because it does not create the distracting patterns that would be visible to the eye if the order were simply left to right across each row of pixels. Hilbert curves in higher dimensions are an instance of a generalization of Gray codes, and are sometimes used for similar purposes, for similar reasons. For multidimensional databases, Hilbert order has been proposed to be used instead of Z order because it has better locality-preserving behavior. For example, Hilbert curves have been used to compress and accelerate R-tree indexes (see Hilbert R-tree). They have also been used to help compress data warehouses.</p>
<p>Given the variety of applications, it is useful to have algorithms to map in both directions. In many languages, these are better if implemented with iteration rather than recursion. The following C code performs the mappings in both directions, using iteration and bit operations rather than recursion. It assumes a square divided into <i>n</i> by <i>n</i> cells, for <i>n</i> a power of 2, with integer coordinates, with (0,0) in the lower left corner, (<i>n</i>-1,<i>n</i>-1) in the upper right corner, and a distance <i>d</i> that starts at 0 in the lower left corner and goes to <img class="mwe-math-fallback-image-inline tex" alt="n^2-1" src="//upload.wikimedia.org/math/5/0/b/50b1a635f896dfa7dac8300ab6de4e17.png"> in the lower-right corner.</p>
<p>WHATSON? 34f64e22-5492-47cc-a21a-541996397957</p>
<pre>
//convert (x,y) to d
int xy2d (int n, int x, int y) {
    int rx, ry, s, d=0;
    for (s=n/2; s&gt;0; s/=2) {
        rx = (x &amp; s) &gt; 0;
        ry = (y &amp; s) &gt; 0;
        d += s * s * ((3 * rx) ^ ry);
        rot(s, &amp;x, &amp;y, rx, ry);
    }
    return d;
}
 
//convert d to (x,y)
void d2xy(int n, int d, int *x, int *y) {
    int rx, ry, s, t=d;
    *x = *y = 0;
    for (s=1; s&lt;n; s*=2) {
        rx = 1 &amp; (t/2);
        ry = 1 &amp; (t ^ rx);
        rot(s, x, y, rx, ry);
        *x += s * rx;
        *y += s * ry;
        t /= 4;
    }
}
 
//rotate/flip a quadrant appropriately
void rot(int n, int *x, int *y, int rx, int ry) {
    if (ry == 0) {
        if (rx == 1) {
            *x = n-1 - *x;
            *y = n-1 - *y;
        }
 
        //Swap x and y
        int t  = *x;
        *x = *y;
        *y = t;
    }
}
</pre>
<p>These use the C conventions: the &amp; symbol is a bitwise AND, the ^ symbol is a bitwise XOR, the += operator adds onto a variable, and the /= operator divides a variable. The handling of booleans in C means that in xy2d, the variable <i>rx</i> is set to 0 or 1 to match bit <i>s</i> of <i>x</i>, and similarly for <i>ry</i>.</p>
<p>The xy2d function works top down, starting with the most significant bits of <i>x</i> and <i>y</i>, and building up the most significant bits of <i>d</i> first. The d2xy function works in the opposite order, starting with the least significant bits of <i>d</i>, and building up <i>x</i> and <i>y</i> starting with the least significant bits. Both functions use the rotation function to rotate and flip the (<i>x</i>,<i>y</i>) coordinate system appropriately.</p>
<p>The two mapping algorithms work in similar ways. The entire square is viewed as composed of 4 regions, arranged 2 by 2. Each region is composed of 4 smaller regions, and so on, for a number of levels. At level <i>s</i>, each region is <i>s</i> by <i>s</i> cells. There is a single FOR loop that iterates through levels. On each iteration, an amount is added to <i>d</i> or to <i>x</i> and <i>y</i>, determined by which of the 4 regions it is in at the current level. The current region out of the 4 is (<i>rx</i>,<i>ry</i>), where <i>rx</i> and <i>ry</i> are each 0 or 1. So it consumes 2 input bits, (either 2 from <i>d</i> or 1 each from <i>x</i> and <i>y</i>), and generates two output bits. It also calls the rotation function so that (<i>x</i>,<i>y</i>) will be appropriate for the next level, on the next iteration. For xy2d, it starts at the top level of the entire square, and works its way down to the lowest level of individual cells. For d2xy, it starts at the bottom with cells, and works up to include the entire square.</p>
<p>It is possible to implement Hilbert curves efficiently even when the data space does not form a square. Moreover there are several possible generalizations of Hilbert curves to higher dimensions.</p>
<h2>Representation as Lindenmayer system</h2>
<p>The Hilbert Curve can be expressed by a rewrite system (L-system).</p>
<p>Here, "F" means "draw forward", "−" means "turn left 90°", "+" means "turn right 90°" (see turtle graphics), and "A" and "B" are ignored during drawing.</p>
<h2>Other implementations</h2>
<p>Arthur Butz provided an algorithm for calculating the Hilbert curve in multidimensions.</p>
<p>Graphics Gems II discusses Hilbert Curve coherency, and provides implementation.</p>
<h2>See also</h2>
<ul>
<li>Hilbert curve scheduling</li>
<li>Hilbert R-tree</li>
<li>Sierpiński curve</li>
<li>Moore curve</li>
<li>Space-filling curves</li>
<li>List of fractals by Hausdorff dimension</li>
</ul>
<h2>Notes</h2>
<ol>
<li><b>^</b> D. Hilbert: Über die stetige Abbildung einer Linie auf ein Flächenstück. Mathematische Annalen 38 (1891), 459–460.</li>
<li><b>^</b> G.Peano: Sur une courbe, qui remplit toute une aire plane. Mathematische Annalen 36 (1890), 157–160.</li>
<li><b>^</b> Moon, B.; Jagadish, H.V.; Faloutsos, C.; Saltz, J.H. (2001), <i>Analysis of the clustering properties of the Hilbert space-filling curve</i>, <i>IEEE Transactions on Knowledge and Data Engineering</i> <b>13</b> (1): 124–141, doi:10.1109/69.908985 .</li>
<li><b>^</b> I. Kamel, C. Faloutsos, Hilbert R-tree: An improved R-tree using fractals, in: Proceedings of the 20th International Conference on Very Large Data Bases, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1994, pp. 500–509.</li>
<li><b>^</b> T. Eavis, D. Cueva, A Hilbert space compression architecture for data warehouse environments, Lecture Notes in Computer Science 4654 (2007) 1–12.</li>
<li><b>^</b> Daniel Lemire and Owen Kaser, Reordering Columns for Smaller Indexes, Information Sciences 181 (12), 2011.</li>
<li><b>^</b> C. H. Hamilton, A. Rau-Chaplin, Compact Hilbert indices: Space-filling curves for domains with unequal side lengths, Information Processing Letters 105 (5) (2007) 155–163.</li>
<li><b>^</b> J. Alber, R. Niedermeier, On multidimensional curves with Hilbert property, Theory of Computing Systems 33 (4) (2000) 295–312.</li>
<li><b>^</b> H. J. Haverkort, F. van Walderveen, Four-dimensional Hilbert curves for R-trees, in: Proceedings of the Eleventh Workshop on Algorithm Engineering and Experiments, 2009, pp. 63–73.</li>
<li><b>^</b> A.R. Butz (April 1971). "Alternative algorithm for Hilbert’s space filling curve.". <i>IEEE Trans. On Computers,</i> <b>20</b>: 424–42. doi:10.1109/T-C.1971.223258. </li>
<li><b>^</b> Voorhies, Douglas: Space-Filling Curves and a Measure of Coherence, p. 26-30, Graphics Gems II.</li>
</ol>
<h2>External links</h2>
<ul>
<li>Dynamic Hilbert curve with JSXGraph</li>
<li>JSHilbert - Calculate normalised distances along Hilbert curve for points in the unit square.</li>
<li>Three.js WebGL 3D Hilbert curve demo</li>
<li>XKCD cartoon using the locality properties of the Hilbert curve to create a "map of the internet"</li>
<li>Gcode generator for Hilbert curve</li>
</ul>
</body>
</html>