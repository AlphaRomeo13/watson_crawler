<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Element-distinctness-problem---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Element distinctness problem</h1>
<p>In computational complexity theory, the <b>element distinctness problem</b> or <b>element uniqueness problem</b> is the problem of determining whether all the elements of a list are distinct.</p>
<p>It is a well studied problem in many different models of computation. The problem may be solved by sorting the list and then checking if there are any consecutive equal elements; it may also be solved in linear expected time by a randomized algorithm that inserts each item into a hash table and compares only those elements that are placed in the same hash table cell.</p>
<p>It is known that, for lists of numbers, the problem's time complexity is Î˜(<i>n</i> log <i>n</i>), i.e., both the upper and lower bounds on its time complexity are of order of the linearithmic function in the algebraic decision tree model of computation, a model of computation in which the elements may not be used to index the computer's memory (as in the hash table solution) but may only be accessed by computing and comparing simple algebraic functions of their values. In other words, an asymptotically optimal algorithm of linearithmic time complexity is known for this model. The algebraic computation tree model basically means that the allowable algorithms are only the ones that can perform polynomial operations of bounded degree on the input data and comparisons of the results of these computations.</p>
<p>The same lower bound was later proved for the randomized algebraic decision tree model.</p>
<p>It is also known that quantum algorithms can solve this problem faster in <img class="mwe-math-fallback-image-inline tex" alt="\Theta\left(n^{2/3}\right)" src="//upload.wikimedia.org/math/0/7/2/0725fe33e0157c1fcace45ef19dfef73.png"> queries. The optimal algorithm is by Andris Ambainis. Scott Aaronson and Yaoyun Shi first proved a tight lower bound for a large but restricted class of functions. Ambainis and Kutin independently (and via different proofs) extended their work to obtain the lower bound for all functions.</p>
<p>Several lower bounds in computational complexity are proved by reducing the element distinctness problem to the problem in question, i.e., by demonstrating that the solution of the element uniqueness problem may be quickly found after solving the problem in question.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Restrictions</li>
<li>2 Generalization: Finding repeated elements</li>
<li>3 See also</li>
<li>4 References</li>
</ul>
<p></p>
<h2>Restrictions</h2>
<p>Decision tree models are inapplicable for determining lower bounds for algorithmic problems for objects that have some <i>a priori</i> properties which can be exploited in construction of algorithms. For example, if it is known that the <i>n</i> objects are integer numbers from the range [1..<i>n</i>], then the element uniqueness problem may be solved in O(<i>n</i>) time by a modification of bucket sort.</p>
<h2>Generalization: Finding repeated elements</h2>
<p>Elements that occur more than <i>n</i>/<i>k</i> times in a multiset of size n may be found in time O(<i>n</i> log <i>k</i>). The element distinctness problem is a special case of <i>k</i>=<i>n</i>. This algorithm is optimal under the decision tree model of computation.</p>
<p>The algorithm is a generalization of the one for a special case of <i>k</i>=2, which had a rather convoluted history of publication.</p>
<p>The above algorithms rely only on the test of identity of the elements. If sorting is allowed, previously known order statistics finding algorithms may be exploited. For example, for <i>k</i>=2, a median may be found first in linear time, and then it may be easily tested whether there are more than <i>n</i>/2 median elements. However the above algorithms require fewer comparisons than the order statistics algorithms.</p>
<h2>See also</h2>
<ul>
<li>Collision problem</li>
</ul>
</body>
</html>