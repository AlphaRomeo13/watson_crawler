<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Eight-queens-puzzle---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Eight queens puzzle</h1>
<p>The <b>eight queens puzzle</b> is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general <b><i>n</i>-queens problem</b> of placing <i>n</i> queens on an <i>n</i>×<i>n</i> chessboard, where solutions exist for all natural numbers <i>n</i> with the exception of <i>n</i>=2 or <i>n</i>=3.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 History</li>
<li>2 Solution construction
<ul>
<li>2.1 Solutions</li>
</ul>
</li>
<li>3 Explicit solutions</li>
<li>4 Counting solutions</li>
<li>5 Related problems</li>
<li>6 Exercise in algorithm design</li>
<li>7 Sample program</li>
<li>8 See also</li>
<li>9 References</li>
<li>10 Further reading</li>
<li>11 External links</li>
</ul>
<ul>
<li>2.1 Solutions</li>
</ul>
<p></p>
<h2>History</h2>
<p>Chess composer Max Bezzel published the eight queens puzzle in 1848. Franz Nauck published the first solutions in 1850. Nauck also extended the puzzle to the <i>n</i>-queens problem, with <i>n</i> queens on a chessboard of <i>n</i> × <i>n</i> squares.</p>
<p>Since then, many mathematicians, including Carl Friedrich Gauss, have worked on both the eight queens puzzle and its generalized <i>n</i>-queens version. In 1874, S. Gunther proposed a method using determinants to find solutions. J.W.L. Glaisher refined Gunther's approach.</p>
<p>In 1972 Edsger Dijkstra used this problem to illustrate the power of what he called structured programming. He published a highly detailed description of a depth-first backtracking algorithm.</p>
<h2>Solution construction</h2>
<p>The problem can be quite computationally expensive as there are 4,426,165,368 (<i>i.e.</i>, <sub>64</sub>C<sub>8</sub>) possible arrangements of eight queens on an 8×8 board, but only 92 solutions. It is possible to use shortcuts that reduce computational requirements or rules of thumb that avoids brute-force computational techniques. For example, just by applying a simple rule that constrains each queen to a single column (or row), though still considered brute force, it is possible to reduce the number of possibilities to just 16,777,216 (that is, 8) possible combinations. Generating permutations further reduces the possibilities to just 40,320 (that is, 8!), which are then checked for diagonal attacks.</p>
<p>These brute-force algorithms are computationally manageable for n = 8, but would be intractable for problems of n ≥ 20, as 20! = 2.433 * 10. Advancements for this and other toy problems are the development and application of heuristics (rules of thumb) that yield solutions to the <i>n</i> queens puzzle at a small fraction of the computational requirements.</p>
<p>This heuristic solves <i>N</i> queens for any <i>N</i> ≥ 4. It forms the list of numbers for vertical positions (rows) of queens with horizontal position (column) simply increasing. <i>N</i> is 8 for eight queens puzzle.</p>
<ol>
<li>If the remainder from dividing <i>N</i> by 6 is not 2 or 3 then the list is simply all even numbers followed by all odd numbers ≤ N</li>
<li>Otherwise, write separate lists of even and odd numbers (i.e. 2,4,6,8 - 1,3,5,7)</li>
<li>If the remainder is 2, swap 1 and 3 in odd list and move 5 to the end (i.e. <b>3,1</b>,7,<b>5</b>)</li>
<li>If the remainder is 3, move 2 to the end of even list and 1,3 to the end of odd list (i.e. 4,6,8,<b>2</b> - 5,7,<b>1,3</b>)</li>
<li>Append odd list to the even list and place queens in the rows given by these numbers, from left to right (i.e. a2, b4, c6, d8, e3, f1, g7, h5)</li>
</ol>
<p>For <i>N</i> = 8 this results in the solution shown above. A few more examples follow.</p>
<ul>
<li>14 queens (remainder 2): 2, 4, 6, 8, 10, 12, 14, 3, 1, 7, 9, 11, 13, 5.</li>
<li>15 queens (remainder 3): 4, 6, 8, 10, 12, 14, 2, 5, 7, 9, 11, 13, 15, 1, 3.</li>
<li>20 queens (remainder 2): 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 3, 1, 7, 9, 11, 13, 15, 17, 19, 5.</li>
</ul>
<p>Martin Richards published a program to count solutions to the n-queens problem using bitwise operations.</p>
<h3>Solutions</h3>
<p>The eight queens puzzle has 92 <b>distinct</b> solutions. If solutions that differ only by symmetry operations (rotations and reflections) of the board are counted as one, the puzzle has 12 <b>fundamental</b> solutions.</p>
<p>A fundamental solution usually has eight variants (including its original form) obtained by rotating 90, 180, or 270 degrees and then reflecting each of the four rotational variants in a mirror in a fixed position. However, should a solution be equivalent to its own 90 degree rotation (as happens to one solution with five queens on a 5x5 board) that fundamental solution will have only two variants (itself and its reflection). Should a solution be equivalent to its own 180 degree rotation (but not to its 90 degree rotation) it will have four variants (itself, its reflection, its 90 degree rotation and the reflection of that). It is not possible for a solution to be equivalent to its own reflection (except at n=1) because that would require two queens to be facing each other. (For n-queen problem's solution to be equivalent to its own mirror-image solution, the solution needs to be symmetrical by the center of the board either horizontally or vertically. Then, two queens would be facing each other, making it not a solution. ) Of the 12 fundamental solutions to the problem with eight queens on an 8x8 board, exactly one is equal to its own 180 degree rotation, and none are equal to their 90 degree rotation, thus the number of distinct solutions is 11*8 + 1*4 = 92 (where the 8 is derived from four 90-degree rotational positions and their reflections, and the 4 is derived from two 180-degree rotational positions and their reflections).</p>
<p>The different fundamental solutions are presented below:</p>
<p>Solution 10 has the additional property that no three queens are in a straight line.</p>
<h2>Explicit solutions</h2>
<p>Explicit solutions exist for placing <i>n</i> queens on an <i>n</i> × <i>n</i> board for all <i>n</i> ≥ 4, requiring no combinatorial search whatsoever. The explicit solutions exhibit stair-stepped patterns, as in the following examples for <i>n</i> = 8, 9 and 10:</p>
<p>The examples above can be obtained with the following formulas. Let (<i>i</i>, <i>j</i>) be the square in column <i>i</i> and row <i>j</i> on the <i>n</i> × <i>n</i> chessboard, <i>k</i> an integer.</p>
<ol>
<li>If <i>n</i> is even and <i>n</i> ≠ 6<i>k</i> + 2, then place queens at (<i>i</i>, 2<i>i</i>) and (<i>n</i>/2 + <i>i</i>, 2<i>i</i> - 1) for <i>i</i> = 1,2,...,<i>n</i>/2.</li>
<li>If <i>n</i> is even and <i>n</i> ≠ 6<i>k</i>, then place queens at (<i>i</i>, 1 + (2<i>i</i> + <i>n</i>/2 - 3 (mod <i>n</i>))) and (<i>n</i> + 1 - <i>i</i>, <i>n</i> - (2<i>i</i> + <i>n</i>/2 - 3 (mod <i>n</i>))) for <i>i</i> = 1,2,...,<i>n</i>/2.</li>
<li>If <i>n</i> is odd, then use one of the patterns above for (<i>n</i> - 1) and add a queen at (<i>n</i>, <i>n</i>).</li>
</ol>
<h2>Counting solutions</h2>
<p>The following table gives the number of solutions for placing <i>n</i> queens on an <i>n</i> × <i>n</i> board, both fundamental (sequence A002562 in OEIS) and all (sequence A000170 in OEIS), for n=1–14, 24–26.</p>
<p>Note that the six queens puzzle has fewer solutions than the five queens puzzle.</p>
<p>There is currently no known formula for the exact number of solutions.</p>
<h2>Related problems</h2>
<ul>
<li>Higher dimensions</li>
</ul>
<ul>
<li>Using pieces other than queens</li>
</ul>
<ul>
<li>Permutation matrix</li>
</ul>
<ul>
<li>Nonstandard boards</li>
</ul>
<ul>
<li>Domination</li>
</ul>
<ul>
<li>Nine queens problem</li>
</ul>
<ul>
<li>Queens and knights problem</li>
</ul>
<ul>
<li>Magic squares</li>
</ul>
<ul>
<li>Latin squares</li>
</ul>
<ul>
<li>Exact cover</li>
</ul>
<h2>Exercise in algorithm design</h2>
<p>Finding all solutions to the eight queens puzzle is a good example of a simple but nontrivial problem. For this reason, it is often used as an example problem for various programming techniques, including nontraditional approaches such as constraint programming, logic programming or genetic algorithms. Most often, it is used as an example of a problem that can be solved with a recursive algorithm, by phrasing the <i>n</i> queens problem inductively in terms of adding a single queen to any solution to the problem of placing <i>n</i>−1 queens on an n-by-n chessboard. The induction bottoms out with the solution to the 'problem' of placing 0 queens on the chessboard, which is the empty chessboard.</p>
<p>This technique is much more efficient than the naïve brute-force search algorithm, which considers all 64 = 2 = 281,474,976,710,656 possible blind placements of eight queens, and then filters these to remove all placements that place two queens either on the same square (leaving only 64!/56! = 178,462,987,637,760 possible placements) or in mutually attacking positions. This very poor algorithm will, among other things, produce the same results over and over again in all the different permutations of the assignments of the eight queens, as well as repeating the same computations over and over again for the different sub-sets of each solution. A better brute-force algorithm places a single queen on each row, leading to only 8 = 2 = 16,777,216 blind placements.</p>
<p>It is possible to do much better than this. One algorithm solves the eight rooks puzzle by generating the permutations of the numbers 1 through 8 (of which there are 8! = 40,320), and uses the elements of each permutation as indices to place a queen on each row. Then it rejects those boards with diagonal attacking positions. The backtracking depth-first search program, a slight improvement on the permutation method, constructs the search tree by considering one row of the board at a time, eliminating most nonsolution board positions at a very early stage in their construction. Because it rejects rook and diagonal attacks even on incomplete boards, it examines only 15,720 possible queen placements. A further improvement, which examines only 5,508 possible queen placements, is to combine the permutation based method with the early pruning method: the permutations are generated depth-first, and the search space is pruned if the partial permutation produces a diagonal attack. Constraint programming can also be very effective on this problem.</p>
<p>An alternative to exhaustive search is an 'iterative repair' algorithm, which typically starts with all queens on the board, for example with one queen per column. It then counts the number of conflicts (attacks), and uses a heuristic to determine how to improve the placement of the queens. The 'minimum-conflicts' heuristic — moving the piece with the largest number of conflicts to the square in the same column where the number of conflicts is smallest — is particularly effective: it finds a solution to the 1,000,000 queen problem in less than 50 steps on average. This assumes that the initial configuration is 'reasonably good' — if a million queens all start in the same row, it will obviously take at least 999,999 steps to fix it. A 'reasonably good' starting point can for instance be found by putting each queen in its own row and column so that it conflicts with the smallest number of queens already on the board.</p>
<p>Note that 'iterative repair', unlike the 'backtracking' search outlined above, does not guarantee a solution: like all hillclimbing (i.e., greedy) procedures, it may get stuck on a local optimum (in which case the algorithm may be restarted with a different initial configuration). On the other hand, it can solve problem sizes that are several orders of magnitude beyond the scope of a depth-first search.</p>
<p><img alt="Eight-queens-animation.gif" src="//upload.wikimedia.org/wikipedia/commons/1/1f/Eight-queens-animation.gif" width="352" height="352" data-file-width="352" data-file-height="352"></p>
<p>This animation uses backtracking to solve the problem. A queen is placed in a column that is known not to cause conflict. If a column is not found the program returns to the last good state and then tries a different column.</p>
<h2>Sample program</h2>
<p>The following is a Pascal program by Niklaus Wirth. It finds one solution to the eight queens problem.</p>
<p>WHATSON? 815e4387-4186-4e79-a4b2-8c88929e7001</p>
<pre>
program eightqueen1(output);
 
var i : integer; q : boolean;
    a : array[ 1 .. 8] of boolean;
    b : array[ 2 .. 16] of boolean;
    c : array[ -7 .. 7] of boolean;
    x : array[ 1 .. 8] of integer;
 
procedure try( i : integer; var q : boolean);
    var j : integer;
    begin 
    j := 0;
    repeat 
        j := j + 1; 
        q := false;
        if a[ j] and b[ i + j] and c[ i - j] then
            begin 
            x[ i    ] := j;
            a[ j    ] := false; 
            b[ i + j] := false; 
            c[ i - j] := false;
            if i &lt; 8 then
                begin
                try( i + 1, q);
                if not q then
                    begin 
                    a[ j] := true; 
                    b[ i + j] := true; 
                    c[ i - j] := true;
                    end
                end 
            else 
                q := true
            end
    until q or (j = 8);
    end;
 
begin
for i :=  1 to  8 do a[ i] := true;
for i :=  2 to 16 do b[ i] := true;
for i := -7 to  7 do c[ i] := true;
try( 1, q);
if q then
    for i := 1 to 8 do write( x[ i]:4);
writeln
end.
</pre>
<h2>See also</h2>
<ul>
<li>Mathematical game</li>
<li>Mathematical puzzle</li>
<li>No-three-in-line problem</li>
<li>Rook polynomial</li>
</ul>
</body>
</html>