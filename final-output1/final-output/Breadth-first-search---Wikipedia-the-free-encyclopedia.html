<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Breadth-first-search---Wikipedia-the-free-encyclopedia.html</title></head>
<body>
<h1>Breadth-first search</h1>
<p>In graph theory, <b>breadth-first search</b> (<b>BFS</b>) is a strategy for searching in a graph when search is limited to essentially two operations: (a) visit and inspect a node of a graph; (b) gain access to visit the nodes that neighbor the currently visited node. The BFS begins at a root node and inspects all the neighboring nodes. Then for each of those neighbor nodes in turn, it inspects their neighbor nodes which were unvisited, and so on. Compare BFS with the equivalent, but more memory-efficient Iterative deepening depth-first search and contrast with depth-first search.</p>
<p>BFS was invented in the late 1950s by E. F. Moore and initially used to find the shortest path out of a maze.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li>1 Algorithm
<ul>
<li>1.1 Pseudocode</li>
</ul>
</li>
<li>2 Analysis
<ul>
<li>2.1 Time and space complexity</li>
<li>2.2 Completeness and optimality</li>
</ul>
</li>
<li>3 Applications
<ul>
<li>3.1 Finding connected components</li>
<li>3.2 Testing bipartiteness</li>
</ul>
</li>
<li>4 See also</li>
<li>5 References</li>
<li>6 External links</li>
</ul>
<ul>
<li>1.1 Pseudocode</li>
</ul>
<ul>
<li>2.1 Time and space complexity</li>
<li>2.2 Completeness and optimality</li>
</ul>
<ul>
<li>3.1 Finding connected components</li>
<li>3.2 Testing bipartiteness</li>
</ul>
<p></p>
<h2>Algorithm</h2>
<ul>
<li>α–β</li>
<li>A*</li>
<li>B*</li>
<li>Backtracking</li>
<li>Beam</li>
<li>Bellman–Ford</li>
<li>Best-first</li>
<li>Bidirectional</li>
<li>Borůvka</li>
<li>Branch &amp; bound</li>
<li><strong class="selflink">BFS</strong></li>
<li>British Museum</li>
<li>D*</li>
<li>DFS</li>
<li>Depth-limited</li>
<li>Dijkstra</li>
<li>Edmonds</li>
<li>Floyd–Warshall</li>
<li>Fringe search</li>
<li>Hill climbing</li>
<li>IDA*</li>
<li>Iterative deepening</li>
<li>Johnson</li>
<li>Jump point</li>
<li>Kruskal</li>
<li>Lexicographic BFS</li>
<li>Prim</li>
<li>SMA*</li>
<li>Uniform-cost</li>
</ul>
<ul>
<li><i>Graph algorithms</i></li>
<li><i>Search algorithms</i></li>
<li><i>List of graph algorithms</i></li>
</ul>
<ul>
<li>Dynamic programming</li>
<li>Graph traversal</li>
<li>Tree traversal</li>
<li>Search games</li>
</ul>
<ul>
<li>v</li>
<li>t</li>
<li>e</li>
</ul>
<p>The algorithm uses a queue data structure to store intermediate results as it traverses the graph, as follows:</p>
<ol>
<li>Enqueue the root node</li>
<li>Dequeue a node and examine it
<ul>
<li>If the element sought is found in this node, quit the search and return a result.</li>
<li>Otherwise enqueue any successors (the direct child nodes) that have not yet been discovered.</li>
</ul>
</li>
<li>If the queue is empty, every node on the graph has been examined – quit the search and return "not found".</li>
<li>If the queue is not empty, repeat from Step 2.</li>
</ol>
<ul>
<li>If the element sought is found in this node, quit the search and return a result.</li>
<li>Otherwise enqueue any successors (the direct child nodes) that have not yet been discovered.</li>
</ul>
<h3>Pseudocode</h3>
<p><b>Input</b>: A graph <i>G</i> and a root <i>v</i> of G</p>
<p>WHATSON? a3425213-bd6b-4aa5-9c85-07bb7af8b1fa</p>
<pre>
1  <b>procedure</b> BFS(<i>G</i>,<i>v</i>) <b>is</b>
2      create a queue <i>Q</i>
3      create a set <i>V</i>
4      add <i>v</i> to <i>V</i>
5      enqueue <i>v</i> onto <i>Q</i>
6      <b>while</b> <i>Q</i> is not empty <b>loop</b>
7         <i>t</i> ← Q.dequeue()
8         <b>if</b> <i>t</i> is what we are looking for then
9            <b>return</b> <i>t</i>
10        <b>end if</b>
11        <b>for all</b> edges <i>e</i> in G.adjacentEdges(t) <b>loop</b>
12           <i>u</i> ← G.adjacentVertex(<i>t</i>,<i>e</i>)
13           <b>if</b> <i>u</i> is not in <i>V</i> <b>then</b>
14               add <i>u</i> to <i>V</i>
15               enqueue <i>u</i> onto <i>Q</i>
16           <b>end if</b>
17        <b>end loop</b>
18     <b>end loop</b>
19     return <i>none</i>
20 <b>end</b> BFS
</pre>
<h2>Analysis</h2>
<h3>Time and space complexity</h3>
<p>The time complexity can be expressed as <img class="mwe-math-fallback-image-inline tex" alt="O(|V|+|E|)" src="//upload.wikimedia.org/math/4/f/e/4fe9f15fb53c589e023213ae35fcf78f.png">  since every vertex and every edge will be explored in the worst case. Note: <img class="mwe-math-fallback-image-inline tex" alt="O(|E|)" src="//upload.wikimedia.org/math/5/0/4/5047506d94a45a73aa51fc971a0ff38d.png"> may vary between <img class="mwe-math-fallback-image-inline tex" alt="O(1)" src="//upload.wikimedia.org/math/5/e/0/5e079a28737d5dd019a3b8f6133ee55e.png"> and <img class="mwe-math-fallback-image-inline tex" alt=" O(|V|^2)" src="//upload.wikimedia.org/math/1/7/5/17589e5af2a8e3d48c486d30939c1268.png">, depending on how sparse the input graph is.</p>
<p>When the number of vertices in the graph is known ahead of time, and additional data structures are used to determine which vertices have already been added to the queue, the space complexity can be expressed as <img class="mwe-math-fallback-image-inline tex" alt="O(|V|)" src="//upload.wikimedia.org/math/c/0/8/c08c0e45a937a414cd20dbdf046ca4b5.png"> where <img class="mwe-math-fallback-image-inline tex" alt="|V|" src="//upload.wikimedia.org/math/7/4/f/74fcb594bdd93c0f956682ae1ea013e6.png"> is the cardinality of the set of vertices. If the graph is represented by an Adjacency list it occupies <img class="mwe-math-fallback-image-inline tex" alt="\Theta(|V|+|E|)" src="//upload.wikimedia.org/math/b/2/9/b29ba10dbabd82fca72194a9921eed54.png"> space in memory, while an Adjacency matrix representation occupies <img class="mwe-math-fallback-image-inline tex" alt="\Theta(|V|^2)" src="//upload.wikimedia.org/math/e/6/2/e62dd1ed7a85fd4dc1b528a0a2250169.png">.</p>
<h3>Completeness and optimality</h3>
<p>In the analysis of algorithms, the input to breadth-first search is assumed to be a finite graph, represented explicitly as an adjacency list or similar representation. However, in the application of graph traversal methods in artificial intelligence the input may be an implicit representation of an infinite graph. In this context, a search method is described as being complete if it is guaranteed to find a goal state if one exists. Breadth-first search is complete, but depth-first search is not: when applied to infinite graphs represented implicitly, it may get lost in parts of the graph that have no goal state and never return.</p>
<p>A search method is optimal if it is guaranteed to find the best solution that exists. In other words, it will find the path to the goal state that involves the least number of steps. Breadth-first search is an optimal search method, but depth-first search is not</p>
<h2>Applications</h2>
<p>Breadth-first search can be used to solve many problems in graph theory, for example:</p>
<ul>
<li>Finding all nodes within one connected component</li>
<li>Copying Collection, Cheney's algorithm</li>
<li>Finding the shortest path between two nodes <i>u</i> and <i>v</i> (with path length measured by number of edges)</li>
<li>Testing a graph for bipartiteness</li>
<li>(Reverse) Cuthill–McKee mesh numbering</li>
<li>Ford–Fulkerson method for computing the maximum flow in a flow network</li>
<li>Serialization/Deserialization of a binary tree vs serialization in sorted order, allows the tree to be re-constructed in an efficient manner.</li>
<li>Construction of the <i>failure function</i> of the Aho-Corasick pattern matcher.</li>
</ul>
<h3>Finding connected components</h3>
<p>The set of nodes reached by a BFS (breadth-first search) form the connected component containing the starting node.</p>
<h3>Testing bipartiteness</h3>
<p>BFS can be used to test bipartiteness, by starting the search at any vertex and giving alternating labels to the vertices visited during the search. That is, give label 0 to the starting vertex, 1 to all its neighbours, 0 to those neighbours' neighbours, and so on. If at any step a vertex has (visited) neighbours with the same label as itself, then the graph is not bipartite. If the search ends without such a situation occurring, then the graph is bipartite.</p>
<h2>See also</h2>
<ul>
<li>Depth-first search</li>
<li>Iterative deepening depth-first search</li>
<li>Level structure</li>
<li>Lexicographic breadth-first search</li>
</ul>
</body>
</html>