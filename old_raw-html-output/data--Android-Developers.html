<h1 itemprop="name">&lt;data&gt;</h1>
<p>WHATSON? 4ff327ed-274f-42d7-b8d2-bb693c54de8f</p>
<pre class="stx">&lt;data android:<a href="#scheme">scheme</a>="<i>string</i>"
      android:<a href="#host">host</a>="<i>string</i>"
      android:<a href="#port">port</a>="<i>string</i>"
      android:<a href="#path">path</a>="<i>string</i>"
      android:<a href="#path">pathPattern</a>="<i>string</i>"
      android:<a href="#path">pathPrefix</a>="<i>string</i>"
      android:<a href="#mime">mimeType</a>="<i>string</i>" /&gt;</pre>
<p style="margin-left: 2em">
<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code></p>
<p>
These attributes that specify the URL format are optional, but also mutually dependent:
</p>
<ul>
  <li>If a <code><a href="/guide/topics/manifest/data-element.html#scheme">scheme</a></code>
is not specified for the intent filter, all the other URI attributes are ignored.</li>
  <li>If a <code><a href="/guide/topics/manifest/data-element.html#host">host</a></code>
is not specified for the filter, the <code>port</code> attribute and all the path attributes are ignored.
</li></ul>
<p>
All the <code>&lt;data&gt;</code> elements contained within the same
<code><a href="/guide/topics/manifest/intent-filter-element.html">&lt;intent-filter&gt;</a></code> element contribute to
the same filter.  So, for example, the following filter specification,
</p>
<p>WHATSON? c0fde319-ee4b-4d38-9e5f-e7e09a455fa1</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>is equivalent to this one:</p>
<p>WHATSON? 18430ddc-28f3-4dd2-8c56-4b073ce277a6</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" /&amp;gt
    &lt;data android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>
You can place any number of <code>&lt;data&gt;</code> elements inside an
<code><a href="/guide/topics/manifest/intent-filter-element.html">&lt;intent-filter&gt;</a></code> to give it multiple data
options.  None of its attributes have default values.
</p>
<p>
Information on how intent filters work, including the rules for how Intent objects
are matched against filters, can be found in another document,
<a href="/guide/components/intents-filters.html">Intents and
Intent Filters</a>.  See also the
<a href="/guide/topics/manifest/manifest-intro.html#ifs">Intent Filters</a>
section in the manifest file overview.
</p>
<p>
A scheme is specified without the trailing colon (for example,
<code>http</code>, rather than <code>http:</code>).
</p>
<p>
If the filter has a data type set (the <code><a href="/guide/topics/manifest/data-element.html#mime">mimeType</a></code>
attribute) but no scheme, the <code>content:</code> and <code>file:</code> schemes are
assumed.
</p>
<p class="note"><strong>Note</strong>: Scheme matching in the Android framework is
case-sensitive, unlike the RFC.  As a result, you should always specify schemes
using lowercase letters.</p>
<p class="note"><strong>Note</strong>: host name matching in the Android framework is
case-sensitive, unlike the formal RFC.  As a result, you should always specify
host names using lowercase letters.</p>
<ul>
<li>An asterisk ('<code>*</code>') matches a sequence of 0 to many occurrences of
the immediately preceding character.</li>

<li>A period followed by an asterisk ("<code>.*</code>") matches any sequence of
0 to many characters.</li>
</ul>
<p>
Because '<code>\</code>' is used as an escape character when the string is read
from XML (before it is parsed as a pattern), you will need to double-escape:
For example, a literal '<code>*</code>' would be written as "<code>\\*</code>" and a
literal '<code>\</code>' would be written as "<code>\\\\</code>".  This is basically
the same as what you would need to write if constructing the string in Java code.
</p>
<p>
For more information on these three types of patterns, see the descriptions of
<code><a href="/reference/android/os/PatternMatcher.html#PATTERN_LITERAL">PATTERN_LITERAL</a></code>,
<code><a href="/reference/android/os/PatternMatcher.html#PATTERN_PREFIX">PATTERN_PREFIX</a></code>, and
<code><a href="/reference/android/os/PatternMatcher.html#PATTERN_SIMPLE_GLOB">PATTERN_SIMPLE_GLOB</a></code> in the
<code><a href="/reference/android/os/PatternMatcher.html">PatternMatcher</a></code> class.
</p>
<p>These attributes are meaningful only if the
<code><a href="#scheme">scheme</a></code> and <code><a href="#host">host</a></code>
attributes are also specified for the filter.
</p>
<p>It's common for an intent filter to declare a <code>&lt;data&gt;</code> that includes
only the <code>android:mimeType</code> attribute.</p>
<p class="note"><strong>Note</strong>: MIME type matching in the Android framework is
case-sensitive, unlike formal RFC MIME types.  As a result, you should always
specify MIME types using lowercase letters.</p>
<h1 itemprop="name">&lt;data&gt;</h1>
<p>WHATSON? afcb057a-6d62-4200-aa8c-9e78fd8e846a</p>
<pre class="stx">&lt;data android:<a href="#scheme">scheme</a>="<i>string</i>"
      android:<a href="#host">host</a>="<i>string</i>"
      android:<a href="#port">port</a>="<i>string</i>"
      android:<a href="#path">path</a>="<i>string</i>"
      android:<a href="#path">pathPattern</a>="<i>string</i>"
      android:<a href="#path">pathPrefix</a>="<i>string</i>"
      android:<a href="#mime">mimeType</a>="<i>string</i>" /&gt;</pre>
<p style="margin-left: 2em">
<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code></p>
<p>
These attributes that specify the URL format are optional, but also mutually dependent:
</p>
<ul>
  <li>If a <code><a href="/guide/topics/manifest/data-element.html#scheme">scheme</a></code>
is not specified for the intent filter, all the other URI attributes are ignored.</li>
  <li>If a <code><a href="/guide/topics/manifest/data-element.html#host">host</a></code>
is not specified for the filter, the <code>port</code> attribute and all the path attributes are ignored.
</li></ul>
<p>
All the <code>&lt;data&gt;</code> elements contained within the same
<code><a href="/guide/topics/manifest/intent-filter-element.html">&lt;intent-filter&gt;</a></code> element contribute to
the same filter.  So, for example, the following filter specification,
</p>
<p>WHATSON? 77983d67-a55d-431c-971d-0f75192faec4</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>is equivalent to this one:</p>
<p>WHATSON? 4c9dcd09-58a9-40e1-ac79-261fbb9a6dcc</p>
<pre>&lt;intent-filter . . . &gt;
    &lt;data android:scheme="something" /&amp;gt
    &lt;data android:host="project.example.com" /&gt;
    . . .
&lt;/intent-filter&gt;</pre>
<p>
You can place any number of <code>&lt;data&gt;</code> elements inside an
<code><a href="/guide/topics/manifest/intent-filter-element.html">&lt;intent-filter&gt;</a></code> to give it multiple data
options.  None of its attributes have default values.
</p>
<p>
Information on how intent filters work, including the rules for how Intent objects
are matched against filters, can be found in another document,
<a href="/guide/components/intents-filters.html">Intents and
Intent Filters</a>.  See also the
<a href="/guide/topics/manifest/manifest-intro.html#ifs">Intent Filters</a>
section in the manifest file overview.
</p>
<p>
A scheme is specified without the trailing colon (for example,
<code>http</code>, rather than <code>http:</code>).
</p>
<p>
If the filter has a data type set (the <code><a href="/guide/topics/manifest/data-element.html#mime">mimeType</a></code>
attribute) but no scheme, the <code>content:</code> and <code>file:</code> schemes are
assumed.
</p>
<p class="note"><strong>Note</strong>: Scheme matching in the Android framework is
case-sensitive, unlike the RFC.  As a result, you should always specify schemes
using lowercase letters.</p>
<p class="note"><strong>Note</strong>: host name matching in the Android framework is
case-sensitive, unlike the formal RFC.  As a result, you should always specify
host names using lowercase letters.</p>
<ul>
<li>An asterisk ('<code>*</code>') matches a sequence of 0 to many occurrences of
the immediately preceding character.</li>

<li>A period followed by an asterisk ("<code>.*</code>") matches any sequence of
0 to many characters.</li>
</ul>
<p>
Because '<code>\</code>' is used as an escape character when the string is read
from XML (before it is parsed as a pattern), you will need to double-escape:
For example, a literal '<code>*</code>' would be written as "<code>\\*</code>" and a
literal '<code>\</code>' would be written as "<code>\\\\</code>".  This is basically
the same as what you would need to write if constructing the string in Java code.
</p>
<p>
For more information on these three types of patterns, see the descriptions of
<code><a href="/reference/android/os/PatternMatcher.html#PATTERN_LITERAL">PATTERN_LITERAL</a></code>,
<code><a href="/reference/android/os/PatternMatcher.html#PATTERN_PREFIX">PATTERN_PREFIX</a></code>, and
<code><a href="/reference/android/os/PatternMatcher.html#PATTERN_SIMPLE_GLOB">PATTERN_SIMPLE_GLOB</a></code> in the
<code><a href="/reference/android/os/PatternMatcher.html">PatternMatcher</a></code> class.
</p>
<p>These attributes are meaningful only if the
<code><a href="#scheme">scheme</a></code> and <code><a href="#host">host</a></code>
attributes are also specified for the filter.
</p>
<p>It's common for an intent filter to declare a <code>&lt;data&gt;</code> that includes
only the <code>android:mimeType</code> attribute.</p>
<p class="note"><strong>Note</strong>: MIME type matching in the Android framework is
case-sensitive, unlike formal RFC MIME types.  As a result, you should always
specify MIME types using lowercase letters.</p>
