<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Multiple inheritance</span></h1>
<p><b>Multiple inheritance</b> is a feature of some <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented</a> computer <a href="/wiki/Programming_language" title="Programming language">programming languages</a> in which an object or <a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">class</a> can <a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">inherit</a> characteristics and features from more than one parent object or <a href="/wiki/Superclass_(computer_science)" title="Superclass (computer science)" class="mw-redirect">parent class</a>. It is distinct from single inheritance, where an object or class may only inherit from one particular object or class.</p>
<p>Multiple inheritance has been a sensitive issue for many years,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> with opponents pointing to its increased complexity and ambiguity in situations such as the "diamond problem", where it may be ambiguous as to which parent class a particular feature is inherited from if more than one parent class implements said feature. This can be addressed in various ways, including using <a href="/wiki/Virtual_inheritance" title="Virtual inheritance">virtual inheritance</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> Alternate methods of object composition not based on inheritance such as <a href="/wiki/Mixin" title="Mixin">mixins</a> and <a href="/wiki/Trait_(computer_programming)" title="Trait (computer programming)">traits</a> have also been proposed to address the ambiguity.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Details"><span class="tocnumber">1</span> <span class="toctext">Details</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Implementations"><span class="tocnumber">2</span> <span class="toctext">Implementations</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#The_diamond_problem"><span class="tocnumber">3</span> <span class="toctext">The diamond problem</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Mitigation"><span class="tocnumber">3.1</span> <span class="toctext">Mitigation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Further_reading"><span class="tocnumber">6</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#External_links"><span class="tocnumber">7</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Mitigation"><span class="tocnumber">3.1</span> <span class="toctext">Mitigation</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Details">Details</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=1" title="Edit section: Details">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a> (OOPs), <i><a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">inheritance</a></i> describes a relationship between two types, or classes, of objects in which one is said to be a <i>subtype</i> or <i>child</i> of the other. The child inherits features of the parent, allowing for shared functionality. For example, one might create a variable class <i>Mammal</i> with features such as eating, reproducing, etc.; then define a subtype <i>Cat</i> that inherits those features without having to explicitly program them, while adding new features like <i>chasing mice</i>.</p>
<p>Multiple inheritance allows programmers to use more than one totally orthogonal hierarchy simultaneously, such as allowing <i>Cat</i> to inherit from <i>Cartoon character</i> and <i>Pet</i> and <i>Mammal</i> and access features from within all of those classes.</p>
<p>The widespread view that multiple inheritance is “bad” or “dangerous” is not justified;<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Neutral_point_of_view" title="Wikipedia:Neutral point of view"><span title="This statement is possibly biased. (November 2014)">neutrality</span></a> is <a href="/wiki/Talk:Multiple_inheritance" title="Talk:Multiple inheritance">disputed</a></i>]</sup> most of the time, it results from experience with imperfect multiple inheritance mechanisms, or improper uses of inheritance.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (November 2014)">citation needed</span></a></i>]</sup> Well-applied multiple and repeated inheritance is a powerful way to combine abstractions, and a key technique of object-oriented software development.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=2" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Languages that support multiple inheritance include: <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a> (via <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a> (CLOS)), <a href="/wiki/EuLisp" title="EuLisp">EuLisp</a> (via The EuLisp Object System TELOS), <a href="/wiki/Curl_(programming_language)" title="Curl (programming language)">Curl</a>, <a href="/wiki/Dylan_(programming_language)" title="Dylan (programming language)">Dylan</a>, <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a>, <a href="/wiki/Logtalk" title="Logtalk">Logtalk</a>, <a href="/wiki/Object_REXX" title="Object REXX">Object REXX</a>, <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> (via use of <a href="/wiki/Mixin" title="Mixin">mixin</a> classes), <a href="/wiki/OCaml" title="OCaml">OCaml</a>, <a href="/wiki/Perl" title="Perl">Perl</a>, <a href="/wiki/Perl_6" title="Perl 6">Perl 6</a>, <a href="/wiki/POP-11" title="POP-11">POP-11</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, and <a href="/wiki/Tcl" title="Tcl">Tcl</a> (built-in from 8.6 or via Incremental Tcl (<a href="/wiki/Incr_Tcl" title="Incr Tcl">Incr Tcl</a>) in earlier versions).<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p>Some object-oriented languages, such as <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, and <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a> implement <i>single inheritance</i>, although <a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">protocols</a>, or <i>interfaces,</i> provide some of the functionality of true multiple inheritance.</p>
<p><a href="/wiki/PHP" title="PHP">PHP</a> uses <a href="/wiki/Traits_class" title="Traits class" class="mw-redirect">traits classes</a> to inherit multiple functions.</p>
<h2><span class="mw-headline" id="The_diamond_problem">The diamond problem</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=3" title="Edit section: The diamond problem">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The "diamond problem" (sometimes referred to as the "deadly diamond of death"<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup>) is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and/or C has <a href="/wiki/Method_overriding_(programming)" title="Method overriding (programming)" class="mw-redirect">overridden</a>, and D does not override it, then which version of the method does D inherit: that of B, or that of C?</p>
<p>For example, in the context of <a href="/wiki/Graphical_user_interface" title="Graphical user interface">GUI</a> <a href="/wiki/Software_development" title="Software development">software development</a>, a class <code>Button</code> may inherit from both classes <code>Rectangle</code> (for appearance) and <code>Clickable</code> (for functionality/input handling), and classes <code>Rectangle</code> and <code>Clickable</code> both inherit from the <code>Object</code> class. Now if the <code>equals</code> method is called for a <code>Button</code> object and there is no such method in the <code>Button</code> class but there is an overridden <code>equals</code> method in <code>Rectangle</code> or <code>Clickable</code> (or both), which method should be eventually called?</p>
<p>It is called the "diamond problem" because of the shape of the class inheritance diagram in this situation. In this case, class A is at the top, both B and C separately beneath it, and D joins the two together at the bottom to form a diamond shape.</p>
<h3><span class="mw-headline" id="Mitigation">Mitigation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=4" title="Edit section: Mitigation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Languages have different ways of dealing with these problems of repeated inheritance.</p>
<ul>
<li><a href="/wiki/C%2B%2B" title="C++">C++</a> by default follows each inheritance path separately, so a <code>D</code> object would actually contain two separate <code>A</code> objects, and uses of <code>A</code>'s members have to be properly qualified. If the inheritance from <code>A</code> to <code>B</code> and the inheritance from <code>A</code> to <code>C</code> are both marked "<code>virtual</code>" (for example, "<code>class B : virtual public A</code>"), C++ takes special care to only create one <code>A</code> object, and uses of <code>A</code>'s members work correctly. If <a href="/wiki/Virtual_inheritance" title="Virtual inheritance">virtual inheritance</a> and nonvirtual inheritance are mixed, there is a single virtual <code>A</code> and a nonvirtual <code>A</code> for each nonvirtual inheritance path to <code>A</code>. C++ requires stating explicitly which parent class the feature to be used is invoked from i.e. "Worker::Human.Age". C++ does not support explicit repeated inheritance since there would be no way to qualify which superclass to use (i.e. having a class appear more than once in a single derivation list [class Dog : public Animal, Animal]). C++ also allows a single instance of the multiple class to be created via the virtual inheritance mechanism (i.e. "Worker::Human" and "Musician::Human" will reference the same object).</li>
<li><a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a> <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">CLOS</a> attempts to provide both reasonable default behavior and the ability to override it. By default, the method with the most specific argument classes is chosen; then in the order in which parent classes are named in the subclass definition. However, the programmer can override this, by giving a specific method resolution order or stating a rule for combining methods. This is called method combination, which may be fully controlled. The MOP (<a href="/wiki/Metaobject" title="Metaobject">metaobject</a> protocol) also provides means to modify the inheritance, <a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">dynamic dispatch</a>, class instantiation, and other internal mechanisms without affecting the stability of the system.</li>
<li><a href="/wiki/Curl_(programming_language)" title="Curl (programming language)">Curl</a> allows only classes that are explicitly marked as <i>shared</i> to be inherited repeatedly. Shared classes must define a <i>secondary constructor</i> for each regular <a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">constructor</a> in the class. The regular constructor is called the first time the state for the shared class is initialized through a subclass constructor, and the secondary constructor will be invoked for all other subclasses.</li>
<li>In <a href="/wiki/Eiffel_(programming_language)" title="Eiffel (programming language)">Eiffel</a>, the ancestors' features are chosen explicitly with select and rename directives. This allows the features of the base class to be shared between its descendants or to give each of them a separate copy of the base class. Eiffel allows explicit joining or separation of features inherited from ancestor classes. Eiffel will automatically join features together, if they have the same name and implementation. The class writer has the option to rename the inherited features to separate them. Multiple inheritance is a frequent occurrence in Eiffel development; most of the effective classes in the widely used EiffelBase library of data structures and algorithms, for example, have two or more parents.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></li>
<li><a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> 8 introduces default methods on interfaces. If <code>A,B,C</code> are interfaces, <code>B,C</code> can each provide a different implementation to an abstract method of <code>A</code>, causing the diamond problem. Either class <code>D</code> must reimplement the method (the body of which can simply forward the call to one of the super implementations), or the ambiguity will be rejected as a compile error.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup> Prior to Java 8, Java was not subject to the Diamond problem risk, as Java does not support multiple inheritance. The default interface method capability added with Java 8 introduced a type of multiple inheritance since classes can implement more than one interface, which can contain default methods that have the same name. However, the Java compiler provides rules to determine which default method a particular class uses, which prevents the Diamond problem.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup></li>
<li><a href="/wiki/JavaFX_Script" title="JavaFX Script">JavaFX Script</a> in version 1.2 allows multiple inheritance through the use of <a href="/wiki/Mixin" title="Mixin">mixins</a>. In case of conflict, the compiler prohibits the direct usage of the ambiguous variable or function. Each inherited member can still be accessed by casting the object to the mixin of interest, e.g. <code>(individual as Person).printInfo();</code>.</li>
<li><a href="/wiki/Logtalk" title="Logtalk">Logtalk</a> supports both interface and implementation multi-inheritance, allowing the declaration of method <i>aliases</i> that provide both renaming and access to methods that would be masked out by the default conflict resolution mechanism.</li>
<li>In <a href="/wiki/OCaml" title="OCaml">OCaml</a>, parent classes are specified individually in the body of the class definition. Methods (and attributes) are inherited in the same order, with each newly inherited method overriding any existing methods. OCaml chooses the last matching definition of a class inheritance list to resolve which method implementation to use under ambiguities. To override the default behavior, one simply qualifies a method call with the desired class definition.</li>
<li><a href="/wiki/Perl" title="Perl">Perl</a> uses the list of classes to inherit from as an ordered list. The compiler uses the first method it finds by <a href="/wiki/Depth-first_search" title="Depth-first search">depth-first searching</a> of the superclass list or using the <a href="/wiki/C3_linearization" title="C3 linearization">C3 linearization</a> of the class hierarchy. Various extensions provide alternative class composition schemes. The order of inheritance affects the class semantics. In the above ambiguity, class <code>B</code> and its ancestors would be checked before class <code>C</code> and its ancestors, so the method in <code>A</code> would be inherited through <code>B</code>. This is shared with <a href="/wiki/Io_programming_language" title="Io programming language" class="mw-redirect">Io</a> and <a href="/wiki/Picolisp" title="Picolisp">Picolisp</a>. In Perl, this behavior can be overridden using the <code>mro</code> or other modules to use <a href="/wiki/C3_linearization" title="C3 linearization">C3 linearization</a> or other algorithms.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (February 2014)">citation needed</span></a></i>]</sup></li>
<li><a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a> has the same structure as Perl, but, unlike Perl, includes it in the syntax of the language. The order of inheritance affects the class semantics. Python had to deal with this upon the introduction of new-style classes, all of which have a common ancestor, <code>object</code>. Python creates a list of classes using the <a href="/wiki/C3_linearization" title="C3 linearization">C3 linearization</a> algorithm. That algorithm enforces two constraints: children precede their parents and if a class inherits from multiple classes, they are kept in the order specified in the tuple of base classes (however in this case, some classes high in the inheritance graph may precede classes lower in the graph<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup>). Thus, the method resolution order is: <code>D</code>, <code>B</code>, <code>C</code>, <code>A</code>.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup><sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup></li>
<li><a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a> allows multiple instantiation of <i>traits</i>, which allows for multiple inheritance by adding a distinction between the class hierarchy and the trait hierarchy. A class can only inherit from a single class, but can mix-in as many traits as desired. Scala resolves method names using a right-first depth-first search of extended 'traits', before eliminating all but the last occurrence of each module in the resulting list. So, the resolution order is: [<code>D</code>, <code>C</code>, <code>A</code>, <code>B</code>, <code>A</code>], which reduces down to [<code>D</code>, <code>C</code>, <code>B</code>, <code>A</code>].</li>
<li><a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a> classes have exactly one parent but may also inherit from multiple <i>modules;</i> ruby class definitions are executed, and the (re)definition of a method obscures any previously existing definition at the time of execution. In the absence of runtime metaprogramming this has approximately the same semantics as rightmost depth first resolution.</li>
<li><a href="/wiki/Tcl" title="Tcl">Tcl</a> allows multiple parent classes; the order of specification in the class declaration affects the name resolution for members using the <a href="/wiki/C3_linearization" title="C3 linearization">C3 linearization</a> algorithm.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>13<span>]</span></a></sup></li>
</ul>
<p>Languages that allow only <a href="/wiki/Single_inheritance" title="Single inheritance" class="mw-redirect">single inheritance</a>, where a class can only derive from one base class, do not have the diamond problem. The reason for this is that such languages have at most one implementation of any method at any level in the inheritance chain regardless of the repetition or placement of methods. Typically these languages allow classes to implement multiple <a href="/wiki/Protocol_(object-oriented_programming)" title="Protocol (object-oriented programming)">protocols</a>, called <a href="/wiki/Interface_(Java)" title="Interface (Java)">interfaces</a> in Java. These protocols define methods but do not provide concrete implementations. This strategy has been used by <a href="/wiki/ActionScript" title="ActionScript">ActionScript</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, <a href="/wiki/D_(programming_language)" title="D (programming language)">D</a>, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, <a href="/wiki/Nemerle" title="Nemerle">Nemerle</a>, <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a> (Delphi), <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>, and <a href="/wiki/Swift_(programming_language)" title="Swift (programming language)">Swift</a>. All but Smalltalk allow classes to implement multiple protocols.</p>
<p>Moreover, languages such as <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, <a href="/wiki/Delphi_programming_language" title="Delphi programming language" class="mw-redirect">Delphi</a>/<a href="/wiki/Free_Pascal" title="Free Pascal">Free Pascal</a>, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, and <a href="/wiki/Swift_(programming_language)" title="Swift (programming language)">Swift</a> allow multiple-inheritance of interfaces (called protocols in Objective-C and Swift). Interfaces are like abstract base classes that specify method signatures without implementing any behavior. ("Pure" interfaces such as the ones in Java up to version 7 do not permit any implementation or instance data in the interface.) Nevertheless, even when several interfaces declare the same method signature, as soon as that method is implemented (defined) anywhere in the inheritance chain, it overrides any implementation of that method in the chain above it (in its superclasses). Hence, at any given level in the inheritance chain, there can be at most one implementation of any method. Thus, single-inheritance method implementation does not exhibit the Diamond Problem even with multiple-inheritance of interfaces.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=5" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Traits_class" title="Traits class" class="mw-redirect">Traits class</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
<li><a href="/wiki/Mixin" title="Mixin">Mixin</a></li>
<li><a href="/wiki/C3_linearization" title="C3 linearization">C3 linearization</a></li>
<li><a href="/wiki/Directed_graph" title="Directed graph">Directed graph</a></li>
<li><a href="/wiki/Nixon_diamond" title="Nixon diamond">Nixon Diamond</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=6" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">[Cargill, T. A. (1991) Controversy: The case against multiple inheritance in C++, Computing Systems 4(1) 69-82]</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">[Waldo, J. (1991) Controversy: The Case For Multiple Inheritance in C++. Computing Systems 4(2) 157-171]</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://web.cecs.pdx.edu/~black/publications/TR_CSE_02-012.pdf">Traits: Composable Units of Behavior</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://www.ecma-international.org/publications/standards/Ecma-367.htm">http://www.ecma-international.org/publications/standards/Ecma-367.htm</a></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://wiki.tcl.tk/590">Tcl Advocacy</a></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span id="CITEREFMartin1997" class="citation"><a href="/wiki/Robert_Cecil_Martin" title="Robert Cecil Martin">Martin, Robert C.</a> (1997-03-09), <a rel="nofollow" class="external text" href="http://objectmentor.com/resources/articles/javacpp.pdf"><i>Java and C++: A critical comparison</i></a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMultiple+inheritance&amp;rft.aufirst=Robert+C.&amp;rft.aulast=Martin&amp;rft.au=Martin%2C+Robert+C.&amp;rft.btitle=Java+and+C%2B%2B%3A+A+critical+comparison&amp;rft.date=1997-03-09&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fobjectmentor.com%2Fresources%2Farticles%2Fjavacpp.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://www.ecma-international.org/publications/standards/Ecma-367.htm">http://www.ecma-international.org/publications/standards/Ecma-367.htm</a></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html</a></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html">http://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html</a></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text">Example 2 of <a rel="nofollow" class="external free" href="https://www.python.org/download/releases/2.3/mro/#examples">https://www.python.org/download/releases/2.3/mro/#examples</a></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="https://www.python.org/download/releases/2.2.3/descrintro/#mro">https://www.python.org/download/releases/2.2.3/descrintro/#mro</a></span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external free" href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super/">http://rhettinger.wordpress.com/2011/05/26/super-considered-super/</a></span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.tcl.tk/man/itcl3.1/class.n.html">Tcl Manual:class</a></span></li>
</ol>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=7" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.23.4735&amp;rep=rep1&amp;type=pdf">Stroustrup, Bjarne (1999). <i>Multiple Inheritance for C++</i>. Proceedings of the Spring 1987 European Unix Users Group Conference</a></li>
<li>Object-Oriented Software Construction<i>, Second Edition, by <a href="/wiki/Bertrand_Meyer" title="Bertrand Meyer">Bertrand Meyer</a>, Prentice Hall, 1997, <a href="/wiki/Special:BookSources/0136291554" class="internal mw-magiclink-isbn">ISBN 0-13-629155-4</a></i></li>
<li><span class="citation journal">Eddy Truyen, Wouter Joosen, Bo Nørregaard, Pierre Verbaeten (2004). <a rel="nofollow" class="external text" href="http://www.cs.kuleuven.ac.be/~eddy/PUBLICATIONS/DAW2004.pdf">"A Generalization and Solution to the Common Ancestor Dilemma Problem in Delegation-Based Object Systems"</a>. <i>Proceedings of the 2004 Dynamic Aspects Workshop</i> (103–119).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMultiple+inheritance&amp;rft.atitle=A+Generalization+and+Solution+to+the+Common+Ancestor+Dilemma+Problem+in+Delegation-Based+Object+Systems&amp;rft.au=Eddy+Truyen%2C+Wouter+Joosen%2C+Bo+N%C3%B8rregaard%2C+Pierre+Verbaeten&amp;rft.aulast=Eddy+Truyen%2C+Wouter+Joosen%2C+Bo+N%C3%B8rregaard%2C+Pierre+Verbaeten&amp;rft.date=2004&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.cs.kuleuven.ac.be%2F~eddy%2FPUBLICATIONS%2FDAW2004.pdf&amp;rft.issue=103%E2%80%93119&amp;rft.jtitle=Proceedings+of+the+2004+Dynamic+Aspects+Workshop&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Multiple_inheritance&amp;action=edit&amp;section=8" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://builder.com.com/5100-6373-5030734.html">Article by Jonathan Lurie of Builder.Com on instances in .NET languages</a></li>
<li><a rel="nofollow" class="external text" href="http://docs.eiffel.com/book/method/et-inheritance">Tutorial on inheritance usage in Eiffel</a></li>
<li><a rel="nofollow" class="external text" href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super/">Tutorial on effective use of multiple inheritance in Python</a></li>
<li><a rel="nofollow" class="external text" href="http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html#toc26">An overview of inheritance in Ocaml</a></li>
</ul>
