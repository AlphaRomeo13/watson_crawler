<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Total functional programming</span></h1>
<p><b>Total functional programming</b> (also known as <b>strong functional programming</b>,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> to be contrasted with ordinary, or <i>weak</i> <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>) is a <a href="/wiki/Computer_programming" title="Computer programming">programming</a> paradigm that restricts the range of programs to those that are <a href="/wiki/Machine_that_always_halts" title="Machine that always halts">provably terminating</a>.<sup id="cite_ref-TFP_2-0" class="reference"><a href="#cite_note-TFP-2"><span>[</span>2<span>]</span></a></sup></p>
<p>Termination is guaranteed by the following restrictions:</p>
<ol>
<li>A restricted form of <a href="/wiki/Recursion" title="Recursion">recursion</a>, which operates only upon ‘reduced’ forms of its arguments, such as <a href="/wiki/Walther_recursion" title="Walther recursion">Walther recursion</a>, substructural recursion, or "strongly normalizing" as proven by abstract interpretation of code.<sup id="cite_ref-ETinESFP_3-0" class="reference"><a href="#cite_note-ETinESFP-3"><span>[</span>3<span>]</span></a></sup></li>
<li>Every function must be a total (as opposed to <a href="/wiki/Partial_function" title="Partial function">partial</a>) function. That is, it must have a definition for everything inside its domain.
<ul>
<li>There are several possible ways to extend commonly used partial functions such as division to be total: choosing an arbitrary result for inputs on which the function is normally undefined (such as <img class="mwe-math-fallback-image-inline tex" alt="\forall x \in \mathbb{N}. x \div 0 = 0" src="//upload.wikimedia.org/math/f/9/8/f98fc80dd8376996b176e08352f3133f.png"> for division); adding another argument to specify the result for those inputs; or excluding them by use of type system features such as <a href="/wiki/Refinement_type" title="Refinement type" class="mw-redirect">refinement types</a>.<sup id="cite_ref-TFP_2-1" class="reference"><a href="#cite_note-TFP-2"><span>[</span>2<span>]</span></a></sup></li>
</ul>
</li>
</ol>
<ul>
<li>There are several possible ways to extend commonly used partial functions such as division to be total: choosing an arbitrary result for inputs on which the function is normally undefined (such as <img class="mwe-math-fallback-image-inline tex" alt="\forall x \in \mathbb{N}. x \div 0 = 0" src="//upload.wikimedia.org/math/f/9/8/f98fc80dd8376996b176e08352f3133f.png"> for division); adding another argument to specify the result for those inputs; or excluding them by use of type system features such as <a href="/wiki/Refinement_type" title="Refinement type" class="mw-redirect">refinement types</a>.<sup id="cite_ref-TFP_2-1" class="reference"><a href="#cite_note-TFP-2"><span>[</span>2<span>]</span></a></sup></li>
</ul>
<p>These restrictions mean that total functional programming is not <a href="/wiki/Turing-complete" title="Turing-complete" class="mw-redirect">Turing-complete</a>. However, the set of algorithms that can be used is still huge. For example, any algorithm for which an <a href="/wiki/Upper_bound" title="Upper bound" class="mw-redirect">asymptotic upper bound</a> can be calculated (by a program that itself only uses Walther recursion) can be trivially transformed into a provably-terminating function by using the upper bound as an extra argument decremented on each iteration or recursion.</p>
<p>For example, <a href="/wiki/Quicksort" title="Quicksort">quicksort</a> is not trivially shown to be substructural recursive, but it only recurs to a maximum depth of the length of the vector (in the worst-case O(n^2) case). A quicksort implementation on lists (which would be rejected by a substructural recursive checker) is:</p>
<p>WHATSON? 94bd1077-c4a7-4704-ae48-9eab59d6bf03</p>
<pre>
<code>qsort []       = []
qsort [a]      = [a]
qsort (a:as)   = let
                   (lesser, greater) = partition a as
                 in qsort lesser ++ [a] ++ qsort greater
</code>
</pre>
<p>To make it substructural recursive using the length of the vector as a limit, we could do:</p>
<p>WHATSON? 6cf8a26b-0527-4025-b190-9a11d8bc1a27</p>
<pre>
<code>qsort x = qsortSub x x
-- minimum case
qsortSub []     as     = as -- shows termination
-- standard qsort cases
qsortSub (l:ls) []     = [] -- nonrecursive, so accepted
qsortSub (l:ls) [a]    = [a] -- nonrecursive, so accepted
qsortSub (l:ls) (a:as) = let
                           (lesser, greater) = partition a as
                            -- recursive, but recurs on ls, which is a substructure of
                            -- its first input.
                         in qsortSub ls lesser ++ [a] ++ qsortSub ls greater
</code>
</pre>
<p>Some classes of algorithms that have no theoretical upper bound but have a practical upper bound (for example, some heuristic-based algorithms) can be programmed to "give up" after so many recursions, also ensuring termination.</p>
<p>Another outcome of total functional programming is that both <a href="/wiki/Strict_evaluation" title="Strict evaluation" class="mw-redirect">strict evaluation</a> and <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a> result in the same behaviour, in principle; however, one or the other may still be preferable (or even required) for performance reasons.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<p>In total functional programming, a distinction is made between <a href="/wiki/Data" title="Data">data</a> and <a href="/wiki/Codata" title="Codata" class="mw-redirect">codata</a>—the former is <a href="/wiki/Finitary" title="Finitary">finitary</a>, while the latter is potentially infinite. Such potentially infinite data structures are used for applications such as <a href="/wiki/I/O" title="I/O" class="mw-redirect">I/O</a>. Using codata entails the usage of such operations as <a href="/wiki/Corecursion" title="Corecursion">corecursion</a>. However, it is possible to do <a href="/wiki/I/O" title="I/O" class="mw-redirect">I/O</a> in a total functional programming language (with <a href="/wiki/Dependent_types" title="Dependent types" class="mw-redirect">dependent types</a>) also without codata.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup></p>
<p>Both <a href="/wiki/Epigram_(programming_language)" title="Epigram (programming language)">Epigram</a> and <a href="/wiki/Charity_(programming_language)" title="Charity (programming language)">Charity</a> could be considered total functional programming languages, even though they don't work in the way Turner specifies in his paper. So could programming directly in plain <a href="/wiki/System_F" title="System F">System F</a>, in <a href="/wiki/Martin-L%C3%B6f_type_theory" title="Martin-Löf type theory" class="mw-redirect">Martin-Löf type theory</a> or the <a href="/wiki/Calculus_of_Constructions" title="Calculus of Constructions" class="mw-redirect">Calculus of Constructions</a>.</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Total_functional_programming&amp;action=edit&amp;section=1" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">This term is due to: <span id="CITEREFTurner1995" class="citation"><a href="/wiki/David_Turner_(computer_scientist)" title="David Turner (computer scientist)">Turner, D.A.</a> (December 1995), "Elementary Strong Functional Programming", <i>First International Symposium on Functional Programming Languages in Education</i>, <i>Springer LNCS</i> <b>1022</b>: 1–13</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATotal+functional+programming&amp;rft.atitle=First+International+Symposium+on+Functional+Programming+Languages+in+Education&amp;rft.aufirst=D.A.&amp;rft.aulast=Turner&amp;rft.au=Turner%2C+D.A.&amp;rft.btitle=Elementary+Strong+Functional+Programming&amp;rft.date=December+1995&amp;rft.genre=bookitem&amp;rft.pages=1-13&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=1022" class="Z3988"><span style="display:none;"> </span></span>.</span></li>
<li id="cite_note-TFP-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-TFP_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-TFP_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span id="CITEREFTurner2004" class="citation"><a href="/wiki/David_Turner_(computer_scientist)" title="David Turner (computer scientist)">Turner, D.A.</a> (2004-07-28), <a rel="nofollow" class="external text" href="http://www.jucs.org/jucs_10_7/total_functional_programming"><i>Total Functional Programming</i></a>, <i>Journal of Universal Computer Science</i> <b>10</b> (7): 751–768, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.3217%2Fjucs-010-07-0751">10.3217/jucs-010-07-0751</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATotal+functional+programming&amp;rft.atitle=Total+Functional+Programming&amp;rft.aufirst=D.A.&amp;rft.aulast=Turner&amp;rft.au=Turner%2C+D.A.&amp;rft.date=2004-07-28&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.jucs.org%2Fjucs_10_7%2Ftotal_functional_programming&amp;rft_id=info%3Adoi%2F10.3217%2Fjucs-010-07-0751&amp;rft.issue=7&amp;rft.jtitle=Journal+of+Universal+Computer+Science&amp;rft.pages=751-768&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=10" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-ETinESFP-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-ETinESFP_3-0">^</a></b></span> <span class="reference-text"><span id="CITEREFTurner2000" class="citation"><a href="/wiki/David_Turner_(computer_scientist)" title="David Turner (computer scientist)">Turner, D.A.</a> (2000-04-28), <a rel="nofollow" class="external text" href="http://www.jucs.org/jucs_6_4/ensuring_termination_in_esfp"><i>Ensuring Termination in ESFP</i></a>, <i>Journal of Universal Computer Science</i> <b>6</b> (4): 474–488, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.3217%2Fjucs-006-04-0474">10.3217/jucs-006-04-0474</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATotal+functional+programming&amp;rft.atitle=Ensuring+Termination+in+ESFP&amp;rft.aufirst=D.A.&amp;rft.aulast=Turner&amp;rft.au=Turner%2C+D.A.&amp;rft.date=2000-04-28&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.jucs.org%2Fjucs_6_4%2Fensuring_termination_in_esfp&amp;rft_id=info%3Adoi%2F10.3217%2Fjucs-006-04-0474&amp;rft.issue=4&amp;rft.jtitle=Journal+of+Universal+Computer+Science&amp;rft.pages=474-488&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">The differences between lazy and eager evaluation are discussed in: <span class="citation book">Granström, J. G. (2011). <a rel="nofollow" class="external text" href="http://www.springer.com/philosophy/book/978-94-007-1735-0"><i>Treatise on Intuitionistic Type Theory</i></a>. Logic, Epistemology, and the Unity of Science <b>7</b>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-94-007-1735-0" title="Special:BookSources/978-94-007-1735-0">978-94-007-1735-0</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATotal+functional+programming&amp;rft.aufirst=J.+G.&amp;rft.au=Granstr%C3%B6m%2C+J.+G.&amp;rft.aulast=Granstr%C3%B6m&amp;rft.btitle=Treatise+on+Intuitionistic+Type+Theory&amp;rft.date=2011&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.springer.com%2Fphilosophy%2Fbook%2F978-94-007-1735-0&amp;rft.isbn=978-94-007-1735-0&amp;rft.series=Logic%2C+Epistemology%2C+and+the+Unity+of+Science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=7" class="Z3988"><span style="display:none;"> </span></span> See in particular pp. 86-91.</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span id="CITEREFGranstr.C3.B6m2012" class="citation">Granström, J. G. (May 2012), <a rel="nofollow" class="external text" href="http://ojs.academypublisher.com/index.php/jsw/article/view/jsw070511361148"><i>A New Paradigm for Component-based Development</i></a>, <i>Journal of Software</i> <b>7</b> (5): 1136–1148, <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.4304%2Fjsw.7.5.1136-1148">10.4304/jsw.7.5.1136-1148</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ATotal+functional+programming&amp;rft.atitle=A+New+Paradigm+for+Component-based+Development&amp;rft.aufirst=J.+G.&amp;rft.au=Granstr%C3%B6m%2C+J.+G.&amp;rft.aulast=Granstr%C3%B6m&amp;rft.date=May+2012&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fojs.academypublisher.com%2Findex.php%2Fjsw%2Farticle%2Fview%2Fjsw070511361148&amp;rft_id=info%3Adoi%2F10.4304%2Fjsw.7.5.1136-1148&amp;rft.issue=5&amp;rft.jtitle=Journal+of+Software&amp;rft.pages=1136-1148&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=7" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
