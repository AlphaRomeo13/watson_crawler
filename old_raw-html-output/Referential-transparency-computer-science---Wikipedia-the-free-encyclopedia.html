<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Referential transparency (computer science)</span></h1>
<p><b>Referential transparency</b> and <b>referential opacity</b> are properties of parts of <a href="/wiki/Computer_program" title="Computer program">computer programs</a>. An <a href="/wiki/Expression_(programming)" title="Expression (programming)" class="mw-redirect">expression</a> is said to be referentially transparent if it can be replaced with its <a href="/wiki/Value_(computer_science)" title="Value (computer science)">value</a> without changing the behavior of a program (in other words, yielding a program that has the same effects and output on the same input). The opposite term is referential opaqueness.</p>
<p>While in <a href="/wiki/Mathematics" title="Mathematics">mathematics</a> all function applications are referentially <a href="/wiki/Transparency_(human-computer_interaction)" title="Transparency (human-computer interaction)" class="mw-redirect">transparent</a>, in programming this is not always the case. The importance of referential transparency is that it allows the <a href="/wiki/Programmer" title="Programmer">programmer</a> and the <a href="/wiki/Compiler" title="Compiler">compiler</a> to reason about program behavior. This can help in proving <a href="/wiki/Correctness_(computer_science)" title="Correctness (computer science)">correctness</a>, simplifying an <a href="/wiki/Algorithm" title="Algorithm">algorithm</a>, assisting in modifying code without breaking it, or <a href="/wiki/Optimization_(computer_science)" title="Optimization (computer science)" class="mw-redirect">optimizing</a> code by means of <a href="/wiki/Memoization" title="Memoization">memoization</a>, <a href="/wiki/Common_subexpression_elimination" title="Common subexpression elimination">common subexpression elimination</a>, <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a>, or <a href="/wiki/Parallelization" title="Parallelization" class="mw-redirect">parallelization</a>.</p>
<p>Referential transparency is one of the principles of <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>; only referentially transparent functions can be memoized (transformed into equivalent functions which cache results). Some <a href="/wiki/Programming_language" title="Programming language">programming languages</a> provide means to guarantee referential transparency. Some functional programming languages enforce referential transparency for all functions.</p>
<p>As referential transparency requires the same results for a given set of inputs at any point in time, a referentially transparent expression is therefore <a href="/wiki/Deterministic_system_(philosophy)" title="Deterministic system (philosophy)">deterministic</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Examples_and_counterexamples"><span class="tocnumber">1</span> <span class="toctext">Examples and counterexamples</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Contrast_to_imperative_programming"><span class="tocnumber">2</span> <span class="toctext">Contrast to imperative programming</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Another_example"><span class="tocnumber">3</span> <span class="toctext">Another example</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Examples_and_counterexamples">Examples and counterexamples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Referential_transparency_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Examples and counterexamples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>If all functions involved in the expression are <a href="/wiki/Pure_function" title="Pure function">pure functions</a>, then the expression is referentially transparent. Also, some impure functions can be included in the expression if their values are discarded and their <a href="/wiki/Side_effect_(computer_science)" title="Side effect (computer science)">side effects</a> are insignificant.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (April 2014)">citation needed</span></a></i>]</sup></p>
<p>Consider a function that returns the input from some source. In pseudocode, a call to this function might be <code>GetInput(Source)</code> where <code>Source</code> might identify a particular disc file, the <a href="/wiki/Computer_keyboard" title="Computer keyboard">keyboard</a>, etc. Even with identical values of <code>Source</code>, the successive return values will be different. Therefore, function <code>GetInput()</code> is neither deterministic nor referentially transparent.</p>
<p>A more subtle example is that of a function that uses a <a href="/wiki/Global_variable" title="Global variable">global variable</a> (or a dynamically <a href="/wiki/Scope_(programming)" title="Scope (programming)" class="mw-redirect">scoped</a> variable, or a lexical <a href="/wiki/Closure_(computer_science)" title="Closure (computer science)" class="mw-redirect">closure</a>) to help it compute its results. Since this variable is not passed as a parameter but can be altered, the results of subsequent calls to the function can differ even if the parameters are identical. In pure <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, <a href="/wiki/Destructive_assignment" title="Destructive assignment" class="mw-redirect">destructive assignment</a> is not allowed; thus, a function that uses global (or <a href="/wiki/Dynamic_scoping" title="Dynamic scoping" class="mw-redirect">dynamically scoped</a>) variables may or may not be referentially transparent, depending on whether the global variables are immutable.</p>
<p>Arithmetic operations are referentially transparent: <code>5*5</code> can be replaced by <code>25</code>, for instance. In fact, all functions in the mathematical sense are referentially transparent: <code>sin(x)</code> is transparent, since it will always give the same result for each particular <code>x</code>.</p>
<p>Assignments are not transparent. For instance, the <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> expression <code>x = x + 1</code> changes the value assigned to the variable <code>x</code>. Assuming <code>x</code> initially has value <code>10</code>, two consecutive evaluations of the expression yield, respectively, <code>11</code> and <code>12</code>. Clearly, replacing <code>x = x + 1</code> with either <code>11</code> or <code>12</code> gives a program with different meaning, and so the expression is not referentially transparent. However, calling a function such as <code>int plusone(int x) {return x+1;}</code> <i>is</i> transparent, as it will not implicitly change the input x and thus has no such <a href="/wiki/Side_effect_(computer_science)" title="Side effect (computer science)">side effects</a>.</p>
<p><code>today()</code> is not transparent, as if you evaluate it and replace it by its value (say, "Jan 1, 2001"), you don't get the same result as you will if you run it tomorrow. This is because it depends on a state (the time).</p>
<h2><span class="mw-headline" id="Contrast_to_imperative_programming">Contrast to imperative programming</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Referential_transparency_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Contrast to imperative programming">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>If the substitution of an expression with its value is valid only at a certain point in the execution of the program, then the expression is not referentially transparent. The definition and ordering of these <a href="/wiki/Sequence_points" title="Sequence points" class="mw-redirect">sequence points</a> are the theoretical foundation of <a href="/wiki/Imperative_programming" title="Imperative programming">imperative programming</a>, and part of the semantics of an imperative programming language.</p>
<p>However, because a referentially transparent expression can be evaluated at any time, it is not necessary to define sequence points nor any guarantee of the order of evaluation at all. Programming done without these considerations is called <a href="/wiki/Purely_functional" title="Purely functional">purely functional programming</a>.</p>
<p>One advantage of writing code in a referentially transparent style is that given an intelligent compiler, <a href="/wiki/Static_code_analysis" title="Static code analysis" class="mw-redirect">static code analysis</a> is easier and better <a href="/wiki/Code-improving_transformation" title="Code-improving transformation" class="mw-redirect">code-improving transformations</a> are possible automatically. For example, when programming in C, there will be a performance penalty for including a call to an expensive function inside a loop, even if the function call could be moved outside of the loop without changing the results of the program. The programmer would be forced to perform manual <a href="/w/index.php?title=Code_motion&amp;action=edit&amp;redlink=1" class="new" title="Code motion (page does not exist)">code motion</a> of the call, possibly at the expense of source code readability. However, if the compiler is able to determine that the function call is referentially transparent, it can perform this transformation automatically.</p>
<p>The primary disadvantage of languages that enforce referential transparency is that they make the expression of operations that naturally fit a sequence-of-steps imperative programming style more awkward and less concise. Such languages often incorporate mechanisms to make these tasks easier while retaining the purely functional quality of the language, such as <a href="/wiki/Definite_clause_grammar" title="Definite clause grammar">definite clause grammars</a> and <a href="/wiki/Monads_in_functional_programming" title="Monads in functional programming" class="mw-redirect">monads</a>.</p>
<p>With referential transparency, no distinction is made or difference recognized between a reference to a thing and the corresponding thing itself. Without referential transparency, such difference can be easily made and utilized in programs.</p>
<h2><span class="mw-headline" id="Another_example">Another example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Referential_transparency_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Another example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>As an example, let's use two functions, one which is referentially opaque, and the other which is referentially transparent:</p>
<p>WHATSON? 0ee3c61a-31c6-4c2d-b8f2-d5b805b4f363</p>
<pre>
 globalValue = 0;

 integer function rq(integer x)
 begin
   globalValue = globalValue + 1;
   return x + globalValue;
 end

 integer function rt(integer x)
 begin
   return x + 1;
 end
</pre>
<p>The function <code>rt</code> is referentially transparent, which means that <code>rt(x) = rt(y)</code> if <code>x = y</code>. For instance, <code>rt(6) = 6 + 1 = 7, rt(4) = 4 + 1 = 5</code>, and so on. However, we can't say any such thing for <code>rq</code> because it uses a global variable that it modifies.</p>
<p>The referential opacity of <code>rq</code> makes reasoning about programs more difficult. For example, say we wish to reason about the following statement:</p>
<p>WHATSON? 6a272fd0-6090-44ae-81a0-093ef415e298</p>
<pre>
integer p = rq(x) + rq(y) * (rq(x) - rq(x));
</pre>
<p>One may be tempted to simplify this statement to:</p>
<p>WHATSON? 1eeb87cd-ce8f-4ea0-84ba-62b60374891c</p>
<pre>
integer p = rq(x) + rq(y) * (0);
integer p = rq(x) + 0;
integer p = rq(x);
</pre>
<p>However, this will not work for <code>rq()</code> because each occurrence of <code>rq(x)</code> evaluates to a different value. Remember that the return value of <code>rq</code> is based on a global value that isn't passed in and which gets modified on each call to <code>rq</code>. This means that mathematical identities such as <img class="mwe-math-fallback-image-inline tex" alt="x - x = 0" src="//upload.wikimedia.org/math/7/4/a/74a4bd55a1631681acb55f219a1476de.png"> no longer hold.</p>
<p>Such mathematical identities <i>will</i> hold for referentially transparent functions such as <code>rt</code>.</p>
<p>However, a more sophisticated analysis can be used to simplify the statement to:</p>
<p>WHATSON? 50c40001-4c78-4c50-ab29-3a912e9b1a9c</p>
<pre>
integer a = globalValue; integer p = x + a + 1 + (y + a + 2) * (x + a + 3 - (x + a + 4)); globalValue = globalValue + 4;
integer a = globalValue; integer p = x + a + 1 + (y + a + 2) * (x + a + 3 - x - a - 4)); globalValue = globalValue + 4;
integer a = globalValue; integer p = x + a + 1 + (y + a + 2) * -1; globalValue = globalValue + 4;
integer a = globalValue; integer p = x + a + 1 - y - a - 2; globalValue = globalValue + 4;
integer p = x - y - 1; globalValue = globalValue + 4;
</pre>
<p>This takes more steps and requires a degree of insight into the code infeasible for compiler optimization.</p>
<p>Therefore, referential transparency allows us to reason about our code which will lead to more robust programs, the possibility of finding bugs that we couldn't hope to find by testing, and the possibility of seeing opportunities for <a href="/wiki/Optimization_(computer_science)" title="Optimization (computer science)" class="mw-redirect">optimization</a>.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Referential_transparency_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Idempotence#Computer_science_meaning" title="Idempotence">Idempotence in computer science</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Referential_transparency_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation journal">Søndergaard, Harald; Sestoft, Peter (1990). <a rel="nofollow" class="external text" href="http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf">"Referential transparency, definiteness and unfoldability"</a>. <i>Acta Informatica</i> <b>27</b> (6): 505–517. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2Fbf00277387">10.1007/bf00277387</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AReferential+transparency+%28computer+science%29&amp;rft.atitle=Referential+transparency%2C+definiteness+and+unfoldability&amp;rft.aufirst=Harald&amp;rft.aulast=S%C3%B8ndergaard&amp;rft.au=S%C3%B8ndergaard%2C+Harald&amp;rft.au=Sestoft%2C+Peter&amp;rft.date=1990&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.itu.dk%2Fpeople%2Fsestoft%2Fpapers%2FSondergaardSestoft1990.pdf&amp;rft_id=info%3Adoi%2F10.1007%2Fbf00277387&amp;rft.issue=6&amp;rft.jtitle=Acta+Informatica&amp;rft.pages=505-517&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=27" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li><span class="citation book">Davie, Antony (1992). <i>An Introduction to Functional Programming Systems Using Haskell</i>. New York: Cambridge University Press. p. 290. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-521-27724-8" title="Special:BookSources/0-521-27724-8">0-521-27724-8</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AReferential+transparency+%28computer+science%29&amp;rft.au=Davie%2C+Antony&amp;rft.aufirst=Antony&amp;rft.aulast=Davie&amp;rft.btitle=An+Introduction+to+Functional+Programming+Systems+Using+Haskell&amp;rft.date=1992&amp;rft.genre=book&amp;rft.isbn=0-521-27724-8&amp;rft.pages=290&amp;rft.place=New+York&amp;rft.pub=Cambridge+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
