<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Anti-unification (computer science)</span></h1>
<p><b>Anti-unification</b> is the process of constructing a generalization common to two given symbolic expressions. As in <a href="/wiki/Unification_(computer_science)" title="Unification (computer science)">unification</a>, several <b>frameworks</b> are distinguished depending on which expressions (also called terms) are allowed, and which expressions are considered equal. If variables representing functions are allowed in an expression, the process is called <b>higher-order anti-unification</b>, otherwise <b>first-order anti-unification</b>. If the generalization is required to have an instance literally equal to each input expression, the process is called <b>syntactical anti-unification</b>, otherwise <b>E-anti-unification</b>, or <b>anti-unification modulo theory</b>.</p>
<p>An anti-unification algorithm should compute for given expressions a <b>complete</b>, and <b>minimal</b> generalization set, that is, a set covering all generalizations, and containing no redundant members, respectively. Depending on the framework, a complete and minimal generalization set may have one, finitely many, or possibly infinitely many members, or may not exist at all;<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>note 1<span>]</span></a></sup> it cannot be empty, since a trivial generalization exists in any case. For first-order syntactical anti-unification, Plotkin<sup id="cite_ref-Plotkin.1970_2-0" class="reference"><a href="#cite_note-Plotkin.1970-2"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-Plotkin.1971_3-0" class="reference"><a href="#cite_note-Plotkin.1971-3"><span>[</span>2<span>]</span></a></sup> gave an algorithm that computes a complete and minimal singleton generalization set containing the so-called <b>least general generalization (lgg)</b>.</p>
<p>Anti-unification should not be confused with <i><a href="/wiki/Dis-unification_(computer_science)" title="Dis-unification (computer science)">dis-unification</a></i>. The latter means the process of solving systems of <a href="/wiki/Inequation" title="Inequation">inequations</a>, that is of finding values for the variables such that all given inequations are satisfied.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>note 2<span>]</span></a></sup> This task is quite different from finding generalizations.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Prerequisites"><span class="tocnumber">1</span> <span class="toctext">Prerequisites</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#First-order_term"><span class="tocnumber">1.1</span> <span class="toctext">First-order term</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Higher-order_term"><span class="tocnumber">1.2</span> <span class="toctext">Higher-order term</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Substitution"><span class="tocnumber">1.3</span> <span class="toctext">Substitution</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Generalization.2C_specialization"><span class="tocnumber">1.4</span> <span class="toctext">Generalization, specialization</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Anti-unification_problem.2C_generalization_set"><span class="tocnumber">1.5</span> <span class="toctext">Anti-unification problem, generalization set</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#First-order_syntactical_anti-unification"><span class="tocnumber">2</span> <span class="toctext">First-order syntactical anti-unification</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#First-order_anti-unification_modulo_theory"><span class="tocnumber">3</span> <span class="toctext">First-order anti-unification modulo theory</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Equational_theories"><span class="tocnumber">3.1</span> <span class="toctext">Equational theories</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#First-order_sorted_anti-unification"><span class="tocnumber">3.2</span> <span class="toctext">First-order sorted anti-unification</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Applications"><span class="tocnumber">3.3</span> <span class="toctext">Applications</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Anti-unification_of_trees_and_linguistic_applications"><span class="tocnumber">3.4</span> <span class="toctext">Anti-unification of trees and linguistic applications</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Higher-order_anti-unification"><span class="tocnumber">4</span> <span class="toctext">Higher-order anti-unification</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Notes"><span class="tocnumber">5</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#First-order_term"><span class="tocnumber">1.1</span> <span class="toctext">First-order term</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Higher-order_term"><span class="tocnumber">1.2</span> <span class="toctext">Higher-order term</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Substitution"><span class="tocnumber">1.3</span> <span class="toctext">Substitution</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Generalization.2C_specialization"><span class="tocnumber">1.4</span> <span class="toctext">Generalization, specialization</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Anti-unification_problem.2C_generalization_set"><span class="tocnumber">1.5</span> <span class="toctext">Anti-unification problem, generalization set</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Equational_theories"><span class="tocnumber">3.1</span> <span class="toctext">Equational theories</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#First-order_sorted_anti-unification"><span class="tocnumber">3.2</span> <span class="toctext">First-order sorted anti-unification</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Applications"><span class="tocnumber">3.3</span> <span class="toctext">Applications</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Anti-unification_of_trees_and_linguistic_applications"><span class="tocnumber">3.4</span> <span class="toctext">Anti-unification of trees and linguistic applications</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Prerequisites">Prerequisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Prerequisites">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Formally, an anti-unification approach presupposes</p>
<ul>
<li>An infinite set <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> of <b>variables</b>. For higher-order anti-unification, it is convenient to choose <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> disjoint from the set of <a href="/wiki/Lambda_term#Lambda_terms" title="Lambda term" class="mw-redirect">lambda-term bound variables</a>.</li>
<li>A set <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> of <b>terms</b> such that <img class="mwe-math-fallback-image-inline tex" alt="V \subseteq T" src="//upload.wikimedia.org/math/e/8/4/e8433fe6280a3b452dc07fe0dc6868cc.png">. For first-order and higher-order anti-unification, <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> is usually the set of <a href="/wiki/Term_(logic)" title="Term (logic)">first-order terms</a> (terms built from variable and function symbols) and <a href="/wiki/Lambda_term#Lambda_terms" title="Lambda term" class="mw-redirect">lambda terms</a> (terms containing some higher-order variables), respectively.</li>
<li>An <b><a href="/wiki/Equivalence_relation" title="Equivalence relation">equivalence relation</a></b> <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> on <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png">, indicating which terms are considered equal. For higher-order anti-unification, usually <img class="mwe-math-fallback-image-inline tex" alt="t \equiv u" src="//upload.wikimedia.org/math/d/a/6/da6b2240463cc4373f8463812e95722c.png"> if <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> and <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> are <a href="/wiki/Lambda_calculus#Alpha_equivalence" title="Lambda calculus">alpha equivalent</a>. For first-order E-anti-unification, <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> reflects the background knowledge about certain function symbols; for example, if <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> is considered commutative, <img class="mwe-math-fallback-image-inline tex" alt="t \equiv u" src="//upload.wikimedia.org/math/d/a/6/da6b2240463cc4373f8463812e95722c.png"> if <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> results from <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> by swapping the arguments of <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> at some (possibly all) occurrences.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>note 3<span>]</span></a></sup> If there is no background knowledge at all, then only literally, or syntactically, identical terms are considered equal.</li>
</ul>
<h3><span class="mw-headline" id="First-order_term">First-order term</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: First-order term">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Given a set <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> of variable symbols, a set <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> of constant symbols and sets <img class="mwe-math-fallback-image-inline tex" alt="F_n" src="//upload.wikimedia.org/math/3/c/5/3c55419967d78bff97d6a021132c947d.png"> of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-ary function symbols, also called operator symbols, for each natural number <img class="mwe-math-fallback-image-inline tex" alt="n \geq 1" src="//upload.wikimedia.org/math/f/e/3/fe37f48a6bb040c06c5e7ccaac63bc66.png">, the set of (unsorted first-order) terms <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> is <a href="/wiki/Recursive_definition" title="Recursive definition">recursively defined</a> to be the smallest set with the following properties:<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>3<span>]</span></a></sup></p>
<ul>
<li>every variable symbol is a term: <img class="mwe-math-fallback-image-inline tex" alt="V \subseteq T" src="//upload.wikimedia.org/math/e/8/4/e8433fe6280a3b452dc07fe0dc6868cc.png">,</li>
<li>every constant symbol is a term: <img class="mwe-math-fallback-image-inline tex" alt="C \subseteq T" src="//upload.wikimedia.org/math/c/d/e/cde56411715abd0105223384e50de7c7.png">,</li>
<li>from every <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> terms <img class="mwe-math-fallback-image-inline tex" alt="t_1,\ldots,t_n" src="//upload.wikimedia.org/math/9/9/8/998c7812117644c3d8f9e87da532300d.png">, and every <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-ary function symbol <img class="mwe-math-fallback-image-inline tex" alt="f \in F_n" src="//upload.wikimedia.org/math/2/e/6/2e6e8a954ca1de44559a6f813fd13ccb.png">, a larger term <img class="mwe-math-fallback-image-inline tex" alt="f(t_1,\ldots,t_n)" src="//upload.wikimedia.org/math/e/0/2/e0206846dd6f69f84a6f52dd0f0544b2.png"> can be built.</li>
</ul>
<p>For example, if <img class="mwe-math-fallback-image-inline tex" alt="x \in V" src="//upload.wikimedia.org/math/7/3/1/7311eadac874d3eb683dd147ce424084.png"> is a variable symbol, <img class="mwe-math-fallback-image-inline tex" alt="1 \in C" src="//upload.wikimedia.org/math/b/7/a/b7aad2384200fe272c634ff58688cf01.png"> is a constant symbol, and <img class="mwe-math-fallback-image-inline tex" alt="\textit{add} \in F_2" src="//upload.wikimedia.org/math/7/1/4/71456f843864f3a1a831e0ec7aebde4d.png"> is a binary function symbol, then <img class="mwe-math-fallback-image-inline tex" alt="x \in T" src="//upload.wikimedia.org/math/b/a/5/ba502c7721edfbe0fa14168da84b4f95.png">, <img class="mwe-math-fallback-image-inline tex" alt="1 \in T" src="//upload.wikimedia.org/math/3/5/3/353f48c338d1f96af2b05f044a95f14f.png">, and (hence) <img class="mwe-math-fallback-image-inline tex" alt="add(x,1) \in T" src="//upload.wikimedia.org/math/1/5/e/15e841f5ac6c07d88cbc558df3e308d2.png"> by the first, second, and third term building rule, respectively. The latter term is usually written as <img class="mwe-math-fallback-image-inline tex" alt="x+1" src="//upload.wikimedia.org/math/c/f/2/cf267a0bc414e4ea2681d6bd522a8992.png">, using <a href="/wiki/Infix_notation" title="Infix notation">Infix notation</a> and the more common operator symbol <img class="mwe-math-fallback-image-inline tex" alt="+" src="//upload.wikimedia.org/math/2/6/b/26b17225b626fb9238849fd60eabdf60.png"> for convenience.</p>
<h3><span class="mw-headline" id="Higher-order_term">Higher-order term</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Higher-order term">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h3><span class="mw-headline" id="Substitution">Substitution</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Substitution">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <b>substitution</b> is a mapping <img class="mwe-math-fallback-image-inline tex" alt="\sigma: V \longrightarrow T" src="//upload.wikimedia.org/math/5/7/d/57d1f0704273c8a61ab942ea4e37a47d.png"> from variables to terms; the notation <img class="mwe-math-fallback-image-inline tex" alt="\{x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \}" src="//upload.wikimedia.org/math/0/b/0/0b028006fb797692255f3923a8d6cdb2.png"> refers to a substitution mapping each variable <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> to the term <img class="mwe-math-fallback-image-inline tex" alt="t_i" src="//upload.wikimedia.org/math/a/5/7/a578f93d86a9111f5900e4681f14ce16.png">, for <img class="mwe-math-fallback-image-inline tex" alt="i=1,\ldots,k" src="//upload.wikimedia.org/math/5/7/4/57419b7c2597864a08a6bb014d96f34e.png">, and every other variable to itself. <b>Applying</b> that substitution to a term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is written in postfix notation as <img class="mwe-math-fallback-image-inline tex" alt="t \{x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \}" src="//upload.wikimedia.org/math/e/f/f/eff0b6db0294cee1b73f7a5765e1afc7.png">; it means to (simultaneously) replace every occurrence of each variable <img class="mwe-math-fallback-image-inline tex" alt="x_i" src="//upload.wikimedia.org/math/0/5/e/05e42209d67fe1eb15a055e9d3b3770e.png"> in the term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> by <img class="mwe-math-fallback-image-inline tex" alt="t_i" src="//upload.wikimedia.org/math/a/5/7/a578f93d86a9111f5900e4681f14ce16.png">. The result <img class="mwe-math-fallback-image-inline tex" alt="t \sigma" src="//upload.wikimedia.org/math/a/c/4/ac47b6b7b9231b57db987c4864aac0ba.png"> of applying a substitution <img class="mwe-math-fallback-image-inline tex" alt="\sigma" src="//upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png"> to a term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is called an <b>instance</b> of that term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">. As a first-order example, applying the substitution <img class="mwe-math-fallback-image-inline tex" alt="\{x \mapsto h(a,y), z \mapsto b\}" src="//upload.wikimedia.org/math/8/8/6/886c35117f6ba2cda6537803434348bb.png"> to the term</p>
<h3><span class="mw-headline" id="Generalization.2C_specialization">Generalization, specialization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Generalization, specialization">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If a term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> has an instance equivalent to a term <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png">, that is, if <img class="mwe-math-fallback-image-inline tex" alt="t \sigma \equiv u" src="//upload.wikimedia.org/math/3/7/c/37cdd6fdf283db60e78bff7fd80b783c.png"> for some substitution <img class="mwe-math-fallback-image-inline tex" alt="\sigma" src="//upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png">, then <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is called <b>more general</b> than <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png">, and <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> is called <b>more special</b> than, or <b>subsumed</b> by, <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">. For example, <img class="mwe-math-fallback-image-inline tex" alt="x \oplus a" src="//upload.wikimedia.org/math/1/b/0/1b0fad102859ccccd829cce737e7d04e.png"> is more general than <img class="mwe-math-fallback-image-inline tex" alt="a \oplus b" src="//upload.wikimedia.org/math/c/5/3/c53e6aad986d493168c51853f8c5a0cf.png"> if <img class="mwe-math-fallback-image-inline tex" alt="\oplus" src="//upload.wikimedia.org/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png"> is <a href="/wiki/Commutative_property" title="Commutative property">commutative</a>, since then <img class="mwe-math-fallback-image-inline tex" alt="(x \oplus a)\{x \mapsto b\} = b \oplus a \equiv a \oplus b" src="//upload.wikimedia.org/math/c/a/d/cad33a5fd4db345d936bd337e4687d65.png">.</p>
<p>If <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> is literal (syntactic) identity of terms, a term may be both more general and more special than another one only if both terms differ just in their variable names, not in their syntactic structure; such terms are called <b>variants</b>, or <b>renamings</b> of each other. For example, <img class="mwe-math-fallback-image-inline tex" alt="f(x_1,a,g(z_1),y_1)" src="//upload.wikimedia.org/math/6/d/9/6d9c6b5135b370893e3bd1623cd13593.png"> is a variant of <img class="mwe-math-fallback-image-inline tex" alt="f(x_2,a,g(z_2),y_2)" src="//upload.wikimedia.org/math/f/0/2/f023ff11390b5b9b626792465740d8d0.png">, since <img class="mwe-math-fallback-image-inline tex" alt="f(x_1,a,g(z_1),y_1) \{ x_1 \mapsto x_2, y_2 \mapsto y_2, z_1 \mapsto z_2\} = f(x_2,a,g(z_2),y_2)" src="//upload.wikimedia.org/math/f/e/c/feca855b3011424b56defea31bad3d65.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(x_2,a,g(z_2),y_2) \{x_1 \mapsto x_1, y_2 \mapsto y_1, z_2 \mapsto z_1\} = f(x_1,a,g(z_1),y_1)" src="//upload.wikimedia.org/math/f/1/2/f126065786ae534a3b5370ac531a4208.png">. However, <img class="mwe-math-fallback-image-inline tex" alt="f(x_1,a,g(z_1),y_1)" src="//upload.wikimedia.org/math/6/d/9/6d9c6b5135b370893e3bd1623cd13593.png"> is <i>not</i> a variant of <img class="mwe-math-fallback-image-inline tex" alt="f(x_2,a,g(x_2),x_2)" src="//upload.wikimedia.org/math/8/2/f/82f544077b272980e2763171ac188821.png">, since no substitution can transform the latter term into the former one. The latter term is therefor properly more special than the former one.</p>
<p>A substitution <img class="mwe-math-fallback-image-inline tex" alt="\sigma" src="//upload.wikimedia.org/math/9/d/4/9d43cb8bbcb702e9d5943de477f099e2.png"> is <b>more special</b> than, or <b>subsumed</b> by, a substitution <img class="mwe-math-fallback-image-inline tex" alt="\tau" src="//upload.wikimedia.org/math/8/1/a/81a69207104f00baaabd6f84cafd15a0.png"> if <img class="mwe-math-fallback-image-inline tex" alt="x \sigma" src="//upload.wikimedia.org/math/5/5/2/5520cb31db22446da765eed2126329ac.png"> is more special than <img class="mwe-math-fallback-image-inline tex" alt="x \tau" src="//upload.wikimedia.org/math/2/1/9/2192ee74eb9c04cecbb49e805ffaa809.png"> for each variable <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png">. For example, <img class="mwe-math-fallback-image-inline tex" alt="\{ x \mapsto f(u), y \mapsto f(f(u)) \}" src="//upload.wikimedia.org/math/e/4/5/e4581fd8ebed374000ce723d3cd04875.png"> is more special than <img class="mwe-math-fallback-image-inline tex" alt="\{ x \mapsto z, y \mapsto f(z) \}" src="//upload.wikimedia.org/math/9/1/c/91ce7e1f93870e1439e6ac0ed74e76b1.png">, since <img class="mwe-math-fallback-image-inline tex" alt="f(u)" src="//upload.wikimedia.org/math/f/2/c/f2c157202779c9a3de64999d015a2095.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(f(u)) " src="//upload.wikimedia.org/math/4/4/d/44d22bb02ba9debf29b8ca8791238d7e.png"> is more special than <img class="mwe-math-fallback-image-inline tex" alt="z" src="//upload.wikimedia.org/math/f/b/a/fbade9e36a3f36d3d676c1b808451dd7.png"> and <img class="mwe-math-fallback-image-inline tex" alt="f(z)" src="//upload.wikimedia.org/math/b/2/3/b23d8bcdb490736c53d5b677455a8cd2.png">, respectively.</p>
<h3><span class="mw-headline" id="Anti-unification_problem.2C_generalization_set">Anti-unification problem, generalization set</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Anti-unification problem, generalization set">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An <b>anti-unification problem</b> is a pair <img class="mwe-math-fallback-image-inline tex" alt="\langle t_1, t_2 \rangle" src="//upload.wikimedia.org/math/2/5/4/2549edeccbed7fb1be308fbfcab9245b.png"> of terms. A term <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is a common <b>generalization</b>, or <b>anti-unifier</b>, of <img class="mwe-math-fallback-image-inline tex" alt="t_1" src="//upload.wikimedia.org/math/7/3/6/7363212f8e5a9d7ace25c6991a33c6fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_2" src="//upload.wikimedia.org/math/9/7/4/974cb705b0c744f1855953c1086337df.png"> if <img class="mwe-math-fallback-image-inline tex" alt="t \sigma_1 \equiv t_1" src="//upload.wikimedia.org/math/4/a/6/4a684dfcc6d3957a6020801b202d3ad1.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t \sigma_2 \equiv t_2" src="//upload.wikimedia.org/math/5/4/0/540bc9e376a12a49b241d90fb11dc6fb.png"> for some substitutions <img class="mwe-math-fallback-image-inline tex" alt="\sigma_1, \sigma_2" src="//upload.wikimedia.org/math/c/3/d/c3d32e1872fcf054c549010f1a258f69.png">. For a given anti-unification problem, a set <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> of anti-unifiers is called <b>complete</b> if each generalization subsumes some term <img class="mwe-math-fallback-image-inline tex" alt="t \in S" src="//upload.wikimedia.org/math/5/9/1/5918191b19cc9305f145c76355763a8e.png">; the set <img class="mwe-math-fallback-image-inline tex" alt="S" src="//upload.wikimedia.org/math/5/d/b/5dbc98dcc983a70728bd082d1a47546e.png"> is called <b>minimal</b> if none of its members subsumes another one.</p>
<h2><span class="mw-headline" id="First-order_syntactical_anti-unification">First-order syntactical anti-unification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: First-order syntactical anti-unification">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The framework of first-order syntactical anti-unification is based on <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> being the set of <i>first-order terms</i> (over some given set <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> of variables, <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> of constants and <img class="mwe-math-fallback-image-inline tex" alt="F_n" src="//upload.wikimedia.org/math/3/c/5/3c55419967d78bff97d6a021132c947d.png"> of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-ary function symbols) and on <img class="mwe-math-fallback-image-inline tex" alt="\equiv" src="//upload.wikimedia.org/math/2/e/f/2ef0deb28c4bbc1ce6c11e4cce7e75b1.png"> being <i>syntactic equality</i>. In this framework, each anti-unification problem <img class="mwe-math-fallback-image-inline tex" alt="\langle t_1, t_2 \rangle" src="//upload.wikimedia.org/math/2/5/4/2549edeccbed7fb1be308fbfcab9245b.png"> has a complete, and obviously minimal, <a href="/wiki/Singleton_(mathematics)" title="Singleton (mathematics)">singleton</a> solution set <img class="mwe-math-fallback-image-inline tex" alt="\{t\}" src="//upload.wikimedia.org/math/6/c/d/6cdef036f26cfd308612361942a3a770.png">. Its member <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png"> is called the <b>least general generalization (lgg)</b> of the problem, it has an instance syntactically equal to <img class="mwe-math-fallback-image-inline tex" alt="t_1" src="//upload.wikimedia.org/math/7/3/6/7363212f8e5a9d7ace25c6991a33c6fe.png"> and another one syntactically equal to <img class="mwe-math-fallback-image-inline tex" alt="t_2" src="//upload.wikimedia.org/math/9/7/4/974cb705b0c744f1855953c1086337df.png">. Any common generalization of <img class="mwe-math-fallback-image-inline tex" alt="t_1" src="//upload.wikimedia.org/math/7/3/6/7363212f8e5a9d7ace25c6991a33c6fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="t_2" src="//upload.wikimedia.org/math/9/7/4/974cb705b0c744f1855953c1086337df.png"> subsumes <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">. The lgg is unique up to variants: if <img class="mwe-math-fallback-image-inline tex" alt="S_1" src="//upload.wikimedia.org/math/8/d/c/8dc4eef060814e559aff4c5fac3f51fe.png"> and <img class="mwe-math-fallback-image-inline tex" alt="S_2" src="//upload.wikimedia.org/math/9/7/a/97a6ae0695c4b2723ff5c8bccdb1e735.png"> are both complete and minimal solution sets of the same syntactical anti-unification problem, then <img class="mwe-math-fallback-image-inline tex" alt="S_1 = \{ s_1\}" src="//upload.wikimedia.org/math/2/7/2/2728067055d55145adbffbcb5bf5b038.png"> and <img class="mwe-math-fallback-image-inline tex" alt="S_2 = \{ s_2 \}" src="//upload.wikimedia.org/math/a/9/3/a939be32be1e88c6af09f7432a76e878.png"> for some terms <img class="mwe-math-fallback-image-inline tex" alt="s_1" src="//upload.wikimedia.org/math/0/3/2/032e388e2ab0ba83dd40c91e1f8d9c2f.png"> and <img class="mwe-math-fallback-image-inline tex" alt="s_2" src="//upload.wikimedia.org/math/3/3/6/336ac411515fbb2b61ec71e6bf2fba27.png">, that are <a href="/wiki/Term_(logic)#Structural_equality" title="Term (logic)">renamings</a> of each other.</p>
<p>Plotkin<sup id="cite_ref-Plotkin.1970_2-1" class="reference"><a href="#cite_note-Plotkin.1970-2"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-Plotkin.1971_3-1" class="reference"><a href="#cite_note-Plotkin.1971-3"><span>[</span>2<span>]</span></a></sup> has given an algorithm to compute the lgg of two given terms. It presupposes an <a href="/wiki/Injective_mapping" title="Injective mapping" class="mw-redirect">injective mapping</a> <img class="mwe-math-fallback-image-inline tex" alt="\phi: T \times T \longrightarrow V" src="//upload.wikimedia.org/math/d/6/9/d69dd6a42db672c4f510675326bb34fe.png">, that is, a mapping assigning each pair <img class="mwe-math-fallback-image-inline tex" alt="s,t" src="//upload.wikimedia.org/math/c/f/a/cfa32cfac3b0f2875f94c90cee520677.png"> of terms an own variable <img class="mwe-math-fallback-image-inline tex" alt="\phi(s,t)" src="//upload.wikimedia.org/math/0/a/0/0a0127324d053ee5b20f18e21046450d.png">, such that no two pairs share the same variable. <sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>note 4<span>]</span></a></sup> The algorithm consists of two rules:</p>
<p>For example, <img class="mwe-math-fallback-image-inline tex" alt="(0*0) \sqcup (4*4) \rightsquigarrow (0 \sqcup 4)*(0 \sqcup 4) \rightsquigarrow \phi(0,4) * \phi(0,4) \rightsquigarrow x*x" src="//upload.wikimedia.org/math/d/5/6/d56473955dca97b327e5027ef68f00f9.png">; this least general generalization reflects the common property of both inputs of being square numbers.</p>
<p>Plotkin used his algorithm to compute the "<a href="/wiki/Inductive_logic_programming#Example" title="Inductive logic programming">relative least general generalization (rlgg)</a>" of two clause sets in first-order logic, which was the basis of the <a href="/wiki/Golem_(ILP)" title="Golem (ILP)">Golem</a> approach to <a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">inductive logic programming</a>.</p>
<h2><span class="mw-headline" id="First-order_anti-unification_modulo_theory">First-order anti-unification modulo theory</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: First-order anti-unification modulo theory">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span id="CITEREFJacobson1991" class="citation">Jacobson, Erik (Jun 1991), <i>Unification and Anti-Unification</i>, Technical Report</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Erik&amp;rft.au=Jacobson%2C+Erik&amp;rft.aulast=Jacobson&amp;rft.btitle=Unification+and+Anti-Unification&amp;rft.date=Jun+1991&amp;rft.genre=book&amp;rft.series=Technical+Report&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span id="CITEREF.C3.98stvold2004" class="citation">Østvold, Bjarte M. (Apr 2004), <i>A Functional Reconstruction of Anti-Unification</i>, NR Note, DART/04/04, Norwegian Computing Center</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=%C3%98stvold%2C+Bjarte+M.&amp;rft.aufirst=Bjarte+M.&amp;rft.aulast=%C3%98stvold&amp;rft.btitle=A+Functional+Reconstruction+of+Anti-Unification&amp;rft.date=Apr+2004&amp;rft.genre=book&amp;rft.pub=Norwegian+Computing+Center&amp;rft.series=NR+Note&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=DART%2F04%2F04" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Boytcheva, Svetla; Markov, Zdravko (2002). "An Algorithm for Inducing Least Generalization Under Relative Implication".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=Boytcheva%2C+Svetla&amp;rft.aufirst=Svetla&amp;rft.aulast=Boytcheva&amp;rft.au=Markov%2C+Zdravko&amp;rft.btitle=An+Algorithm+for+Inducing+Least+Generalization+Under+Relative+Implication&amp;rft.date=2002&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Kutsia, Temur; Levy, Jordi; Villaret, Mateu (2014). <a rel="nofollow" class="external text" href="http://link.springer.com/content/pdf/10.1007%2Fs10817-013-9285-6.pdf">"Anti-Unification for Unranked Terms and Hedges"</a>. <i>Journal of Automated Reasoning</i> (Springer) <b>52</b> (2): 155–190. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2Fs10817-013-9285-6">10.1007/s10817-013-9285-6</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Anti-Unification+for+Unranked+Terms+and+Hedges&amp;rft.aufirst=Temur&amp;rft.au=Kutsia%2C+Temur&amp;rft.aulast=Kutsia&amp;rft.au=Levy%2C+Jordi&amp;rft.au=Villaret%2C+Mateu&amp;rft.date=2014&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flink.springer.com%2Fcontent%2Fpdf%2F10.1007%252Fs10817-013-9285-6.pdf&amp;rft_id=info%3Adoi%2F10.1007%2Fs10817-013-9285-6&amp;rft.issue=2&amp;rft.jtitle=Journal+of+Automated+Reasoning&amp;rft.pages=155-190&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=52" class="Z3988"><span style="display:none;"> </span></span> <a rel="nofollow" class="external text" href="http://www.risc.jku.at/projects/stout/software/antiunify.php">Software.</a></li>
</ul>
<h3><span class="mw-headline" id="Equational_theories">Equational theories</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: Equational theories">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li>One associative and commutative operation: <span id="CITEREFPottier1989" class="citation">Pottier, Loic (Feb 1989), <i>Algorithms des completion et generalisation en logic du premier ordre</i></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Loic&amp;rft.aulast=Pottier&amp;rft.au=Pottier%2C+Loic&amp;rft.btitle=Algorithms+des+completion+et+generalisation+en+logic+du+premier+ordre&amp;rft.date=Feb+1989&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>; <span id="CITEREFPottier1989" class="citation">Pottier, Loic (1989), <i>Generalisation de termes en theorie equationelle – Cas associatif-commutatif</i>, INRIA Report <b>1056</b>, INRIA</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Loic&amp;rft.aulast=Pottier&amp;rft.au=Pottier%2C+Loic&amp;rft.btitle=Generalisation+de+termes+en+theorie+equationelle+%E2%80%93+Cas+associatif-commutatif&amp;rft.date=1989&amp;rft.genre=book&amp;rft.pub=INRIA&amp;rft.series=INRIA+Report&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=1056" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Commutative theories: <span class="citation conference">Baader, Franz (1991). "Unification, Weak Unification, Upper Bound, Lower Bound, and Generalization Problems". "Proc. 4th Conf. on Rewriting Techniques and Applications (RTA)". LNCS <b>488</b>. Springer. pp. 86–91.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+4th+Conf.+on+Rewriting+Techniques+and+Applications+%28RTA%29&amp;rft.au=Baader%2C+Franz&amp;rft.aufirst=Franz&amp;rft.aulast=Baader&amp;rft.btitle=Unification%2C+Weak+Unification%2C+Upper+Bound%2C+Lower+Bound%2C+and+Generalization+Problems&amp;rft.date=1991&amp;rft.genre=bookitem&amp;rft.pages=86-91&amp;rft.pub=Springer&amp;rft.series=LNCS&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=488" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Free monoids: <span id="CITEREFBiere1993" class="citation">Biere, A. (1993), <a rel="nofollow" class="external text" href="http://fmv.jku.at/papers/Biere-Diploma-Thesis-1993.pdf"><i>Normalisierung, Unifikation und Antiunifikation in Freien Monoiden</i></a>, Univ. Karlsruhe, Germany</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=Biere%2C+A.&amp;rft.aufirst=A.&amp;rft.aulast=Biere&amp;rft.btitle=Normalisierung%2C+Unifikation+und+Antiunifikation+in+Freien+Monoiden&amp;rft.date=1993&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Ffmv.jku.at%2Fpapers%2FBiere-Diploma-Thesis-1993.pdf&amp;rft.pub=Univ.+Karlsruhe%2C+Germany&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Regular congruence classes: <span id="CITEREFHeinz1995" class="citation">Heinz, Birgit (Dec 1995), <i>Anti-Unifikation modulo Gleichungstheorie und deren Anwendung zur Lemmagenerierung</i>, GMD Berichte <b>261</b>, TU Berlin, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/3-486-23873-6" title="Special:BookSources/3-486-23873-6">3-486-23873-6</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Birgit&amp;rft.au=Heinz%2C+Birgit&amp;rft.aulast=Heinz&amp;rft.btitle=Anti-Unifikation+modulo+Gleichungstheorie+und+deren+Anwendung+zur+Lemmagenerierung&amp;rft.date=Dec+1995&amp;rft.genre=book&amp;rft.isbn=3-486-23873-6&amp;rft.pub=TU+Berlin&amp;rft.series=GMD+Berichte&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=261" class="Z3988"><span style="display:none;"> </span></span>; <span class="citation journal">Burghardt, Jochen (2005). <a rel="nofollow" class="external text" href="http://user.cs.tu-berlin.de/~jochen/aij05.pdf">"E-Generalization Using Grammars"</a>. <i>Artificial Intelligence Journal</i> (Elsevier) <b>165</b> (1): 1–35. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fj.artint.2005.01.008">10.1016/j.artint.2005.01.008</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=E-Generalization+Using+Grammars&amp;rft.au=Burghardt%2C+Jochen&amp;rft.aufirst=Jochen&amp;rft.aulast=Burghardt&amp;rft.date=2005&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fuser.cs.tu-berlin.de%2F~jochen%2Faij05.pdf&amp;rft_id=info%3Adoi%2F10.1016%2Fj.artint.2005.01.008&amp;rft.issue=1&amp;rft.jtitle=Artificial+Intelligence+Journal&amp;rft.pages=1-35&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=165" class="Z3988"><span style="display:none;"> </span></span></li>
<li>A-, C-, AC-, ACU-theories with ordered sorts: <span class="citation journal">Alpuente, Maria; Escobar, Santiago; Espert, Javier; Meseguer, Jose (2014). <a rel="nofollow" class="external text" href="https://www.ideals.illinois.edu/bitstream/handle/2142/25871/journal.pdf">"A modular order-sorted equational generalization algorithm"</a>. <i>Information and Computation</i> (Elsevier).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=A+modular+order-sorted+equational+generalization+algorithm&amp;rft.au=Alpuente%2C+Maria&amp;rft.au=Escobar%2C+Santiago&amp;rft.au=Espert%2C+Javier&amp;rft.aufirst=Maria&amp;rft.aulast=Alpuente&amp;rft.au=Meseguer%2C+Jose&amp;rft.date=2014&amp;rft.genre=article&amp;rft_id=https%3A%2F%2Fwww.ideals.illinois.edu%2Fbitstream%2Fhandle%2F2142%2F25871%2Fjournal.pdf&amp;rft.jtitle=Information+and+Computation&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h3><span class="mw-headline" id="First-order_sorted_anti-unification">First-order sorted anti-unification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: First-order sorted anti-unification">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li>Taxonomic sorts: <span class="citation journal">Frisch, Alan M.; Page, David (1990). "Generalisation with Taxonomic Information". <i>AAAI</i>: 755–761.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Generalisation+with+Taxonomic+Information&amp;rft.aufirst=Alan+M.&amp;rft.au=Frisch%2C+Alan+M.&amp;rft.aulast=Frisch&amp;rft.au=Page%2C+David&amp;rft.date=1990&amp;rft.genre=article&amp;rft.jtitle=AAAI&amp;rft.pages=755-761&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span>; <span class="citation conference">Frisch, Alan M.; Page Jr., C. David (1991). "Generalizing Atoms in Constraint Logic". "Proc. Conf. on Knowledge Representation".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+Conf.+on+Knowledge+Representation&amp;rft.aufirst=Alan+M.&amp;rft.au=Frisch%2C+Alan+M.&amp;rft.aulast=Frisch&amp;rft.au=Page+Jr.%2C+C.+David&amp;rft.btitle=Generalizing+Atoms+in+Constraint+Logic&amp;rft.date=1991&amp;rft.genre=bookitem&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>; <span class="citation conference">Frisch, A.M.; Page, C.D. (1995). "Building Theories into Instantiation". In Mellish, C.S. "Proc. 14th IJCAI". Morgan Kaufmann. pp. 1210–1216.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+14th+IJCAI&amp;rft.aufirst=A.M.&amp;rft.au=Frisch%2C+A.M.&amp;rft.aulast=Frisch&amp;rft.au=Page%2C+C.D.&amp;rft.btitle=Building+Theories+into+Instantiation&amp;rft.date=1995&amp;rft.genre=bookitem&amp;rft.pages=1210-1216&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Feature terms: <span class="citation conference">Plaza, E. (1995). "Cases as Terms: A Feature Term Approach to the Structured Representation of Cases". "Proc. 1st International Conference on Case-Based Reasoning (ICCBR)". LNCS <b>1010</b>. Springer. pp. 265–276. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0302-9743">0302-9743</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+1st+International+Conference+on+Case-Based+Reasoning+%28ICCBR%29&amp;rft.aufirst=E.&amp;rft.aulast=Plaza&amp;rft.au=Plaza%2C+E.&amp;rft.btitle=Cases+as+Terms%3A+A+Feature+Term+Approach+to+the+Structured+Representation+of+Cases&amp;rft.date=1995&amp;rft.genre=bookitem&amp;rft.issn=0302-9743&amp;rft.pages=265-276&amp;rft.pub=Springer&amp;rft.series=LNCS&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=1010" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation conference">Idestam-Almquist, Peter (Jun 1993). "Generalization under Implication by Recursive Anti-Unification". "Proc. 10th Conf. on Machine Learning". Morgan Kaufmann. pp. 151–158.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+10th+Conf.+on+Machine+Learning&amp;rft.aufirst=Peter&amp;rft.au=Idestam-Almquist%2C+Peter&amp;rft.aulast=Idestam-Almquist&amp;rft.btitle=Generalization+under+Implication+by+Recursive+Anti-Unification&amp;rft.date=Jun+1993&amp;rft.genre=bookitem&amp;rft.pages=151-158&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span id="CITEREFFischer1994" class="citation">Fischer, Cornelia (May 1994), <i>PAntUDE – An Anti-Unification Algorithm for Expressing Refined Generalizations</i>, Research Report, TM-94-04, DFKI</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Cornelia&amp;rft.au=Fischer%2C+Cornelia&amp;rft.aulast=Fischer&amp;rft.btitle=PAntUDE+%E2%80%93+An+Anti-Unification+Algorithm+for+Expressing+Refined+Generalizations&amp;rft.date=May+1994&amp;rft.genre=book&amp;rft.pub=DFKI&amp;rft.series=Research+Report&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=TM-94-04" class="Z3988"><span style="display:none;"> </span></span></li>
<li>A-, C-, AC-, ACU-theories with ordered sorts: <a href="#Equational_theories">see above</a></li>
</ul>
<h3><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li>Program analysis: <span class="citation journal">Bulychev, Peter; Minea, Marius (2008). "Duplicate Code Detection Using Anti-Unification".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=Bulychev%2C+Peter&amp;rft.aufirst=Peter&amp;rft.aulast=Bulychev&amp;rft.au=Minea%2C+Marius&amp;rft.btitle=Duplicate+Code+Detection+Using+Anti-Unification&amp;rft.date=2008&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>; <span class="citation journal">Bulychev, Peter E.; Kostylev, Egor V.; Zakharov, Vladimir A. (2009). "Anti-Unification Algorithms and their Applications in Program Analysis".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=Bulychev%2C+Peter+E.&amp;rft.aufirst=Peter+E.&amp;rft.au=Kostylev%2C+Egor+V.&amp;rft.aulast=Bulychev&amp;rft.au=Zakharov%2C+Vladimir+A.&amp;rft.btitle=Anti-Unification+Algorithms+and+their+Applications+in+Program+Analysis&amp;rft.date=2009&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Code factoring: <span id="CITEREFCottrell2008" class="citation">Cottrell, Rylan (Sep 2008), <i>Semi-automating Small-Scale Source Code Reuse via Structural Correspondence</i>, Univ. Calgary</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=Cottrell%2C+Rylan&amp;rft.aufirst=Rylan&amp;rft.aulast=Cottrell&amp;rft.btitle=Semi-automating+Small-Scale+Source+Code+Reuse+via+Structural+Correspondence&amp;rft.date=Sep+2008&amp;rft.genre=book&amp;rft.pub=Univ.+Calgary&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Induction proving: <span id="CITEREFHeinz1994" class="citation">Heinz, Birgit (1994), <i>Lemma Discovery by Anti-Unification of Regular Sorts</i>, Technical Report, 94-21, TU Berlin</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Birgit&amp;rft.au=Heinz%2C+Birgit&amp;rft.aulast=Heinz&amp;rft.btitle=Lemma+Discovery+by+Anti-Unification+of+Regular+Sorts&amp;rft.date=1994&amp;rft.genre=book&amp;rft.pub=TU+Berlin&amp;rft.series=Technical+Report&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=94-21" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Information Extraction: <span class="citation journal">Thomas, Bernd (1999). "Anti-Unification Based Learning of T-Wrappers for Information Extraction". <i>AAAI Technical Report</i>. WS-99-11: 15–20.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Anti-Unification+Based+Learning+of+T-Wrappers+for+Information+Extraction&amp;rft.aufirst=Bernd&amp;rft.aulast=Thomas&amp;rft.au=Thomas%2C+Bernd&amp;rft.date=1999&amp;rft.genre=article&amp;rft.jtitle=AAAI+Technical+Report&amp;rft.pages=15-20&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=WS-99-11" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Case-based reasoning: <span class="citation journal">Armengol, Eva; Plaza, Enric (2005). "Using Symbolic Descriptions to Explain Similarity on CBR".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=Armengol%2C+Eva&amp;rft.aufirst=Eva&amp;rft.aulast=Armengol&amp;rft.au=Plaza%2C+Enric&amp;rft.btitle=Using+Symbolic+Descriptions+to+Explain+Similarity+on+CBR&amp;rft.date=2005&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h3><span class="mw-headline" id="Anti-unification_of_trees_and_linguistic_applications">Anti-unification of trees and linguistic applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Anti-unification of trees and linguistic applications">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a href="/wiki/Parse_tree" title="Parse tree">Parse trees</a> for sentences can be subject to least general generalization to derive a maximal common sub-parse trees for language learning. There are applications in search and text classification.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>4<span>]</span></a></sup></li>
<li><a href="/wiki/Parse_thicket" title="Parse thicket" class="mw-redirect">Parse thickets</a> for paragraphs as graphs can be subject to least general generalization.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>5<span>]</span></a></sup></li>
<li>Operation of generalization commutes with the operation of transition from syntactic (parse trees) to semantic (symbolic expressions) level. The latter can then be subject to conventional anti-unification.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>6<span>]</span></a></sup><sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>7<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="Higher-order_anti-unification">Higher-order anti-unification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: Higher-order anti-unification">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>Calculus of constructions: <span class="citation conference">Pfenning, Frank (Jul 1991). <a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/~fp/papers/lics91.pdf">"Unification and Anti-Unification in the Calculus of Constructions"</a>. "Proc. 6th LICS". Springer. pp. 74–85.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+6th+LICS&amp;rft.aufirst=Frank&amp;rft.aulast=Pfenning&amp;rft.au=Pfenning%2C+Frank&amp;rft.btitle=Unification+and+Anti-Unification+in+the+Calculus+of+Constructions&amp;rft.date=Jul+1991&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cs.cmu.edu%2F~fp%2Fpapers%2Flics91.pdf&amp;rft.pages=74-85&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Simply-typed lambda calculus (Input: Terms in the eta-long beta-normal form. Output: higher-order patterns): Baumgartner, Alexander; Kutsia, Temur; Levy, Jordi; Villaret, Mateu (Jun 2013). <a rel="nofollow" class="external text" href="http://drops.dagstuhl.de/opus/volltexte/2013/4057/pdf/10.pdf">A Variant of Higher-Order Anti-Unification</a>. Proc. RTA 2013. Vol. 21 of LIPIcs. Schloss Dagstuhl, 113-127. <a rel="nofollow" class="external text" href="http://www.risc.jku.at/projects/stout/software/hoau.php">Software.</a></li>
<li>Restricted Higher-Order: <span id="CITEREFWagner2002" class="citation">Wagner, Ulrich (Apr 2002), <i>Combinatorically Restricted Higher Order Anti-Unification</i>, TU Berlin</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Ulrich&amp;rft.aulast=Wagner&amp;rft.au=Wagner%2C+Ulrich&amp;rft.btitle=Combinatorically+Restricted+Higher+Order+Anti-Unification&amp;rft.date=Apr+2002&amp;rft.genre=book&amp;rft.pub=TU+Berlin&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span>; <span id="CITEREFSchmidt2010" class="citation">Schmidt, Martin (Sep 2010), <i>Restricted Higher-Order Anti-Unification for Heuristic-Driven Theory Projection</i>, PICS-Report, 31-2010, Univ. Osnabrück, Germany, <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/1610-5389">1610-5389</a></span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.aufirst=Martin&amp;rft.aulast=Schmidt&amp;rft.au=Schmidt%2C+Martin&amp;rft.btitle=Restricted+Higher-Order+Anti-Unification+for+Heuristic-Driven+Theory+Projection&amp;rft.date=Sep+2010&amp;rft.genre=book&amp;rft.issn=1610-5389&amp;rft.pub=Univ.+Osnabr%C3%BCck%2C+Germany&amp;rft.series=PICS-Report&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=31-2010" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Complete generalization sets always exist, but it may be the case that every complete generalization set is non-minimal.</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Comon referred in 1986 to inequation-solving as "anti-unification", which nowadays has become quite unusual. <span class="citation conference">Comon, Hubert (1986). "Sufficient Completeness, Term Rewriting Systems and 'Anti-Unification<span style="padding-right:0.2em;">'</span>". "Proc. 8th International Conference on Automated Deduction". LNCS <b>230</b>. Springer. pp. 128–140.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Proc.+8th+International+Conference+on+Automated+Deduction&amp;rft.au=Comon%2C+Hubert&amp;rft.aufirst=Hubert&amp;rft.aulast=Comon&amp;rft.btitle=Sufficient+Completeness%2C+Term+Rewriting+Systems+and+%27Anti-Unification%27&amp;rft.date=1986&amp;rft.genre=bookitem&amp;rft.pages=128-140&amp;rft.pub=Springer&amp;rft.series=LNCS&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=230" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">E.g. <img class="mwe-math-fallback-image-inline tex" alt=" a \oplus (b \oplus f(x)) \equiv a \oplus (f(x) \oplus b) \equiv (b \oplus f(x)) \oplus a \equiv (f(x) \oplus b) \oplus a" src="//upload.wikimedia.org/math/d/b/e/dbe8bbe8ba01ecdcd892c8dd8eaaeab9.png"></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">From a theoretical viewpoint, such a mapping exists, since both <img class="mwe-math-fallback-image-inline tex" alt="V" src="//upload.wikimedia.org/math/5/2/0/5206560a306a2e085a437fd258eb57ce.png"> and <img class="mwe-math-fallback-image-inline tex" alt="T \times T" src="//upload.wikimedia.org/math/a/0/e/a0e8151da4d8c9d29908305f11749c4d.png"> are <a href="/wiki/Countably_infinite" title="Countably infinite" class="mw-redirect">countably infinite</a> sets; for practical purposes, <img class="mwe-math-fallback-image-inline tex" alt="\phi" src="//upload.wikimedia.org/math/7/f/2/7f20aa0b3691b496aec21cf356f63e04.png"> can be built up as needed, remembering assigned mappings <img class="mwe-math-fallback-image-inline tex" alt="\langle s,t,\phi(s,t) \rangle" src="//upload.wikimedia.org/math/3/0/a/30a537a6786e84a59c61261c8f1d292e.png"> in a <a href="/wiki/Hash_table" title="Hash table">hash table</a>.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Anti-unification_(computer_science)&amp;action=edit&amp;section=15" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-Plotkin.1970-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-Plotkin.1970_2-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Plotkin.1970_2-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Plotkin, Gordon D. (1970). Meltzer, B.; Michie, D., eds. "A Note on Inductive Generalization". <i>Machine Intelligence</i> (Edinburgh University Press) <b>5</b>: 153–163.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=A+Note+on+Inductive+Generalization&amp;rft.aufirst=Gordon+D.&amp;rft.aulast=Plotkin&amp;rft.au=Plotkin%2C+Gordon+D.&amp;rft.date=1970&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=153-163&amp;rft.pub=Edinburgh+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=5" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Plotkin.1971-3"><span class="mw-cite-backlink">^ <a href="#cite_ref-Plotkin.1971_3-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Plotkin.1971_3-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Plotkin, Gordon D. (1971). Meltzer, B.; Michie, D., eds. "A Further Note on Inductive Generalization". <i>Machine Intelligence</i> (Edinburgh University Press) <b>6</b>: 101–124.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=A+Further+Note+on+Inductive+Generalization&amp;rft.aufirst=Gordon+D.&amp;rft.aulast=Plotkin&amp;rft.au=Plotkin%2C+Gordon+D.&amp;rft.date=1971&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=101-124&amp;rft.pub=Edinburgh+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation book">C.C. Chang, H. Jerome Keisler (1977). A. Heyting and H.J. Keisler and A. Mostowski and A. Robinson and P. Suppes, ed. <i>Model Theory</i>. Studies in Logic and the Foundation of Mathematics <b>73</b>. North Holland.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.au=C.C.+Chang%2C+H.+Jerome+Keisler&amp;rft.aulast=C.C.+Chang%2C+H.+Jerome+Keisler&amp;rft.btitle=Model+Theory&amp;rft.date=1977&amp;rft.genre=book&amp;rft.pub=North+Holland&amp;rft.series=Studies+in+Logic+and+the+Foundation+of+Mathematics&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=73" class="Z3988"><span style="display:none;"> </span></span>; here: Sect.1.3</span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation journal">Boris Galitsky, Josep Lluís de la Rose, Gabor Dobrocsi (2011). "Mapping Syntactic to Semantic Generalizations of Linguistic Parse Trees". <i>FLAIRS Conference</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Mapping+Syntactic+to+Semantic+Generalizations+of+Linguistic+Parse+Trees&amp;rft.au=Boris+Galitsky%2C+Josep+Llu%C3%ADs+de+la+Rose%2C+Gabor+Dobrocsi&amp;rft.aulast=Boris+Galitsky%2C+Josep+Llu%C3%ADs+de+la+Rose%2C+Gabor+Dobrocsi&amp;rft.date=2011&amp;rft.genre=article&amp;rft.jtitle=FLAIRS+Conference&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><span class="citation journal">Boris Galitsky, Kuznetsov SO, Usikov DA (2013). "Parse Thicket Representation for Multi-sentence Search". <i>Lecture Notes in Computer Science</i> <b>7735</b>: 1072–1091. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F978-3-642-35786-2_12">10.1007/978-3-642-35786-2_12</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Parse+Thicket+Representation+for+Multi-sentence+Search&amp;rft.au=Boris+Galitsky%2C+Kuznetsov+SO%2C+Usikov+DA&amp;rft.aulast=Boris+Galitsky%2C+Kuznetsov+SO%2C+Usikov+DA&amp;rft.date=2013&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-642-35786-2_12&amp;rft.jtitle=Lecture+Notes+in+Computer+Science&amp;rft.pages=1072-1091&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=7735" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation journal">Boris Galitsky, Gabor Dobrocsi, Josep Lluís de la Rosa, Sergei O. Kuznetsov (2010). <a rel="nofollow" class="external text" href="http://link.springer.com/chapter/10.1007%2F978-3-642-14197-3_19">"From Generalization of Syntactic Parse Trees to Conceptual Graphs"</a>. <i>Lecture Notes in Computer Science</i> <b>6208</b>: 185–190. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F978-3-642-14197-3_19">10.1007/978-3-642-14197-3_19</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=From+Generalization+of+Syntactic+Parse+Trees+to+Conceptual+Graphs&amp;rft.au=Boris+Galitsky%2C+Gabor+Dobrocsi%2C+Josep+Llu%C3%ADs+de+la+Rosa%2C+Sergei+O.+Kuznetsov&amp;rft.aulast=Boris+Galitsky%2C+Gabor+Dobrocsi%2C+Josep+Llu%C3%ADs+de+la+Rosa%2C+Sergei+O.+Kuznetsov&amp;rft.date=2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flink.springer.com%2Fchapter%2F10.1007%252F978-3-642-14197-3_19&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-642-14197-3_19&amp;rft.jtitle=Lecture+Notes+in+Computer+Science&amp;rft.pages=185-190&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6208" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation journal">Boris Galitsky, de la Rosa JL, Dobrocsi G. (2012). "Inferring the semantic properties of sentences by mining syntactic parse trees". <i>Data &amp; Knowledge Engineering</i>. 81-82: 21–45. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fj.datak.2012.07.003">10.1016/j.datak.2012.07.003</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnti-unification+%28computer+science%29&amp;rft.atitle=Inferring+the+semantic+properties+of+sentences+by+mining+syntactic+parse+trees&amp;rft.au=Boris+Galitsky%2C+de+la+Rosa+JL%2C+Dobrocsi+G.&amp;rft.aulast=Boris+Galitsky%2C+de+la+Rosa+JL%2C+Dobrocsi+G.&amp;rft.date=2012&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2Fj.datak.2012.07.003&amp;rft.jtitle=Data+%26+Knowledge+Engineering&amp;rft.pages=21-45&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=81-82" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
