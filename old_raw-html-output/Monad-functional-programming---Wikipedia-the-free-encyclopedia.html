<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Monad (functional programming)</span></h1>
<p>In <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, a <b>monad</b> is a structure that represents <a href="/wiki/Computation" title="Computation">computations</a> defined as sequences of steps: a <a href="/wiki/Type_(computer_science)" title="Type (computer science)" class="mw-redirect">type</a> with a monad structure defines what it means to <a href="/wiki/Block_(programming)" title="Block (programming)">chain operations</a>, or nest <a href="/wiki/Function_(computer_science)" title="Function (computer science)" class="mw-redirect">functions</a> of that type together. This allows the programmer to build <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">pipelines</a> that process data in steps, in which each action is <a href="/wiki/Decorator_pattern" title="Decorator pattern">decorated</a> with additional processing rules provided by the monad.<sup id="cite_ref-RealWorldHaskell_1-0" class="reference"><a href="#cite_note-RealWorldHaskell-1"><span>[</span>1<span>]</span></a></sup> As such, monads have been described as "programmable semicolons"; a semicolon is the operator used to chain together individual <a href="/wiki/Statement_(computer_programming)" title="Statement (computer programming)" class="mw-redirect">statements</a> in many <a href="/wiki/Imperative_programming" title="Imperative programming">imperative programming</a> languages,<sup id="cite_ref-RealWorldHaskell_1-1" class="reference"><a href="#cite_note-RealWorldHaskell-1"><span>[</span>1<span>]</span></a></sup> thus the expression implies that extra code will be executed between the statements in the pipeline. Monads have also been explained with a <a href="/wiki/Physical_metaphor" title="Physical metaphor" class="mw-redirect">physical metaphor</a> as <a href="/wiki/Assembly_line" title="Assembly line">assembly lines</a>, where a conveyor belt transports data between functional units that transform it one step at a time.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> They can also be seen as a functional <a href="/wiki/Design_pattern" title="Design pattern">design pattern</a> to build <a href="/wiki/Parameterized_type" title="Parameterized type" class="mw-redirect">generic types</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p><a href="/wiki/Purely_functional" title="Purely functional">Purely functional</a> programs can use monads to structure procedures that include sequenced operations like those found in <a href="/wiki/Structured_programming" title="Structured programming">structured programming</a>.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> Many common programming concepts can be described in terms of a monad structure, including <a href="/wiki/Side_effect_(computer_science)" title="Side effect (computer science)">side effects</a> such as <a href="/wiki/Input/output" title="Input/output">input/output</a>, variable <a href="/wiki/Assignment_(computer_science)" title="Assignment (computer science)">assignment</a>, <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a>, <a href="/wiki/Parsing" title="Parsing">parsing</a>, <a href="/wiki/Nondeterministic_programming" title="Nondeterministic programming">nondeterminism</a>, <a href="/wiki/Concurrency_(computer_science)" title="Concurrency (computer science)">concurrency</a>, and <a href="/wiki/Continuation" title="Continuation">continuations</a>. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics. Languages like <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> provide monads in the standard core, allowing programmers to reuse large parts of their formal definition and apply in many different libraries the same interfaces for combining functions.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Description"><span class="tocnumber">1</span> <span class="toctext">Description</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#History"><span class="tocnumber">2</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Motivating_examples"><span class="tocnumber">3</span> <span class="toctext">Motivating examples</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#The_Maybe_monad"><span class="tocnumber">3.1</span> <span class="toctext">The Maybe monad</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#The_Writer_monad"><span class="tocnumber">3.2</span> <span class="toctext">The Writer monad</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#The_I.2FO_monad"><span class="tocnumber">3.3</span> <span class="toctext">The I/O monad</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Formal_definition"><span class="tocnumber">4</span> <span class="toctext">Formal definition</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Monad_laws"><span class="tocnumber">4.1</span> <span class="toctext">Monad laws</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#fmap_and_join"><span class="tocnumber">4.2</span> <span class="toctext">fmap and join</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Additive_monads"><span class="tocnumber">4.3</span> <span class="toctext">Additive monads </span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Syntactic_sugar:_do-notation"><span class="tocnumber">5</span> <span class="toctext">Syntactic sugar: do-notation </span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Generic_monadic_functions"><span class="tocnumber">6</span> <span class="toctext">Generic monadic functions</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Other_examples"><span class="tocnumber">7</span> <span class="toctext">Other examples</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Identity_monad"><span class="tocnumber">7.1</span> <span class="toctext">Identity monad</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Collections"><span class="tocnumber">7.2</span> <span class="toctext">Collections</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#State_monads"><span class="tocnumber">7.3</span> <span class="toctext">State monads</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Environment_monad"><span class="tocnumber">7.4</span> <span class="toctext">Environment monad</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Writer_monad"><span class="tocnumber">7.5</span> <span class="toctext">Writer monad</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Continuation_monad"><span class="tocnumber">7.6</span> <span class="toctext">Continuation monad</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Others"><span class="tocnumber">7.7</span> <span class="toctext">Others</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="#Free_monads"><span class="tocnumber">8</span> <span class="toctext">Free monads</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#Comonads"><span class="tocnumber">9</span> <span class="toctext">Comonads</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Identity_comonad"><span class="tocnumber">9.1</span> <span class="toctext">Identity comonad</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Product_comonad"><span class="tocnumber">9.2</span> <span class="toctext">Product comonad</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Function_comonad"><span class="tocnumber">9.3</span> <span class="toctext">Function comonad</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Costate_comonad"><span class="tocnumber">9.4</span> <span class="toctext">Costate comonad</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-27"><a href="#See_also"><span class="tocnumber">10</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-28"><a href="#Notes"><span class="tocnumber">11</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-29"><a href="#References"><span class="tocnumber">12</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="#External_links"><span class="tocnumber">13</span> <span class="toctext">External links</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#Haskell_monad_tutorials"><span class="tocnumber">13.1</span> <span class="toctext">Haskell monad tutorials</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Older_tutorials"><span class="tocnumber">13.1.1</span> <span class="toctext">Older tutorials</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Other_documentation"><span class="tocnumber">13.1.2</span> <span class="toctext">Other documentation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="#Scala_monad_tutorials"><span class="tocnumber">13.2</span> <span class="toctext">Scala monad tutorials</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Monads_in_other_languages"><span class="tocnumber">13.3</span> <span class="toctext">Monads in other languages</span></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#The_Maybe_monad"><span class="tocnumber">3.1</span> <span class="toctext">The Maybe monad</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#The_Writer_monad"><span class="tocnumber">3.2</span> <span class="toctext">The Writer monad</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#The_I.2FO_monad"><span class="tocnumber">3.3</span> <span class="toctext">The I/O monad</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Monad_laws"><span class="tocnumber">4.1</span> <span class="toctext">Monad laws</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#fmap_and_join"><span class="tocnumber">4.2</span> <span class="toctext">fmap and join</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Additive_monads"><span class="tocnumber">4.3</span> <span class="toctext">Additive monads </span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Identity_monad"><span class="tocnumber">7.1</span> <span class="toctext">Identity monad</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Collections"><span class="tocnumber">7.2</span> <span class="toctext">Collections</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#State_monads"><span class="tocnumber">7.3</span> <span class="toctext">State monads</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Environment_monad"><span class="tocnumber">7.4</span> <span class="toctext">Environment monad</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Writer_monad"><span class="tocnumber">7.5</span> <span class="toctext">Writer monad</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Continuation_monad"><span class="tocnumber">7.6</span> <span class="toctext">Continuation monad</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Others"><span class="tocnumber">7.7</span> <span class="toctext">Others</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Identity_comonad"><span class="tocnumber">9.1</span> <span class="toctext">Identity comonad</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Product_comonad"><span class="tocnumber">9.2</span> <span class="toctext">Product comonad</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Function_comonad"><span class="tocnumber">9.3</span> <span class="toctext">Function comonad</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Costate_comonad"><span class="tocnumber">9.4</span> <span class="toctext">Costate comonad</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#Haskell_monad_tutorials"><span class="tocnumber">13.1</span> <span class="toctext">Haskell monad tutorials</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Older_tutorials"><span class="tocnumber">13.1.1</span> <span class="toctext">Older tutorials</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Other_documentation"><span class="tocnumber">13.1.2</span> <span class="toctext">Other documentation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="#Scala_monad_tutorials"><span class="tocnumber">13.2</span> <span class="toctext">Scala monad tutorials</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Monads_in_other_languages"><span class="tocnumber">13.3</span> <span class="toctext">Monads in other languages</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Older_tutorials"><span class="tocnumber">13.1.1</span> <span class="toctext">Older tutorials</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Other_documentation"><span class="tocnumber">13.1.2</span> <span class="toctext">Other documentation</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Description">Description</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=1" title="Edit section: Description">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Formally, a monad consists of a <a href="/wiki/Type_constructor" title="Type constructor">type constructor</a> <i>M</i> and two operations, <i>bind</i> and <i>return</i> (where <i>return</i> is often also called <i>unit</i>):</p>
<ul>
<li>The <i>return</i> operation takes a value from a plain type and puts it into a monadic container using the constructor, creating a <i>monadic value</i>.</li>
<li>The <i>bind</i> operation performs the reverse process, extracting the original value from the container and passing it to the associated next function in the pipeline, possibly with additional checks and transformations.</li>
</ul>
<p>The operations must fulfill several properties to allow the correct composition of <i>monadic</i> functions (i.e. functions that use values from the monad as their arguments or return value). Because a monad can insert additional operations around a program's domain logic, monads can be considered a sort of <a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">aspect-oriented programming</a>.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> The <a href="/wiki/Domain_logic" title="Domain logic" class="mw-redirect">domain logic</a> can be defined by the application programmer in the pipeline, while required aside <a href="/wiki/Bookkeeping_code" title="Bookkeeping code" class="mw-redirect">bookkeeping</a> operations can be handled by a pre-defined monad built in advance.</p>
<p>The name and concept comes from the eponymous concept (<a href="/wiki/Monad_(category_theory)" title="Monad (category theory)">monad</a>) in <a href="/wiki/Category_theory" title="Category theory">category theory</a>, where monads are one particular kind of <a href="/wiki/Functor" title="Functor">functor</a>, a mapping between categories; although the term <i>monad</i> in functional programming contexts is usually used with a meaning corresponding to that of the term <i><a href="/wiki/Strong_monad" title="Strong monad">strong monad</a></i> in category theory.<sup id="cite_ref-moggi91_8-0" class="reference"><a href="#cite_note-moggi91-8"><span>[</span>8<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=2" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The concept of monad programming appeared in the 1980s in the programming language <a href="/wiki/Opal_programming_language" title="Opal programming language" class="mw-redirect">Opal</a> even though it was called "commands" and never formally specified.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2013)">citation needed</span></a></i>]</sup></p>
<p><a href="/wiki/Eugenio_Moggi" title="Eugenio Moggi">Eugenio Moggi</a> first described the general use of monads to structure programs in 1991.<sup id="cite_ref-moggi91_8-1" class="reference"><a href="#cite_note-moggi91-8"><span>[</span>8<span>]</span></a></sup> Several people built on his work, including programming language researchers <a href="/wiki/Philip_Wadler" title="Philip Wadler">Philip Wadler</a> and <a href="/wiki/Simon_Peyton_Jones" title="Simon Peyton Jones">Simon Peyton Jones</a> (both of whom were involved in the specification of <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>). Early versions of Haskell used a problematic "lazy list" model for I/O, and Haskell 1.3 introduced monads as a more flexible way to combine I/O with <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a>.</p>
<p>In addition to I/O, programming language researchers and Haskell library designers have successfully applied monads to topics including parsers and programming language interpreters. The concept of monads along with the Haskell do-notation for them has also been generalized to form <a href="/w/index.php?title=Applicative_functor&amp;action=edit&amp;redlink=1" class="new" title="Applicative functor (page does not exist)">applicative functors</a> and <a href="/wiki/Arrow_(computer_science)" title="Arrow (computer science)">arrows</a>.</p>
<p>For a long time, Haskell and its derivatives have been the only major users of monads in programming. There also exist formulations in <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>, <a href="/wiki/Perl" title="Perl">Perl</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, <a href="/wiki/Racket_(programming_language)" title="Racket (programming language)">Racket</a>, <a href="/wiki/Clojure" title="Clojure">Clojure</a> and <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a>, and monads have been an option in the design of a new <a href="/wiki/ML_(programming_language)" title="ML (programming language)">ML</a> standard. Recently <a href="/wiki/F_Sharp_(programming_language)" title="F Sharp (programming language)">F#</a> has included a feature called <a href="/wiki/Computation_expressions" title="Computation expressions" class="mw-redirect">computation expressions</a> or <i>workflows</i>, which are an attempt to introduce monadic constructs within a syntax more palatable to those programmers whose only prior experience has been with imperative languages.<sup id="cite_ref-seq_9-0" class="reference"><a href="#cite_note-seq-9"><span>[</span>9<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Motivating_examples">Motivating examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=3" title="Edit section: Motivating examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell programming language</a> is a functional language that makes heavy use of monads, and includes <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> to make monadic composition more convenient. All of the code samples in this article are written in <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> unless noted otherwise.</p>
<p>We demonstrate two common examples given when introducing monads: the <i>Maybe</i> monad and the <i>I/O</i> monad. Monads are of course not restricted to the Haskell language, though: the second set of examples shows the <i>Writer</i> monad in <a href="/wiki/JavaScript" title="JavaScript">JavaScript</a>.</p>
<h3><span class="mw-headline" id="The_Maybe_monad">The Maybe monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=4" title="Edit section: The Maybe monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Consider the <a href="/wiki/Option_type" title="Option type">option type</a> <i>Maybe a</i>, representing a value that is either a single value of type <i>a</i>, or no value at all. To distinguish these, we have two <a href="/wiki/Algebraic_data_type" title="Algebraic data type">algebraic data type</a> constructors: <code>Just t</code>, containing the value <code>t</code>, or <code>Nothing</code>, containing no value.</p>
<p>WHATSON? 5f743b1d-ffb4-41b6-a438-d9cde568cd45</p>
<pre class="de1">
<span class="kw1">data</span> <span class="kw4">Maybe</span> t <span class="sy0">=</span> Just t <span class="sy0">|</span> Nothing
</pre>
<p>We would like to be able to use this type as a simple sort of <a href="/wiki/Checked_exception" title="Checked exception" class="mw-redirect">checked exception</a>: at any point in a computation, the computation may fail, which causes the rest of the computation to be skipped and the final result to be <code>Nothing</code>. If all steps of the calculation succeed, the final result is <code>Just x</code> for some value <code>x</code>.</p>
<p>In the following example, <code>add</code> is a function that takes two arguments of type <i>Maybe Int</i>, and returns a result of the same type. If both <code>mx</code> and <code>my</code> have <code>Just</code> values, we want to return <code>Just</code> their sum; but if either <code>mx</code> or <code>my</code> is <code>Nothing</code>, we want to return <code>Nothing</code>. If we naively attempt to write functions with this kind of behavior, we'll end up with a nested series of "if <code>Nothing</code> then <code>Nothing</code> else do something with the <code>x</code> in <code>Just x</code>" cases that will quickly become unwieldy:<sup id="cite_ref-RealWorldHaskell_1-2" class="reference"><a href="#cite_note-RealWorldHaskell-1"><span>[</span>1<span>]</span></a></sup></p>
<p>WHATSON? 17a93efc-e8e3-4968-bdc9-51f37ced977c</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add mx my <span class="sy0">=</span>
  <span class="kw1">case</span> mx <span class="kw1">of</span>
    Nothing <span class="sy0">-&gt;</span> Nothing
    Just x  <span class="sy0">-&gt;</span> <span class="kw1">case</span> my <span class="kw1">of</span>
                 Nothing <span class="sy0">-&gt;</span> Nothing
                 Just y  <span class="sy0">-&gt;</span> Just <span class="br0">(</span>x <span class="sy0">+</span> y<span class="br0">)</span>
</pre>
<p>To alleviate this, we can define operations for chaining these computations together. The <i>bind</i> binary operator (<code>&gt;&gt;=</code>) chains the results of one computation that could fail, into a function that chooses another computation that could fail. If the first argument is <code>Nothing</code>, the second argument (the function) is ignored and the entire operation simply fails. If the first argument is <code>Just x</code>, we pass <code>x</code> to the function to get a new <i>Maybe</i> value, which may or may not result in a <code>Just</code> value.</p>
<p>WHATSON? f6b17a5f-8ef6-4f80-9649-5f672528139b</p>
<pre class="de1">
<span class="br0">(</span><span class="sy0">&gt;&gt;=</span><span class="br0">)</span> <span class="sy0">::</span> <span class="kw4">Maybe</span> a <span class="sy0">-&gt;</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> b
Nothing  <span class="sy0">&gt;&gt;=</span> _  <span class="sy0">=</span>  Nothing    <span class="co1">-- A failed computation returns Nothing</span>
<span class="br0">(</span>Just x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> f  <span class="sy0">=</span>  f x        <span class="co1">-- Applies function f to value x</span>
</pre>
<p>We already have a value constructor that returns a value without affecting the computation's additional state: <code>Just</code>.</p>
<p>WHATSON? 7899d737-accc-4120-9d43-5df79fd10d52</p>
<pre class="de1">
<span class="kw3">return</span> <span class="sy0">::</span> a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a
<span class="kw3">return</span> x <span class="sy0">=</span> Just x       <span class="co1">-- Wraps value x, returning a value of type (Maybe a)</span>
</pre>
<p>We can then write the example as:</p>
<p>WHATSON? 70f6b1c8-d2bd-4b32-9309-c8982c243545</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add mx my <span class="sy0">=</span>             <span class="co1">-- Adds two values of type (Maybe Int), where each input value can be Nothing</span>
  mx <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span>         <span class="co1">-- Extracts value x if mx is not Nothing</span>
    my <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>y <span class="sy0">-&gt;</span>       <span class="co1">-- Extracts value y if my is not Nothing</span>
      <span class="kw3">return</span> <span class="br0">(</span>x <span class="sy0">+</span> y<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>  <span class="co1">-- Wraps value (x+y), returning the sum as a value of type (Maybe Int)</span>
</pre>
<p>Using some additional <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> known as <a href="/wiki/Do-notation" title="Do-notation" class="mw-redirect">do-notation</a>, the example can be written as:</p>
<p>WHATSON? bfe2e5b8-6f81-4d45-9f14-c20cdb72690a</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add mx my <span class="sy0">=</span> <span class="kw1">do</span>
  x <span class="sy0">&lt;-</span> mx
  y <span class="sy0">&lt;-</span> my
  <span class="kw3">return</span> <span class="br0">(</span>x <span class="sy0">+</span> y<span class="br0">)</span>
</pre>
<p>Since this type of operation is quite common, there is a standard function in Haskell (<code>liftM2</code>) to take two monadic values (here: two Maybes) and combine their contents (two numbers) using another function (addition), making it possible to write the previous example as</p>
<p>WHATSON? 3cfd5dd5-131b-4163-b684-be4bfb2ca397</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add <span class="sy0">=</span> liftM2 <span class="br0">(</span><span class="sy0">+</span><span class="br0">)</span>
</pre>
<p>(Writing out the definition of liftM2 yields the code presented above in do-notation.)</p>
<h3><span class="mw-headline" id="The_Writer_monad">The Writer monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=5" title="Edit section: The Writer monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Writer monad allows a process to carry additional information "on the side", along with the computed value. This can be useful to log error or debugging information which is not the primary result.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup></p>
<p>The following example implements a Writer monad in Javascript:</p>
<p>First, a Writer monad is declared. Function <i>unit</i> creates a new value type from a basic type, with an empty log string attached to it; and <i>bind</i> applies a function to an old value, and returns the new result value with an expanded log. The <a href="/wiki/Bracket#Uses_of_.22.5B.22_and_.22.5D.22" title="Bracket">array brackets</a> work here as the monad's type constructor, creating a value of the monadic type for the Writer monad from simpler components (the value in position 0 of the array, and the log string in position 1).</p>
<p>WHATSON? 27185e95-276e-4e72-bd7e-e04375b5b95b</p>
<pre class="de1">
<span class="kw1">var</span> unit <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>value<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="br0">[</span>value<span class="sy0">,</span> <span class="st0">''</span><span class="br0">]</span> <span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>WHATSON? 5efd00f4-6bb4-40d3-bef7-5db4a2834441</p>
<pre class="de1">
<span class="kw1">var</span> bind <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>monadicValue<span class="sy0">,</span> transformWithLog<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">var</span> value  <span class="sy0">=</span> monadicValue<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span>
        log <span class="sy0">=</span> monadicValue<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">,</span>
        result <span class="sy0">=</span> transformWithLog<span class="br0">(</span>value<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="br0">[</span> result<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> log <span class="sy0">+</span> result<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p><i>pipeline</i> is an auxiliary function that concatenates a sequence of <i>bind</i>s applied to an array of functions.</p>
<p>WHATSON? 90e52566-f698-4039-a665-1f21c4734ca3</p>
<pre class="de1">
<span class="kw1">var</span> pipeline <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>monadicValue<span class="sy0">,</span> functions<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw1">var</span> key <span class="kw1">in</span> functions<span class="br0">)</span> <span class="br0">{</span>
        monadicValue <span class="sy0">=</span> bind<span class="br0">(</span>monadicValue<span class="sy0">,</span> functions<span class="br0">[</span>key<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> monadicValue<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>Examples of functions that return values of the type expected by the above Writer monad:</p>
<p>WHATSON? 69d6fa80-4fcd-4fb6-b091-f59eb16f4e2c</p>
<pre class="de1">
<span class="kw1">var</span> squared <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="br0">[</span>x <span class="sy0">*</span> x<span class="sy0">,</span> <span class="st0">'was squared.'</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
 
<span class="kw1">var</span> halved <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="br0">[</span>x <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="st0">'was halved.'</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>Finally, an example of using the monad to build a pipeline of mathematical functions with debug information on the side (that is, a string of debug information is concatenated, and returned with the result, as well):</p>
<p>WHATSON? 29680e06-a08a-4e54-8134-e9aecca02425</p>
<pre class="de1">
pipeline<span class="br0">(</span>unit<span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">,</span> <span class="br0">[</span>squared<span class="sy0">,</span> halved<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// [8, "was squared.was halved."]</span>
</pre>
<h3><span class="mw-headline" id="The_I.2FO_monad">The I/O monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=6" title="Edit section: The I/O monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a <a href="/wiki/Purely_functional" title="Purely functional">purely functional</a> language, such as Haskell, functions cannot have any externally visible side effects as part of the function semantics. Although a function cannot directly cause a side effect, it can construct a value <i>describing</i> a desired side effect, that the caller should apply at a convenient time.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> In the Haskell notation, a value of type <i>IO a</i> represents an action that, when performed, produces a value of type <i>a</i>.</p>
<p>We can think of a value of type <code>IO</code> as an <i>action</i> that takes as its argument the current state of the world, and will return a new world where the state has been changed according to the function's return value. For example, the functions <code>doesFileExist</code> and <code>removeFile</code> in the standard Haskell library have the following types</p>
<p>WHATSON? 1dc5d1c4-77bb-4b71-809d-3ca67c46b5a0</p>
<pre class="de1">
doesFileExist <span class="sy0">::</span> FilePath <span class="sy0">-&gt;</span> <span class="kw4">IO</span> <span class="kw4">Bool</span>
removeFile <span class="sy0">::</span> FilePath <span class="sy0">-&gt;</span> <span class="kw4">IO</span> <span class="br0">(</span><span class="br0">)</span>
</pre>
<p>So, one can think of <code>removeFile</code> as a function that, given a <code>FilePath</code>, returns an <code>IO</code> <i>action</i>; this action will ensure that the world, in this case the underlying file system, won't have a file named by that <code>FilePath</code> when it gets <i>executed</i>. Here, the <code>IO</code> internal value is of type <code>()</code> which means that the caller does not care about any other outcomes. On the other hand, in <code>doesFileExist</code>, the function returns an <code>IO</code> <i>action</i> which wraps a boolean value, <code>True</code> or <code>False</code>; this conceptually represents a new state of the world where the caller knows for certain whether that <code>FilePath</code> is present in the file system or not at the time of the <i>action</i> is performed. The state of the world managed in this way can be passed from action to action, thus defining a series of actions which will be applied in order as steps of state changes. This process is similar to how a <a href="/wiki/Temporal_logic" title="Temporal logic">temporal logic</a> represents the passage of time using only <a href="/wiki/Declarative_programming" title="Declarative programming">declarative</a> propositions. The following example clarifies in detail how this chaining of actions occurs in a program, again using Haskell.</p>
<p>We would like to be able to describe all of the basic types of I/O operations, e.g. write text to <a href="/wiki/Standard_output" title="Standard output" class="mw-redirect">standard output</a>, read text from standard input, read and write files, send data over networks, etc. In addition, we need to be able to compose these primitives to form larger programs. For example, we would like to be able to write:</p>
<p>WHATSON? ae48ee73-80d6-4a7f-99de-1ee06625f3bf</p>
<pre class="de1">
main <span class="sy0">::</span> <span class="kw4">IO</span> <span class="br0">(</span><span class="br0">)</span>
main <span class="sy0">=</span> <span class="kw1">do</span>
  <span class="kw3">putStrLn</span> <span class="st0">"What is your name?"</span>
  name <span class="sy0">&lt;-</span> <span class="kw3">getLine</span>
  <span class="kw3">putStrLn</span> <span class="br0">(</span><span class="st0">"Nice to meet you, "</span> <span class="sy0">++</span> name <span class="sy0">++</span> <span class="st0">"!"</span><span class="br0">)</span>
</pre>
<p>How can we formalize this intuitive notation? To do this, we need to be able to perform some basic operations with I/O actions:</p>
<ul>
<li>We should be able to sequence two I/O operations together. In Haskell, this is written as an infix operator <code>&gt;&gt;</code>, so that <code>putStrLn "abc" &gt;&gt; putStrLn "def"</code> is an I/O action that prints two lines of text to the console. The type of <code>&gt;&gt;</code> is <i>IO a → IO b → IO b</i>, meaning that the operator takes two I/O operations and returns a third that sequences the two together and returns the value of the second.</li>
<li>We should have an I/O action which does <i>nothing</i>. That is, it returns a value but has no side effects. In Haskell, this action constructor is called <code>return</code>; it has type <i>a → IO a</i>.</li>
<li>More subtly, we should be able to determine our next action based on the results of previous actions. To do this, Haskell has an operator <code>&gt;&gt;=</code> (pronounced <i>bind</i>) with type <i>IO a → (a → IO b) → IO b</i>. That is, the operand on the left is an I/O action that returns a value of type <code>a</code>; the operand on the right is a function that can pick an I/O action based on the value produced by the action on the left. The resulting combined action, when performed, performs the first action, then evaluates the function with the first action's return value, then performs the second action, and finally returns the second action's value.</li>
</ul>
<p>It is not necessarily obvious that the three preceding operations, along with a suitable primitive set of I/O operations, allow us to define <i>any program action whatsoever</i>, including data transformations (using <a href="/wiki/Lambda_expressions" title="Lambda expressions" class="mw-redirect">lambda expressions</a>), if/then control flow, and looping control flows (using recursion). We can write the above example as one long expression:</p>
<p>WHATSON? 5ad06536-02df-496b-9227-25e234d761fa</p>
<pre class="de1">
main <span class="sy0">=</span>
  <span class="kw3">putStrLn</span> <span class="st0">"What is your name?"</span> <span class="sy0">&gt;&gt;</span> 
  <span class="kw3">getLine</span> <span class="sy0">&gt;&gt;=</span> <span class="sy0">\</span>name <span class="sy0">-&gt;</span>
  <span class="kw3">putStrLn</span> <span class="br0">(</span><span class="st0">"Nice to meet you, "</span> <span class="sy0">++</span> name <span class="sy0">++</span> <span class="st0">"!"</span><span class="br0">)</span>
</pre>
<p>The pipeline structure of the <i>bind</i> operator ensures that the <i>getLine</i> and <i>putStrLn</i> operations get evaluated only once and in the given order, so that the side-effects of extracting text from the input stream and writing to the output stream are correctly handled in the functional pipeline. This remains true even if the language performs <a href="/wiki/Out-of-order_execution" title="Out-of-order execution">out-of-order</a> or <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a> of functions.</p>
<p>Clearly, there is some common structure between the I/O definitions and the Maybe definitions, even though they are different in many ways. Monads are an abstraction upon the structures described above, and many similar structures, that finds and exploits the commonalities. The general monad concept includes any situation where the programmer wants to carry out a purely functional computation while a related computation is carried out on the side.</p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=7" title="Edit section: Formal definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A monad is a construction that, given an underlying <a href="/wiki/Type_system" title="Type system">type system</a>, embeds a corresponding type system (called the <i>monadic type system</i>) into it (that is, each monadic type acts as the underlying type). This monadic type system preserves all significant aspects of the underlying type system, while adding features particular to the monad.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>a<span>]</span></a></sup></p>
<p>The usual formulation of a monad for programming is known as a <a href="/wiki/Kleisli_triple" title="Kleisli triple" class="mw-redirect">Kleisli triple</a>, and has the following components:</p>
<ol>
<li>A <i>type constructor</i> that defines, for every underlying type, how to obtain a corresponding monadic type. In Haskell's notation, the name of the monad represents the type constructor. If <i>M</i> is the name of the monad and <i>t</i> is a data type, then <i>M t</i> is the corresponding type in the monad.</li>
<li>A <i>unit function</i> that maps a value in an underlying type to a value in the corresponding monadic type. The unit function has the polymorphic type <i>t→M t</i>. The result is normally the "simplest" value in the corresponding type that completely preserves the original value (simplicity being understood appropriately to the monad). In Haskell, this function is called <code>return</code> due to the way it is used in the do-notation described later.</li>
<li>A <i>binding operation</i> of polymorphic type <i>(M t)→(t→M u)→(M u)</i>, which Haskell represents by the <a href="/wiki/Infix_notation" title="Infix notation">infix</a> operator <code>&gt;&gt;=</code>. Its first argument is a value in a monadic type, its second argument is a function that maps from the underlying type of the first argument to another monadic type, and its result is in that other monadic type. Typically, the binding operation can be understood as having four stages:
<ol>
<li>The monad-related structure on the first argument is "pierced" to expose any number of values in the underlying type t.</li>
<li>The given function is applied to all of those values to obtain values of type (M u).</li>
<li>The monad-related structure on those values is also pierced, exposing values of type u.</li>
<li>Finally, the monad-related structure is reassembled over all of the results, giving a single value of type (M u).</li>
</ol>
</li>
</ol>
<ol>
<li>The monad-related structure on the first argument is "pierced" to expose any number of values in the underlying type t.</li>
<li>The given function is applied to all of those values to obtain values of type (M u).</li>
<li>The monad-related structure on those values is also pierced, exposing values of type u.</li>
<li>Finally, the monad-related structure is reassembled over all of the results, giving a single value of type (M u).</li>
</ol>
<p>Given a type constructor <i>M</i>, in most contexts, a value of type <i>M a</i> can be thought of as an action that returns a value of type <i>a</i>. The <i>return</i> operation takes a value from a plain type <i>a</i> and puts it into a monadic container of type <i>M a</i>; the <i>bind</i> operation chains a monadic value of type <i>M a</i> with a function of type <i>a → M b</i> to create a monadic value of type <i>M b</i>.</p>
<h3><span class="mw-headline" id="Monad_laws">Monad laws</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=8" title="Edit section: Monad laws">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>For a monad to behave correctly, the definitions must obey a few axioms, together called the monad laws.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>12<span>]</span></a></sup> The ≡ symbol indicates equivalence between two Haskell expressions in the following text.</p>
<ul>
<li><i>return</i> acts approximately as a <a href="/wiki/Neutral_element" title="Neutral element" class="mw-redirect">neutral element</a> of <tt>&gt;&gt;=</tt>, in that:
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span><span class="kw3">return</span> x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> f   ≡   f x</span></li>
<li><span class="mw-geshi haskell source-haskell">m <span class="sy0">&gt;&gt;=</span> <span class="kw3">return</span>   ≡   m</span></li>
</ul>
</li>
<li>Binding two functions in succession is the same as binding one function that can be determined from them:
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span>m <span class="sy0">&gt;&gt;=</span> f<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> g   ≡   m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span> <span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">(</span>f x <span class="sy0">&gt;&gt;=</span> g<span class="br0">)</span> <span class="br0">)</span></span></li>
</ul>
</li>
</ul>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span><span class="kw3">return</span> x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> f   ≡   f x</span></li>
<li><span class="mw-geshi haskell source-haskell">m <span class="sy0">&gt;&gt;=</span> <span class="kw3">return</span>   ≡   m</span></li>
</ul>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span>m <span class="sy0">&gt;&gt;=</span> f<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> g   ≡   m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span> <span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">(</span>f x <span class="sy0">&gt;&gt;=</span> g<span class="br0">)</span> <span class="br0">)</span></span></li>
</ul>
<p>The axioms can also be expressed using expressions in <a href="#do-notation">do-block style</a>:</p>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="kw1">do</span> <span class="br0">{</span> f x <span class="br0">}</span>   ≡   <span class="kw1">do</span> <span class="br0">{</span> v <span class="sy0">&lt;-</span> <span class="kw3">return</span> x; f v <span class="br0">}</span></span></li>
<li><span class="mw-geshi haskell source-haskell"><span class="kw1">do</span> <span class="br0">{</span> m <span class="br0">}</span>   ≡   <span class="kw1">do</span> <span class="br0">{</span> v <span class="sy0">&lt;-</span> m; <span class="kw3">return</span> v <span class="br0">}</span></span></li>
<li><span class="mw-geshi haskell source-haskell"><span class="kw1">do</span> <span class="br0">{</span> x <span class="sy0">&lt;-</span> m; y <span class="sy0">&lt;-</span> f x; g y <span class="br0">}</span>   ≡   <span class="kw1">do</span> <span class="br0">{</span> y <span class="sy0">&lt;-</span> <span class="kw1">do</span> <span class="br0">{</span> x <span class="sy0">&lt;-</span> m; f x <span class="br0">}</span>; g y <span class="br0">}</span></span></li>
</ul>
<p>or using the monadic composition operator, <span class="mw-geshi haskell source-haskell"><span class="br0">(</span>f <span class="sy0">&gt;=&gt;</span> g<span class="br0">)</span> x <span class="sy0">=</span> <span class="br0">(</span>f x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> g</span>:</p>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="kw3">return</span> <span class="sy0">&gt;=&gt;</span> g   ≡   g</span></li>
<li><span class="mw-geshi haskell source-haskell">f <span class="sy0">&gt;=&gt;</span> <span class="kw3">return</span>   ≡   f</span></li>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span>f <span class="sy0">&gt;=&gt;</span> g<span class="br0">)</span> <span class="sy0">&gt;=&gt;</span> h   ≡   f <span class="sy0">&gt;=&gt;</span> <span class="br0">(</span>g <span class="sy0">&gt;=&gt;</span> h<span class="br0">)</span></span></li>
</ul>
<h3><span class="mw-headline" id="fmap_and_join">fmap and join</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=9" title="Edit section: fmap and join">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Although Haskell defines monads in terms of the <i>return</i> and <i>bind</i> functions, it is also possible to define a monad in terms of <i>return</i> and two other operations, <i>join</i> and <i>fmap</i>. This formulation fits more closely with the original definition of monads in category theory. The <i>fmap</i> operation, with type (<i>t</i>→<i>u</i>) → M <i>t</i>→M <i>u</i>,<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>13<span>]</span></a></sup> takes a function between two types and produces a function that does the "same thing" to values in the monad. The <i>join</i> operation, with type M (M <i>t</i>)→M <i>t</i>, "flattens" two layers of monadic information into one.</p>
<p>The two formulations are related as follows:</p>
<p>WHATSON? 3531692b-65e4-405d-9fd0-c6925e9724a3</p>
<pre class="de1">
<span class="kw3">fmap</span> f m <span class="sy0">=</span> m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="kw3">return</span> . f<span class="br0">)</span>
join n <span class="sy0">=</span> n <span class="sy0">&gt;&gt;=</span> <span class="kw3">id</span>
 
m <span class="sy0">&gt;&gt;=</span> g   ≡   join <span class="br0">(</span><span class="kw3">fmap</span> g m<span class="br0">)</span>
</pre>
<p>Here, m has the type M <i>t</i>, n has the type M (M <i>r</i>), f has the type <i>t</i> → <i>u</i>, and g has the type t → M <i>v</i>, where <i>t</i>, <i>r</i>, <i>u</i> and <i>v</i> are underlying types.</p>
<p>The fmap function is defined for any <a href="/wiki/Functor" title="Functor">functor</a> in the category of types and functions, not just for monads. It is expected to satisfy the functor laws:</p>
<p>WHATSON? bf9e0a5a-4a88-49d5-979f-84e5d70bafd4</p>
<pre class="de1">
<span class="kw3">fmap</span> <span class="kw3">id</span>   ≡   <span class="kw3">id</span>
<span class="kw3">fmap</span> <span class="br0">(</span>f . g<span class="br0">)</span>   ≡   <span class="br0">(</span><span class="kw3">fmap</span> f<span class="br0">)</span> . <span class="br0">(</span><span class="kw3">fmap</span> g<span class="br0">)</span>
</pre>
<p>The <i>return</i> function characterizes <a href="/w/index.php?title=Pointed_functor&amp;action=edit&amp;redlink=1" class="new" title="Pointed functor (page does not exist)">pointed functors</a> in the same category, by accounting for the ability to "lift" values into the functor. It should satisfy the following law:</p>
<p>WHATSON? 09b816b4-993b-4787-89cc-cff43c085a64</p>
<pre class="de1">
<span class="kw3">return</span> . f ≡ <span class="kw3">fmap</span> f . <span class="kw3">return</span>
</pre>
<p>In addition, the <i>join</i> function characterizes monads:</p>
<p>WHATSON? 360c42f6-94a4-4e6b-87f3-593fefc5af53</p>
<pre class="de1">
join . <span class="kw3">fmap</span> join     ≡ join . join
join . <span class="kw3">fmap</span> <span class="kw3">return</span>   ≡ join . <span class="kw3">return</span> <span class="sy0">=</span> <span class="kw3">id</span>
join . <span class="kw3">fmap</span> <span class="br0">(</span><span class="kw3">fmap</span> f<span class="br0">)</span> ≡ <span class="kw3">fmap</span> f . join
</pre>
<h3><span class="mw-headline" id="Additive_monads">Additive monads <span id="Additive_monad"></span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=10" title="Edit section: Additive monads">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An <b>additive monad</b> is a monad endowed with a monadic zero <i>mzero</i> and a binary operator <i>mplus</i> satisfying the <a href="/wiki/Monoid" title="Monoid">monoid</a> laws, with the monadic zero as unit. The operator <i>mplus</i> has type <i>M t</i> → <i>M t</i> → <i>M t</i> (where <i>M</i> is the monad constructor and <i>t</i> is the underlying data type), satisfies the <a href="/wiki/Associative_law" title="Associative law" class="mw-redirect">associative law</a> and has the zero as both left and right identity. That is:</p>
<p>WHATSON? cc26fda7-2691-4efb-bffa-46d9ccca7096</p>
<pre class="de1">
<span class="br0">(</span>a `mplus` b<span class="br0">)</span> `mplus` c   <span class="sy0">=</span>   a `mplus` <span class="br0">(</span>b `mplus c`<span class="br0">)</span>
m `mplus` mzero           ≡   mzero `mplus` m           ≡    m
</pre>
<p>Thus, an additive monad is also a monoid. For &gt;&gt;=, on the other hand, mzero acts as a null-element. Just as multiplying a number by 0 results in 0, binding <i>mzero</i> with any function produces the zero for the result type:</p>
<p>WHATSON? 60415afe-d762-427a-8f68-af07121cb1f5</p>
<pre class="de1">
mzero <span class="sy0">&gt;&gt;=</span> f               ≡   mzero
</pre>
<p>Similarly, binding any <i>m</i> with a function that always returns a zero results in a zero</p>
<p>WHATSON? 322bc8a3-d194-42d2-bf8d-8de20153ffb5</p>
<pre class="de1">
m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> mzero<span class="br0">)</span>       ≡   mzero
</pre>
<p>Intuitively, the zero represents a value in the monad that has only monad-related structure and no values from the underlying type. In the Maybe monad, "Nothing" is a zero. In the List monad, "[]" (the empty list) is a zero.</p>
<h2><span class="mw-headline" id="Syntactic_sugar:_do-notation">Syntactic sugar: <code>do</code>-notation <span id="do-notation"></span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=11" title="Edit section: Syntactic sugar: do-notation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Although there are times when it makes sense to use the <i>bind</i> operator <code>&gt;&gt;=</code> directly in a program, it is more typical to use a format called <i>do-notation</i> (<i>perform-notation</i> in <a href="/wiki/OCaml" title="OCaml">OCaml</a>, <i>computation expressions</i> in <a href="/wiki/F_Sharp_(programming_language)" title="F Sharp (programming language)">F#</a>), that mimics the appearance of imperative languages. The compiler translates do-notation to expressions involving <code>&gt;&gt;=</code>. For example, the following code:</p>
<p>WHATSON? ca625a3e-5000-4c7a-bb87-11c43cff1e7f</p>
<pre class="de1">
a <span class="sy0">=</span> <span class="kw1">do</span> x <span class="sy0">&lt;-</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span>
       <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span>
       <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span>
</pre>
<p>is transformed during compilation into:</p>
<p>WHATSON? 3f552f77-327b-4f43-a168-bd3f5014c072</p>
<pre class="de1">
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>It is helpful to see the implementation of the list monad, and to know that concatMap maps a function over a list and concatenates (flattens) the resulting lists:</p>
<p>WHATSON? fcc59236-7307-4b0f-9aef-0dd079d11613</p>
<pre class="de1">
<span class="kw1">instance</span> <span class="kw5">Monad</span> <span class="br0">[</span><span class="br0">]</span> <span class="kw1">where</span>
  m <span class="sy0">&gt;&gt;=</span> f  <span class="sy0">=</span> <span class="kw3">concat</span> <span class="br0">(</span><span class="kw3">map</span> f m<span class="br0">)</span>
  <span class="kw3">return</span> x <span class="sy0">=</span> <span class="br0">[</span>x<span class="br0">]</span>
  <span class="kw3">fail</span> s   <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
</pre>
<p>Therefore, the following transformations hold and all the following expressions are equivalent:</p>
<p>WHATSON? 29a11b2e-a541-417b-997c-e6c185ad7a0d</p>
<pre class="de1">
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="kw3">concatMap</span> <span class="br0">(</span><span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span> <span class="br0">)</span>
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span><span class="br0">]</span> <span class="br0">)</span>
a <span class="sy0">=</span> <span class="kw3">concatMap</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span><span class="br0">]</span> <span class="br0">)</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span>
a <span class="sy0">=</span> <span class="br0">[</span><span class="br0">(</span><span class="nu0">3</span>,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span><span class="nu0">3</span>,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span><span class="nu0">4</span>,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span><span class="nu0">4</span>,<span class="nu0">42</span><span class="br0">)</span><span class="br0">]</span>
</pre>
<p>Notice that the list <tt>[1..2]</tt> is not used. The lack of a left-pointing arrow, translated into a binding to a function that ignores its argument, indicates that only the monadic structure is of interest, not the values inside it, e.g. for a state monad this might be used for changing the state without producing any more result values. The do-block notation can be used with any monad as it is simply syntactic sugar for <code>&gt;&gt;=</code>.</p>
<p>The following definitions for safe division for values in the Maybe monad are also equivalent:</p>
<p>WHATSON? 84732e51-1e3b-4644-b8e5-9f525b0fba98</p>
<pre class="de1">
x <span class="sy0">//</span> y <span class="sy0">=</span> <span class="kw1">do</span>
  a <span class="sy0">&lt;-</span> x  <span class="co1">-- Extract the values "inside" x and y, if there are any.</span>
  b <span class="sy0">&lt;-</span> y
  <span class="kw1">if</span> b <span class="sy0">==</span> <span class="nu0">0</span> <span class="kw1">then</span> Nothing <span class="kw1">else</span> Just <span class="br0">(</span>a <span class="sy0">/</span> b<span class="br0">)</span>
 
x <span class="sy0">//</span> y <span class="sy0">=</span> x <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>a <span class="sy0">-&gt;</span> y <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>b <span class="sy0">-&gt;</span> <span class="kw1">if</span> b <span class="sy0">==</span> <span class="nu0">0</span> <span class="kw1">then</span> Nothing <span class="kw1">else</span> Just <span class="br0">(</span>a <span class="sy0">/</span> b<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>A similar example in F# using a computation expression:</p>
<p>WHATSON? 7ec65f56-136b-4a27-b9fe-01dbc5b83d62</p>
<pre class="de1">
<span class="kw1">let</span> readNum <span class="br0">(</span><span class="br0">)</span> <span class="sy0">=</span>
  <span class="kw1">let</span> s <span class="sy0">=</span> Console<span class="sy0">.</span>ReadLine<span class="br0">(</span><span class="br0">)</span>
  <span class="kw1">let</span> <span class="kw3">succ</span>,v <span class="sy0">=</span> <span class="kw2">Int32</span><span class="sy0">.</span>TryParse<span class="br0">(</span>s<span class="br0">)</span>
  <span class="kw1">if</span> <span class="br0">(</span><span class="kw3">succ</span><span class="br0">)</span> <span class="kw1">then</span> Some<span class="br0">(</span>v<span class="br0">)</span> <span class="kw1">else</span> None
 
<span class="kw1">let</span> secure_div <span class="sy0">=</span> 
  maybe <span class="br0">{</span> 
    <span class="kw1">let</span><span class="sy0">!</span> x <span class="sy0">=</span> readNum<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">let</span><span class="sy0">!</span> y <span class="sy0">=</span> readNum<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span> 
    <span class="kw1">then</span> None
    <span class="kw1">else</span> return <span class="br0">(</span>x <span class="sy0">/</span> y<span class="br0">)</span>
  <span class="br0">}</span>
</pre>
<p>The syntactic sugar of the maybe block would get translated internally to the following expression:</p>
<p>WHATSON? 71e88da2-7bdc-46b3-ad37-6f79ae19547e</p>
<pre class="de1">
maybe<span class="sy0">.</span>Delay<span class="br0">(</span><span class="kw1">fun</span> <span class="br0">(</span><span class="br0">)</span> <span class="sy0">-&gt;</span>
  maybe<span class="sy0">.</span>Bind<span class="br0">(</span>readNum<span class="br0">(</span><span class="br0">)</span>, <span class="kw1">fun</span> x <span class="sy0">-&gt;</span>
    maybe<span class="sy0">.</span>Bind<span class="br0">(</span>readNum<span class="br0">(</span><span class="br0">)</span>, <span class="kw1">fun</span> y <span class="sy0">-&gt;</span>
      <span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">=</span><span class="nu0">0</span><span class="br0">)</span> <span class="kw1">then</span> None <span class="kw1">else</span> maybe<span class="sy0">.</span>Return<span class="br0">(</span> x<span class="sy0">/</span>y <span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<h2><span class="mw-headline" id="Generic_monadic_functions">Generic monadic functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=12" title="Edit section: Generic monadic functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Given values produced by safe division, we might want to carry on doing calculations without having to check manually if they are <tt>Nothing</tt> (i.e. resulted from an attempted division by zero). We can do this using a "<a href="/wiki/Lift_(mathematics)" title="Lift (mathematics)">lifting</a>" function, which we can define not only for <tt>Maybe</tt> but for arbitrary monads. In Haskell this is called <tt>liftM2</tt>:</p>
<p>WHATSON? 084efd62-470c-46e8-98c9-a0ad15858621</p>
<pre class="de1">
liftM2 <span class="sy0">::</span> <span class="kw5">Monad</span> m <span class="sy0">=&gt;</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> c<span class="br0">)</span> <span class="sy0">-&gt;</span> m a <span class="sy0">-&gt;</span> m b <span class="sy0">-&gt;</span> m c
liftM2 op mx my <span class="sy0">=</span> <span class="kw1">do</span>
    x <span class="sy0">&lt;-</span> mx
    y <span class="sy0">&lt;-</span> my
    <span class="kw3">return</span> <span class="br0">(</span>op x y<span class="br0">)</span>
</pre>
<p>Recall that arrows in a type <a href="/wiki/Currying#Definition" title="Currying">associate to the right</a>, so <tt>liftM2</tt> is a function that takes a binary function as an argument and returns another binary function. The type signature says: If <tt>m</tt> is a monad, we can "lift" any binary function into it. For example:</p>
<p>WHATSON? 35d0d250-730d-4d64-942b-c1ba60fae45b</p>
<pre class="de1">
<span class="br0">(</span>.<span class="sy0">*</span>.<span class="br0">)</span> <span class="sy0">::</span> <span class="br0">(</span><span class="kw5">Monad</span> m, <span class="kw5">Num</span> a<span class="br0">)</span> <span class="sy0">=&gt;</span> m a <span class="sy0">-&gt;</span> m a <span class="sy0">-&gt;</span> m a
x .<span class="sy0">*</span>. y <span class="sy0">=</span> liftM2 <span class="br0">(</span><span class="sy0">*</span><span class="br0">)</span> x y
</pre>
<p>defines an operator <tt>(.*.)</tt> which multiplies two numbers, unless one of them is <tt>Nothing</tt> (in which case it again returns <tt>Nothing</tt>). The advantage here is that we need not dive into the details of the implementation of the monad; if we need to do the same kind of thing with another function, or in another monad, using <tt>liftM2</tt> makes it immediately clear what is meant (see <a href="/wiki/Code_reuse" title="Code reuse">Code reuse</a>).</p>
<p>Mathematically, the liftM2 operator is defined by:</p>
<h2><span class="mw-headline" id="Other_examples">Other examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=13" title="Edit section: Other examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Identity_monad">Identity monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=14" title="Edit section: Identity monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The simplest monad is the identity monad, which attaches no information to values.</p>
<p>WHATSON? 7ab68294-7c97-4351-8b84-87b5d682a7e9</p>
<pre class="de1">
Id t <span class="sy0">=</span> t
<span class="kw3">return</span> x <span class="sy0">=</span> x
x <span class="sy0">&gt;&gt;=</span> f <span class="sy0">=</span> f x
</pre>
<p>A do-block in this monad performs <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variable</a> substitution; <tt>do {x &lt;- 2; return 3*x}</tt> results in 6.</p>
<p>From the category theory point of view, the identity monad is derived from the adjunction between <a href="/wiki/Identity_functor" title="Identity functor" class="mw-redirect">identity functors</a>.</p>
<h3><span class="mw-headline" id="Collections">Collections</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=15" title="Edit section: Collections">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some familiar <a href="/wiki/Collection_(computing)" title="Collection (computing)" class="mw-redirect">collection</a> types, including <a href="/wiki/Linked_list" title="Linked list">lists</a>, <a href="/wiki/Set_(computer_science)" title="Set (computer science)" class="mw-redirect">sets</a>, and <a href="/wiki/Multiset" title="Multiset">multisets</a>, are monads. The definition for lists is given here.</p>
<p>WHATSON? 4348d3bc-ec35-4f3e-a707-e4f4c5d468a1</p>
<pre class="de1">
<span class="co1">-- "return" constructs a one-item list.</span>
<span class="kw3">return</span> x <span class="sy0">=</span> <span class="br0">[</span>x<span class="br0">]</span>
<span class="co1">-- "bind" concatenates the lists obtained by applying f to each item in list xs.</span>
xs <span class="sy0">&gt;&gt;=</span> f <span class="sy0">=</span> <span class="kw3">concat</span> <span class="br0">(</span><span class="kw3">map</span> f xs<span class="br0">)</span>
<span class="co1">-- The zero object is an empty list.</span>
mzero <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
</pre>
<p><a href="/wiki/List_comprehension" title="List comprehension">List comprehensions</a> are a special application of the list monad. For example, the list comprehension <tt>[ 2*x | x &lt;- [1..n], isOkay x]</tt> corresponds to the computation in the list monad <tt>do {x &lt;- [1..n]; if isOkay x then return (2*x) else mzero;}</tt>.</p>
<p>The notation of list comprehensions is similar to the <a href="/wiki/Set-builder_notation" title="Set-builder notation">set-builder notation</a>, but sets can't be made into a monad, since there's a restriction on the type of computation to be comparable for equality, whereas a monad does not put any constraints on the types of computations. Actually, the Set is a <b>restricted monad</b>.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>14<span>]</span></a></sup> The monads for collections naturally represent <a href="/wiki/Nondeterministic_algorithm" title="Nondeterministic algorithm">nondeterministic computation</a>. The list (or other collection) represents all the possible results from different nondeterministic paths of computation at that given time. For example, when one executes <tt>x &lt;- [1,2,3,4,5]</tt>, one is saying that the variable <tt>x</tt> can non-deterministically take on any of the values of that list. If one were to return <tt>x</tt>, it would evaluate to a list of the results from each path of computation. Notice that the bind operator above follows this theme by performing <tt>f</tt> on each of the current possible results, and then it concatenates the result lists together.</p>
<p>Statements like <tt>if condition x y then return () else mzero</tt> are also often seen; if the condition is true, the non-deterministic choice is being performed from one dummy path of computation, which returns a value we are not assigning to anything; however, if the condition is false, then the <tt>mzero = []</tt> monad value non-deterministically chooses from 0 values, effectively terminating that path of computation. Other paths of computations might still succeed. This effectively serves as a "guard" to enforce that only paths of computation that satisfy certain conditions can continue. So collection monads are very useful for solving logic puzzles, Sudoku, and similar problems.</p>
<p>In a language with <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a>, like <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, a list is evaluated only to the degree that its elements are requested: for example, if one asks for the first element of a list, only the first element will be computed. With respect to usage of the list monad for non-deterministic computation that means that we can non-deterministically generate a lazy list of all results of the computation and ask for the first of them, and only as much work will be performed as is needed to get that first result. The process roughly corresponds to backtracking: a path of computation is chosen, and then if it fails at some point (if it evaluates <tt>mzero</tt>), then it <a href="/wiki/Backtracking" title="Backtracking">backtracks</a> to the last branching point, and follows the next path, and so on. If the second element is then requested, it again does just enough work to get the second solution, and so on. So the list monad is a simple way to implement a backtracking algorithm in a lazy language.</p>
<p>From the category theory point of view, collection monads are derived from <a href="/wiki/Adjoint_functors" title="Adjoint functors">adjunctions</a> between a <a href="/wiki/Free_functor" title="Free functor" class="mw-redirect">free functor</a> and an underlying functor between the <a href="/wiki/Category_of_sets" title="Category of sets">category of sets</a> and a <a href="/wiki/Category_of_monoids" title="Category of monoids" class="mw-redirect">category of monoids</a>. Taking different types of monoids, we obtain different types of collections, as in the table below:</p>
<h3><span class="mw-headline" id="State_monads">State monads</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=16" title="Edit section: State monads">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A state monad allows a programmer to attach state information of any type to a calculation. Given any value type, the corresponding type in the state monad is a function which accepts a state, then outputs a new state (of type <tt>s</tt>) along with a return value (of type <tt>t</tt>).</p>
<p>WHATSON? b9221b0a-acc0-4f81-aaa1-440d20df024d</p>
<pre class="de1">
<span class="kw1">type</span> State s t <span class="sy0">=</span> s <span class="sy0">-&gt;</span> <span class="br0">(</span>t, s<span class="br0">)</span>
</pre>
<p>Note that this monad, unlike those already seen, takes a type parameter, the type of the state information. The monad operations are defined as follows:</p>
<p>WHATSON? 553d02af-34ac-45bd-b589-d2127641303b</p>
<pre class="de1">
<span class="co1">-- "return" produces the given value without changing the state.</span>
<span class="kw3">return</span> x <span class="sy0">=</span> <span class="sy0">\</span>s <span class="sy0">-&gt;</span> <span class="br0">(</span>x, s<span class="br0">)</span>
<span class="co1">-- "bind" modifies m so that it applies f to its result.</span>
m <span class="sy0">&gt;&gt;=</span> f <span class="sy0">=</span> <span class="sy0">\</span>r <span class="sy0">-&gt;</span> <span class="kw1">let</span> <span class="br0">(</span>x, s<span class="br0">)</span> <span class="sy0">=</span> m r <span class="kw1">in</span> <span class="br0">(</span>f x<span class="br0">)</span> s
</pre>
<p>Useful state operations include:</p>
<p>WHATSON? ccdd71c7-8386-490e-806b-07c4665eae05</p>
<pre class="de1">
get <span class="sy0">=</span> <span class="sy0">\</span>s <span class="sy0">-&gt;</span> <span class="br0">(</span>s, s<span class="br0">)</span> <span class="co1">-- Examine the state at this point in the computation.</span>
put s <span class="sy0">=</span> <span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="br0">(</span><span class="br0">(</span><span class="br0">)</span>, s<span class="br0">)</span> <span class="co1">-- Replace the state.</span>
modify f <span class="sy0">=</span> <span class="sy0">\</span>s <span class="sy0">-&gt;</span> <span class="br0">(</span><span class="br0">(</span><span class="br0">)</span>, f s<span class="br0">)</span> <span class="co1">-- Update the state</span>
</pre>
<p>Another operation applies a state monad to a given initial state:</p>
<p>WHATSON? 86541f0f-c4ee-4f8f-a325-0a951290a65a</p>
<pre class="de1">
runState <span class="sy0">::</span> State s a <span class="sy0">-&gt;</span> s <span class="sy0">-&gt;</span> <span class="br0">(</span>a, s<span class="br0">)</span>
runState t s <span class="sy0">=</span> t s
</pre>
<p>do-blocks in a state monad are sequences of operations that can examine and update the state data.</p>
<p>Informally, a state monad of state type <i>S</i> maps the type of return values <i>T</i> into functions of type <img class="mwe-math-fallback-image-inline tex" alt="S \rarr T \times S" src="//upload.wikimedia.org/math/2/0/0/200d0ac3c0f7a8e786fc3f2595e94fb1.png">, where <i>S</i> is the underlying state. The <i>return</i> function is simply:</p>
<p>The <i>bind</i> function is:</p>
<p>From the category theory point of view, a state monad is derived from the adjunction between the product functor and the exponential functor, which exists in any <a href="/wiki/Cartesian_closed_category" title="Cartesian closed category">cartesian closed category</a> by definition.</p>
<h3><span class="mw-headline" id="Environment_monad">Environment monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=17" title="Edit section: Environment monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The environment monad (also called the <i>reader monad</i> and the <i>function monad</i>) allows a computation to depend on values from a shared environment. The monad type constructor maps a type <i>T</i> to functions of type <i>E</i> → <i>T</i>, where E is the type of the shared environment. The monad functions are:</p>
<p>The following monadic operations are useful:</p>
<p>The <i>ask</i> operation is used to retrieve the current context, while <i>local</i> executes a computation in a modified subcontext. As in the state monad, computations in the environment monad may be invoked by simply providing an environment value and applying it to an instance of the monad.</p>
<h3><span class="mw-headline" id="Writer_monad">Writer monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=18" title="Edit section: Writer monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The writer monad allows a program to compute various kinds of auxiliary output which can be "composed" or "accumulated" step-by-step, in addition to the main result of a computation. It is often used for logging or profiling. Given the underlying type <i>T</i>, a value in the writer monad has type <i>W</i> × <i>T</i>, where <i>W</i> is a type endowed with an operation satisfying the <a href="/wiki/Monoid" title="Monoid">monoid</a> laws. The monad functions are simply:</p>
<p>where ε and * are the identity element of the monoid W and its associative operation, respectively.</p>
<p>The <i>tell</i> monadic operation is defined by:</p>
<p>where 1 and () denote the <a href="/wiki/Unit_type" title="Unit type">unit type</a> and its trivial element. It is used in combination with <i>bind</i> to update the auxiliary value without affecting the main computation.</p>
<h3><span class="mw-headline" id="Continuation_monad">Continuation monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=19" title="Edit section: Continuation monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <a href="/wiki/Continuation" title="Continuation">continuation</a> monad with return type <img class="mwe-math-fallback-image-inline tex" alt="R" src="//upload.wikimedia.org/math/e/1/e/e1e1d3d40573127e9ee0480caf1283d6.png"> maps type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into functions of type <img class="mwe-math-fallback-image-inline tex" alt="\left( T \rarr R \right) \rarr R" src="//upload.wikimedia.org/math/f/1/f/f1f8f3648559de057ec4ad323165bdb1.png">. It is used to model <a href="/wiki/Continuation-passing_style" title="Continuation-passing style">continuation-passing style</a>. The return and bind functions are as follows:</p>
<p>The <a href="/wiki/Call-with-current-continuation" title="Call-with-current-continuation">call-with-current-continuation</a> function is defined as follows:</p>
<h3><span class="mw-headline" id="Others">Others</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=20" title="Edit section: Others">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Other concepts that researchers have expressed as monads include:</p>
<ul>
<li><a href="/wiki/Iteratee" title="Iteratee">Iteratee</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception handling</a></li>
<li><a href="/wiki/Graphical_user_interface" title="Graphical user interface">Graphical user interfaces</a></li>
<li><a href="/wiki/Interprocess_communication" title="Interprocess communication" class="mw-redirect">Interprocess communication</a></li>
<li><a href="/wiki/Parser" title="Parser" class="mw-redirect">Parsers</a></li>
<li><a href="/wiki/Interpreter_(computing)" title="Interpreter (computing)">Interpreters</a></li>
<li><a href="/wiki/Strict_evaluation" title="Strict evaluation" class="mw-redirect">Strict evaluation</a></li>
<li>Interfaces to code written in other languages</li>
</ul>
<h2><span class="mw-headline" id="Free_monads">Free monads</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=21" title="Edit section: Free monads">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Free monads are similar to <a href="/wiki/Free_monoid" title="Free monoid">free monoids</a>, in that they, intuitively speaking, are generic structures that fulfill the monad (monoid) laws without depending on the type in question.</p>
<p>For any type t, the free monoid of <code>t</code> is <code>[t]</code>, with <code>++</code> as the associative binary operation and <code>[]</code> as the unit element. In Haskell, we can write this as:</p>
<p>WHATSON? cb229e0e-b8cb-445d-bafa-e408dfdfdf7a</p>
<pre class="de1">
<span class="kw1">instance</span> <span class="kw5">Functor</span> <span class="br0">[</span><span class="br0">]</span> <span class="kw1">where</span>
   <span class="kw3">fmap</span> _ <span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   <span class="kw3">fmap</span> fun <span class="br0">(</span>x<span class="sy0">:</span>xs<span class="br0">)</span> <span class="sy0">=</span> fun x <span class="sy0">:</span> <span class="kw3">fmap</span> fun xs
 
<span class="kw1">instance</span> Monoid <span class="br0">[</span>t<span class="br0">]</span> <span class="kw1">where</span>
   mappend xs ys <span class="sy0">=</span> xs <span class="sy0">++</span> ys
   mempty <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
</pre>
<p>Whereas in a concrete monoid, one could add the values <code>t1,t2,...,tn</code> with its binary operation; in <code>[]</code>, they are simply concatenated into <code>[t1,t2,...,tn]</code>, signifying that they "belong together". What that "belonging together" means, however, is left unspecified.</p>
<p>The free monad is based on the same idea. If we take <code>List t = Nil | Cons t (List t)</code> and insert a <a href="/wiki/Functor" title="Functor">Functor</a> into it, we get the free monad:</p>
<p>WHATSON? b515bba7-cb14-411f-b65e-f72288432e6e</p>
<pre class="de1">
<span class="kw1">data</span> Free f t <span class="sy0">=</span> Return a <span class="sy0">|</span> Bind <span class="br0">(</span>f <span class="br0">(</span>Free f t<span class="br0">)</span><span class="br0">)</span>
 
<span class="kw1">instance</span> <span class="kw5">Functor</span> f <span class="sy0">=&gt;</span> <span class="kw5">Functor</span> <span class="br0">(</span>Free f<span class="br0">)</span> <span class="kw1">where</span>
   <span class="kw3">fmap</span> fun <span class="br0">(</span>Return x<span class="br0">)</span> <span class="sy0">=</span> Return <span class="br0">(</span>fun x<span class="br0">)</span>
   <span class="kw3">fmap</span> fun <span class="br0">(</span>Bind x<span class="br0">)</span> <span class="sy0">=</span> Bind <span class="br0">(</span><span class="kw3">fmap</span> <span class="br0">(</span><span class="kw3">fmap</span> fun<span class="br0">)</span> x<span class="br0">)</span>
 
<span class="kw1">instance</span> <span class="kw5">Functor</span> f <span class="sy0">=&gt;</span> <span class="kw5">Monad</span> <span class="br0">(</span>Free f<span class="br0">)</span> <span class="kw1">where</span>
   <span class="kw3">return</span> x <span class="sy0">=</span> Return x
   x <span class="sy0">&gt;&gt;=</span> fun <span class="sy0">=</span> Bind <span class="br0">(</span><span class="kw3">fmap</span> <span class="br0">(</span><span class="sy0">&gt;&gt;=</span> fun<span class="br0">)</span> x<span class="br0">)</span>
</pre>
<p>Unlike <code>List</code>, which stores a list of values, <code>Free</code> stores a list of functors, wrapped around an initial value. Accordingly, the <code>Functor</code> and <code>Monad</code> instances of <code>Free</code> do nothing other than handing a given function down that list with <code>fmap</code>.</p>
<h2><span class="mw-headline" id="Comonads">Comonads</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=22" title="Edit section: Comonads">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Comonads are the <a href="/wiki/Categorical_dual" title="Categorical dual" class="mw-redirect">categorical dual</a> of monads. They are defined by a type constructor W <i>T</i> and two operations: <i>extract</i> with type W <i>T</i> → <i>T</i> for any <i>T</i>, and <i>extend</i> with type (W <i>T</i> → <i>T'</i> ) → W <i>T</i> → W <i>T'</i> . The operations <i>extend</i> and <i>extract</i> are expected to satisfy these laws:</p>
<p>Alternatively, comonads may be defined in terms of operations <i>fmap</i>, <i>extract</i> and <i>duplicate</i>. The <i>fmap</i> and <i>extract</i> operations define W as a copointed functor. The <i>duplicate</i> operation characterizes comonads: it has type W <i>T</i> → W (W <i>T</i>) and satisfies the following laws:</p>
<p>The two formulations are related as follows:</p>
<p>Whereas monads could be said to represent side-effects, a comonad <i>W</i> represents a kind of <i>context</i>. The <i>extract</i> functions extracts a value from its context, while the <i>extend</i> function may be used to compose a pipeline of "context-dependent functions" of type W <i>A</i> → <i>B</i>.</p>
<h3><span class="mw-headline" id="Identity_comonad">Identity comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=23" title="Edit section: Identity comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The identity comonad is the simplest comonad: it maps type <i>T</i> to itself. The <i>extract</i> operator is the identity and the <i>extend</i> operator is function application.</p>
<h3><span class="mw-headline" id="Product_comonad">Product comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=24" title="Edit section: Product comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The product comonad maps type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into tuples of type <img class="mwe-math-fallback-image-inline tex" alt="C \times T" src="//upload.wikimedia.org/math/d/a/2/da2ae3964dc07295a6eb64b457173934.png">, where <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> is the context type of the comonad. The comonad operations are:</p>
<h3><span class="mw-headline" id="Function_comonad">Function comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=25" title="Edit section: Function comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The function comonad maps type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into functions of type <img class="mwe-math-fallback-image-inline tex" alt="M \rarr T" src="//upload.wikimedia.org/math/2/2/2/222a33db17919e6720318fb57c4f9fcd.png">, where <img class="mwe-math-fallback-image-inline tex" alt="M" src="//upload.wikimedia.org/math/6/9/6/69691c7bdcc3ce6d5d8a1361f22d04ac.png"> is a type endowed with a <a href="/wiki/Monoid" title="Monoid">monoid</a> structure. The comonad operations are:</p>
<p>where ε is the identity element of <img class="mwe-math-fallback-image-inline tex" alt="M" src="//upload.wikimedia.org/math/6/9/6/69691c7bdcc3ce6d5d8a1361f22d04ac.png"> and * is its associative operation.</p>
<h3><span class="mw-headline" id="Costate_comonad">Costate comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=26" title="Edit section: Costate comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The costate comonad maps a type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into type <img class="mwe-math-fallback-image-inline tex" alt="(S \rarr T) \times S" src="//upload.wikimedia.org/math/0/c/8/0c83942968bc3618ce0b49846add20d9.png">, where S is the base type of the store. The comonad operations are:</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=27" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Arrows_in_functional_programming" title="Arrows in functional programming" class="mw-redirect">Arrows in functional programming</a> — whereas monads generalize the results of a computation to effects, arrows further generalize the inputs similarly.</li>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented programming</a>, a paradigm to increase modularity by isolating secondary or supporting functionality.</li>
<li><a href="/wiki/Effect_system" title="Effect system">Effect system</a>, an alternative way of describing side effects as types.</li>
<li><a href="/wiki/Inversion_of_control" title="Inversion of control">Inversion of control</a> — the abstract principle of calling specific functions from a reusable software entity.</li>
<li><a href="/wiki/Monad_transformer" title="Monad transformer">Monad transformers</a> — which allow monads to be composed in a modular and convenient way.</li>
<li><a href="/wiki/Uniqueness_type" title="Uniqueness type">Uniqueness types</a> - an alternative way of dealing with side-effects in functional languages</li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=28" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text">Technically, the monad is not required to preserve the underlying type. For example, the trivial monad in which there is only one polymorphic value which is produced by all operations satisfies all of the axioms for a monad. Conversely, the monad is not required to add any additional structure; the identity monad, which simply preserves the original type unchanged, also satisfies the monad axioms and is useful as a recursive base for monad transformers.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=29" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-RealWorldHaskell-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-RealWorldHaskell_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-RealWorldHaskell_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-RealWorldHaskell_1-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">O'Sullivan, Bryan; Goerzen, John; Stewart, Don. <i><a rel="nofollow" class="external text" href="http://book.realworldhaskell.org/">Real World Haskell</a></i>. O'Reilly, 2009. ch. 14.</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://web.archive.org/web/20100910074354/http://www.haskell.org/all_about_monads/html/analogy.html">"A physical analogy for monads"</a>. Archived from <a rel="nofollow" class="external text" href="http://www.haskell.org/all_about_monads/html/analogy.html">the original</a> on 10 Sep 2010.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=A+physical+analogy+for+monads&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fall_about_monads%2Fhtml%2Fanalogy.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web">Eric Lippert. <a rel="nofollow" class="external text" href="http://ericlippert.com/2013/02/21/monads-part-one/">"Monads, part one"</a><span class="reference-accessdate">. Retrieved 6 September 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.au=Eric+Lippert&amp;rft.aulast=Eric+Lippert&amp;rft.btitle=Monads%2C+part+one&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fericlippert.com%2F2013%2F02%2F21%2Fmonads-part-one%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><a href="/wiki/Philip_Wadler" title="Philip Wadler">Wadler, Philip</a>. <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/wadler92comprehending.html">Comprehending Monads</a>. Proceedings of the 1990 ACM Conference on LISP and Functional Programming, Nice. 1990.</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Wadler, Philip. <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9516">The Essence of Functional Programming</a>. Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. 1992.</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Hughes, J. (2005). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.9534&amp;rep=rep1&amp;type=pdf">Programming with arrows</a>. In Advanced Functional Programming (pp. 73-129). Springer Berlin Heidelberg. "</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">De Meuter, Wolfgang. "<a rel="nofollow" class="external text" href="http://soft.vub.ac.be/Publications/1997/vub-prog-tr-97-10.pdf">Monads as a theoretical foundation for AOP</a>". Workshop on Aspect Oriented Programming, ECOOP 1997.</span></li>
<li id="cite_note-moggi91-8"><span class="mw-cite-backlink">^ <a href="#cite_ref-moggi91_8-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-moggi91_8-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation journal"><a href="/wiki/Eugenio_Moggi" title="Eugenio Moggi">Moggi, Eugenio</a> (1991). <a rel="nofollow" class="external text" href="http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf">"Notions of computation and monads"</a>. <i>Information and Computation</i> <b>93</b> (1). <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0890-5401%2891%2990052-4">10.1016/0890-5401(91)90052-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Notions+of+computation+and+monads&amp;rft.aufirst=Eugenio&amp;rft.aulast=Moggi&amp;rft.au=Moggi%2C+Eugenio&amp;rft.date=1991&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.disi.unige.it%2Fperson%2FMoggiE%2Fftp%2Fic91.pdf&amp;rft_id=info%3Adoi%2F10.1016%2F0890-5401%2891%2990052-4&amp;rft.issue=1&amp;rft.jtitle=Information+and+Computation&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=93" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-seq-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-seq_9-0">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://blogs.msdn.com/dsyme/archive/2007/09/22/some-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx">"Some Details on F# Computation Expressions"</a><span class="reference-accessdate">. Retrieved 2007-12-14</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=Some+Details+on+F%23+Computation+Expressions&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fdsyme%2Farchive%2F2007%2F09%2F22%2Fsome-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://monads.haskell.cz/html/writermonad.html">"The Writer monad"</a>. haskell.cz.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=The+Writer+monad&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmonads.haskell.cz%2Fhtml%2Fwritermonad.html&amp;rft.pub=haskell.cz&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><a href="/wiki/Simon_Peyton_Jones" title="Simon Peyton Jones">Peyton Jones, Simon L.</a>; Wadler, Philip. <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/peytonjones93imperative.html">Imperative Functional Programming</a>. Conference record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, South Carolina. 1993</span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/Monad_laws">"Monad laws"</a>. <i>HaskellWiki</i>. haskell.org<span class="reference-accessdate">. Retrieved 2011-12-11</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Monad+laws&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FMonad_laws&amp;rft.jtitle=HaskellWiki&amp;rft.pub=haskell.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">"Functors, Applicative Functors and Monoids"</a>. learnyouahaskell.com.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=Functors%2C+Applicative+Functors+and+Monoids&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Flearnyouahaskell.com%2Ffunctors-applicative-functors-and-monoids&amp;rft.pub=learnyouahaskell.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros">How to make Data.Set a monad</a> shows an implementation of the Set restricted monad in <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=30" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Haskell_monad_tutorials">Haskell monad tutorials</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=31" title="Edit section: Haskell monad tutorials">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/Monad_tutorials_timeline">Monad Tutorials Timeline</a> Probably the most comprehensive collection of links to monad tutorials, ordered by date.</li>
<li><span class="citation web">Piponi, Dan (August 7, 2006). <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">"You Could Have Invented Monads! (And Maybe You Already Have.)"</a>. <i>A Neighborhood of Infinity</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=You+Could+Have+Invented+Monads%21+%28And+Maybe+You+Already+Have.%29&amp;rft.aufirst=Dan&amp;rft.aulast=Piponi&amp;rft.au=Piponi%2C+Dan&amp;rft.date=August+7%2C+2006&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fblog.sigfpe.com%2F2006%2F08%2Fyou-could-have-invented-monads-and.html&amp;rft.jtitle=A+Neighborhood+of+Infinity&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — The most famous "blog post" tutorial.</li>
<li><span class="citation journal">Yorgey, Brent (12 March 2009). <a rel="nofollow" class="external text" href="http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf">"The Typeclassopedia"</a>. <i>The Monad.Reader</i> (13): 17–68.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=The+Typeclassopedia&amp;rft.aufirst=Brent&amp;rft.aulast=Yorgey&amp;rft.au=Yorgey%2C+Brent&amp;rft.date=12+March+2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fwikiupload%2F8%2F85%2FTMR-Issue13.pdf&amp;rft.issue=13&amp;rft.jtitle=The+Monad.Reader&amp;rft.pages=17-68&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — An attempt to explain all of the leading typeclasses in Haskell in an elementary way, with monadic functors considered as only one form, best understood by comparison with others: e.g., the more general idea of a "Functor" as something you can map over; "Applicative" functors, and so forth; contains an extensive bibliography.</li>
<li><span class="citation web">Yorgey, Brent (January 12, 2009). <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">"Abstraction, intuition, and the "monad tutorial fallacy<span style="padding-right:0.2em;">"</span>"</a>. <i>blog :: Brent -&gt; [String]</i>. <a href="/wiki/WordPress.com" title="WordPress.com">WordPress.com</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Abstraction%2C+intuition%2C+and+the+%22monad+tutorial+fallacy%22&amp;rft.aufirst=Brent&amp;rft.aulast=Yorgey&amp;rft.au=Yorgey%2C+Brent&amp;rft.date=January+12%2C+2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fbyorgey.wordpress.com%2F2009%2F01%2F12%2Fabstraction-intuition-and-the-monad-tutorial-fallacy%2F&amp;rft.jtitle=blog+%3A%3A+Brent+-%3E+%5BString%5D&amp;rft.pub=WordPress.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — Opposes the idea of making a tutorial about monads in particular.</li>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/What_a_Monad_is_not">What a Monad is not</a> deals with common misconceptions and oversimplifications in a humorous way.</li>
<li><span class="citation web">beelsebob (March 31, 2009). <a rel="nofollow" class="external text" href="http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/">"How you should(n’t) use Monad"</a>. <i>No Ordering</i>. <a href="/wiki/WordPress.com" title="WordPress.com">WordPress.com</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=How+you+should%28n%E2%80%99t%29+use+Monad&amp;rft.au=beelsebob&amp;rft.aulast=beelsebob&amp;rft.date=March+31%2C+2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fnoordering.wordpress.com%2F2009%2F03%2F31%2Fhow-you-shouldnt-use-monad%2F&amp;rft.jtitle=No+Ordering&amp;rft.pub=WordPress.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — Takes a similar point of view, locating monads in a much wider array of Haskell functor classes, of use only in special circumstances.</li>
<li><span class="citation web">Vanier, Mike (July 25, 2010). <a rel="nofollow" class="external text" href="http://mvanier.livejournal.com/3917.html">"Yet Another Monad Tutorial (part 1: basics)"</a>. <i>Mike's World-O-Programming</i>. <a href="/wiki/LiveJournal" title="LiveJournal">LiveJournal</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Yet+Another+Monad+Tutorial+%28part+1%3A+basics%29&amp;rft.aufirst=Mike&amp;rft.aulast=Vanier&amp;rft.au=Vanier%2C+Mike&amp;rft.date=July+25%2C+2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fmvanier.livejournal.com%2F3917.html&amp;rft.jtitle=Mike%27s+World-O-Programming&amp;rft.pub=LiveJournal&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — An extremely detailed set of tutorials, deriving monads from first principles.</li>
<li><span class="citation web"><a rel="nofollow" class="external text" href="http://learnyouahaskell.com/a-fistful-of-monads">"A Fistful of Monads"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=A+Fistful+of+Monads&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Flearnyouahaskell.com%2Fa-fistful-of-monads&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> An explanation of Monads, building on the concepts of Functors, Applicative Functors and Monoids discussed in the <a rel="nofollow" class="external text" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">previous chapter</a>.</li>
<li><a rel="nofollow" class="external text" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives and Monads in Pictures</a>. A humorous beginner's guide to monads.</li>
</ul>
<h4><span class="mw-headline" id="Older_tutorials">Older tutorials</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=32" title="Edit section: Older tutorials">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/All_About_Monads">All About Monads</a></li>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/Monads_as_computation">Haskell Wiki: Monads as Computation</a></li>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/Monads_as_containers">Haskell Wiki: Monads as Containers</a></li>
<li><span class="citation web">Norvell, Theodore. <a rel="nofollow" class="external text" href="http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm">"Monads for the Working Haskell Programmer"</a>. Memorial University of Newfoundland.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Theodore&amp;rft.aulast=Norvell&amp;rft.au=Norvell%2C+Theodore&amp;rft.btitle=Monads+for+the+Working+Haskell+Programmer&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.engr.mun.ca%2F~theo%2FMisc%2Fhaskell_and_monads.htm&amp;rft.pub=Memorial+University+of+Newfoundland&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Klinger, Stefan (15 December 2005). <a rel="nofollow" class="external text" href="http://stefan-klinger.de/files/monadGuide.pdf">"The Haskell Programmer’s Guide to the IO Monad — Don’t Panic"</a> (5–54). Centre for Telematics and Information Technology, University of Twente. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/1381-3625">1381-3625</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Stefan&amp;rft.au=Klinger%2C+Stefan&amp;rft.aulast=Klinger&amp;rft.btitle=The+Haskell+Programmer%E2%80%99s+Guide+to+the+IO+Monad+%E2%80%94+Don%E2%80%99t+Panic&amp;rft.date=15+December+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fstefan-klinger.de%2Ffiles%2FmonadGuide.pdf&amp;rft.issn=1381-3625&amp;rft.issue=5%E2%80%9354&amp;rft.pub=Centre+for+Telematics+and+Information+Technology%2C+University+of+Twente&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Turoff, Adam (August 2, 2007). <a rel="nofollow" class="external text" href="http://onlamp.com/pub/a/onlamp/2007/08/02/introduction-to-haskell-pure-functions.html">"Introduction to Haskell, Part 3: Monads"</a>. <i>ONLamp</i>. O'Reilly Media.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Introduction+to+Haskell%2C+Part+3%3A+Monads&amp;rft.aufirst=Adam&amp;rft.aulast=Turoff&amp;rft.au=Turoff%2C+Adam&amp;rft.date=August+2%2C+2007&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fonlamp.com%2Fpub%2Fa%2Fonlamp%2F2007%2F08%2F02%2Fintroduction-to-haskell-pure-functions.html&amp;rft.jtitle=ONLamp&amp;rft.pub=O%27Reilly+Media&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
<li><a rel="nofollow" class="external text" href="http://spbhug.folding-maps.org/wiki/MonadsEn">Monads</a> A monad tutorial providing examples of non-trivial monads apart from the conventional IO/Maybe/List/State monads.</li>
<li><span class="citation web">Söylemez, Ertugrul (2010-07-11). <a rel="nofollow" class="external text" href="http://ertes.de/articles/monads.html">"Understanding Haskell Monads"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Ertugrul&amp;rft.aulast=S%C3%B6ylemez&amp;rft.au=S%C3%B6ylemez%2C+Ertugrul&amp;rft.btitle=Understanding+Haskell+Monads&amp;rft.date=2010-07-11&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fertes.de%2Farticles%2Fmonads.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h4><span class="mw-headline" id="Other_documentation">Other documentation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=33" title="Edit section: Other documentation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><span class="citation web">van Tuyl, Henk-Jan (2010-02-27). <a rel="nofollow" class="external text" href="http://members.chello.nl/hjgtuyl/tourdemonad.html">"A tour of the Haskell monad functions"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Henk-Jan&amp;rft.aulast=van+Tuyl&amp;rft.au=van+Tuyl%2C+Henk-Jan&amp;rft.btitle=A+tour+of+the+Haskell+monad+functions&amp;rft.date=2010-02-27&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmembers.chello.nl%2Fhjgtuyl%2Ftourdemonad.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Moggi, Eugenio. <a rel="nofollow" class="external text" href="http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf">"Notions of computation and monads"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Eugenio&amp;rft.aulast=Moggi&amp;rft.au=Moggi%2C+Eugenio&amp;rft.btitle=Notions+of+computation+and+monads&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.disi.unige.it%2Fperson%2FMoggiE%2Fftp%2Fic91.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> — The original paper suggesting use of monads for programming</li>
<li><span class="citation journal"><a href="/wiki/Philip_Wadler" title="Philip Wadler">Wadler, Philip</a> (August 2001). <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">"Monads for functional programming"</a>. University of Glasgow.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Philip&amp;rft.aulast=Wadler&amp;rft.au=Wadler%2C+Philip&amp;rft.btitle=Monads+for+functional+programming&amp;rft.date=August+2001&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fhomepages.inf.ed.ac.uk%2Fwadler%2Fpapers%2Fmarktoberdorf%2Fbaastad.pdf&amp;rft.pub=University+of+Glasgow&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> — Describes monads in Haskell (before they were implemented)</li>
</ul>
<h3><span class="mw-headline" id="Scala_monad_tutorials">Scala monad tutorials</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=34" title="Edit section: Scala monad tutorials">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><span class="citation audio-visual">League, Chris (July 12, 2010). <a rel="nofollow" class="external text" href="http://vimeo.com/13304075"><i>Monadologie: Professional Help for Type Anxiety</i></a> (flv) (Tech talk). <a href="/wiki/New_York_City" title="New York City">New York City</a>: New York Scala Enthusiasts.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=Monadologie%3A+Professional+Help+for+Type+Anxiety&amp;rft.date=July+12%2C+2010&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fvimeo.com%2F13304075&amp;rft.place=New+York+City&amp;rft.pub=New+York+Scala+Enthusiasts&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Morris, Tony (June 22, 2010). <a rel="nofollow" class="external text" href="http://blog.tmorris.net/posts/understanding-monads-using-scala-part-1/index.html">"Understanding Monads using Scala (Part 1)"</a>. <i>λ Tony’s blog λ</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Understanding+Monads+using+Scala+%28Part+1%29&amp;rft.aufirst=Tony&amp;rft.aulast=Morris&amp;rft.au=Morris%2C+Tony&amp;rft.date=June+22%2C+2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fblog.tmorris.net%2Fposts%2Funderstanding-monads-using-scala-part-1%2Findex.html&amp;rft.jtitle=%CE%BB+Tony%E2%80%99s+blog+%CE%BB&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Iry, James (September 18, 2007). <a rel="nofollow" class="external text" href="http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html">"Monads are Elephants"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=James&amp;rft.au=Iry%2C+James&amp;rft.aulast=Iry&amp;rft.btitle=Monads+are+Elephants&amp;rft.date=September+18%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fjames-iry.blogspot.com%2F2007%2F09%2Fmonads-are-elephants-part-1.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Meredith, Gregory (April 25, 2010). <a rel="nofollow" class="external text" href="https://github.com/leithaus/XTrace/blob/monadic/src/main/book/content/monadic.pdf">"Pro Scala: Monadic Design Patterns for the Web"</a> (1st ed.). p. 300.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Gregory&amp;rft.aulast=Meredith&amp;rft.au=Meredith%2C+Gregory&amp;rft.btitle=Pro+Scala%3A+Monadic+Design+Patterns+for+the+Web&amp;rft.date=April+25%2C+2010&amp;rft.edition=1st&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fgithub.com%2Fleithaus%2FXTrace%2Fblob%2Fmonadic%2Fsrc%2Fmain%2Fbook%2Fcontent%2Fmonadic.pdf&amp;rft.pages=300&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h3><span class="mw-headline" id="Monads_in_other_languages">Monads in other languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=35" title="Edit section: Monads in other languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a rel="nofollow" class="external text" href="http://web.archive.org/web/20080515195640/http://sleepingsquirrel.org/monads/monads.html">Monads in Perl</a></li>
<li><a rel="nofollow" class="external text" href="http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html">Monads in Ruby</a></li>
<li><a rel="nofollow" class="external text" href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html">Monads in Python</a></li>
<li><a rel="nofollow" class="external text" href="http://lamp.epfl.ch/~emir/bqbase/2005/01/20/monad.html">Monads in Scala</a></li>
<li><a rel="nofollow" class="external text" href="http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/">Monads in Clojure</a></li>
<li><a rel="nofollow" class="external text" href="http://labs.mudynamics.com/2009/05/13/monadic-parser-in-javascript/">Monads in JavaScript</a></li>
<li><a rel="nofollow" class="external text" href="http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">Introduction to monads in C# and LINQ</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/louthy/csharp-monad">Library of monads for C#</a></li>
<li><a rel="nofollow" class="external text" href="http://blog.enfranchisedmind.com/2007/08/a-monad-tutorial-for-ocaml/">Monads in Ocaml</a></li>
<li><a rel="nofollow" class="external text" href="http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html">Monads in PHP</a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Monad (functional programming)</span></h1>
<p>In <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, a <b>monad</b> is a structure that represents <a href="/wiki/Computation" title="Computation">computations</a> defined as sequences of steps: a <a href="/wiki/Type_(computer_science)" title="Type (computer science)" class="mw-redirect">type</a> with a monad structure defines what it means to <a href="/wiki/Block_(programming)" title="Block (programming)">chain operations</a>, or nest <a href="/wiki/Function_(computer_science)" title="Function (computer science)" class="mw-redirect">functions</a> of that type together. This allows the programmer to build <a href="/wiki/Pipeline_(software)" title="Pipeline (software)">pipelines</a> that process data in steps, in which each action is <a href="/wiki/Decorator_pattern" title="Decorator pattern">decorated</a> with additional processing rules provided by the monad.<sup id="cite_ref-RealWorldHaskell_1-0" class="reference"><a href="#cite_note-RealWorldHaskell-1"><span>[</span>1<span>]</span></a></sup> As such, monads have been described as "programmable semicolons"; a semicolon is the operator used to chain together individual <a href="/wiki/Statement_(computer_programming)" title="Statement (computer programming)" class="mw-redirect">statements</a> in many <a href="/wiki/Imperative_programming" title="Imperative programming">imperative programming</a> languages,<sup id="cite_ref-RealWorldHaskell_1-1" class="reference"><a href="#cite_note-RealWorldHaskell-1"><span>[</span>1<span>]</span></a></sup> thus the expression implies that extra code will be executed between the statements in the pipeline. Monads have also been explained with a <a href="/wiki/Physical_metaphor" title="Physical metaphor" class="mw-redirect">physical metaphor</a> as <a href="/wiki/Assembly_line" title="Assembly line">assembly lines</a>, where a conveyor belt transports data between functional units that transform it one step at a time.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> They can also be seen as a functional <a href="/wiki/Design_pattern" title="Design pattern">design pattern</a> to build <a href="/wiki/Parameterized_type" title="Parameterized type" class="mw-redirect">generic types</a>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p><a href="/wiki/Purely_functional" title="Purely functional">Purely functional</a> programs can use monads to structure procedures that include sequenced operations like those found in <a href="/wiki/Structured_programming" title="Structured programming">structured programming</a>.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> Many common programming concepts can be described in terms of a monad structure, including <a href="/wiki/Side_effect_(computer_science)" title="Side effect (computer science)">side effects</a> such as <a href="/wiki/Input/output" title="Input/output">input/output</a>, variable <a href="/wiki/Assignment_(computer_science)" title="Assignment (computer science)">assignment</a>, <a href="/wiki/Exception_handling" title="Exception handling">exception handling</a>, <a href="/wiki/Parsing" title="Parsing">parsing</a>, <a href="/wiki/Nondeterministic_programming" title="Nondeterministic programming">nondeterminism</a>, <a href="/wiki/Concurrency_(computer_science)" title="Concurrency (computer science)">concurrency</a>, and <a href="/wiki/Continuation" title="Continuation">continuations</a>. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics. Languages like <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> provide monads in the standard core, allowing programmers to reuse large parts of their formal definition and apply in many different libraries the same interfaces for combining functions.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Description"><span class="tocnumber">1</span> <span class="toctext">Description</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#History"><span class="tocnumber">2</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Motivating_examples"><span class="tocnumber">3</span> <span class="toctext">Motivating examples</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#The_Maybe_monad"><span class="tocnumber">3.1</span> <span class="toctext">The Maybe monad</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#The_Writer_monad"><span class="tocnumber">3.2</span> <span class="toctext">The Writer monad</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#The_I.2FO_monad"><span class="tocnumber">3.3</span> <span class="toctext">The I/O monad</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Formal_definition"><span class="tocnumber">4</span> <span class="toctext">Formal definition</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Monad_laws"><span class="tocnumber">4.1</span> <span class="toctext">Monad laws</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#fmap_and_join"><span class="tocnumber">4.2</span> <span class="toctext">fmap and join</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Additive_monads"><span class="tocnumber">4.3</span> <span class="toctext">Additive monads </span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Syntactic_sugar:_do-notation"><span class="tocnumber">5</span> <span class="toctext">Syntactic sugar: do-notation </span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Generic_monadic_functions"><span class="tocnumber">6</span> <span class="toctext">Generic monadic functions</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Other_examples"><span class="tocnumber">7</span> <span class="toctext">Other examples</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Identity_monad"><span class="tocnumber">7.1</span> <span class="toctext">Identity monad</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Collections"><span class="tocnumber">7.2</span> <span class="toctext">Collections</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#State_monads"><span class="tocnumber">7.3</span> <span class="toctext">State monads</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Environment_monad"><span class="tocnumber">7.4</span> <span class="toctext">Environment monad</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Writer_monad"><span class="tocnumber">7.5</span> <span class="toctext">Writer monad</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Continuation_monad"><span class="tocnumber">7.6</span> <span class="toctext">Continuation monad</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Others"><span class="tocnumber">7.7</span> <span class="toctext">Others</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="#Free_monads"><span class="tocnumber">8</span> <span class="toctext">Free monads</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#Comonads"><span class="tocnumber">9</span> <span class="toctext">Comonads</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Identity_comonad"><span class="tocnumber">9.1</span> <span class="toctext">Identity comonad</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Product_comonad"><span class="tocnumber">9.2</span> <span class="toctext">Product comonad</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Function_comonad"><span class="tocnumber">9.3</span> <span class="toctext">Function comonad</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Costate_comonad"><span class="tocnumber">9.4</span> <span class="toctext">Costate comonad</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-27"><a href="#See_also"><span class="tocnumber">10</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-28"><a href="#Notes"><span class="tocnumber">11</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-29"><a href="#References"><span class="tocnumber">12</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="#External_links"><span class="tocnumber">13</span> <span class="toctext">External links</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#Haskell_monad_tutorials"><span class="tocnumber">13.1</span> <span class="toctext">Haskell monad tutorials</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Older_tutorials"><span class="tocnumber">13.1.1</span> <span class="toctext">Older tutorials</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Other_documentation"><span class="tocnumber">13.1.2</span> <span class="toctext">Other documentation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="#Scala_monad_tutorials"><span class="tocnumber">13.2</span> <span class="toctext">Scala monad tutorials</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Monads_in_other_languages"><span class="tocnumber">13.3</span> <span class="toctext">Monads in other languages</span></a></li>
</ul>
</li>
</ul>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#The_Maybe_monad"><span class="tocnumber">3.1</span> <span class="toctext">The Maybe monad</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#The_Writer_monad"><span class="tocnumber">3.2</span> <span class="toctext">The Writer monad</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#The_I.2FO_monad"><span class="tocnumber">3.3</span> <span class="toctext">The I/O monad</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Monad_laws"><span class="tocnumber">4.1</span> <span class="toctext">Monad laws</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#fmap_and_join"><span class="tocnumber">4.2</span> <span class="toctext">fmap and join</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Additive_monads"><span class="tocnumber">4.3</span> <span class="toctext">Additive monads </span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Identity_monad"><span class="tocnumber">7.1</span> <span class="toctext">Identity monad</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Collections"><span class="tocnumber">7.2</span> <span class="toctext">Collections</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#State_monads"><span class="tocnumber">7.3</span> <span class="toctext">State monads</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Environment_monad"><span class="tocnumber">7.4</span> <span class="toctext">Environment monad</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Writer_monad"><span class="tocnumber">7.5</span> <span class="toctext">Writer monad</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Continuation_monad"><span class="tocnumber">7.6</span> <span class="toctext">Continuation monad</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Others"><span class="tocnumber">7.7</span> <span class="toctext">Others</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Identity_comonad"><span class="tocnumber">9.1</span> <span class="toctext">Identity comonad</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Product_comonad"><span class="tocnumber">9.2</span> <span class="toctext">Product comonad</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Function_comonad"><span class="tocnumber">9.3</span> <span class="toctext">Function comonad</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Costate_comonad"><span class="tocnumber">9.4</span> <span class="toctext">Costate comonad</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#Haskell_monad_tutorials"><span class="tocnumber">13.1</span> <span class="toctext">Haskell monad tutorials</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Older_tutorials"><span class="tocnumber">13.1.1</span> <span class="toctext">Older tutorials</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Other_documentation"><span class="tocnumber">13.1.2</span> <span class="toctext">Other documentation</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="#Scala_monad_tutorials"><span class="tocnumber">13.2</span> <span class="toctext">Scala monad tutorials</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Monads_in_other_languages"><span class="tocnumber">13.3</span> <span class="toctext">Monads in other languages</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-32"><a href="#Older_tutorials"><span class="tocnumber">13.1.1</span> <span class="toctext">Older tutorials</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Other_documentation"><span class="tocnumber">13.1.2</span> <span class="toctext">Other documentation</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Description">Description</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=1" title="Edit section: Description">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Formally, a monad consists of a <a href="/wiki/Type_constructor" title="Type constructor">type constructor</a> <i>M</i> and two operations, <i>bind</i> and <i>return</i> (where <i>return</i> is often also called <i>unit</i>):</p>
<ul>
<li>The <i>return</i> operation takes a value from a plain type and puts it into a monadic container using the constructor, creating a <i>monadic value</i>.</li>
<li>The <i>bind</i> operation performs the reverse process, extracting the original value from the container and passing it to the associated next function in the pipeline, possibly with additional checks and transformations.</li>
</ul>
<p>The operations must fulfill several properties to allow the correct composition of <i>monadic</i> functions (i.e. functions that use values from the monad as their arguments or return value). Because a monad can insert additional operations around a program's domain logic, monads can be considered a sort of <a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">aspect-oriented programming</a>.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> The <a href="/wiki/Domain_logic" title="Domain logic" class="mw-redirect">domain logic</a> can be defined by the application programmer in the pipeline, while required aside <a href="/wiki/Bookkeeping_code" title="Bookkeeping code" class="mw-redirect">bookkeeping</a> operations can be handled by a pre-defined monad built in advance.</p>
<p>The name and concept comes from the eponymous concept (<a href="/wiki/Monad_(category_theory)" title="Monad (category theory)">monad</a>) in <a href="/wiki/Category_theory" title="Category theory">category theory</a>, where monads are one particular kind of <a href="/wiki/Functor" title="Functor">functor</a>, a mapping between categories; although the term <i>monad</i> in functional programming contexts is usually used with a meaning corresponding to that of the term <i><a href="/wiki/Strong_monad" title="Strong monad">strong monad</a></i> in category theory.<sup id="cite_ref-moggi91_8-0" class="reference"><a href="#cite_note-moggi91-8"><span>[</span>8<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=2" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The concept of monad programming appeared in the 1980s in the programming language <a href="/wiki/Opal_programming_language" title="Opal programming language" class="mw-redirect">Opal</a> even though it was called "commands" and never formally specified.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2013)">citation needed</span></a></i>]</sup></p>
<p><a href="/wiki/Eugenio_Moggi" title="Eugenio Moggi">Eugenio Moggi</a> first described the general use of monads to structure programs in 1991.<sup id="cite_ref-moggi91_8-1" class="reference"><a href="#cite_note-moggi91-8"><span>[</span>8<span>]</span></a></sup> Several people built on his work, including programming language researchers <a href="/wiki/Philip_Wadler" title="Philip Wadler">Philip Wadler</a> and <a href="/wiki/Simon_Peyton_Jones" title="Simon Peyton Jones">Simon Peyton Jones</a> (both of whom were involved in the specification of <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>). Early versions of Haskell used a problematic "lazy list" model for I/O, and Haskell 1.3 introduced monads as a more flexible way to combine I/O with <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a>.</p>
<p>In addition to I/O, programming language researchers and Haskell library designers have successfully applied monads to topics including parsers and programming language interpreters. The concept of monads along with the Haskell do-notation for them has also been generalized to form <a href="/w/index.php?title=Applicative_functor&amp;action=edit&amp;redlink=1" class="new" title="Applicative functor (page does not exist)">applicative functors</a> and <a href="/wiki/Arrow_(computer_science)" title="Arrow (computer science)">arrows</a>.</p>
<p>For a long time, Haskell and its derivatives have been the only major users of monads in programming. There also exist formulations in <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>, <a href="/wiki/Perl" title="Perl">Perl</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, <a href="/wiki/Racket_(programming_language)" title="Racket (programming language)">Racket</a>, <a href="/wiki/Clojure" title="Clojure">Clojure</a> and <a href="/wiki/Scala_(programming_language)" title="Scala (programming language)">Scala</a>, and monads have been an option in the design of a new <a href="/wiki/ML_(programming_language)" title="ML (programming language)">ML</a> standard. Recently <a href="/wiki/F_Sharp_(programming_language)" title="F Sharp (programming language)">F#</a> has included a feature called <a href="/wiki/Computation_expressions" title="Computation expressions" class="mw-redirect">computation expressions</a> or <i>workflows</i>, which are an attempt to introduce monadic constructs within a syntax more palatable to those programmers whose only prior experience has been with imperative languages.<sup id="cite_ref-seq_9-0" class="reference"><a href="#cite_note-seq-9"><span>[</span>9<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Motivating_examples">Motivating examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=3" title="Edit section: Motivating examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell programming language</a> is a functional language that makes heavy use of monads, and includes <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> to make monadic composition more convenient. All of the code samples in this article are written in <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> unless noted otherwise.</p>
<p>We demonstrate two common examples given when introducing monads: the <i>Maybe</i> monad and the <i>I/O</i> monad. Monads are of course not restricted to the Haskell language, though: the second set of examples shows the <i>Writer</i> monad in <a href="/wiki/JavaScript" title="JavaScript">JavaScript</a>.</p>
<h3><span class="mw-headline" id="The_Maybe_monad">The Maybe monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=4" title="Edit section: The Maybe monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Consider the <a href="/wiki/Option_type" title="Option type">option type</a> <i>Maybe a</i>, representing a value that is either a single value of type <i>a</i>, or no value at all. To distinguish these, we have two <a href="/wiki/Algebraic_data_type" title="Algebraic data type">algebraic data type</a> constructors: <code>Just t</code>, containing the value <code>t</code>, or <code>Nothing</code>, containing no value.</p>
<p>WHATSON? 08731dfb-c19a-495b-ae56-9cee2f0e6e16</p>
<pre class="de1">
<span class="kw1">data</span> <span class="kw4">Maybe</span> t <span class="sy0">=</span> Just t <span class="sy0">|</span> Nothing
</pre>
<p>We would like to be able to use this type as a simple sort of <a href="/wiki/Checked_exception" title="Checked exception" class="mw-redirect">checked exception</a>: at any point in a computation, the computation may fail, which causes the rest of the computation to be skipped and the final result to be <code>Nothing</code>. If all steps of the calculation succeed, the final result is <code>Just x</code> for some value <code>x</code>.</p>
<p>In the following example, <code>add</code> is a function that takes two arguments of type <i>Maybe Int</i>, and returns a result of the same type. If both <code>mx</code> and <code>my</code> have <code>Just</code> values, we want to return <code>Just</code> their sum; but if either <code>mx</code> or <code>my</code> is <code>Nothing</code>, we want to return <code>Nothing</code>. If we naively attempt to write functions with this kind of behavior, we'll end up with a nested series of "if <code>Nothing</code> then <code>Nothing</code> else do something with the <code>x</code> in <code>Just x</code>" cases that will quickly become unwieldy:<sup id="cite_ref-RealWorldHaskell_1-2" class="reference"><a href="#cite_note-RealWorldHaskell-1"><span>[</span>1<span>]</span></a></sup></p>
<p>WHATSON? 3700d333-3c7f-4231-ada5-2641045a5966</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add mx my <span class="sy0">=</span>
  <span class="kw1">case</span> mx <span class="kw1">of</span>
    Nothing <span class="sy0">-&gt;</span> Nothing
    Just x  <span class="sy0">-&gt;</span> <span class="kw1">case</span> my <span class="kw1">of</span>
                 Nothing <span class="sy0">-&gt;</span> Nothing
                 Just y  <span class="sy0">-&gt;</span> Just <span class="br0">(</span>x <span class="sy0">+</span> y<span class="br0">)</span>
</pre>
<p>To alleviate this, we can define operations for chaining these computations together. The <i>bind</i> binary operator (<code>&gt;&gt;=</code>) chains the results of one computation that could fail, into a function that chooses another computation that could fail. If the first argument is <code>Nothing</code>, the second argument (the function) is ignored and the entire operation simply fails. If the first argument is <code>Just x</code>, we pass <code>x</code> to the function to get a new <i>Maybe</i> value, which may or may not result in a <code>Just</code> value.</p>
<p>WHATSON? f55edd69-23f8-495c-abd1-362897a92d28</p>
<pre class="de1">
<span class="br0">(</span><span class="sy0">&gt;&gt;=</span><span class="br0">)</span> <span class="sy0">::</span> <span class="kw4">Maybe</span> a <span class="sy0">-&gt;</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> b<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> b
Nothing  <span class="sy0">&gt;&gt;=</span> _  <span class="sy0">=</span>  Nothing    <span class="co1">-- A failed computation returns Nothing</span>
<span class="br0">(</span>Just x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> f  <span class="sy0">=</span>  f x        <span class="co1">-- Applies function f to value x</span>
</pre>
<p>We already have a value constructor that returns a value without affecting the computation's additional state: <code>Just</code>.</p>
<p>WHATSON? 05c4e1b1-2018-4406-96d2-2fa624a74cad</p>
<pre class="de1">
<span class="kw3">return</span> <span class="sy0">::</span> a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a
<span class="kw3">return</span> x <span class="sy0">=</span> Just x       <span class="co1">-- Wraps value x, returning a value of type (Maybe a)</span>
</pre>
<p>We can then write the example as:</p>
<p>WHATSON? f73eb185-1efd-429b-892f-e297db21da42</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add mx my <span class="sy0">=</span>             <span class="co1">-- Adds two values of type (Maybe Int), where each input value can be Nothing</span>
  mx <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span>         <span class="co1">-- Extracts value x if mx is not Nothing</span>
    my <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>y <span class="sy0">-&gt;</span>       <span class="co1">-- Extracts value y if my is not Nothing</span>
      <span class="kw3">return</span> <span class="br0">(</span>x <span class="sy0">+</span> y<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>  <span class="co1">-- Wraps value (x+y), returning the sum as a value of type (Maybe Int)</span>
</pre>
<p>Using some additional <a href="/wiki/Syntactic_sugar" title="Syntactic sugar">syntactic sugar</a> known as <a href="/wiki/Do-notation" title="Do-notation" class="mw-redirect">do-notation</a>, the example can be written as:</p>
<p>WHATSON? 1f1b40b9-a2b3-4594-ab89-2a4b73c0299f</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add mx my <span class="sy0">=</span> <span class="kw1">do</span>
  x <span class="sy0">&lt;-</span> mx
  y <span class="sy0">&lt;-</span> my
  <span class="kw3">return</span> <span class="br0">(</span>x <span class="sy0">+</span> y<span class="br0">)</span>
</pre>
<p>Since this type of operation is quite common, there is a standard function in Haskell (<code>liftM2</code>) to take two monadic values (here: two Maybes) and combine their contents (two numbers) using another function (addition), making it possible to write the previous example as</p>
<p>WHATSON? 8de71a55-cc8f-42a0-a43c-f3629fdb8331</p>
<pre class="de1">
add <span class="sy0">::</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> <span class="kw4">Int</span>
add <span class="sy0">=</span> liftM2 <span class="br0">(</span><span class="sy0">+</span><span class="br0">)</span>
</pre>
<p>(Writing out the definition of liftM2 yields the code presented above in do-notation.)</p>
<h3><span class="mw-headline" id="The_Writer_monad">The Writer monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=5" title="Edit section: The Writer monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Writer monad allows a process to carry additional information "on the side", along with the computed value. This can be useful to log error or debugging information which is not the primary result.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup></p>
<p>The following example implements a Writer monad in Javascript:</p>
<p>First, a Writer monad is declared. Function <i>unit</i> creates a new value type from a basic type, with an empty log string attached to it; and <i>bind</i> applies a function to an old value, and returns the new result value with an expanded log. The <a href="/wiki/Bracket#Uses_of_.22.5B.22_and_.22.5D.22" title="Bracket">array brackets</a> work here as the monad's type constructor, creating a value of the monadic type for the Writer monad from simpler components (the value in position 0 of the array, and the log string in position 1).</p>
<p>WHATSON? 45f04da2-d585-44a5-ae96-37efb9f05657</p>
<pre class="de1">
<span class="kw1">var</span> unit <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>value<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="br0">[</span>value<span class="sy0">,</span> <span class="st0">''</span><span class="br0">]</span> <span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>WHATSON? 1a306555-6105-4997-a56b-0b4537e21b25</p>
<pre class="de1">
<span class="kw1">var</span> bind <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>monadicValue<span class="sy0">,</span> transformWithLog<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">var</span> value  <span class="sy0">=</span> monadicValue<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span>
        log <span class="sy0">=</span> monadicValue<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">,</span>
        result <span class="sy0">=</span> transformWithLog<span class="br0">(</span>value<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="br0">[</span> result<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> log <span class="sy0">+</span> result<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p><i>pipeline</i> is an auxiliary function that concatenates a sequence of <i>bind</i>s applied to an array of functions.</p>
<p>WHATSON? 3ad62208-c734-403b-93c1-1cec46c5191c</p>
<pre class="de1">
<span class="kw1">var</span> pipeline <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>monadicValue<span class="sy0">,</span> functions<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw1">var</span> key <span class="kw1">in</span> functions<span class="br0">)</span> <span class="br0">{</span>
        monadicValue <span class="sy0">=</span> bind<span class="br0">(</span>monadicValue<span class="sy0">,</span> functions<span class="br0">[</span>key<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> monadicValue<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>Examples of functions that return values of the type expected by the above Writer monad:</p>
<p>WHATSON? 6aa03602-08cc-4330-a958-c7afadbdddda</p>
<pre class="de1">
<span class="kw1">var</span> squared <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="br0">[</span>x <span class="sy0">*</span> x<span class="sy0">,</span> <span class="st0">'was squared.'</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
 
<span class="kw1">var</span> halved <span class="sy0">=</span> <span class="kw1">function</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="br0">[</span>x <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="st0">'was halved.'</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>Finally, an example of using the monad to build a pipeline of mathematical functions with debug information on the side (that is, a string of debug information is concatenated, and returned with the result, as well):</p>
<p>WHATSON? 5244e763-eb45-454c-9644-0174d152006e</p>
<pre class="de1">
pipeline<span class="br0">(</span>unit<span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">,</span> <span class="br0">[</span>squared<span class="sy0">,</span> halved<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// [8, "was squared.was halved."]</span>
</pre>
<h3><span class="mw-headline" id="The_I.2FO_monad">The I/O monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=6" title="Edit section: The I/O monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a <a href="/wiki/Purely_functional" title="Purely functional">purely functional</a> language, such as Haskell, functions cannot have any externally visible side effects as part of the function semantics. Although a function cannot directly cause a side effect, it can construct a value <i>describing</i> a desired side effect, that the caller should apply at a convenient time.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> In the Haskell notation, a value of type <i>IO a</i> represents an action that, when performed, produces a value of type <i>a</i>.</p>
<p>We can think of a value of type <code>IO</code> as an <i>action</i> that takes as its argument the current state of the world, and will return a new world where the state has been changed according to the function's return value. For example, the functions <code>doesFileExist</code> and <code>removeFile</code> in the standard Haskell library have the following types</p>
<p>WHATSON? ccc6dec7-148d-4a4f-a19b-601fc498519b</p>
<pre class="de1">
doesFileExist <span class="sy0">::</span> FilePath <span class="sy0">-&gt;</span> <span class="kw4">IO</span> <span class="kw4">Bool</span>
removeFile <span class="sy0">::</span> FilePath <span class="sy0">-&gt;</span> <span class="kw4">IO</span> <span class="br0">(</span><span class="br0">)</span>
</pre>
<p>So, one can think of <code>removeFile</code> as a function that, given a <code>FilePath</code>, returns an <code>IO</code> <i>action</i>; this action will ensure that the world, in this case the underlying file system, won't have a file named by that <code>FilePath</code> when it gets <i>executed</i>. Here, the <code>IO</code> internal value is of type <code>()</code> which means that the caller does not care about any other outcomes. On the other hand, in <code>doesFileExist</code>, the function returns an <code>IO</code> <i>action</i> which wraps a boolean value, <code>True</code> or <code>False</code>; this conceptually represents a new state of the world where the caller knows for certain whether that <code>FilePath</code> is present in the file system or not at the time of the <i>action</i> is performed. The state of the world managed in this way can be passed from action to action, thus defining a series of actions which will be applied in order as steps of state changes. This process is similar to how a <a href="/wiki/Temporal_logic" title="Temporal logic">temporal logic</a> represents the passage of time using only <a href="/wiki/Declarative_programming" title="Declarative programming">declarative</a> propositions. The following example clarifies in detail how this chaining of actions occurs in a program, again using Haskell.</p>
<p>We would like to be able to describe all of the basic types of I/O operations, e.g. write text to <a href="/wiki/Standard_output" title="Standard output" class="mw-redirect">standard output</a>, read text from standard input, read and write files, send data over networks, etc. In addition, we need to be able to compose these primitives to form larger programs. For example, we would like to be able to write:</p>
<p>WHATSON? 7e0dc25f-cc0d-402e-8675-1dde49af2c21</p>
<pre class="de1">
main <span class="sy0">::</span> <span class="kw4">IO</span> <span class="br0">(</span><span class="br0">)</span>
main <span class="sy0">=</span> <span class="kw1">do</span>
  <span class="kw3">putStrLn</span> <span class="st0">"What is your name?"</span>
  name <span class="sy0">&lt;-</span> <span class="kw3">getLine</span>
  <span class="kw3">putStrLn</span> <span class="br0">(</span><span class="st0">"Nice to meet you, "</span> <span class="sy0">++</span> name <span class="sy0">++</span> <span class="st0">"!"</span><span class="br0">)</span>
</pre>
<p>How can we formalize this intuitive notation? To do this, we need to be able to perform some basic operations with I/O actions:</p>
<ul>
<li>We should be able to sequence two I/O operations together. In Haskell, this is written as an infix operator <code>&gt;&gt;</code>, so that <code>putStrLn "abc" &gt;&gt; putStrLn "def"</code> is an I/O action that prints two lines of text to the console. The type of <code>&gt;&gt;</code> is <i>IO a → IO b → IO b</i>, meaning that the operator takes two I/O operations and returns a third that sequences the two together and returns the value of the second.</li>
<li>We should have an I/O action which does <i>nothing</i>. That is, it returns a value but has no side effects. In Haskell, this action constructor is called <code>return</code>; it has type <i>a → IO a</i>.</li>
<li>More subtly, we should be able to determine our next action based on the results of previous actions. To do this, Haskell has an operator <code>&gt;&gt;=</code> (pronounced <i>bind</i>) with type <i>IO a → (a → IO b) → IO b</i>. That is, the operand on the left is an I/O action that returns a value of type <code>a</code>; the operand on the right is a function that can pick an I/O action based on the value produced by the action on the left. The resulting combined action, when performed, performs the first action, then evaluates the function with the first action's return value, then performs the second action, and finally returns the second action's value.</li>
</ul>
<p>It is not necessarily obvious that the three preceding operations, along with a suitable primitive set of I/O operations, allow us to define <i>any program action whatsoever</i>, including data transformations (using <a href="/wiki/Lambda_expressions" title="Lambda expressions" class="mw-redirect">lambda expressions</a>), if/then control flow, and looping control flows (using recursion). We can write the above example as one long expression:</p>
<p>WHATSON? ab43e522-604f-4d24-82bc-7f6574c737a0</p>
<pre class="de1">
main <span class="sy0">=</span>
  <span class="kw3">putStrLn</span> <span class="st0">"What is your name?"</span> <span class="sy0">&gt;&gt;</span> 
  <span class="kw3">getLine</span> <span class="sy0">&gt;&gt;=</span> <span class="sy0">\</span>name <span class="sy0">-&gt;</span>
  <span class="kw3">putStrLn</span> <span class="br0">(</span><span class="st0">"Nice to meet you, "</span> <span class="sy0">++</span> name <span class="sy0">++</span> <span class="st0">"!"</span><span class="br0">)</span>
</pre>
<p>The pipeline structure of the <i>bind</i> operator ensures that the <i>getLine</i> and <i>putStrLn</i> operations get evaluated only once and in the given order, so that the side-effects of extracting text from the input stream and writing to the output stream are correctly handled in the functional pipeline. This remains true even if the language performs <a href="/wiki/Out-of-order_execution" title="Out-of-order execution">out-of-order</a> or <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a> of functions.</p>
<p>Clearly, there is some common structure between the I/O definitions and the Maybe definitions, even though they are different in many ways. Monads are an abstraction upon the structures described above, and many similar structures, that finds and exploits the commonalities. The general monad concept includes any situation where the programmer wants to carry out a purely functional computation while a related computation is carried out on the side.</p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=7" title="Edit section: Formal definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A monad is a construction that, given an underlying <a href="/wiki/Type_system" title="Type system">type system</a>, embeds a corresponding type system (called the <i>monadic type system</i>) into it (that is, each monadic type acts as the underlying type). This monadic type system preserves all significant aspects of the underlying type system, while adding features particular to the monad.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>a<span>]</span></a></sup></p>
<p>The usual formulation of a monad for programming is known as a <a href="/wiki/Kleisli_triple" title="Kleisli triple" class="mw-redirect">Kleisli triple</a>, and has the following components:</p>
<ol>
<li>A <i>type constructor</i> that defines, for every underlying type, how to obtain a corresponding monadic type. In Haskell's notation, the name of the monad represents the type constructor. If <i>M</i> is the name of the monad and <i>t</i> is a data type, then <i>M t</i> is the corresponding type in the monad.</li>
<li>A <i>unit function</i> that maps a value in an underlying type to a value in the corresponding monadic type. The unit function has the polymorphic type <i>t→M t</i>. The result is normally the "simplest" value in the corresponding type that completely preserves the original value (simplicity being understood appropriately to the monad). In Haskell, this function is called <code>return</code> due to the way it is used in the do-notation described later.</li>
<li>A <i>binding operation</i> of polymorphic type <i>(M t)→(t→M u)→(M u)</i>, which Haskell represents by the <a href="/wiki/Infix_notation" title="Infix notation">infix</a> operator <code>&gt;&gt;=</code>. Its first argument is a value in a monadic type, its second argument is a function that maps from the underlying type of the first argument to another monadic type, and its result is in that other monadic type. Typically, the binding operation can be understood as having four stages:
<ol>
<li>The monad-related structure on the first argument is "pierced" to expose any number of values in the underlying type t.</li>
<li>The given function is applied to all of those values to obtain values of type (M u).</li>
<li>The monad-related structure on those values is also pierced, exposing values of type u.</li>
<li>Finally, the monad-related structure is reassembled over all of the results, giving a single value of type (M u).</li>
</ol>
</li>
</ol>
<ol>
<li>The monad-related structure on the first argument is "pierced" to expose any number of values in the underlying type t.</li>
<li>The given function is applied to all of those values to obtain values of type (M u).</li>
<li>The monad-related structure on those values is also pierced, exposing values of type u.</li>
<li>Finally, the monad-related structure is reassembled over all of the results, giving a single value of type (M u).</li>
</ol>
<p>Given a type constructor <i>M</i>, in most contexts, a value of type <i>M a</i> can be thought of as an action that returns a value of type <i>a</i>. The <i>return</i> operation takes a value from a plain type <i>a</i> and puts it into a monadic container of type <i>M a</i>; the <i>bind</i> operation chains a monadic value of type <i>M a</i> with a function of type <i>a → M b</i> to create a monadic value of type <i>M b</i>.</p>
<h3><span class="mw-headline" id="Monad_laws">Monad laws</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=8" title="Edit section: Monad laws">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>For a monad to behave correctly, the definitions must obey a few axioms, together called the monad laws.<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>12<span>]</span></a></sup> The ≡ symbol indicates equivalence between two Haskell expressions in the following text.</p>
<ul>
<li><i>return</i> acts approximately as a <a href="/wiki/Neutral_element" title="Neutral element" class="mw-redirect">neutral element</a> of <tt>&gt;&gt;=</tt>, in that:
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span><span class="kw3">return</span> x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> f   ≡   f x</span></li>
<li><span class="mw-geshi haskell source-haskell">m <span class="sy0">&gt;&gt;=</span> <span class="kw3">return</span>   ≡   m</span></li>
</ul>
</li>
<li>Binding two functions in succession is the same as binding one function that can be determined from them:
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span>m <span class="sy0">&gt;&gt;=</span> f<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> g   ≡   m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span> <span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">(</span>f x <span class="sy0">&gt;&gt;=</span> g<span class="br0">)</span> <span class="br0">)</span></span></li>
</ul>
</li>
</ul>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span><span class="kw3">return</span> x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> f   ≡   f x</span></li>
<li><span class="mw-geshi haskell source-haskell">m <span class="sy0">&gt;&gt;=</span> <span class="kw3">return</span>   ≡   m</span></li>
</ul>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span>m <span class="sy0">&gt;&gt;=</span> f<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> g   ≡   m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span> <span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">(</span>f x <span class="sy0">&gt;&gt;=</span> g<span class="br0">)</span> <span class="br0">)</span></span></li>
</ul>
<p>The axioms can also be expressed using expressions in <a href="#do-notation">do-block style</a>:</p>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="kw1">do</span> <span class="br0">{</span> f x <span class="br0">}</span>   ≡   <span class="kw1">do</span> <span class="br0">{</span> v <span class="sy0">&lt;-</span> <span class="kw3">return</span> x; f v <span class="br0">}</span></span></li>
<li><span class="mw-geshi haskell source-haskell"><span class="kw1">do</span> <span class="br0">{</span> m <span class="br0">}</span>   ≡   <span class="kw1">do</span> <span class="br0">{</span> v <span class="sy0">&lt;-</span> m; <span class="kw3">return</span> v <span class="br0">}</span></span></li>
<li><span class="mw-geshi haskell source-haskell"><span class="kw1">do</span> <span class="br0">{</span> x <span class="sy0">&lt;-</span> m; y <span class="sy0">&lt;-</span> f x; g y <span class="br0">}</span>   ≡   <span class="kw1">do</span> <span class="br0">{</span> y <span class="sy0">&lt;-</span> <span class="kw1">do</span> <span class="br0">{</span> x <span class="sy0">&lt;-</span> m; f x <span class="br0">}</span>; g y <span class="br0">}</span></span></li>
</ul>
<p>or using the monadic composition operator, <span class="mw-geshi haskell source-haskell"><span class="br0">(</span>f <span class="sy0">&gt;=&gt;</span> g<span class="br0">)</span> x <span class="sy0">=</span> <span class="br0">(</span>f x<span class="br0">)</span> <span class="sy0">&gt;&gt;=</span> g</span>:</p>
<ul>
<li><span class="mw-geshi haskell source-haskell"><span class="kw3">return</span> <span class="sy0">&gt;=&gt;</span> g   ≡   g</span></li>
<li><span class="mw-geshi haskell source-haskell">f <span class="sy0">&gt;=&gt;</span> <span class="kw3">return</span>   ≡   f</span></li>
<li><span class="mw-geshi haskell source-haskell"><span class="br0">(</span>f <span class="sy0">&gt;=&gt;</span> g<span class="br0">)</span> <span class="sy0">&gt;=&gt;</span> h   ≡   f <span class="sy0">&gt;=&gt;</span> <span class="br0">(</span>g <span class="sy0">&gt;=&gt;</span> h<span class="br0">)</span></span></li>
</ul>
<h3><span class="mw-headline" id="fmap_and_join">fmap and join</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=9" title="Edit section: fmap and join">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Although Haskell defines monads in terms of the <i>return</i> and <i>bind</i> functions, it is also possible to define a monad in terms of <i>return</i> and two other operations, <i>join</i> and <i>fmap</i>. This formulation fits more closely with the original definition of monads in category theory. The <i>fmap</i> operation, with type (<i>t</i>→<i>u</i>) → M <i>t</i>→M <i>u</i>,<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>13<span>]</span></a></sup> takes a function between two types and produces a function that does the "same thing" to values in the monad. The <i>join</i> operation, with type M (M <i>t</i>)→M <i>t</i>, "flattens" two layers of monadic information into one.</p>
<p>The two formulations are related as follows:</p>
<p>WHATSON? 98c319b2-84d7-4ac0-a3be-49e90d93819a</p>
<pre class="de1">
<span class="kw3">fmap</span> f m <span class="sy0">=</span> m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="kw3">return</span> . f<span class="br0">)</span>
join n <span class="sy0">=</span> n <span class="sy0">&gt;&gt;=</span> <span class="kw3">id</span>
 
m <span class="sy0">&gt;&gt;=</span> g   ≡   join <span class="br0">(</span><span class="kw3">fmap</span> g m<span class="br0">)</span>
</pre>
<p>Here, m has the type M <i>t</i>, n has the type M (M <i>r</i>), f has the type <i>t</i> → <i>u</i>, and g has the type t → M <i>v</i>, where <i>t</i>, <i>r</i>, <i>u</i> and <i>v</i> are underlying types.</p>
<p>The fmap function is defined for any <a href="/wiki/Functor" title="Functor">functor</a> in the category of types and functions, not just for monads. It is expected to satisfy the functor laws:</p>
<p>WHATSON? da9812c4-132a-4cde-ac3b-f7b077caf591</p>
<pre class="de1">
<span class="kw3">fmap</span> <span class="kw3">id</span>   ≡   <span class="kw3">id</span>
<span class="kw3">fmap</span> <span class="br0">(</span>f . g<span class="br0">)</span>   ≡   <span class="br0">(</span><span class="kw3">fmap</span> f<span class="br0">)</span> . <span class="br0">(</span><span class="kw3">fmap</span> g<span class="br0">)</span>
</pre>
<p>The <i>return</i> function characterizes <a href="/w/index.php?title=Pointed_functor&amp;action=edit&amp;redlink=1" class="new" title="Pointed functor (page does not exist)">pointed functors</a> in the same category, by accounting for the ability to "lift" values into the functor. It should satisfy the following law:</p>
<p>WHATSON? 3172ad43-9787-41ae-9eb7-92f9c7a12239</p>
<pre class="de1">
<span class="kw3">return</span> . f ≡ <span class="kw3">fmap</span> f . <span class="kw3">return</span>
</pre>
<p>In addition, the <i>join</i> function characterizes monads:</p>
<p>WHATSON? 14cf8f1b-57c0-4514-839d-2edd15fe47c8</p>
<pre class="de1">
join . <span class="kw3">fmap</span> join     ≡ join . join
join . <span class="kw3">fmap</span> <span class="kw3">return</span>   ≡ join . <span class="kw3">return</span> <span class="sy0">=</span> <span class="kw3">id</span>
join . <span class="kw3">fmap</span> <span class="br0">(</span><span class="kw3">fmap</span> f<span class="br0">)</span> ≡ <span class="kw3">fmap</span> f . join
</pre>
<h3><span class="mw-headline" id="Additive_monads">Additive monads <span id="Additive_monad"></span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=10" title="Edit section: Additive monads">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An <b>additive monad</b> is a monad endowed with a monadic zero <i>mzero</i> and a binary operator <i>mplus</i> satisfying the <a href="/wiki/Monoid" title="Monoid">monoid</a> laws, with the monadic zero as unit. The operator <i>mplus</i> has type <i>M t</i> → <i>M t</i> → <i>M t</i> (where <i>M</i> is the monad constructor and <i>t</i> is the underlying data type), satisfies the <a href="/wiki/Associative_law" title="Associative law" class="mw-redirect">associative law</a> and has the zero as both left and right identity. That is:</p>
<p>WHATSON? 06f1b765-4e2f-4a26-be5d-7e183b26afd8</p>
<pre class="de1">
<span class="br0">(</span>a `mplus` b<span class="br0">)</span> `mplus` c   <span class="sy0">=</span>   a `mplus` <span class="br0">(</span>b `mplus c`<span class="br0">)</span>
m `mplus` mzero           ≡   mzero `mplus` m           ≡    m
</pre>
<p>Thus, an additive monad is also a monoid. For &gt;&gt;=, on the other hand, mzero acts as a null-element. Just as multiplying a number by 0 results in 0, binding <i>mzero</i> with any function produces the zero for the result type:</p>
<p>WHATSON? a0571b39-d699-4b71-800e-a26124c5bd25</p>
<pre class="de1">
mzero <span class="sy0">&gt;&gt;=</span> f               ≡   mzero
</pre>
<p>Similarly, binding any <i>m</i> with a function that always returns a zero results in a zero</p>
<p>WHATSON? 3757ec2e-8d0e-4a70-838c-7e2f10a63fad</p>
<pre class="de1">
m <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> mzero<span class="br0">)</span>       ≡   mzero
</pre>
<p>Intuitively, the zero represents a value in the monad that has only monad-related structure and no values from the underlying type. In the Maybe monad, "Nothing" is a zero. In the List monad, "[]" (the empty list) is a zero.</p>
<h2><span class="mw-headline" id="Syntactic_sugar:_do-notation">Syntactic sugar: <code>do</code>-notation <span id="do-notation"></span></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=11" title="Edit section: Syntactic sugar: do-notation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Although there are times when it makes sense to use the <i>bind</i> operator <code>&gt;&gt;=</code> directly in a program, it is more typical to use a format called <i>do-notation</i> (<i>perform-notation</i> in <a href="/wiki/OCaml" title="OCaml">OCaml</a>, <i>computation expressions</i> in <a href="/wiki/F_Sharp_(programming_language)" title="F Sharp (programming language)">F#</a>), that mimics the appearance of imperative languages. The compiler translates do-notation to expressions involving <code>&gt;&gt;=</code>. For example, the following code:</p>
<p>WHATSON? 342563d5-4337-40be-a66f-38f31d675291</p>
<pre class="de1">
a <span class="sy0">=</span> <span class="kw1">do</span> x <span class="sy0">&lt;-</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span>
       <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span>
       <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span>
</pre>
<p>is transformed during compilation into:</p>
<p>WHATSON? 6ef151ba-01f6-4bcb-9071-a42dbfe6ea7c</p>
<pre class="de1">
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>It is helpful to see the implementation of the list monad, and to know that concatMap maps a function over a list and concatenates (flattens) the resulting lists:</p>
<p>WHATSON? bce16dac-ac12-49e1-9a04-003f3a9bfea4</p>
<pre class="de1">
<span class="kw1">instance</span> <span class="kw5">Monad</span> <span class="br0">[</span><span class="br0">]</span> <span class="kw1">where</span>
  m <span class="sy0">&gt;&gt;=</span> f  <span class="sy0">=</span> <span class="kw3">concat</span> <span class="br0">(</span><span class="kw3">map</span> f m<span class="br0">)</span>
  <span class="kw3">return</span> x <span class="sy0">=</span> <span class="br0">[</span>x<span class="br0">]</span>
  <span class="kw3">fail</span> s   <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
</pre>
<p>Therefore, the following transformations hold and all the following expressions are equivalent:</p>
<p>WHATSON? 949d9d0f-8c71-4263-85a0-a24eb92fa914</p>
<pre class="de1">
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="kw3">concatMap</span> <span class="br0">(</span><span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="kw3">return</span> <span class="br0">(</span>x, <span class="nu0">42</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">[</span><span class="nu0">1</span>..<span class="nu0">2</span><span class="br0">]</span> <span class="br0">)</span>
a <span class="sy0">=</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span> <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span><span class="br0">]</span> <span class="br0">)</span>
a <span class="sy0">=</span> <span class="kw3">concatMap</span> <span class="br0">(</span><span class="sy0">\</span>x <span class="sy0">-&gt;</span> <span class="br0">[</span><span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span>x,<span class="nu0">42</span><span class="br0">)</span><span class="br0">]</span> <span class="br0">)</span> <span class="br0">[</span><span class="nu0">3</span>..<span class="nu0">4</span><span class="br0">]</span>
a <span class="sy0">=</span> <span class="br0">[</span><span class="br0">(</span><span class="nu0">3</span>,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span><span class="nu0">3</span>,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span><span class="nu0">4</span>,<span class="nu0">42</span><span class="br0">)</span>,<span class="br0">(</span><span class="nu0">4</span>,<span class="nu0">42</span><span class="br0">)</span><span class="br0">]</span>
</pre>
<p>Notice that the list <tt>[1..2]</tt> is not used. The lack of a left-pointing arrow, translated into a binding to a function that ignores its argument, indicates that only the monadic structure is of interest, not the values inside it, e.g. for a state monad this might be used for changing the state without producing any more result values. The do-block notation can be used with any monad as it is simply syntactic sugar for <code>&gt;&gt;=</code>.</p>
<p>The following definitions for safe division for values in the Maybe monad are also equivalent:</p>
<p>WHATSON? be251d18-3cbc-4bfb-a17e-97b9b8b49b2d</p>
<pre class="de1">
x <span class="sy0">//</span> y <span class="sy0">=</span> <span class="kw1">do</span>
  a <span class="sy0">&lt;-</span> x  <span class="co1">-- Extract the values "inside" x and y, if there are any.</span>
  b <span class="sy0">&lt;-</span> y
  <span class="kw1">if</span> b <span class="sy0">==</span> <span class="nu0">0</span> <span class="kw1">then</span> Nothing <span class="kw1">else</span> Just <span class="br0">(</span>a <span class="sy0">/</span> b<span class="br0">)</span>
 
x <span class="sy0">//</span> y <span class="sy0">=</span> x <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>a <span class="sy0">-&gt;</span> y <span class="sy0">&gt;&gt;=</span> <span class="br0">(</span><span class="sy0">\</span>b <span class="sy0">-&gt;</span> <span class="kw1">if</span> b <span class="sy0">==</span> <span class="nu0">0</span> <span class="kw1">then</span> Nothing <span class="kw1">else</span> Just <span class="br0">(</span>a <span class="sy0">/</span> b<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>A similar example in F# using a computation expression:</p>
<p>WHATSON? ec60149a-5fb4-4246-be78-3a5232450bfd</p>
<pre class="de1">
<span class="kw1">let</span> readNum <span class="br0">(</span><span class="br0">)</span> <span class="sy0">=</span>
  <span class="kw1">let</span> s <span class="sy0">=</span> Console<span class="sy0">.</span>ReadLine<span class="br0">(</span><span class="br0">)</span>
  <span class="kw1">let</span> <span class="kw3">succ</span>,v <span class="sy0">=</span> <span class="kw2">Int32</span><span class="sy0">.</span>TryParse<span class="br0">(</span>s<span class="br0">)</span>
  <span class="kw1">if</span> <span class="br0">(</span><span class="kw3">succ</span><span class="br0">)</span> <span class="kw1">then</span> Some<span class="br0">(</span>v<span class="br0">)</span> <span class="kw1">else</span> None
 
<span class="kw1">let</span> secure_div <span class="sy0">=</span> 
  maybe <span class="br0">{</span> 
    <span class="kw1">let</span><span class="sy0">!</span> x <span class="sy0">=</span> readNum<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">let</span><span class="sy0">!</span> y <span class="sy0">=</span> readNum<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span> 
    <span class="kw1">then</span> None
    <span class="kw1">else</span> return <span class="br0">(</span>x <span class="sy0">/</span> y<span class="br0">)</span>
  <span class="br0">}</span>
</pre>
<p>The syntactic sugar of the maybe block would get translated internally to the following expression:</p>
<p>WHATSON? ea867038-5acc-4643-9074-15415f73666e</p>
<pre class="de1">
maybe<span class="sy0">.</span>Delay<span class="br0">(</span><span class="kw1">fun</span> <span class="br0">(</span><span class="br0">)</span> <span class="sy0">-&gt;</span>
  maybe<span class="sy0">.</span>Bind<span class="br0">(</span>readNum<span class="br0">(</span><span class="br0">)</span>, <span class="kw1">fun</span> x <span class="sy0">-&gt;</span>
    maybe<span class="sy0">.</span>Bind<span class="br0">(</span>readNum<span class="br0">(</span><span class="br0">)</span>, <span class="kw1">fun</span> y <span class="sy0">-&gt;</span>
      <span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">=</span><span class="nu0">0</span><span class="br0">)</span> <span class="kw1">then</span> None <span class="kw1">else</span> maybe<span class="sy0">.</span>Return<span class="br0">(</span> x<span class="sy0">/</span>y <span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<h2><span class="mw-headline" id="Generic_monadic_functions">Generic monadic functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=12" title="Edit section: Generic monadic functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Given values produced by safe division, we might want to carry on doing calculations without having to check manually if they are <tt>Nothing</tt> (i.e. resulted from an attempted division by zero). We can do this using a "<a href="/wiki/Lift_(mathematics)" title="Lift (mathematics)">lifting</a>" function, which we can define not only for <tt>Maybe</tt> but for arbitrary monads. In Haskell this is called <tt>liftM2</tt>:</p>
<p>WHATSON? 0c8e510e-1c6e-4c7f-a479-81f6e81c2d74</p>
<pre class="de1">
liftM2 <span class="sy0">::</span> <span class="kw5">Monad</span> m <span class="sy0">=&gt;</span> <span class="br0">(</span>a <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> c<span class="br0">)</span> <span class="sy0">-&gt;</span> m a <span class="sy0">-&gt;</span> m b <span class="sy0">-&gt;</span> m c
liftM2 op mx my <span class="sy0">=</span> <span class="kw1">do</span>
    x <span class="sy0">&lt;-</span> mx
    y <span class="sy0">&lt;-</span> my
    <span class="kw3">return</span> <span class="br0">(</span>op x y<span class="br0">)</span>
</pre>
<p>Recall that arrows in a type <a href="/wiki/Currying#Definition" title="Currying">associate to the right</a>, so <tt>liftM2</tt> is a function that takes a binary function as an argument and returns another binary function. The type signature says: If <tt>m</tt> is a monad, we can "lift" any binary function into it. For example:</p>
<p>WHATSON? e4a7db0c-05cb-4b71-9e91-f1387748b752</p>
<pre class="de1">
<span class="br0">(</span>.<span class="sy0">*</span>.<span class="br0">)</span> <span class="sy0">::</span> <span class="br0">(</span><span class="kw5">Monad</span> m, <span class="kw5">Num</span> a<span class="br0">)</span> <span class="sy0">=&gt;</span> m a <span class="sy0">-&gt;</span> m a <span class="sy0">-&gt;</span> m a
x .<span class="sy0">*</span>. y <span class="sy0">=</span> liftM2 <span class="br0">(</span><span class="sy0">*</span><span class="br0">)</span> x y
</pre>
<p>defines an operator <tt>(.*.)</tt> which multiplies two numbers, unless one of them is <tt>Nothing</tt> (in which case it again returns <tt>Nothing</tt>). The advantage here is that we need not dive into the details of the implementation of the monad; if we need to do the same kind of thing with another function, or in another monad, using <tt>liftM2</tt> makes it immediately clear what is meant (see <a href="/wiki/Code_reuse" title="Code reuse">Code reuse</a>).</p>
<p>Mathematically, the liftM2 operator is defined by:</p>
<h2><span class="mw-headline" id="Other_examples">Other examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=13" title="Edit section: Other examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Identity_monad">Identity monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=14" title="Edit section: Identity monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The simplest monad is the identity monad, which attaches no information to values.</p>
<p>WHATSON? 8deaa7a6-f3fe-4db5-81e4-5559407273c4</p>
<pre class="de1">
Id t <span class="sy0">=</span> t
<span class="kw3">return</span> x <span class="sy0">=</span> x
x <span class="sy0">&gt;&gt;=</span> f <span class="sy0">=</span> f x
</pre>
<p>A do-block in this monad performs <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variable</a> substitution; <tt>do {x &lt;- 2; return 3*x}</tt> results in 6.</p>
<p>From the category theory point of view, the identity monad is derived from the adjunction between <a href="/wiki/Identity_functor" title="Identity functor" class="mw-redirect">identity functors</a>.</p>
<h3><span class="mw-headline" id="Collections">Collections</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=15" title="Edit section: Collections">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Some familiar <a href="/wiki/Collection_(computing)" title="Collection (computing)" class="mw-redirect">collection</a> types, including <a href="/wiki/Linked_list" title="Linked list">lists</a>, <a href="/wiki/Set_(computer_science)" title="Set (computer science)" class="mw-redirect">sets</a>, and <a href="/wiki/Multiset" title="Multiset">multisets</a>, are monads. The definition for lists is given here.</p>
<p>WHATSON? 1afc85d6-f15b-41ee-93e5-66c5235c3177</p>
<pre class="de1">
<span class="co1">-- "return" constructs a one-item list.</span>
<span class="kw3">return</span> x <span class="sy0">=</span> <span class="br0">[</span>x<span class="br0">]</span>
<span class="co1">-- "bind" concatenates the lists obtained by applying f to each item in list xs.</span>
xs <span class="sy0">&gt;&gt;=</span> f <span class="sy0">=</span> <span class="kw3">concat</span> <span class="br0">(</span><span class="kw3">map</span> f xs<span class="br0">)</span>
<span class="co1">-- The zero object is an empty list.</span>
mzero <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
</pre>
<p><a href="/wiki/List_comprehension" title="List comprehension">List comprehensions</a> are a special application of the list monad. For example, the list comprehension <tt>[ 2*x | x &lt;- [1..n], isOkay x]</tt> corresponds to the computation in the list monad <tt>do {x &lt;- [1..n]; if isOkay x then return (2*x) else mzero;}</tt>.</p>
<p>The notation of list comprehensions is similar to the <a href="/wiki/Set-builder_notation" title="Set-builder notation">set-builder notation</a>, but sets can't be made into a monad, since there's a restriction on the type of computation to be comparable for equality, whereas a monad does not put any constraints on the types of computations. Actually, the Set is a <b>restricted monad</b>.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>14<span>]</span></a></sup> The monads for collections naturally represent <a href="/wiki/Nondeterministic_algorithm" title="Nondeterministic algorithm">nondeterministic computation</a>. The list (or other collection) represents all the possible results from different nondeterministic paths of computation at that given time. For example, when one executes <tt>x &lt;- [1,2,3,4,5]</tt>, one is saying that the variable <tt>x</tt> can non-deterministically take on any of the values of that list. If one were to return <tt>x</tt>, it would evaluate to a list of the results from each path of computation. Notice that the bind operator above follows this theme by performing <tt>f</tt> on each of the current possible results, and then it concatenates the result lists together.</p>
<p>Statements like <tt>if condition x y then return () else mzero</tt> are also often seen; if the condition is true, the non-deterministic choice is being performed from one dummy path of computation, which returns a value we are not assigning to anything; however, if the condition is false, then the <tt>mzero = []</tt> monad value non-deterministically chooses from 0 values, effectively terminating that path of computation. Other paths of computations might still succeed. This effectively serves as a "guard" to enforce that only paths of computation that satisfy certain conditions can continue. So collection monads are very useful for solving logic puzzles, Sudoku, and similar problems.</p>
<p>In a language with <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a>, like <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, a list is evaluated only to the degree that its elements are requested: for example, if one asks for the first element of a list, only the first element will be computed. With respect to usage of the list monad for non-deterministic computation that means that we can non-deterministically generate a lazy list of all results of the computation and ask for the first of them, and only as much work will be performed as is needed to get that first result. The process roughly corresponds to backtracking: a path of computation is chosen, and then if it fails at some point (if it evaluates <tt>mzero</tt>), then it <a href="/wiki/Backtracking" title="Backtracking">backtracks</a> to the last branching point, and follows the next path, and so on. If the second element is then requested, it again does just enough work to get the second solution, and so on. So the list monad is a simple way to implement a backtracking algorithm in a lazy language.</p>
<p>From the category theory point of view, collection monads are derived from <a href="/wiki/Adjoint_functors" title="Adjoint functors">adjunctions</a> between a <a href="/wiki/Free_functor" title="Free functor" class="mw-redirect">free functor</a> and an underlying functor between the <a href="/wiki/Category_of_sets" title="Category of sets">category of sets</a> and a <a href="/wiki/Category_of_monoids" title="Category of monoids" class="mw-redirect">category of monoids</a>. Taking different types of monoids, we obtain different types of collections, as in the table below:</p>
<h3><span class="mw-headline" id="State_monads">State monads</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=16" title="Edit section: State monads">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A state monad allows a programmer to attach state information of any type to a calculation. Given any value type, the corresponding type in the state monad is a function which accepts a state, then outputs a new state (of type <tt>s</tt>) along with a return value (of type <tt>t</tt>).</p>
<p>WHATSON? 2c0a1e1e-1a7e-4ca1-bbae-fe0cf73e2d7e</p>
<pre class="de1">
<span class="kw1">type</span> State s t <span class="sy0">=</span> s <span class="sy0">-&gt;</span> <span class="br0">(</span>t, s<span class="br0">)</span>
</pre>
<p>Note that this monad, unlike those already seen, takes a type parameter, the type of the state information. The monad operations are defined as follows:</p>
<p>WHATSON? 34e0b895-5819-426e-8556-41dacb90f097</p>
<pre class="de1">
<span class="co1">-- "return" produces the given value without changing the state.</span>
<span class="kw3">return</span> x <span class="sy0">=</span> <span class="sy0">\</span>s <span class="sy0">-&gt;</span> <span class="br0">(</span>x, s<span class="br0">)</span>
<span class="co1">-- "bind" modifies m so that it applies f to its result.</span>
m <span class="sy0">&gt;&gt;=</span> f <span class="sy0">=</span> <span class="sy0">\</span>r <span class="sy0">-&gt;</span> <span class="kw1">let</span> <span class="br0">(</span>x, s<span class="br0">)</span> <span class="sy0">=</span> m r <span class="kw1">in</span> <span class="br0">(</span>f x<span class="br0">)</span> s
</pre>
<p>Useful state operations include:</p>
<p>WHATSON? c5c8dd75-5ab1-4f74-af79-15e92e46eb10</p>
<pre class="de1">
get <span class="sy0">=</span> <span class="sy0">\</span>s <span class="sy0">-&gt;</span> <span class="br0">(</span>s, s<span class="br0">)</span> <span class="co1">-- Examine the state at this point in the computation.</span>
put s <span class="sy0">=</span> <span class="sy0">\</span>_ <span class="sy0">-&gt;</span> <span class="br0">(</span><span class="br0">(</span><span class="br0">)</span>, s<span class="br0">)</span> <span class="co1">-- Replace the state.</span>
modify f <span class="sy0">=</span> <span class="sy0">\</span>s <span class="sy0">-&gt;</span> <span class="br0">(</span><span class="br0">(</span><span class="br0">)</span>, f s<span class="br0">)</span> <span class="co1">-- Update the state</span>
</pre>
<p>Another operation applies a state monad to a given initial state:</p>
<p>WHATSON? 3ce281f9-7fd7-489a-81a9-ce14d0ae7d11</p>
<pre class="de1">
runState <span class="sy0">::</span> State s a <span class="sy0">-&gt;</span> s <span class="sy0">-&gt;</span> <span class="br0">(</span>a, s<span class="br0">)</span>
runState t s <span class="sy0">=</span> t s
</pre>
<p>do-blocks in a state monad are sequences of operations that can examine and update the state data.</p>
<p>Informally, a state monad of state type <i>S</i> maps the type of return values <i>T</i> into functions of type <img class="mwe-math-fallback-image-inline tex" alt="S \rarr T \times S" src="//upload.wikimedia.org/math/2/0/0/200d0ac3c0f7a8e786fc3f2595e94fb1.png">, where <i>S</i> is the underlying state. The <i>return</i> function is simply:</p>
<p>The <i>bind</i> function is:</p>
<p>From the category theory point of view, a state monad is derived from the adjunction between the product functor and the exponential functor, which exists in any <a href="/wiki/Cartesian_closed_category" title="Cartesian closed category">cartesian closed category</a> by definition.</p>
<h3><span class="mw-headline" id="Environment_monad">Environment monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=17" title="Edit section: Environment monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The environment monad (also called the <i>reader monad</i> and the <i>function monad</i>) allows a computation to depend on values from a shared environment. The monad type constructor maps a type <i>T</i> to functions of type <i>E</i> → <i>T</i>, where E is the type of the shared environment. The monad functions are:</p>
<p>The following monadic operations are useful:</p>
<p>The <i>ask</i> operation is used to retrieve the current context, while <i>local</i> executes a computation in a modified subcontext. As in the state monad, computations in the environment monad may be invoked by simply providing an environment value and applying it to an instance of the monad.</p>
<h3><span class="mw-headline" id="Writer_monad">Writer monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=18" title="Edit section: Writer monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The writer monad allows a program to compute various kinds of auxiliary output which can be "composed" or "accumulated" step-by-step, in addition to the main result of a computation. It is often used for logging or profiling. Given the underlying type <i>T</i>, a value in the writer monad has type <i>W</i> × <i>T</i>, where <i>W</i> is a type endowed with an operation satisfying the <a href="/wiki/Monoid" title="Monoid">monoid</a> laws. The monad functions are simply:</p>
<p>where ε and * are the identity element of the monoid W and its associative operation, respectively.</p>
<p>The <i>tell</i> monadic operation is defined by:</p>
<p>where 1 and () denote the <a href="/wiki/Unit_type" title="Unit type">unit type</a> and its trivial element. It is used in combination with <i>bind</i> to update the auxiliary value without affecting the main computation.</p>
<h3><span class="mw-headline" id="Continuation_monad">Continuation monad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=19" title="Edit section: Continuation monad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <a href="/wiki/Continuation" title="Continuation">continuation</a> monad with return type <img class="mwe-math-fallback-image-inline tex" alt="R" src="//upload.wikimedia.org/math/e/1/e/e1e1d3d40573127e9ee0480caf1283d6.png"> maps type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into functions of type <img class="mwe-math-fallback-image-inline tex" alt="\left( T \rarr R \right) \rarr R" src="//upload.wikimedia.org/math/f/1/f/f1f8f3648559de057ec4ad323165bdb1.png">. It is used to model <a href="/wiki/Continuation-passing_style" title="Continuation-passing style">continuation-passing style</a>. The return and bind functions are as follows:</p>
<p>The <a href="/wiki/Call-with-current-continuation" title="Call-with-current-continuation">call-with-current-continuation</a> function is defined as follows:</p>
<h3><span class="mw-headline" id="Others">Others</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=20" title="Edit section: Others">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Other concepts that researchers have expressed as monads include:</p>
<ul>
<li><a href="/wiki/Iteratee" title="Iteratee">Iteratee</a></li>
<li><a href="/wiki/Exception_handling" title="Exception handling">Exception handling</a></li>
<li><a href="/wiki/Graphical_user_interface" title="Graphical user interface">Graphical user interfaces</a></li>
<li><a href="/wiki/Interprocess_communication" title="Interprocess communication" class="mw-redirect">Interprocess communication</a></li>
<li><a href="/wiki/Parser" title="Parser" class="mw-redirect">Parsers</a></li>
<li><a href="/wiki/Interpreter_(computing)" title="Interpreter (computing)">Interpreters</a></li>
<li><a href="/wiki/Strict_evaluation" title="Strict evaluation" class="mw-redirect">Strict evaluation</a></li>
<li>Interfaces to code written in other languages</li>
</ul>
<h2><span class="mw-headline" id="Free_monads">Free monads</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=21" title="Edit section: Free monads">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Free monads are similar to <a href="/wiki/Free_monoid" title="Free monoid">free monoids</a>, in that they, intuitively speaking, are generic structures that fulfill the monad (monoid) laws without depending on the type in question.</p>
<p>For any type t, the free monoid of <code>t</code> is <code>[t]</code>, with <code>++</code> as the associative binary operation and <code>[]</code> as the unit element. In Haskell, we can write this as:</p>
<p>WHATSON? 590c7dfb-0c12-40c7-b5a4-01b50a488c79</p>
<pre class="de1">
<span class="kw1">instance</span> <span class="kw5">Functor</span> <span class="br0">[</span><span class="br0">]</span> <span class="kw1">where</span>
   <span class="kw3">fmap</span> _ <span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   <span class="kw3">fmap</span> fun <span class="br0">(</span>x<span class="sy0">:</span>xs<span class="br0">)</span> <span class="sy0">=</span> fun x <span class="sy0">:</span> <span class="kw3">fmap</span> fun xs
 
<span class="kw1">instance</span> Monoid <span class="br0">[</span>t<span class="br0">]</span> <span class="kw1">where</span>
   mappend xs ys <span class="sy0">=</span> xs <span class="sy0">++</span> ys
   mempty <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
</pre>
<p>Whereas in a concrete monoid, one could add the values <code>t1,t2,...,tn</code> with its binary operation; in <code>[]</code>, they are simply concatenated into <code>[t1,t2,...,tn]</code>, signifying that they "belong together". What that "belonging together" means, however, is left unspecified.</p>
<p>The free monad is based on the same idea. If we take <code>List t = Nil | Cons t (List t)</code> and insert a <a href="/wiki/Functor" title="Functor">Functor</a> into it, we get the free monad:</p>
<p>WHATSON? 8ef1f1bc-30bb-4078-97ac-b74ae2eb4573</p>
<pre class="de1">
<span class="kw1">data</span> Free f t <span class="sy0">=</span> Return a <span class="sy0">|</span> Bind <span class="br0">(</span>f <span class="br0">(</span>Free f t<span class="br0">)</span><span class="br0">)</span>
 
<span class="kw1">instance</span> <span class="kw5">Functor</span> f <span class="sy0">=&gt;</span> <span class="kw5">Functor</span> <span class="br0">(</span>Free f<span class="br0">)</span> <span class="kw1">where</span>
   <span class="kw3">fmap</span> fun <span class="br0">(</span>Return x<span class="br0">)</span> <span class="sy0">=</span> Return <span class="br0">(</span>fun x<span class="br0">)</span>
   <span class="kw3">fmap</span> fun <span class="br0">(</span>Bind x<span class="br0">)</span> <span class="sy0">=</span> Bind <span class="br0">(</span><span class="kw3">fmap</span> <span class="br0">(</span><span class="kw3">fmap</span> fun<span class="br0">)</span> x<span class="br0">)</span>
 
<span class="kw1">instance</span> <span class="kw5">Functor</span> f <span class="sy0">=&gt;</span> <span class="kw5">Monad</span> <span class="br0">(</span>Free f<span class="br0">)</span> <span class="kw1">where</span>
   <span class="kw3">return</span> x <span class="sy0">=</span> Return x
   x <span class="sy0">&gt;&gt;=</span> fun <span class="sy0">=</span> Bind <span class="br0">(</span><span class="kw3">fmap</span> <span class="br0">(</span><span class="sy0">&gt;&gt;=</span> fun<span class="br0">)</span> x<span class="br0">)</span>
</pre>
<p>Unlike <code>List</code>, which stores a list of values, <code>Free</code> stores a list of functors, wrapped around an initial value. Accordingly, the <code>Functor</code> and <code>Monad</code> instances of <code>Free</code> do nothing other than handing a given function down that list with <code>fmap</code>.</p>
<h2><span class="mw-headline" id="Comonads">Comonads</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=22" title="Edit section: Comonads">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Comonads are the <a href="/wiki/Categorical_dual" title="Categorical dual" class="mw-redirect">categorical dual</a> of monads. They are defined by a type constructor W <i>T</i> and two operations: <i>extract</i> with type W <i>T</i> → <i>T</i> for any <i>T</i>, and <i>extend</i> with type (W <i>T</i> → <i>T'</i> ) → W <i>T</i> → W <i>T'</i> . The operations <i>extend</i> and <i>extract</i> are expected to satisfy these laws:</p>
<p>Alternatively, comonads may be defined in terms of operations <i>fmap</i>, <i>extract</i> and <i>duplicate</i>. The <i>fmap</i> and <i>extract</i> operations define W as a copointed functor. The <i>duplicate</i> operation characterizes comonads: it has type W <i>T</i> → W (W <i>T</i>) and satisfies the following laws:</p>
<p>The two formulations are related as follows:</p>
<p>Whereas monads could be said to represent side-effects, a comonad <i>W</i> represents a kind of <i>context</i>. The <i>extract</i> functions extracts a value from its context, while the <i>extend</i> function may be used to compose a pipeline of "context-dependent functions" of type W <i>A</i> → <i>B</i>.</p>
<h3><span class="mw-headline" id="Identity_comonad">Identity comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=23" title="Edit section: Identity comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The identity comonad is the simplest comonad: it maps type <i>T</i> to itself. The <i>extract</i> operator is the identity and the <i>extend</i> operator is function application.</p>
<h3><span class="mw-headline" id="Product_comonad">Product comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=24" title="Edit section: Product comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The product comonad maps type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into tuples of type <img class="mwe-math-fallback-image-inline tex" alt="C \times T" src="//upload.wikimedia.org/math/d/a/2/da2ae3964dc07295a6eb64b457173934.png">, where <img class="mwe-math-fallback-image-inline tex" alt="C" src="//upload.wikimedia.org/math/0/d/6/0d61f8370cad1d412f80b84d143e1257.png"> is the context type of the comonad. The comonad operations are:</p>
<h3><span class="mw-headline" id="Function_comonad">Function comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=25" title="Edit section: Function comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The function comonad maps type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into functions of type <img class="mwe-math-fallback-image-inline tex" alt="M \rarr T" src="//upload.wikimedia.org/math/2/2/2/222a33db17919e6720318fb57c4f9fcd.png">, where <img class="mwe-math-fallback-image-inline tex" alt="M" src="//upload.wikimedia.org/math/6/9/6/69691c7bdcc3ce6d5d8a1361f22d04ac.png"> is a type endowed with a <a href="/wiki/Monoid" title="Monoid">monoid</a> structure. The comonad operations are:</p>
<p>where ε is the identity element of <img class="mwe-math-fallback-image-inline tex" alt="M" src="//upload.wikimedia.org/math/6/9/6/69691c7bdcc3ce6d5d8a1361f22d04ac.png"> and * is its associative operation.</p>
<h3><span class="mw-headline" id="Costate_comonad">Costate comonad</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=26" title="Edit section: Costate comonad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The costate comonad maps a type <img class="mwe-math-fallback-image-inline tex" alt="T" src="//upload.wikimedia.org/math/b/9/e/b9ece18c950afbfa6b0fdbfa4ff731d3.png"> into type <img class="mwe-math-fallback-image-inline tex" alt="(S \rarr T) \times S" src="//upload.wikimedia.org/math/0/c/8/0c83942968bc3618ce0b49846add20d9.png">, where S is the base type of the store. The comonad operations are:</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=27" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Arrows_in_functional_programming" title="Arrows in functional programming" class="mw-redirect">Arrows in functional programming</a> — whereas monads generalize the results of a computation to effects, arrows further generalize the inputs similarly.</li>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented programming</a>, a paradigm to increase modularity by isolating secondary or supporting functionality.</li>
<li><a href="/wiki/Effect_system" title="Effect system">Effect system</a>, an alternative way of describing side effects as types.</li>
<li><a href="/wiki/Inversion_of_control" title="Inversion of control">Inversion of control</a> — the abstract principle of calling specific functions from a reusable software entity.</li>
<li><a href="/wiki/Monad_transformer" title="Monad transformer">Monad transformers</a> — which allow monads to be composed in a modular and convenient way.</li>
<li><a href="/wiki/Uniqueness_type" title="Uniqueness type">Uniqueness types</a> - an alternative way of dealing with side-effects in functional languages</li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=28" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text">Technically, the monad is not required to preserve the underlying type. For example, the trivial monad in which there is only one polymorphic value which is produced by all operations satisfies all of the axioms for a monad. Conversely, the monad is not required to add any additional structure; the identity monad, which simply preserves the original type unchanged, also satisfies the monad axioms and is useful as a recursive base for monad transformers.</span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=29" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-RealWorldHaskell-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-RealWorldHaskell_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-RealWorldHaskell_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-RealWorldHaskell_1-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">O'Sullivan, Bryan; Goerzen, John; Stewart, Don. <i><a rel="nofollow" class="external text" href="http://book.realworldhaskell.org/">Real World Haskell</a></i>. O'Reilly, 2009. ch. 14.</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://web.archive.org/web/20100910074354/http://www.haskell.org/all_about_monads/html/analogy.html">"A physical analogy for monads"</a>. Archived from <a rel="nofollow" class="external text" href="http://www.haskell.org/all_about_monads/html/analogy.html">the original</a> on 10 Sep 2010.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=A+physical+analogy+for+monads&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fall_about_monads%2Fhtml%2Fanalogy.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation web">Eric Lippert. <a rel="nofollow" class="external text" href="http://ericlippert.com/2013/02/21/monads-part-one/">"Monads, part one"</a><span class="reference-accessdate">. Retrieved 6 September 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.au=Eric+Lippert&amp;rft.aulast=Eric+Lippert&amp;rft.btitle=Monads%2C+part+one&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fericlippert.com%2F2013%2F02%2F21%2Fmonads-part-one%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><a href="/wiki/Philip_Wadler" title="Philip Wadler">Wadler, Philip</a>. <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/wadler92comprehending.html">Comprehending Monads</a>. Proceedings of the 1990 ACM Conference on LISP and Functional Programming, Nice. 1990.</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Wadler, Philip. <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9516">The Essence of Functional Programming</a>. Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. 1992.</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Hughes, J. (2005). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.9534&amp;rep=rep1&amp;type=pdf">Programming with arrows</a>. In Advanced Functional Programming (pp. 73-129). Springer Berlin Heidelberg. "</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text">De Meuter, Wolfgang. "<a rel="nofollow" class="external text" href="http://soft.vub.ac.be/Publications/1997/vub-prog-tr-97-10.pdf">Monads as a theoretical foundation for AOP</a>". Workshop on Aspect Oriented Programming, ECOOP 1997.</span></li>
<li id="cite_note-moggi91-8"><span class="mw-cite-backlink">^ <a href="#cite_ref-moggi91_8-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-moggi91_8-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation journal"><a href="/wiki/Eugenio_Moggi" title="Eugenio Moggi">Moggi, Eugenio</a> (1991). <a rel="nofollow" class="external text" href="http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf">"Notions of computation and monads"</a>. <i>Information and Computation</i> <b>93</b> (1). <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0890-5401%2891%2990052-4">10.1016/0890-5401(91)90052-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Notions+of+computation+and+monads&amp;rft.aufirst=Eugenio&amp;rft.aulast=Moggi&amp;rft.au=Moggi%2C+Eugenio&amp;rft.date=1991&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.disi.unige.it%2Fperson%2FMoggiE%2Fftp%2Fic91.pdf&amp;rft_id=info%3Adoi%2F10.1016%2F0890-5401%2891%2990052-4&amp;rft.issue=1&amp;rft.jtitle=Information+and+Computation&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=93" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-seq-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-seq_9-0">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://blogs.msdn.com/dsyme/archive/2007/09/22/some-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx">"Some Details on F# Computation Expressions"</a><span class="reference-accessdate">. Retrieved 2007-12-14</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=Some+Details+on+F%23+Computation+Expressions&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fblogs.msdn.com%2Fdsyme%2Farchive%2F2007%2F09%2F22%2Fsome-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://monads.haskell.cz/html/writermonad.html">"The Writer monad"</a>. haskell.cz.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=The+Writer+monad&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmonads.haskell.cz%2Fhtml%2Fwritermonad.html&amp;rft.pub=haskell.cz&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><a href="/wiki/Simon_Peyton_Jones" title="Simon Peyton Jones">Peyton Jones, Simon L.</a>; Wadler, Philip. <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/peytonjones93imperative.html">Imperative Functional Programming</a>. Conference record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, South Carolina. 1993</span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/Monad_laws">"Monad laws"</a>. <i>HaskellWiki</i>. haskell.org<span class="reference-accessdate">. Retrieved 2011-12-11</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Monad+laws&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FMonad_laws&amp;rft.jtitle=HaskellWiki&amp;rft.pub=haskell.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">"Functors, Applicative Functors and Monoids"</a>. learnyouahaskell.com.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=Functors%2C+Applicative+Functors+and+Monoids&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Flearnyouahaskell.com%2Ffunctors-applicative-functors-and-monoids&amp;rft.pub=learnyouahaskell.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros">How to make Data.Set a monad</a> shows an implementation of the Set restricted monad in <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=30" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Haskell_monad_tutorials">Haskell monad tutorials</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=31" title="Edit section: Haskell monad tutorials">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/Monad_tutorials_timeline">Monad Tutorials Timeline</a> Probably the most comprehensive collection of links to monad tutorials, ordered by date.</li>
<li><span class="citation web">Piponi, Dan (August 7, 2006). <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">"You Could Have Invented Monads! (And Maybe You Already Have.)"</a>. <i>A Neighborhood of Infinity</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=You+Could+Have+Invented+Monads%21+%28And+Maybe+You+Already+Have.%29&amp;rft.aufirst=Dan&amp;rft.aulast=Piponi&amp;rft.au=Piponi%2C+Dan&amp;rft.date=August+7%2C+2006&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fblog.sigfpe.com%2F2006%2F08%2Fyou-could-have-invented-monads-and.html&amp;rft.jtitle=A+Neighborhood+of+Infinity&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — The most famous "blog post" tutorial.</li>
<li><span class="citation journal">Yorgey, Brent (12 March 2009). <a rel="nofollow" class="external text" href="http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf">"The Typeclassopedia"</a>. <i>The Monad.Reader</i> (13): 17–68.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=The+Typeclassopedia&amp;rft.aufirst=Brent&amp;rft.aulast=Yorgey&amp;rft.au=Yorgey%2C+Brent&amp;rft.date=12+March+2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fwikiupload%2F8%2F85%2FTMR-Issue13.pdf&amp;rft.issue=13&amp;rft.jtitle=The+Monad.Reader&amp;rft.pages=17-68&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — An attempt to explain all of the leading typeclasses in Haskell in an elementary way, with monadic functors considered as only one form, best understood by comparison with others: e.g., the more general idea of a "Functor" as something you can map over; "Applicative" functors, and so forth; contains an extensive bibliography.</li>
<li><span class="citation web">Yorgey, Brent (January 12, 2009). <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">"Abstraction, intuition, and the "monad tutorial fallacy<span style="padding-right:0.2em;">"</span>"</a>. <i>blog :: Brent -&gt; [String]</i>. <a href="/wiki/WordPress.com" title="WordPress.com">WordPress.com</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Abstraction%2C+intuition%2C+and+the+%22monad+tutorial+fallacy%22&amp;rft.aufirst=Brent&amp;rft.aulast=Yorgey&amp;rft.au=Yorgey%2C+Brent&amp;rft.date=January+12%2C+2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fbyorgey.wordpress.com%2F2009%2F01%2F12%2Fabstraction-intuition-and-the-monad-tutorial-fallacy%2F&amp;rft.jtitle=blog+%3A%3A+Brent+-%3E+%5BString%5D&amp;rft.pub=WordPress.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — Opposes the idea of making a tutorial about monads in particular.</li>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/What_a_Monad_is_not">What a Monad is not</a> deals with common misconceptions and oversimplifications in a humorous way.</li>
<li><span class="citation web">beelsebob (March 31, 2009). <a rel="nofollow" class="external text" href="http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/">"How you should(n’t) use Monad"</a>. <i>No Ordering</i>. <a href="/wiki/WordPress.com" title="WordPress.com">WordPress.com</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=How+you+should%28n%E2%80%99t%29+use+Monad&amp;rft.au=beelsebob&amp;rft.aulast=beelsebob&amp;rft.date=March+31%2C+2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fnoordering.wordpress.com%2F2009%2F03%2F31%2Fhow-you-shouldnt-use-monad%2F&amp;rft.jtitle=No+Ordering&amp;rft.pub=WordPress.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — Takes a similar point of view, locating monads in a much wider array of Haskell functor classes, of use only in special circumstances.</li>
<li><span class="citation web">Vanier, Mike (July 25, 2010). <a rel="nofollow" class="external text" href="http://mvanier.livejournal.com/3917.html">"Yet Another Monad Tutorial (part 1: basics)"</a>. <i>Mike's World-O-Programming</i>. <a href="/wiki/LiveJournal" title="LiveJournal">LiveJournal</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Yet+Another+Monad+Tutorial+%28part+1%3A+basics%29&amp;rft.aufirst=Mike&amp;rft.aulast=Vanier&amp;rft.au=Vanier%2C+Mike&amp;rft.date=July+25%2C+2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fmvanier.livejournal.com%2F3917.html&amp;rft.jtitle=Mike%27s+World-O-Programming&amp;rft.pub=LiveJournal&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span> — An extremely detailed set of tutorials, deriving monads from first principles.</li>
<li><span class="citation web"><a rel="nofollow" class="external text" href="http://learnyouahaskell.com/a-fistful-of-monads">"A Fistful of Monads"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=A+Fistful+of+Monads&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Flearnyouahaskell.com%2Fa-fistful-of-monads&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> An explanation of Monads, building on the concepts of Functors, Applicative Functors and Monoids discussed in the <a rel="nofollow" class="external text" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">previous chapter</a>.</li>
<li><a rel="nofollow" class="external text" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives and Monads in Pictures</a>. A humorous beginner's guide to monads.</li>
</ul>
<h4><span class="mw-headline" id="Older_tutorials">Older tutorials</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=32" title="Edit section: Older tutorials">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/All_About_Monads">All About Monads</a></li>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/Monads_as_computation">Haskell Wiki: Monads as Computation</a></li>
<li><a rel="nofollow" class="external text" href="http://haskell.org/haskellwiki/Monads_as_containers">Haskell Wiki: Monads as Containers</a></li>
<li><span class="citation web">Norvell, Theodore. <a rel="nofollow" class="external text" href="http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm">"Monads for the Working Haskell Programmer"</a>. Memorial University of Newfoundland.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Theodore&amp;rft.aulast=Norvell&amp;rft.au=Norvell%2C+Theodore&amp;rft.btitle=Monads+for+the+Working+Haskell+Programmer&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.engr.mun.ca%2F~theo%2FMisc%2Fhaskell_and_monads.htm&amp;rft.pub=Memorial+University+of+Newfoundland&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Klinger, Stefan (15 December 2005). <a rel="nofollow" class="external text" href="http://stefan-klinger.de/files/monadGuide.pdf">"The Haskell Programmer’s Guide to the IO Monad — Don’t Panic"</a> (5–54). Centre for Telematics and Information Technology, University of Twente. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/1381-3625">1381-3625</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Stefan&amp;rft.au=Klinger%2C+Stefan&amp;rft.aulast=Klinger&amp;rft.btitle=The+Haskell+Programmer%E2%80%99s+Guide+to+the+IO+Monad+%E2%80%94+Don%E2%80%99t+Panic&amp;rft.date=15+December+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fstefan-klinger.de%2Ffiles%2FmonadGuide.pdf&amp;rft.issn=1381-3625&amp;rft.issue=5%E2%80%9354&amp;rft.pub=Centre+for+Telematics+and+Information+Technology%2C+University+of+Twente&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Turoff, Adam (August 2, 2007). <a rel="nofollow" class="external text" href="http://onlamp.com/pub/a/onlamp/2007/08/02/introduction-to-haskell-pure-functions.html">"Introduction to Haskell, Part 3: Monads"</a>. <i>ONLamp</i>. O'Reilly Media.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Introduction+to+Haskell%2C+Part+3%3A+Monads&amp;rft.aufirst=Adam&amp;rft.aulast=Turoff&amp;rft.au=Turoff%2C+Adam&amp;rft.date=August+2%2C+2007&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fonlamp.com%2Fpub%2Fa%2Fonlamp%2F2007%2F08%2F02%2Fintroduction-to-haskell-pure-functions.html&amp;rft.jtitle=ONLamp&amp;rft.pub=O%27Reilly+Media&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
<li><a rel="nofollow" class="external text" href="http://spbhug.folding-maps.org/wiki/MonadsEn">Monads</a> A monad tutorial providing examples of non-trivial monads apart from the conventional IO/Maybe/List/State monads.</li>
<li><span class="citation web">Söylemez, Ertugrul (2010-07-11). <a rel="nofollow" class="external text" href="http://ertes.de/articles/monads.html">"Understanding Haskell Monads"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Ertugrul&amp;rft.aulast=S%C3%B6ylemez&amp;rft.au=S%C3%B6ylemez%2C+Ertugrul&amp;rft.btitle=Understanding+Haskell+Monads&amp;rft.date=2010-07-11&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fertes.de%2Farticles%2Fmonads.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h4><span class="mw-headline" id="Other_documentation">Other documentation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=33" title="Edit section: Other documentation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul>
<li><span class="citation web">van Tuyl, Henk-Jan (2010-02-27). <a rel="nofollow" class="external text" href="http://members.chello.nl/hjgtuyl/tourdemonad.html">"A tour of the Haskell monad functions"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Henk-Jan&amp;rft.aulast=van+Tuyl&amp;rft.au=van+Tuyl%2C+Henk-Jan&amp;rft.btitle=A+tour+of+the+Haskell+monad+functions&amp;rft.date=2010-02-27&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmembers.chello.nl%2Fhjgtuyl%2Ftourdemonad.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Moggi, Eugenio. <a rel="nofollow" class="external text" href="http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf">"Notions of computation and monads"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Eugenio&amp;rft.aulast=Moggi&amp;rft.au=Moggi%2C+Eugenio&amp;rft.btitle=Notions+of+computation+and+monads&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.disi.unige.it%2Fperson%2FMoggiE%2Fftp%2Fic91.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> — The original paper suggesting use of monads for programming</li>
<li><span class="citation journal"><a href="/wiki/Philip_Wadler" title="Philip Wadler">Wadler, Philip</a> (August 2001). <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">"Monads for functional programming"</a>. University of Glasgow.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Philip&amp;rft.aulast=Wadler&amp;rft.au=Wadler%2C+Philip&amp;rft.btitle=Monads+for+functional+programming&amp;rft.date=August+2001&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fhomepages.inf.ed.ac.uk%2Fwadler%2Fpapers%2Fmarktoberdorf%2Fbaastad.pdf&amp;rft.pub=University+of+Glasgow&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> — Describes monads in Haskell (before they were implemented)</li>
</ul>
<h3><span class="mw-headline" id="Scala_monad_tutorials">Scala monad tutorials</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=34" title="Edit section: Scala monad tutorials">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><span class="citation audio-visual">League, Chris (July 12, 2010). <a rel="nofollow" class="external text" href="http://vimeo.com/13304075"><i>Monadologie: Professional Help for Type Anxiety</i></a> (flv) (Tech talk). <a href="/wiki/New_York_City" title="New York City">New York City</a>: New York Scala Enthusiasts.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.btitle=Monadologie%3A+Professional+Help+for+Type+Anxiety&amp;rft.date=July+12%2C+2010&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fvimeo.com%2F13304075&amp;rft.place=New+York+City&amp;rft.pub=New+York+Scala+Enthusiasts&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Morris, Tony (June 22, 2010). <a rel="nofollow" class="external text" href="http://blog.tmorris.net/posts/understanding-monads-using-scala-part-1/index.html">"Understanding Monads using Scala (Part 1)"</a>. <i>λ Tony’s blog λ</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.atitle=Understanding+Monads+using+Scala+%28Part+1%29&amp;rft.aufirst=Tony&amp;rft.aulast=Morris&amp;rft.au=Morris%2C+Tony&amp;rft.date=June+22%2C+2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fblog.tmorris.net%2Fposts%2Funderstanding-monads-using-scala-part-1%2Findex.html&amp;rft.jtitle=%CE%BB+Tony%E2%80%99s+blog+%CE%BB&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Iry, James (September 18, 2007). <a rel="nofollow" class="external text" href="http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html">"Monads are Elephants"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=James&amp;rft.au=Iry%2C+James&amp;rft.aulast=Iry&amp;rft.btitle=Monads+are+Elephants&amp;rft.date=September+18%2C+2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fjames-iry.blogspot.com%2F2007%2F09%2Fmonads-are-elephants-part-1.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Meredith, Gregory (April 25, 2010). <a rel="nofollow" class="external text" href="https://github.com/leithaus/XTrace/blob/monadic/src/main/book/content/monadic.pdf">"Pro Scala: Monadic Design Patterns for the Web"</a> (1st ed.). p. 300.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMonad+%28functional+programming%29&amp;rft.aufirst=Gregory&amp;rft.aulast=Meredith&amp;rft.au=Meredith%2C+Gregory&amp;rft.btitle=Pro+Scala%3A+Monadic+Design+Patterns+for+the+Web&amp;rft.date=April+25%2C+2010&amp;rft.edition=1st&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fgithub.com%2Fleithaus%2FXTrace%2Fblob%2Fmonadic%2Fsrc%2Fmain%2Fbook%2Fcontent%2Fmonadic.pdf&amp;rft.pages=300&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h3><span class="mw-headline" id="Monads_in_other_languages">Monads in other languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Monad_(functional_programming)&amp;action=edit&amp;section=35" title="Edit section: Monads in other languages">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><a rel="nofollow" class="external text" href="http://web.archive.org/web/20080515195640/http://sleepingsquirrel.org/monads/monads.html">Monads in Perl</a></li>
<li><a rel="nofollow" class="external text" href="http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html">Monads in Ruby</a></li>
<li><a rel="nofollow" class="external text" href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html">Monads in Python</a></li>
<li><a rel="nofollow" class="external text" href="http://lamp.epfl.ch/~emir/bqbase/2005/01/20/monad.html">Monads in Scala</a></li>
<li><a rel="nofollow" class="external text" href="http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/">Monads in Clojure</a></li>
<li><a rel="nofollow" class="external text" href="http://labs.mudynamics.com/2009/05/13/monadic-parser-in-javascript/">Monads in JavaScript</a></li>
<li><a rel="nofollow" class="external text" href="http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">Introduction to monads in C# and LINQ</a></li>
<li><a rel="nofollow" class="external text" href="https://github.com/louthy/csharp-monad">Library of monads for C#</a></li>
<li><a rel="nofollow" class="external text" href="http://blog.enfranchisedmind.com/2007/08/a-monad-tutorial-for-ocaml/">Monads in Ocaml</a></li>
<li><a rel="nofollow" class="external text" href="http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html">Monads in PHP</a></li>
</ul>
