<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Answer set programming</span></h1>
<ul>
<li><a href="/wiki/Action_language" title="Action language">Action</a></li>
<li><a href="/wiki/Agent-oriented_programming" title="Agent-oriented programming">Agent-oriented</a></li>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Automata-based_programming" title="Automata-based programming">Automata-based</a></li>
<li><a href="/wiki/Concurrent_computing" title="Concurrent computing">Concurrent computing</a>
<ul>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
</ul>
</li>
<li><a href="/wiki/Data-driven_programming" title="Data-driven programming">Data-driven</a></li>
<li><a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a> (contrast: <a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a>)
<ul>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a></li>
<li><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
</li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional</a>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
</li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic</a>
<ul>
<li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><strong class="selflink">Answer set</strong></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
</ul>
</li>
<li><a href="/wiki/Relational_programming" title="Relational programming">Relational</a></li>
</ul>
</li>
<li><a href="/wiki/End-user_development" title="End-user development">End-user programming</a></li>
<li><a href="/wiki/Event-driven_programming" title="Event-driven programming">Event-driven</a>
<ul>
<li><a href="/wiki/Service-oriented_architecture" title="Service-oriented architecture">Service-oriented</a></li>
<li><a href="/wiki/Time-driven_programming" title="Time-driven programming">Time-driven</a></li>
</ul>
</li>
<li><a href="/wiki/Expression-oriented_programming_language" title="Expression-oriented programming language">Expression-oriented</a></li>
<li><a href="/wiki/Feature-oriented_programming" title="Feature-oriented programming">Feature-oriented</a></li>
<li><a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a> (contrast: <a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a>)</li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a> (contrast: <a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a>)
<ul>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
</ul>
</li>
<li><a href="/wiki/Language-oriented_programming" title="Language-oriented programming">Language-oriented</a>
<ul>
<li><a href="/wiki/Natural_language_programming" title="Natural language programming">Natural language programming</a></li>
<li><a href="/wiki/Service-oriented_modeling#Discipline-specific_modeling" title="Service-oriented modeling">Discipline-specific</a></li>
<li><a href="/wiki/Domain-specific_language" title="Domain-specific language">Domain-specific</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
</li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
</ul>
</li>
<li><a href="/wiki/Metaprogramming" title="Metaprogramming">Metaprogramming</a>
<ul>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a></li>
<li><a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">Reflective</a>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a> (contrast: <a href="/wiki/Structured_programming" title="Structured programming">Structured</a>)
<ul>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
</ul>
</li>
<li><a href="/wiki/Nondeterministic_programming" title="Nondeterministic programming">Nondeterministic</a></li>
<li><a href="/wiki/Parallel_computing" title="Parallel computing">Parallel computing</a>
<ul>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Tacit_programming" title="Tacit programming">Point-free style</a>
<ul>
<li><a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
</ul>
</li>
<li><a href="/wiki/Semantic-oriented_programming" title="Semantic-oriented programming">Semantic</a></li>
<li><a href="/wiki/Structured_programming" title="Structured programming">Structured</a> (contrast: <a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a>)
<ul>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a> (contrast: <a href="/wiki/Monolithic_application" title="Monolithic application">Monolithic</a>)</li>
<li><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented (OOP)</a>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
</li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
</ul>
</li>
<li><a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a> (contrast: <a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a>)</li>
<li><a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">Probabilistic</a></li>
<li><a href="/wiki/Concept_programming" title="Concept programming">Concept</a></li>
</ul>
<ul>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
</ul>
<ul>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a></li>
<li><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
</li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional</a>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
</li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic</a>
<ul>
<li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><strong class="selflink">Answer set</strong></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
</ul>
</li>
<li><a href="/wiki/Relational_programming" title="Relational programming">Relational</a></li>
</ul>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
<ul>
<li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><strong class="selflink">Answer set</strong></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
</ul>
<ul>
<li><a href="/wiki/Service-oriented_architecture" title="Service-oriented architecture">Service-oriented</a></li>
<li><a href="/wiki/Time-driven_programming" title="Time-driven programming">Time-driven</a></li>
</ul>
<ul>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
</ul>
<ul>
<li><a href="/wiki/Natural_language_programming" title="Natural language programming">Natural language programming</a></li>
<li><a href="/wiki/Service-oriented_modeling#Discipline-specific_modeling" title="Service-oriented modeling">Discipline-specific</a></li>
<li><a href="/wiki/Domain-specific_language" title="Domain-specific language">Domain-specific</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
</li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
</ul>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
<ul>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a></li>
<li><a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">Reflective</a>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
<ul>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
</ul>
<ul>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
</ul>
<ul>
<li><a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
</ul>
<ul>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a> (contrast: <a href="/wiki/Monolithic_application" title="Monolithic application">Monolithic</a>)</li>
<li><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented (OOP)</a>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
</li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
</ul>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Programming_paradigms" title="Template:Programming paradigms"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Programming_paradigms" title="Template talk:Programming paradigms"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p><b>Answer set programming</b> (ASP) is a form of <a href="/wiki/Declarative_programming" title="Declarative programming">declarative programming</a> oriented towards difficult (primarily <a href="/wiki/NP-hard" title="NP-hard">NP-hard</a>) <a href="/wiki/Search_algorithm" title="Search algorithm">search problems</a>. It is based on the <a href="/wiki/Stable_model_semantics" title="Stable model semantics">stable model</a> (answer set) semantics of <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a>. In ASP, search problems are reduced to computing stable models, and <i>answer set solvers</i> — programs for generating stable models—are used to perform search. The computational process employed in the design of many answer set solvers is an enhancement of the <a href="/wiki/DPLL_algorithm" title="DPLL algorithm">DPLL algorithm</a> and, in principle, it always terminates (unlike <a href="/wiki/Prolog" title="Prolog">Prolog</a> query evaluation, which may lead to an <a href="/wiki/Infinite_loop" title="Infinite loop">infinite loop</a>).</p>
<p>In a more general sense, ASP includes all applications of answer sets to <a href="/wiki/Knowledge_representation" title="Knowledge representation" class="mw-redirect">knowledge representation</a><sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> and the use of Prolog-style query evaluation for solving problems arising in these applications.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Answer_set_programming_language_AnsProlog"><span class="tocnumber">2</span> <span class="toctext">Answer set programming language AnsProlog</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Generating_stable_models"><span class="tocnumber">3</span> <span class="toctext">Generating stable models</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Examples_of_ASP_programs"><span class="tocnumber">4</span> <span class="toctext">Examples of ASP programs</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Graph_coloring"><span class="tocnumber">4.1</span> <span class="toctext">Graph coloring</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Large_clique"><span class="tocnumber">4.2</span> <span class="toctext">Large clique</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Hamiltonian_cycle"><span class="tocnumber">4.3</span> <span class="toctext">Hamiltonian cycle</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Comparison_of_implementations"><span class="tocnumber">5</span> <span class="toctext">Comparison of implementations</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#External_links"><span class="tocnumber">8</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Graph_coloring"><span class="tocnumber">4.1</span> <span class="toctext">Graph coloring</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Large_clique"><span class="tocnumber">4.2</span> <span class="toctext">Large clique</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Hamiltonian_cycle"><span class="tocnumber">4.3</span> <span class="toctext">Hamiltonian cycle</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/Automated_planning_and_scheduling" title="Automated planning and scheduling">planning</a> method proposed in 1993 by Dimopoulos, Nebel and Köhler<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> is an early example of answer set programming. Their approach is based on the relationship between plans and stable models.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> Soininen and Niemelä<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> applied what is now known as answer set programming to the problem of product configuration. The use of answer set solvers for search was identified as a new programming paradigm by Marek and Truszczyński in a paper that appeared in a 25-year perspective on the logic programming paradigm published in 1999 <sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> and in [Niemelä 1999].<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> Indeed, the new terminology of "answer set" instead of "stable model" was first proposed by Lifschitz<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup> in a paper appearing in the same retrospective volume as the Marek-Truszczynski paper.</p>
<h2><span class="mw-headline" id="Answer_set_programming_language_AnsProlog">Answer set programming language AnsProlog</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=2" title="Edit section: Answer set programming language AnsProlog">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a rel="nofollow" class="external text" href="http://www.tcs.hut.fi/Software/smodels/lparse.ps">Lparse</a> is the name of the program that was originally created as grounding tool (front-end) for the answer set solver <a rel="nofollow" class="external text" href="http://www.tcs.hut.fi/Software/smodels/">smodels</a>. The language that Lparse accepts is now commonly called AnsProlog*,<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup> short for <i>Answer Set Programming in Logic</i>.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup> It is now used in the same way in many other answer set solvers, including <a rel="nofollow" class="external text" href="http://assat.cs.ust.hk/">assat</a>, <a rel="nofollow" class="external text" href="http://www.cs.uni-potsdam.de/clasp/">clasp</a>, <a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/users/tag/cmodels/">cmodels</a>, <a rel="nofollow" class="external text" href="http://www.tcs.hut.fi/Software/gnt/">gNt</a>, <a rel="nofollow" class="external text" href="http://www.cs.uni-potsdam.de/nomore/">nomore++</a> and <a rel="nofollow" class="external text" href="http://www.cs.uky.edu/ai/pbmodels/">pbmodels</a>. (<a rel="nofollow" class="external text" href="http://www.dbai.tuwien.ac.at/proj/dlv/">dlv</a> is an exception; the syntax of ASP programs written for dlv is somewhat different.)</p>
<p>An AnsProlog program consists of rules of the form</p>
<p>WHATSON? 51bd1e89-acc7-41d4-b63a-4fe5f52413d5</p>
<pre class="de1">
<span class="sy6">&lt;</span>head<span class="sy6">&gt;</span> <span class="sy1">:-</span> <span class="sy6">&lt;</span>body<span class="sy6">&gt;</span> <span class="sy4">.</span>
</pre>
<p>The symbol <code>:-</code> ("if") is dropped if <code>&lt;body&gt;</code> is empty; such rules are called <i>facts</i>. The simplest kind of Lparse rules are <a href="/wiki/Stable_model_semantics#Programs_with_constraints" title="Stable model semantics">rules with constraints</a>.</p>
<p>One other useful construct included in this language is <i>choice</i>. For instance, the choice rule</p>
<p>WHATSON? f09a09ab-7f6f-4d02-99cc-02d4db3f69ea</p>
<pre class="de1">
<span class="br0">{</span>p<span class="sy4">,</span>q<span class="sy4">,</span>r<span class="br0">}</span><span class="sy4">.</span>
</pre>
<p>says: choose arbitrarily which of the atoms <img class="mwe-math-fallback-image-inline tex" alt="p,q,r" src="//upload.wikimedia.org/math/f/8/2/f822943e0c6b5002a4eb16d73ae5e391.png"> to include in the stable model. The lparse program that contains this choice rule and no other rules has 8 stable models—arbitrary subsets of <img class="mwe-math-fallback-image-inline tex" alt="\{p,q,r\}" src="//upload.wikimedia.org/math/e/7/8/e780192ee1f3747772125f9ea037a538.png">. The definition of a stable model was generalized to programs with choice rules.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> Choice rules can be treated also as abbreviations for <a href="/wiki/Stable_model_semantics#Stable_models_of_a_set_of_propositional_formulas" title="Stable model semantics">propositional formulas under the stable model semantics</a>.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup> For instance, the choice rule above can be viewed as shorthand for the conjunction of three "<a href="/wiki/Excluded_middle" title="Excluded middle" class="mw-redirect">excluded middle</a>" formulas:</p>
<p>The language of lparse allows us also to write "constrained" choice rules, such as</p>
<p>WHATSON? d1f0f90a-a431-45b9-b760-742f0853ac9e</p>
<pre class="de1">
<span class="nu0">1</span><span class="br0">{</span>p<span class="sy4">,</span>q<span class="sy4">,</span>r<span class="br0">}</span><span class="nu0">2</span><span class="sy4">.</span>
</pre>
<p>This rule says: choose at least 1 of the atoms <img class="mwe-math-fallback-image-inline tex" alt="p,q,r" src="//upload.wikimedia.org/math/f/8/2/f822943e0c6b5002a4eb16d73ae5e391.png">, but not more than 2. The meaning of this rule under the stable model semantics is represented by the <a href="/wiki/Propositional_formula" title="Propositional formula">propositional formula</a></p>
<p>Cardinality bounds can be used in the body of a rule as well, for instance:</p>
<p>WHATSON? 27f5eb7f-2261-411f-bd96-6262df4e6157</p>
<pre class="de1">
<span class="sy1">:-</span> <span class="nu0">2</span><span class="br0">{</span>p<span class="sy4">,</span>q<span class="sy4">,</span>r<span class="br0">}</span><span class="sy4">.</span>
</pre>
<p>Adding this constraint to an Lparse program eliminates the stable models that contain at least 2 of the atoms <img class="mwe-math-fallback-image-inline tex" alt="p,q,r" src="//upload.wikimedia.org/math/f/8/2/f822943e0c6b5002a4eb16d73ae5e391.png">. The meaning of this rule can be represented by the propositional formula</p>
<p>Variables (capitalized, as in <a href="/wiki/Prolog#Data_types" title="Prolog">Prolog</a>) are used in Lparse to abbreviate collections of rules that follow the same pattern, and also to abbreviate collections of atoms within the same rule. For instance, the Lparse program</p>
<p>WHATSON? 17754fbf-abdd-494b-a5c8-d4f523b6d34d</p>
<pre class="de1">
p<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>c<span class="br0">)</span><span class="sy4">.</span>
q<span class="br0">(</span>X<span class="br0">)</span> <span class="sy1">:-</span> p<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">,</span> X<span class="sy5">!</span><span class="sy6">=</span>a<span class="sy4">.</span>
</pre>
<p>has the same meaning as</p>
<p>WHATSON? 88ffb3ce-55a9-4c45-9e37-54e7d63fee49</p>
<pre class="de1">
p<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>c<span class="br0">)</span><span class="sy4">.</span>
q<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">.</span> q<span class="br0">(</span>c<span class="br0">)</span><span class="sy4">.</span>
</pre>
<p>The program</p>
<p>WHATSON? 9ed46e29-5a50-418c-a3a4-6408a47b5698</p>
<pre class="de1">
p<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>c<span class="br0">)</span><span class="sy4">.</span>
<span class="br0">{</span>q<span class="br0">(</span>X<span class="br0">)</span><span class="sy1">:-</span>p<span class="br0">(</span>X<span class="br0">)</span><span class="br0">}</span><span class="nu0">2</span><span class="sy4">.</span>
</pre>
<p>is shorthand for</p>
<p>WHATSON? 772ab5ba-0db0-4794-a5e1-129cfb5fd325</p>
<pre class="de1">
p<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">.</span> p<span class="br0">(</span>c<span class="br0">)</span><span class="sy4">.</span>
<span class="br0">{</span>q<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">,</span>q<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">,</span>q<span class="br0">(</span>c<span class="br0">)</span><span class="br0">}</span><span class="nu0">2</span><span class="sy4">.</span>
</pre>
<h2><span class="mw-headline" id="Generating_stable_models">Generating stable models</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=3" title="Edit section: Generating stable models">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To find a stable model of the Lparse program stored in file <code>&lt;filename&gt;</code> we use the command</p>
<p>WHATSON? 5b4140bc-4c82-4823-8dd6-89ef0b2cfe9b</p>
<pre class="de1">
<span class="sy0">%</span> lparse <span class="sy0">&lt;</span>filename<span class="sy0">&gt;</span> <span class="sy0">|</span> smodels
</pre>
<p>Option 0 instructs smodels to find <i>all</i> stable models of the program. For instance, if file <code>test</code> contains the rules</p>
<p>WHATSON? 6ac2bd46-babd-4d4b-81a7-7fa5dfe7ff4d</p>
<pre class="de1">
<span class="nu0">1</span><span class="br0">{</span>p<span class="sy4">,</span>q<span class="sy4">,</span>r<span class="br0">}</span><span class="nu0">2</span><span class="sy4">.</span>
s <span class="sy1">:-</span> not p<span class="sy4">.</span>
</pre>
<p>then the command</p>
<p>WHATSON? 7334830b-dd7e-491d-b6a7-605aad75ab43</p>
<pre class="de1">
<span class="sy0">%</span> lparse <span class="kw3">test</span> <span class="sy0">|</span> smodels <span class="nu0">0</span>
</pre>
<p>produces the output</p>
<p>WHATSON? 49192a8e-6f6f-478f-816f-cf6625a6042a</p>
<pre class="de1">
Answer: 1
Stable Model: q p 
Answer: 2
Stable Model: p 
Answer: 3
Stable Model: r p 
Answer: 4
Stable Model: q s 
Answer: 5
Stable Model: r s 
Answer: 6
Stable Model: r q s
</pre>
<h2><span class="mw-headline" id="Examples_of_ASP_programs">Examples of ASP programs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=4" title="Edit section: Examples of ASP programs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Graph_coloring">Graph coloring</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=5" title="Edit section: Graph coloring">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-<a href="/wiki/Graph_coloring" title="Graph coloring">coloring</a> of a <a href="/wiki/Graph_(mathematics)" title="Graph (mathematics)">graph</a> <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png"> is a function <img class="mwe-math-fallback-image-inline tex" alt="color\ " src="//upload.wikimedia.org/math/0/8/a/08a31d631f1f0e371e354b024649cfea.png"> from its set of vertices to <img class="mwe-math-fallback-image-inline tex" alt="\{1,\dots,n\}" src="//upload.wikimedia.org/math/7/f/5/7f5344e7d30be028726e79563bbee4fb.png"> such that <img class="mwe-math-fallback-image-inline tex" alt="color(x)\neq color(y)" src="//upload.wikimedia.org/math/7/6/3/7638657fc61fa4bf9f374c1a95f2dbee.png"> for every pair of adjacent vertices <img class="mwe-math-fallback-image-inline tex" alt="x,y" src="//upload.wikimedia.org/math/f/1/0/f10bc3c94b77e1d6b9f98106daf335c1.png">. We would like to use ASP to find an <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-coloring of a given graph (or determine that it does not exist).</p>
<p>This can be accomplished using the following Lparse program:</p>
<p>WHATSON? 51c82748-f2aa-4ade-98dd-fae7e48ffb80</p>
<pre class="de1">
c<span class="br0">(</span><span class="nu0">1</span><span class="sy4">..</span>n<span class="br0">)</span><span class="sy4">.</span>                                           
<span class="nu0">1</span> <span class="br0">{</span>color<span class="br0">(</span>X<span class="sy4">,</span>I<span class="br0">)</span> <span class="sy4">:</span> c<span class="br0">(</span>I<span class="br0">)</span><span class="br0">}</span> <span class="nu0">1</span> <span class="sy1">:-</span> v<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">.</span>             
<span class="sy1">:-</span> color<span class="br0">(</span>X<span class="sy4">,</span>I<span class="br0">)</span><span class="sy4">,</span> color<span class="br0">(</span>Y<span class="sy4">,</span>I<span class="br0">)</span><span class="sy4">,</span> e<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="sy4">,</span> c<span class="br0">(</span>I<span class="br0">)</span><span class="sy4">.</span>
</pre>
<p>Line 1 defines the numbers <img class="mwe-math-fallback-image-inline tex" alt="1,\dots,n" src="//upload.wikimedia.org/math/3/9/d/39d4af9a3089186a26fe4b87d91c9279.png"> to be colors. According to the choice rule in Line 2, a unique color <img class="mwe-math-fallback-image-inline tex" alt="i" src="//upload.wikimedia.org/math/8/6/5/865c0c0b4ab0e063e5caa3387c1a8741.png"> should be assigned to each vertex <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png">. The constraint in Line 3 prohibits assigning the same color to vertices <img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> and <img class="mwe-math-fallback-image-inline tex" alt="y" src="//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png"> if there is an edge connecting them.</p>
<p>If we combine this file with a definition of <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png">, such as</p>
<p>WHATSON? b1aca9da-150b-43da-bdc5-ff2a2ba1bcba</p>
<pre class="de1">
v<span class="br0">(</span><span class="nu0">1</span><span class="sy4">..</span><span class="nu0">100</span><span class="br0">)</span><span class="sy4">.</span> <span class="co1">% 1,...,100 are vertices</span>
e<span class="br0">(</span><span class="nu0">1</span><span class="sy4">,</span><span class="nu0">55</span><span class="br0">)</span><span class="sy4">.</span> <span class="co1">% there is an edge from 1 to 55</span>
<span class="sy4">.</span> <span class="sy4">.</span> <span class="sy4">.</span>
</pre>
<p>and run smodels on it, with the numeric value of <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> specified on the command line, then the atoms of the form <img class="mwe-math-fallback-image-inline tex" alt="color(\dots,\dots)" src="//upload.wikimedia.org/math/6/4/c/64c0673f265ab35daae68991e5aa735b.png"> in the output of smodels will represent an <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-coloring of <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png">.</p>
<p>The program in this example illustrates the "generate-and-test" organization that is often found in simple ASP programs. The choice rule describes a set of "potential solutions" — a simple superset of the set of solutions to the given search problem. It is followed by a constraint, which eliminates all potential solutions that are not acceptable. However, the search process employed by smodels and other answer set solvers is not based on <a href="/wiki/Trial_and_error" title="Trial and error">trial and error</a>.</p>
<h3><span class="mw-headline" id="Large_clique">Large clique</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=6" title="Edit section: Large clique">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <a href="/wiki/Clique_(graph_theory)" title="Clique (graph theory)">clique</a> in a graph is a set of pairwise adjacent vertices. The following lparse program finds a clique of size <img class="mwe-math-fallback-image-inline tex" alt="\geq n" src="//upload.wikimedia.org/math/a/5/6/a5646a3abb821d8273287bc2035c9b73.png"> in a given graph, or determines that it does not exist:</p>
<p>WHATSON? 40becf70-1bf9-40b7-8d61-aff57728b147</p>
<pre class="de1">
n <span class="br0">{</span>in<span class="br0">(</span>X<span class="br0">)</span> <span class="sy4">:</span> v<span class="br0">(</span>X<span class="br0">)</span><span class="br0">}</span><span class="sy4">.</span>
<span class="sy1">:-</span> in<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">,</span> in<span class="br0">(</span>Y<span class="br0">)</span><span class="sy4">,</span> v<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">,</span> v<span class="br0">(</span>Y<span class="br0">)</span><span class="sy4">,</span> X<span class="sy5">!</span><span class="sy6">=</span>Y<span class="sy4">,</span> not e<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="sy4">,</span> not e<span class="br0">(</span>Y<span class="sy4">,</span>X<span class="br0">)</span><span class="sy4">.</span>
</pre>
<p>This is another example of the generate-and-test organization. The choice rule in Line 1 "generates" all sets consisting of <img class="mwe-math-fallback-image-inline tex" alt="\geq n" src="//upload.wikimedia.org/math/a/5/6/a5646a3abb821d8273287bc2035c9b73.png"> vertices. The constraint in Line 2 "weeds out" the sets that are not cliques.</p>
<h3><span class="mw-headline" id="Hamiltonian_cycle">Hamiltonian cycle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=7" title="Edit section: Hamiltonian cycle">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <a href="/wiki/Hamiltonian_cycle" title="Hamiltonian cycle" class="mw-redirect">Hamiltonian cycle</a> in a <a href="/wiki/Directed_graph" title="Directed graph">directed graph</a> is a <a href="/wiki/Path_(graph_theory)" title="Path (graph theory)">cycle</a> that passes through each vertex of the graph exactly once. The following Lparse program can be used to find a Hamiltonian cycle in a given directed graph if it exists; we assume that 0 is one of the vertices.</p>
<p>WHATSON? 5364038e-4878-4de3-9257-24d4bddabc21</p>
<pre class="de1">
<span class="br0">{</span>in<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="br0">}</span> <span class="sy1">:-</span> e<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="sy4">.</span>
 
<span class="sy1">:-</span> <span class="nu0">2</span> <span class="br0">{</span>in<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span> <span class="sy4">:</span> e<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="br0">}</span><span class="sy4">,</span> v<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">.</span>
<span class="sy1">:-</span> <span class="nu0">2</span> <span class="br0">{</span>in<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span> <span class="sy4">:</span> e<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="br0">}</span><span class="sy4">,</span> v<span class="br0">(</span>Y<span class="br0">)</span><span class="sy4">.</span>
 
r<span class="br0">(</span>X<span class="br0">)</span> <span class="sy1">:-</span> in<span class="br0">(</span><span class="nu0">0</span><span class="sy4">,</span>X<span class="br0">)</span><span class="sy4">,</span> v<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">.</span>
r<span class="br0">(</span>Y<span class="br0">)</span> <span class="sy1">:-</span> r<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">,</span> in<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="sy4">,</span> e<span class="br0">(</span>X<span class="sy4">,</span>Y<span class="br0">)</span><span class="sy4">.</span>
 
<span class="sy1">:-</span> not r<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">,</span> v<span class="br0">(</span>X<span class="br0">)</span><span class="sy4">.</span>
</pre>
<p>The choice rule in Line 1 "generates" all subsets of the set of edges. The three constraints "weed out" the subsets that are not Hamiltonian cycles. The last of them uses the auxiliary predicate <img class="mwe-math-fallback-image-inline tex" alt="r(x)" src="//upload.wikimedia.org/math/7/f/0/7f0562b7361b94feb27ee472a1cbc253.png"> ("<img class="mwe-math-fallback-image-inline tex" alt="x" src="//upload.wikimedia.org/math/9/d/d/9dd4e461268c8034f5c8564e155c67a6.png"> is reachable from 0") to prohibit the vertices that do not satisfy this condition. This predicate is defined recursively in Lines 4 and 5.</p>
<p>This program is an example of the more general "generate, define and test" organization: it includes the definition of an auxiliary predicate that helps us eliminate all "bad" potential solutions.</p>
<h2><span class="mw-headline" id="Comparison_of_implementations">Comparison of implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=8" title="Edit section: Comparison of implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Early systems, such as Smodels, used backtracking to find solutions. As the theory and practice of <a href="/wiki/Boolean_SAT_solver" title="Boolean SAT solver" class="mw-redirect">Boolean SAT solvers</a> evolved, a number of ASP solvers were built on top of SAT solvers, including ASSAT and Cmodels. These converted ASP formula into SAT propositions, applied the SAT solver, and then converted the solutions back to ASP form. More recent systems, such as Clasp, use a hybrid approach, using conflict-driven algorithms inspired by SAT, without full converting into a boolean-logic form. These approaches allow for significant improvements of performance, often by an order of magnitude, over earlier backtracking algorithms.</p>
<p>The <a rel="nofollow" class="external text" href="http://potassco.sourceforge.net/">Potassco</a> project acts as an umbrella for many of the systems below, including <i>clasp</i>, grounding systems (<i>gringo</i>), incremental systems (<i>iclingo</i>), constraint solvers (<i>clingcon</i>), <a href="/wiki/Action_language" title="Action language">action language</a> to ASP compilers (<i>coala</i>), distributed MPI implementations (<i>claspar</i>), and many others.</p>
<p>Most systems support variables, but only indirectly, by forcing grounding, by using a grounding system such as <i>Lparse</i> or <i>gringo</i> as a front end. The need for grounding can cause a combinatorial explosion of clauses; thus, systems that perform on-the-fly grounding might have an advantage.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=9" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Default_logic" title="Default logic">Default logic</a></li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic programming</a></li>
<li><a href="/wiki/Non-monotonic_logic" title="Non-monotonic logic">Non-monotonic logic</a></li>
<li><a href="/wiki/Prolog" title="Prolog">Prolog</a></li>
<li><a href="/wiki/Stable_model_semantics" title="Stable model semantics">Stable model semantics</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=10" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation book">Baral, Chitta (2003). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=iTS4ZdEpGZQC"><i>Knowledge Representation, Reasoning and Declarative Problem Solving</i></a>. Cambridge University Press. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-521-81802-5" title="Special:BookSources/978-0-521-81802-5">978-0-521-81802-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.au=Baral%2C+Chitta&amp;rft.aufirst=Chitta&amp;rft.aulast=Baral&amp;rft.btitle=Knowledge+Representation%2C+Reasoning+and+Declarative+Problem+Solving&amp;rft.date=2003&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DiTS4ZdEpGZQC&amp;rft.isbn=978-0-521-81802-5&amp;rft.pub=Cambridge+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation book">Gelfond, Michael (2008). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=xwBDylHhJhYC&amp;pg=PA285">"Answer sets"</a>. In van Harmelen, Frank; Lifschitz, Vladimir; Porter, Bruce. <i>Handbook of Knowledge Representation</i>. Elsevier. pp. 285–316. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-08-055702-1" title="Special:BookSources/978-0-08-055702-1">978-0-08-055702-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=Handbook+of+Knowledge+Representation&amp;rft.aufirst=Michael&amp;rft.au=Gelfond%2C+Michael&amp;rft.aulast=Gelfond&amp;rft.btitle=Answer+sets&amp;rft.date=2008&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DxwBDylHhJhYC%26pg%3DPA285&amp;rft.isbn=978-0-08-055702-1&amp;rft.pages=285-316&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> <a rel="nofollow" class="external text" href="http://www.depts.ttu.edu/cs/research/krlab/pdfs/papers/gel07b.pdf">as PDF</a></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation book">Dimopoulos, Y.; <a href="/wiki/Bernhard_Nebel" title="Bernhard Nebel">Nebel, B.</a>; Köhler, J. (1997). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=QSBoQgAACAAJ">"Encoding planning problems in non-monotonic logic programs"</a>. In Steel, Sam; Alami, Rachid. <i>Recent Advances in AI Planning: 4th European Conference on Planning, ECP'97, Toulouse, France, September 24–26, 1997, Proceedings</i>. Lecture notes in computer science: Lecture notes in artificial intelligence <b>1348</b>. Springer. pp. 273–285. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-63912-1" title="Special:BookSources/978-3-540-63912-1">978-3-540-63912-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=Recent+Advances+in+AI+Planning%3A+4th+European+Conference+on+Planning%2C+ECP%2797%2C+Toulouse%2C+France%2C+September+24%E2%80%9326%2C+1997%2C+Proceedings&amp;rft.au=Dimopoulos%2C+Y.&amp;rft.aufirst=Y.&amp;rft.au=K%C3%B6hler%2C+J.&amp;rft.aulast=Dimopoulos&amp;rft.au=Nebel%2C+B.&amp;rft.btitle=Encoding+planning+problems+in+non-monotonic+logic+programs&amp;rft.date=1997&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DQSBoQgAACAAJ&amp;rft.isbn=978-3-540-63912-1&amp;rft.pages=273-285&amp;rft.pub=Springer&amp;rft.series=Lecture+notes+in+computer+science%3A+Lecture+notes+in+artificial+intelligence&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=1348" class="Z3988"><span style="display:none;"> </span></span> <a rel="nofollow" class="external text" href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/ki/dimopoulos-etal-ecp97.ps.gz">as Postscript</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Subrahmanian, V.S.; Zaniolo, C. (1995). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=vpGEyZWP1dYC&amp;pg=PA233">"Relating stable models and AI planning domains"</a>. In Sterling, Leon. <i>Logic Programming: Proceedings of the Twelfth International Conference on Logic Programming</i>. MIT Press. pp. 233–247. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-262-69177-2" title="Special:BookSources/978-0-262-69177-2">978-0-262-69177-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=Logic+Programming%3A+Proceedings+of+the+Twelfth+International+Conference+on+Logic+Programming&amp;rft.aufirst=V.S.&amp;rft.aulast=Subrahmanian&amp;rft.au=Subrahmanian%2C+V.S.&amp;rft.au=Zaniolo%2C+C.&amp;rft.btitle=Relating+stable+models+and+AI+planning+domains&amp;rft.date=1995&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DvpGEyZWP1dYC%26pg%3DPA233&amp;rft.isbn=978-0-262-69177-2&amp;rft.pages=233-247&amp;rft.pub=MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> <a rel="nofollow" class="external text" href="http://www.cs.ucla.edu/%7Ezaniolo/papers/iclp95.ps">as Postscript</a></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span id="CITEREFSoininenNiemel.C3.A41998" class="citation">Soininen, T.; Niemelä, I. (1998), <a rel="nofollow" class="external text" href="http://www.tcs.hut.fi/~ini/papers/sn-faanmr98.ps.gz"><i>Formalizing configuration knowledge using rules with choices</i></a> (Postscript) (TKO-B142), Laboratory of Information Processing Science, Helsinki University of Technology</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.aufirst=T.&amp;rft.aulast=Soininen&amp;rft.au=Niemel%C3%A4%2C+I.&amp;rft.au=Soininen%2C+T.&amp;rft.btitle=Formalizing+configuration+knowledge+using+rules+with+choices&amp;rft.date=1998&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.tcs.hut.fi%2F~ini%2Fpapers%2Fsn-faanmr98.ps.gz&amp;rft.issue=TKO-B142&amp;rft.pub=Laboratory+of+Information+Processing+Science%2C+Helsinki+University+of+Technology&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span id="CITEREFApt1999" class="citation book">Marek, V.; Truszczyński, M. (1999). <a rel="nofollow" class="external text" href="http://xxx.lanl.gov/pdf/cs/9809032">"Stable models and an alternative logic programming paradigm"</a>. In Apt, Krzysztof R. <a rel="nofollow" class="external text" href="http://books.google.com/books?id=GIhQAAAAMAAJ"><i>The Logic programming paradigm: a 25-year perspective</i></a> (PDF). Springer. pp. 169–181. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-65463-6" title="Special:BookSources/978-3-540-65463-6">978-3-540-65463-6</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=The+Logic+programming+paradigm%3A+a+25-year+perspective&amp;rft.aufirst=V.&amp;rft.aulast=Marek&amp;rft.au=Marek%2C+V.&amp;rft.au=Truszczy%C5%84ski%2C+M.&amp;rft.btitle=Stable+models+and+an+alternative+logic+programming+paradigm&amp;rft.date=1999&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DGIhQAAAAMAAJ&amp;rft.isbn=978-3-540-65463-6&amp;rft.pages=169-181&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation journal">Niemelä, I. (1999). <a rel="nofollow" class="external text" href="http://users.ics.aalto.fi/ini/papers/lp-csp-long.ps.gz">"Logic programs with stable model semantics as a constraint programming paradigm"</a> (Postscript,gzipped). <i>Annals of Mathematics and Artificial Intelligence</i> <b>25</b>: 241–273. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1023%2FA%3A1018930122475">10.1023/A:1018930122475</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=Logic+programs+with+stable+model+semantics+as+a+constraint+programming+paradigm&amp;rft.aufirst=I.&amp;rft.aulast=Niemel%C3%A4&amp;rft.au=Niemel%C3%A4%2C+I.&amp;rft.date=1999&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fusers.ics.aalto.fi%2Fini%2Fpapers%2Flp-csp-long.ps.gz&amp;rft_id=info%3Adoi%2F10.1023%2FA%3A1018930122475&amp;rft.jtitle=Annals+of+Mathematics+and+Artificial+Intelligence&amp;rft.pages=241-273&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=25" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation journal">Lifschitz, V. (1999). "Action Languages, Answer Sets, and Planning".</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.aufirst=V.&amp;rft.aulast=Lifschitz&amp;rft.au=Lifschitz%2C+V.&amp;rft.btitle=Action+Languages%2C+Answer+Sets%2C+and+Planning&amp;rft.date=1999&amp;rft.genre=book&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> In <a href="#CITEREFApt1999">Apt 1999</a>, pp. 357–374</span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><span class="citation thesis">Crick, Tom (2009). <a rel="nofollow" class="external text" href="http://opus.bath.ac.uk/20352/1/UnivBath_PhD_2009_T_Crick.pdf"><i>Superoptimisation: Provably Optimal Code Generation using Answer Set Programming</i></a> (Ph.D.). University of Bath. Docket 20352.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.au=Crick%2C+Tom&amp;rft.aufirst=Tom&amp;rft.aulast=Crick&amp;rft.btitle=Superoptimisation%3A+Provably+Optimal+Code+Generation+using+Answer+Set+Programming&amp;rft.date=2009&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fopus.bath.ac.uk%2F20352%2F1%2FUnivBath_PhD_2009_T_Crick.pdf&amp;rft.pub=University+of+Bath&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><span class="citation web">Rogelio Davila. <a rel="nofollow" class="external text" href="http://www.rogeliodavila.com/Programacion%20Logica/PL%20Notas/AnsProlog%20Overview.ppt">"AnsProlog, an overview"</a> (PowerPoint).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.aulast=Rogelio+Davila&amp;rft.au=Rogelio+Davila&amp;rft.btitle=AnsProlog%2C+an+overview&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.rogeliodavila.com%2FProgramacion%2520Logica%2FPL%2520Notas%2FAnsProlog%2520Overview.ppt&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><span class="citation book">Niemelä, I.; Simons, P.; Soinenen, T. (2000). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=Abj-OpFeDjQC&amp;pg=PA317">"Stable model semantics of weight constraint rules"</a>. In Gelfond, Michael; Leone, Nicole; Pfeifer, Gerald. <i>Logic Programming and Nonmonotonic Reasoning: 5th International Conference, LPNMR '99, El Paso, Texas, USA, December 2–4, 1999 Proceedings</i>. Lecture notes in computer science: Lecture notes in artificial intelligence <b>1730</b>. Springer. pp. 317–331. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-66749-0" title="Special:BookSources/978-3-540-66749-0">978-3-540-66749-0</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=Logic+Programming+and+Nonmonotonic+Reasoning%3A+5th+International+Conference%2C+LPNMR+%2799%2C+El+Paso%2C+Texas%2C+USA%2C+December+2%E2%80%934%2C+1999+Proceedings&amp;rft.aufirst=I.&amp;rft.aulast=Niemel%C3%A4&amp;rft.au=Niemel%C3%A4%2C+I.&amp;rft.au=Simons%2C+P.&amp;rft.au=Soinenen%2C+T.&amp;rft.btitle=Stable+model+semantics+of+weight+constraint+rules&amp;rft.date=2000&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DAbj-OpFeDjQC%26pg%3DPA317&amp;rft.isbn=978-3-540-66749-0&amp;rft.pages=317-331&amp;rft.pub=Springer&amp;rft.series=Lecture+notes+in+computer+science%3A+Lecture+notes+in+artificial+intelligence&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=1730" class="Z3988"><span style="display:none;"> </span></span> <a rel="nofollow" class="external text" href="http://www.tcs.hut.fi/~ini/papers/nss-lpnmr99-www.ps.gz">as Postscript</a></span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation journal">Ferraris, P.; Lifschitz, V. (January 2005). <a rel="nofollow" class="external text" href="http://arxiv.org/pdf/cs/0312045">"Weight constraints as nested expressions"</a> (PDF). <i>Theory and Practice of Logic Programming</i> <b>5</b> (1-2): 45–74. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1017%2FS1471068403001923">10.1017/S1471068403001923</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.atitle=Weight+constraints+as+nested+expressions&amp;rft.au=Ferraris%2C+P.&amp;rft.aufirst=P.&amp;rft.aulast=Ferraris&amp;rft.au=Lifschitz%2C+V.&amp;rft.date=January+2005&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Farxiv.org%2Fpdf%2Fcs%2F0312045&amp;rft_id=info%3Adoi%2F10.1017%2FS1471068403001923&amp;rft.issue=1-2&amp;rft.jtitle=Theory+and+Practice+of+Logic+Programming&amp;rft.pages=45-74&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=5" class="Z3988"><span style="display:none;"> </span></span> <a rel="nofollow" class="external text" href="http://www.cs.utexas.edu/users/vl/papers/weight.ps">as Postscript</a></span></li>
<li id="cite_note-dlvsystem.com-13"><span class="mw-cite-backlink">^ <a href="#cite_ref-dlvsystem.com_13-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-dlvsystem.com_13-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.dlvsystem.com">"DLV System company page"</a>. DLVSYSTEM s.r.l<span class="reference-accessdate">. Retrieved 16 November 2011</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAnswer+set+programming&amp;rft.btitle=DLV+System+company+page&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.dlvsystem.com&amp;rft.pub=DLVSYSTEM+s.r.l.&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Answer_set_programming&amp;action=edit&amp;section=11" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://asparagus.cs.uni-potsdam.de/contest/">First ASP System Competition</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.kuleuven.be/~dtai/events/ASP-competition/index.shtml">Second ASP Competition</a></li>
<li><a rel="nofollow" class="external text" href="http://www.mat.unical.it/aspcomp2011/">Third ASP Competition</a></li>
<li><a rel="nofollow" class="external text" href="http://www.mat.unical.it/aspcomp2013">Fourth ASP Competition</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.uni-potsdam.de/platypus/">Platypus</a></li>
<li><a rel="nofollow" class="external text" href="http://www.kr.tuwien.ac.at/staff/tkren/deb.html">A variety of answer set solvers packaged for Debian / Ubuntu</a></li>
<li><a rel="nofollow" class="external text" href="http://www.cs.uni-potsdam.de/clasp/">Clasp Answer Set Solver</a></li>
</ul>
