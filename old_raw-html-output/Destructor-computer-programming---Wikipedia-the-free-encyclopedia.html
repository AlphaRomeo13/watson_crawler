<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Destructor (computer programming)</span></h1>
<p>In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, a <b>destructor</b> (sometimes shortened to <b>dtor</b>) is a <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> which is automatically invoked when the <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> is destroyed. It can happen when its lifetime is bound to scope and the execution leaves the scope, when it is embedded into another object whose lifetime ends, or when it was <a href="/wiki/Dynamic_memory#Dynamic_memory_allocation" title="Dynamic memory" class="mw-redirect">allocated dynamically</a> and is released explicitly. Its main purpose is to free the <a href="/wiki/Resource_(computer_science)" title="Resource (computer science)" class="mw-redirect">resources</a> (memory allocations, open files or sockets, <a href="/wiki/Database_connection" title="Database connection">database connections</a>, resource locks, etc.) which were acquired by the object along its life cycle and/or deregister from other entities which may keep references to it. The use of destructors is a necessity to the concept of <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a> (RAII).</p>
<p>In a language with an <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">automatic garbage collection</a> mechanism, it would be difficult to deterministically ensure the invocation of a destructor, and hence these languages are generally considered unsuitable for <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">RAII</a>. In such languages, unlinking an object from existing resources must be done by an explicit call of an appropriate function (usually called <code><a href="/wiki/Dispose_pattern" title="Dispose pattern">Dispose()</a></code>). This method is also recommended for freeing resources rather than using <a href="/wiki/Finalizer" title="Finalizer">finalizers</a> for that.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Destructor_syntax"><span class="tocnumber">1</span> <span class="toctext">Destructor syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#In_C.2B.2B"><span class="tocnumber">2</span> <span class="toctext">In C++</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#In_C_with_GCC_extensions"><span class="tocnumber">3</span> <span class="toctext">In C with GCC extensions</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#REALbasic"><span class="tocnumber">4</span> <span class="toctext">REALbasic</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Destructor_syntax">Destructor syntax</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Destructor syntax">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>C++ has the naming convention in which destructors have the same name as the class of which they are associated with, but prefixed with a <a href="/wiki/Tilde" title="Tilde">tilde</a> (~).</li>
<li>In <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a>, destructors have the keyword "<code>destructor</code>" and can have user-defined names (but are mostly called "Destroy").</li>
<li>In <a href="/wiki/Perl" title="Perl">Perl</a>, the destructor method is named <i>DESTROY</i>.</li>
<li>In <a href="/wiki/Moose_perl" title="Moose perl" class="mw-redirect">Moose object system</a> for Perl, the destructor method is named <i>DEMOLISH</i>.</li>
<li>In <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, the destructor method is named "<code>dealloc</code>".</li>
<li>In <a href="/wiki/Swift_(Apple_programming_language)" title="Swift (Apple programming language)" class="mw-redirect">Swift</a>, the destructor method is named <code>deinit</code>.</li>
<li>In <a href="/wiki/PHP_5" title="PHP 5" class="mw-redirect">PHP 5</a>, the destructor method is named "<code>__destruct</code>". There were no destructors in previous versions of PHP.<sup id="cite_ref-php5cpnstructor_1-0" class="reference"><a href="#cite_note-php5cpnstructor-1"><span>[</span>1<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="In_C.2B.2B">In C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: In C++">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The destructor has the same name as the class, but with a <a href="/wiki/Tilde" title="Tilde">tilde</a> (~) in front of it. If the object was created as an <a href="/wiki/Automatic_variable" title="Automatic variable">automatic variable</a>, its destructor is automatically called when it goes out of <a href="/wiki/Scope_(programming)" title="Scope (programming)" class="mw-redirect">scope</a>. If the object was created with a <tt><a href="/wiki/New_(C%2B%2B)" title="New (C++)">new</a></tt> expression, then its destructor is called when the <tt><a href="/wiki/Delete_(C%2B%2B)" title="Delete (C++)">delete</a></tt> operator is applied to a pointer to the object. Usually that operation occurs within another destructor, typically the destructor of a <a href="/wiki/Smart_pointer" title="Smart pointer">smart pointer</a> object.</p>
<p>In inheritance hierarchies, the declaration of a <a href="/wiki/Virtual_function#Virtual_destructors" title="Virtual function">virtual destructor</a> in the base class ensures that the destructors of derived classes are invoked properly when an object is deleted through a pointer-to-base-class. Objects that may be deleted in this way need to inherit a virtual destructor.</p>
<p>A destructor should never throw an exception.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>WHATSON? 7afdda4c-0a0f-4cf8-95e2-0b0e17bcd2b7</p>
<pre class="de1">
<span class="co2">#include &lt;cstring&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw2">class</span> foo_t
<span class="br0">{</span>
	<span class="kw2">friend</span> std<span class="sy4">::</span><span class="me2">ostream</span> <span class="sy3">&amp;</span> operator <span class="sy1">&lt;&lt;</span> <span class="br0">(</span> std<span class="sy4">::</span><span class="me2">ostream</span> <span class="sy3">&amp;</span> os, foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> foo <span class="br0">)</span>
	<span class="br0">{</span>
		os <span class="sy1">&lt;&lt;</span> foo.<span class="me1">data</span><span class="sy4">;</span>
		<span class="kw1">return</span> os<span class="sy4">;</span>
	<span class="br0">}</span>
 
<span class="kw2">private</span><span class="sy4">:</span>
	<span class="kw4">char</span> <span class="sy2">*</span> data<span class="sy4">;</span>
	foo_t<span class="br0">(</span> foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> other <span class="br0">)</span><span class="sy4">;</span>                <span class="co1">// disable copy construction</span>
	foo_t<span class="sy3">&amp;</span> operator <span class="sy1">=</span> <span class="br0">(</span> foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> other <span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// disable assignment</span>
 
<span class="kw2">public</span><span class="sy4">:</span>
	foo_t<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span> <span class="sy4">:</span> data<span class="br0">(</span> <span class="kw3">new</span> <span class="kw4">char</span><span class="br0">[</span> <span class="nu0">14</span> <span class="br0">]</span> <span class="br0">)</span> <span class="br0">{</span> std<span class="sy4">::</span><span class="kw3">strcpy</span><span class="br0">(</span> data, <span class="st0">"Hello, World!"</span> <span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> 
	~foo_t<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span> <span class="br0">{</span> <span class="kw3">delete</span> <span class="br0">[</span><span class="br0">]</span> data<span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	foo_t foo<span class="sy4">;</span>
	std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> foo <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<p>Objects which cannot be safely copied and/or assigned should be disabled from such semantics by declaring their corresponding functions within a non-public encapsulation level (in the above example, "private"). A detailed description of this technique can be found in <a href="/wiki/Scott_Meyers" title="Scott Meyers">Scott Meyers</a>' popular book, <i>Effective C++</i> (Item 6: "Explicitly disallow the use of compiler-generated functions you do not want."<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup>).</p>
<h2><span class="mw-headline" id="In_C_with_GCC_extensions">In C with GCC extensions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: In C with GCC extensions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GNU Compiler Collection</a>'s <a href="/wiki/C_(Programming_Language)" title="C (Programming Language)" class="mw-redirect">C</a> compiler comes with 2 extensions that allow to implement destructors:</p>
<ul>
<li>the <a rel="nofollow" class="external text" href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">"destructor" function attribute</a> allows defining global prioritized destructor functions: when <i>main()</i> returns, these functions are called in priority order before the process terminates. See also <sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></li>
<li>the <a href="/wiki/Resource_Acquisition_Is_Initialization#GCC_extensions_for_C" title="Resource Acquisition Is Initialization">"cleanup" variable attribute</a> allows attaching a destructor function to a variable: the function is called when the variable goes out of scope.</li>
</ul>
<h2><span class="mw-headline" id="REALbasic">REALbasic</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: REALbasic">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Destructors in <a href="/wiki/REALbasic" title="REALbasic" class="mw-redirect">REALbasic</a> can be in one of two forms. Each form uses a regular method declaration with a special name (with no parameters and no return value). The older form uses the same name as the Class itself with a ~ (tilde) prefix. The newer form uses the name "Destructor". The newer form is the preferred one because it makes <a href="/wiki/Refactoring" title="Refactoring" class="mw-redirect">refactoring</a> the class easier.</p>
<p>WHATSON? 2d558b6e-811b-4a02-abae-acd26e1b4488</p>
<pre>
Class Foobar
  // Old form
  Sub ~Foobar()
  End Sub

  // New form
  Sub Destructor()
  End Sub
End Class
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Finalizer" title="Finalizer">Finalizer</a></li>
<li><a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">Constructor</a></li>
<li><a href="/wiki/Object_lifetime" title="Object lifetime">Object lifetime</a></li>
<li><a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-php5cpnstructor-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-php5cpnstructor_1-0">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.php.net/manual/en/language.oop5.decon.php">Constructors and Destructors</a>, from PHP online documentation</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.gotw.ca/gotw/047.htm">GotW #47: Uncaught exceptions</a> Accessed 31 July 2011.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Scott Meyers: <i>Effective C++</i>, Addison-Wesley, <a href="/wiki/Special:BookSources/0321334876" class="internal mw-magiclink-isbn">ISBN 0-321-33487-6</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Erickson, Jon (2008). <i>Hacking the art of exploitation</i>. <a href="/wiki/No_Starch_Press" title="No Starch Press">No Starch Press</a>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/1-59327-144-1" title="Special:BookSources/1-59327-144-1">1-59327-144-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADestructor+%28computer+programming%29&amp;rft.au=Erickson%2C+Jon&amp;rft.aufirst=Jon&amp;rft.aulast=Erickson&amp;rft.btitle=Hacking+the+art+of+exploitation&amp;rft.date=2008&amp;rft.genre=book&amp;rft.isbn=1-59327-144-1&amp;rft.pub=No+Starch+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Destructor (computer programming)</span></h1>
<p>In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, a <b>destructor</b> (sometimes shortened to <b>dtor</b>) is a <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> which is automatically invoked when the <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> is destroyed. It can happen when its lifetime is bound to scope and the execution leaves the scope, when it is embedded into another object whose lifetime ends, or when it was <a href="/wiki/Dynamic_memory#Dynamic_memory_allocation" title="Dynamic memory" class="mw-redirect">allocated dynamically</a> and is released explicitly. Its main purpose is to free the <a href="/wiki/Resource_(computer_science)" title="Resource (computer science)" class="mw-redirect">resources</a> (memory allocations, open files or sockets, <a href="/wiki/Database_connection" title="Database connection">database connections</a>, resource locks, etc.) which were acquired by the object along its life cycle and/or deregister from other entities which may keep references to it. The use of destructors is a necessity to the concept of <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a> (RAII).</p>
<p>In a language with an <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">automatic garbage collection</a> mechanism, it would be difficult to deterministically ensure the invocation of a destructor, and hence these languages are generally considered unsuitable for <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">RAII</a>. In such languages, unlinking an object from existing resources must be done by an explicit call of an appropriate function (usually called <code><a href="/wiki/Dispose_pattern" title="Dispose pattern">Dispose()</a></code>). This method is also recommended for freeing resources rather than using <a href="/wiki/Finalizer" title="Finalizer">finalizers</a> for that.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Destructor_syntax"><span class="tocnumber">1</span> <span class="toctext">Destructor syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#In_C.2B.2B"><span class="tocnumber">2</span> <span class="toctext">In C++</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#In_C_with_GCC_extensions"><span class="tocnumber">3</span> <span class="toctext">In C with GCC extensions</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#REALbasic"><span class="tocnumber">4</span> <span class="toctext">REALbasic</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Destructor_syntax">Destructor syntax</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Destructor syntax">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>C++ has the naming convention in which destructors have the same name as the class of which they are associated with, but prefixed with a <a href="/wiki/Tilde" title="Tilde">tilde</a> (~).</li>
<li>In <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a>, destructors have the keyword "<code>destructor</code>" and can have user-defined names (but are mostly called "Destroy").</li>
<li>In <a href="/wiki/Perl" title="Perl">Perl</a>, the destructor method is named <i>DESTROY</i>.</li>
<li>In <a href="/wiki/Moose_perl" title="Moose perl" class="mw-redirect">Moose object system</a> for Perl, the destructor method is named <i>DEMOLISH</i>.</li>
<li>In <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, the destructor method is named "<code>dealloc</code>".</li>
<li>In <a href="/wiki/Swift_(Apple_programming_language)" title="Swift (Apple programming language)" class="mw-redirect">Swift</a>, the destructor method is named <code>deinit</code>.</li>
<li>In <a href="/wiki/PHP_5" title="PHP 5" class="mw-redirect">PHP 5</a>, the destructor method is named "<code>__destruct</code>". There were no destructors in previous versions of PHP.<sup id="cite_ref-php5cpnstructor_1-0" class="reference"><a href="#cite_note-php5cpnstructor-1"><span>[</span>1<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="In_C.2B.2B">In C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: In C++">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The destructor has the same name as the class, but with a <a href="/wiki/Tilde" title="Tilde">tilde</a> (~) in front of it. If the object was created as an <a href="/wiki/Automatic_variable" title="Automatic variable">automatic variable</a>, its destructor is automatically called when it goes out of <a href="/wiki/Scope_(programming)" title="Scope (programming)" class="mw-redirect">scope</a>. If the object was created with a <tt><a href="/wiki/New_(C%2B%2B)" title="New (C++)">new</a></tt> expression, then its destructor is called when the <tt><a href="/wiki/Delete_(C%2B%2B)" title="Delete (C++)">delete</a></tt> operator is applied to a pointer to the object. Usually that operation occurs within another destructor, typically the destructor of a <a href="/wiki/Smart_pointer" title="Smart pointer">smart pointer</a> object.</p>
<p>In inheritance hierarchies, the declaration of a <a href="/wiki/Virtual_function#Virtual_destructors" title="Virtual function">virtual destructor</a> in the base class ensures that the destructors of derived classes are invoked properly when an object is deleted through a pointer-to-base-class. Objects that may be deleted in this way need to inherit a virtual destructor.</p>
<p>A destructor should never throw an exception.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>WHATSON? ef90f290-c7ed-44f6-a991-f895ad83ae98</p>
<pre class="de1">
<span class="co2">#include &lt;cstring&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw2">class</span> foo_t
<span class="br0">{</span>
	<span class="kw2">friend</span> std<span class="sy4">::</span><span class="me2">ostream</span> <span class="sy3">&amp;</span> operator <span class="sy1">&lt;&lt;</span> <span class="br0">(</span> std<span class="sy4">::</span><span class="me2">ostream</span> <span class="sy3">&amp;</span> os, foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> foo <span class="br0">)</span>
	<span class="br0">{</span>
		os <span class="sy1">&lt;&lt;</span> foo.<span class="me1">data</span><span class="sy4">;</span>
		<span class="kw1">return</span> os<span class="sy4">;</span>
	<span class="br0">}</span>
 
<span class="kw2">private</span><span class="sy4">:</span>
	<span class="kw4">char</span> <span class="sy2">*</span> data<span class="sy4">;</span>
	foo_t<span class="br0">(</span> foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> other <span class="br0">)</span><span class="sy4">;</span>                <span class="co1">// disable copy construction</span>
	foo_t<span class="sy3">&amp;</span> operator <span class="sy1">=</span> <span class="br0">(</span> foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> other <span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// disable assignment</span>
 
<span class="kw2">public</span><span class="sy4">:</span>
	foo_t<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span> <span class="sy4">:</span> data<span class="br0">(</span> <span class="kw3">new</span> <span class="kw4">char</span><span class="br0">[</span> <span class="nu0">14</span> <span class="br0">]</span> <span class="br0">)</span> <span class="br0">{</span> std<span class="sy4">::</span><span class="kw3">strcpy</span><span class="br0">(</span> data, <span class="st0">"Hello, World!"</span> <span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> 
	~foo_t<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span> <span class="br0">{</span> <span class="kw3">delete</span> <span class="br0">[</span><span class="br0">]</span> data<span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	foo_t foo<span class="sy4">;</span>
	std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> foo <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<p>Objects which cannot be safely copied and/or assigned should be disabled from such semantics by declaring their corresponding functions within a non-public encapsulation level (in the above example, "private"). A detailed description of this technique can be found in <a href="/wiki/Scott_Meyers" title="Scott Meyers">Scott Meyers</a>' popular book, <i>Effective C++</i> (Item 6: "Explicitly disallow the use of compiler-generated functions you do not want."<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup>).</p>
<h2><span class="mw-headline" id="In_C_with_GCC_extensions">In C with GCC extensions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: In C with GCC extensions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GNU Compiler Collection</a>'s <a href="/wiki/C_(Programming_Language)" title="C (Programming Language)" class="mw-redirect">C</a> compiler comes with 2 extensions that allow to implement destructors:</p>
<ul>
<li>the <a rel="nofollow" class="external text" href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">"destructor" function attribute</a> allows defining global prioritized destructor functions: when <i>main()</i> returns, these functions are called in priority order before the process terminates. See also <sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></li>
<li>the <a href="/wiki/Resource_Acquisition_Is_Initialization#GCC_extensions_for_C" title="Resource Acquisition Is Initialization">"cleanup" variable attribute</a> allows attaching a destructor function to a variable: the function is called when the variable goes out of scope.</li>
</ul>
<h2><span class="mw-headline" id="REALbasic">REALbasic</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: REALbasic">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Destructors in <a href="/wiki/REALbasic" title="REALbasic" class="mw-redirect">REALbasic</a> can be in one of two forms. Each form uses a regular method declaration with a special name (with no parameters and no return value). The older form uses the same name as the Class itself with a ~ (tilde) prefix. The newer form uses the name "Destructor". The newer form is the preferred one because it makes <a href="/wiki/Refactoring" title="Refactoring" class="mw-redirect">refactoring</a> the class easier.</p>
<p>WHATSON? 219f1429-646b-4a19-a944-3b9f1e64fc12</p>
<pre>
Class Foobar
  // Old form
  Sub ~Foobar()
  End Sub

  // New form
  Sub Destructor()
  End Sub
End Class
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Finalizer" title="Finalizer">Finalizer</a></li>
<li><a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">Constructor</a></li>
<li><a href="/wiki/Object_lifetime" title="Object lifetime">Object lifetime</a></li>
<li><a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-php5cpnstructor-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-php5cpnstructor_1-0">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.php.net/manual/en/language.oop5.decon.php">Constructors and Destructors</a>, from PHP online documentation</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.gotw.ca/gotw/047.htm">GotW #47: Uncaught exceptions</a> Accessed 31 July 2011.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Scott Meyers: <i>Effective C++</i>, Addison-Wesley, <a href="/wiki/Special:BookSources/0321334876" class="internal mw-magiclink-isbn">ISBN 0-321-33487-6</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Erickson, Jon (2008). <i>Hacking the art of exploitation</i>. <a href="/wiki/No_Starch_Press" title="No Starch Press">No Starch Press</a>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/1-59327-144-1" title="Special:BookSources/1-59327-144-1">1-59327-144-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADestructor+%28computer+programming%29&amp;rft.au=Erickson%2C+Jon&amp;rft.aufirst=Jon&amp;rft.aulast=Erickson&amp;rft.btitle=Hacking+the+art+of+exploitation&amp;rft.date=2008&amp;rft.genre=book&amp;rft.isbn=1-59327-144-1&amp;rft.pub=No+Starch+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Destructor (computer programming)</span></h1>
<p>In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, a <b>destructor</b> (sometimes shortened to <b>dtor</b>) is a <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> which is automatically invoked when the <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> is destroyed. It can happen when its lifetime is bound to scope and the execution leaves the scope, when it is embedded into another object whose lifetime ends, or when it was <a href="/wiki/Dynamic_memory#Dynamic_memory_allocation" title="Dynamic memory" class="mw-redirect">allocated dynamically</a> and is released explicitly. Its main purpose is to free the <a href="/wiki/Resource_(computer_science)" title="Resource (computer science)" class="mw-redirect">resources</a> (memory allocations, open files or sockets, <a href="/wiki/Database_connection" title="Database connection">database connections</a>, resource locks, etc.) which were acquired by the object along its life cycle and/or deregister from other entities which may keep references to it. The use of destructors is a necessity to the concept of <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a> (RAII).</p>
<p>In a language with an <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">automatic garbage collection</a> mechanism, it would be difficult to deterministically ensure the invocation of a destructor, and hence these languages are generally considered unsuitable for <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">RAII</a>. In such languages, unlinking an object from existing resources must be done by an explicit call of an appropriate function (usually called <code><a href="/wiki/Dispose_pattern" title="Dispose pattern">Dispose()</a></code>). This method is also recommended for freeing resources rather than using <a href="/wiki/Finalizer" title="Finalizer">finalizers</a> for that.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Destructor_syntax"><span class="tocnumber">1</span> <span class="toctext">Destructor syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#In_C.2B.2B"><span class="tocnumber">2</span> <span class="toctext">In C++</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#In_C_with_GCC_extensions"><span class="tocnumber">3</span> <span class="toctext">In C with GCC extensions</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#REALbasic"><span class="tocnumber">4</span> <span class="toctext">REALbasic</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Destructor_syntax">Destructor syntax</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=1" title="Edit section: Destructor syntax">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>C++ has the naming convention in which destructors have the same name as the class of which they are associated with, but prefixed with a <a href="/wiki/Tilde" title="Tilde">tilde</a> (~).</li>
<li>In <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a>, destructors have the keyword "<code>destructor</code>" and can have user-defined names (but are mostly called "Destroy").</li>
<li>In <a href="/wiki/Perl" title="Perl">Perl</a>, the destructor method is named <i>DESTROY</i>.</li>
<li>In <a href="/wiki/Moose_perl" title="Moose perl" class="mw-redirect">Moose object system</a> for Perl, the destructor method is named <i>DEMOLISH</i>.</li>
<li>In <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a>, the destructor method is named "<code>dealloc</code>".</li>
<li>In <a href="/wiki/Swift_(Apple_programming_language)" title="Swift (Apple programming language)" class="mw-redirect">Swift</a>, the destructor method is named <code>deinit</code>.</li>
<li>In <a href="/wiki/PHP_5" title="PHP 5" class="mw-redirect">PHP 5</a>, the destructor method is named "<code>__destruct</code>". There were no destructors in previous versions of PHP.<sup id="cite_ref-php5cpnstructor_1-0" class="reference"><a href="#cite_note-php5cpnstructor-1"><span>[</span>1<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="In_C.2B.2B">In C++</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=2" title="Edit section: In C++">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The destructor has the same name as the class, but with a <a href="/wiki/Tilde" title="Tilde">tilde</a> (~) in front of it. If the object was created as an <a href="/wiki/Automatic_variable" title="Automatic variable">automatic variable</a>, its destructor is automatically called when it goes out of <a href="/wiki/Scope_(programming)" title="Scope (programming)" class="mw-redirect">scope</a>. If the object was created with a <tt><a href="/wiki/New_(C%2B%2B)" title="New (C++)">new</a></tt> expression, then its destructor is called when the <tt><a href="/wiki/Delete_(C%2B%2B)" title="Delete (C++)">delete</a></tt> operator is applied to a pointer to the object. Usually that operation occurs within another destructor, typically the destructor of a <a href="/wiki/Smart_pointer" title="Smart pointer">smart pointer</a> object.</p>
<p>In inheritance hierarchies, the declaration of a <a href="/wiki/Virtual_function#Virtual_destructors" title="Virtual function">virtual destructor</a> in the base class ensures that the destructors of derived classes are invoked properly when an object is deleted through a pointer-to-base-class. Objects that may be deleted in this way need to inherit a virtual destructor.</p>
<p>A destructor should never throw an exception.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=3" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>WHATSON? 41b0bbd3-1f05-4934-acad-ea58868a19ed</p>
<pre class="de1">
<span class="co2">#include &lt;cstring&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw2">class</span> foo_t
<span class="br0">{</span>
	<span class="kw2">friend</span> std<span class="sy4">::</span><span class="me2">ostream</span> <span class="sy3">&amp;</span> operator <span class="sy1">&lt;&lt;</span> <span class="br0">(</span> std<span class="sy4">::</span><span class="me2">ostream</span> <span class="sy3">&amp;</span> os, foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> foo <span class="br0">)</span>
	<span class="br0">{</span>
		os <span class="sy1">&lt;&lt;</span> foo.<span class="me1">data</span><span class="sy4">;</span>
		<span class="kw1">return</span> os<span class="sy4">;</span>
	<span class="br0">}</span>
 
<span class="kw2">private</span><span class="sy4">:</span>
	<span class="kw4">char</span> <span class="sy2">*</span> data<span class="sy4">;</span>
	foo_t<span class="br0">(</span> foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> other <span class="br0">)</span><span class="sy4">;</span>                <span class="co1">// disable copy construction</span>
	foo_t<span class="sy3">&amp;</span> operator <span class="sy1">=</span> <span class="br0">(</span> foo_t <span class="kw4">const</span> <span class="sy3">&amp;</span> other <span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// disable assignment</span>
 
<span class="kw2">public</span><span class="sy4">:</span>
	foo_t<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span> <span class="sy4">:</span> data<span class="br0">(</span> <span class="kw3">new</span> <span class="kw4">char</span><span class="br0">[</span> <span class="nu0">14</span> <span class="br0">]</span> <span class="br0">)</span> <span class="br0">{</span> std<span class="sy4">::</span><span class="kw3">strcpy</span><span class="br0">(</span> data, <span class="st0">"Hello, World!"</span> <span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> 
	~foo_t<span class="br0">(</span> <span class="kw4">void</span> <span class="br0">)</span> <span class="br0">{</span> <span class="kw3">delete</span> <span class="br0">[</span><span class="br0">]</span> data<span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	foo_t foo<span class="sy4">;</span>
	std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> foo <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre>
<p>Objects which cannot be safely copied and/or assigned should be disabled from such semantics by declaring their corresponding functions within a non-public encapsulation level (in the above example, "private"). A detailed description of this technique can be found in <a href="/wiki/Scott_Meyers" title="Scott Meyers">Scott Meyers</a>' popular book, <i>Effective C++</i> (Item 6: "Explicitly disallow the use of compiler-generated functions you do not want."<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup>).</p>
<h2><span class="mw-headline" id="In_C_with_GCC_extensions">In C with GCC extensions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=4" title="Edit section: In C with GCC extensions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GNU Compiler Collection</a>'s <a href="/wiki/C_(Programming_Language)" title="C (Programming Language)" class="mw-redirect">C</a> compiler comes with 2 extensions that allow to implement destructors:</p>
<ul>
<li>the <a rel="nofollow" class="external text" href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">"destructor" function attribute</a> allows defining global prioritized destructor functions: when <i>main()</i> returns, these functions are called in priority order before the process terminates. See also <sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></li>
<li>the <a href="/wiki/Resource_Acquisition_Is_Initialization#GCC_extensions_for_C" title="Resource Acquisition Is Initialization">"cleanup" variable attribute</a> allows attaching a destructor function to a variable: the function is called when the variable goes out of scope.</li>
</ul>
<h2><span class="mw-headline" id="REALbasic">REALbasic</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=5" title="Edit section: REALbasic">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Destructors in <a href="/wiki/REALbasic" title="REALbasic" class="mw-redirect">REALbasic</a> can be in one of two forms. Each form uses a regular method declaration with a special name (with no parameters and no return value). The older form uses the same name as the Class itself with a ~ (tilde) prefix. The newer form uses the name "Destructor". The newer form is the preferred one because it makes <a href="/wiki/Refactoring" title="Refactoring" class="mw-redirect">refactoring</a> the class easier.</p>
<p>WHATSON? ff03852a-42a1-4d10-a45a-ba8ff000a45a</p>
<pre>
Class Foobar
  // Old form
  Sub ~Foobar()
  End Sub

  // New form
  Sub Destructor()
  End Sub
End Class
</pre>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Finalizer" title="Finalizer">Finalizer</a></li>
<li><a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">Constructor</a></li>
<li><a href="/wiki/Object_lifetime" title="Object lifetime">Object lifetime</a></li>
<li><a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Destructor_(computer_programming)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-php5cpnstructor-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-php5cpnstructor_1-0">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.php.net/manual/en/language.oop5.decon.php">Constructors and Destructors</a>, from PHP online documentation</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.gotw.ca/gotw/047.htm">GotW #47: Uncaught exceptions</a> Accessed 31 July 2011.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Scott Meyers: <i>Effective C++</i>, Addison-Wesley, <a href="/wiki/Special:BookSources/0321334876" class="internal mw-magiclink-isbn">ISBN 0-321-33487-6</a></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Erickson, Jon (2008). <i>Hacking the art of exploitation</i>. <a href="/wiki/No_Starch_Press" title="No Starch Press">No Starch Press</a>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/1-59327-144-1" title="Special:BookSources/1-59327-144-1">1-59327-144-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADestructor+%28computer+programming%29&amp;rft.au=Erickson%2C+Jon&amp;rft.aufirst=Jon&amp;rft.aulast=Erickson&amp;rft.btitle=Hacking+the+art+of+exploitation&amp;rft.date=2008&amp;rft.genre=book&amp;rft.isbn=1-59327-144-1&amp;rft.pub=No+Starch+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
