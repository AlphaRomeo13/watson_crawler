<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Virtual function</span></h1>
<ul>
<li><a href="/wiki/Ad_hoc_polymorphism" title="Ad hoc polymorphism">Ad hoc polymorphism</a></li>
<li><a href="/wiki/Function_overloading" title="Function overloading">Function overloading</a></li>
<li><a href="/wiki/Operator_overloading" title="Operator overloading">Operator overloading</a></li>
<li><a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">Parametric polymorphism</a></li>
<li><a href="/wiki/Double_dispatch" title="Double dispatch">Double dispatch</a></li>
<li><a href="/wiki/Multiple_dispatch" title="Multiple dispatch">Multiple dispatch</a></li>
<li><a href="/wiki/Dynamic_dispatch" title="Dynamic dispatch">Single &amp; dynamic dispatch</a></li>
<li><a href="/wiki/Subtyping" title="Subtyping">Subtyping</a></li>
<li><strong class="selflink">Virtual function</strong></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Polymorphism" title="Template:Polymorphism"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Polymorphism" title="Template talk:Polymorphism"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Polymorphism&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p>In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, a <b>virtual function</b> or <b>virtual method</b> is a <a href="/wiki/Function_(computer_science)" title="Function (computer science)" class="mw-redirect">function</a> or <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> whose behavior can be <a href="/wiki/Method_overriding_(programming)" title="Method overriding (programming)" class="mw-redirect">overridden</a> within an inheriting class by a function with the same <a href="/wiki/Method_signature" title="Method signature" class="mw-redirect">signature</a>. This concept is an important part of the <a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">polymorphism</a> portion of <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a> (OOP).</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Purpose"><span class="tocnumber">1</span> <span class="toctext">Purpose</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Example"><span class="tocnumber">2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Abstract_classes_and_pure_virtual_functions"><span class="tocnumber">3</span> <span class="toctext">Abstract classes and pure virtual functions</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Behavior_during_construction_and_destruction"><span class="tocnumber">4</span> <span class="toctext">Behavior during construction and destruction</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Virtual_destructors"><span class="tocnumber">5</span> <span class="toctext">Virtual destructors</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">7</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Purpose">Purpose</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=1" title="Edit section: Purpose">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The concept of the virtual function solves the following problem:</p>
<p>In object-oriented programming, when a derived class inherits from a base class, an object of the derived class may be referred to via a pointer or reference of the base class type instead of the derived class type. If there are base class methods overridden by the derived class, the method actually called by such a reference or pointer can be bound either 'early' (by the compiler), according to the declared type of the pointer or reference, or 'late' (i.e. by the runtime system of the language), according to the actual type of the object referred to.</p>
<p>Virtual functions are resolved 'late'. If the function in question is 'virtual' in the base class, the most-derived class's implementation of the function is called according to the actual type of the object referred to, regardless of the declared type of the pointer or reference. If it is not 'virtual', the method is resolved 'early' and the function called is selected according to the declared type of the pointer or reference.</p>
<p>Virtual functions allow a program to call methods that don't necessarily even exist at the moment the code is compiled.</p>
<p>In C++, <i>virtual methods</i> are declared by prepending the <span class="mw-geshi cpp source-cpp"><span class="kw2">virtual</span></span> keyword to the function's declaration in the base class. This modifier is inherited by all implementations of that method in derived classes, meaning that they can continue to over-ride each other and be late-bound.</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=2" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For example, a base class <code>Animal</code> could have a virtual function <code>eat</code>. Subclass <code>Fish</code> would implement <code>eat()</code> differently than subclass <code>Wolf</code>, but one can invoke <code>eat()</code> on any class instance referred to as Animal, and get the <code>eat()</code> behavior of the specific subclass.</p>
<p>This allows a programmer to process a list of objects of class <code>Animal</code>, telling each in turn to eat (by calling <code>eat()</code>), without needing to know what kind of animal may be in the list, how each animal eats, or what the complete set of possible animal types might be.</p>
<h2><span class="mw-headline" id="Abstract_classes_and_pure_virtual_functions">Abstract classes and pure virtual functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=3" title="Edit section: Abstract classes and pure virtual functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A <b>pure virtual function</b> or <b>pure virtual method</b> is a virtual function that is required to be implemented by a derived class if that class is not <a href="/wiki/Abstract_type" title="Abstract type">abstract</a>. Classes containing pure virtual methods are termed "abstract" and they cannot be instantiated directly. A <a href="/wiki/Subclass_(computer_science)" title="Subclass (computer science)" class="mw-redirect">subclass</a> of an abstract class can only be instantiated directly if all inherited pure virtual methods have been implemented by that class or a parent class. Pure virtual methods typically have a <a href="/wiki/Declaration_(computer_science)" title="Declaration (computer science)" class="mw-redirect">declaration</a> (signature) and no definition (implementation).</p>
<p>As an example, an abstract base class <code>MathSymbol</code> may provide a pure virtual function <code>doOperation()</code>, and derived classes <code>Plus</code> and <code>Minus</code> implement <code>doOperation()</code> to provide concrete implementations. Implementing <code>doOperation()</code> would not make sense in the <code>MathSymbol</code> class, as <code>MathSymbol</code> is an abstract concept whose behaviour is defined solely for each given kind (subclass) of <code>MathSymbol</code>. Similarly, a given subclass of <code>MathSymbol</code> would not be complete without an implementation of <code>doOperation()</code>.</p>
<p>Although pure virtual methods typically have no implementation in the class that declares them, pure virtual methods in C++ are permitted to contain an implementation in their declaring class, providing fallback or default behaviour that a derived class can delegate to, if appropriate.</p>
<p>Pure virtual functions can also be used where the method declarations are being used to define an <a href="/wiki/Interface_(Java)" title="Interface (Java)">interface</a> - similar to what the interface keyword in Java explicitly specifies. In such a use, derived classes will supply all implementations. In such a <a href="/wiki/Design_pattern" title="Design pattern">design pattern</a>, the abstract class which serves as an interface will contain <i>only</i> pure virtual functions, but no data members or ordinary methods. In C++, using such purely abstract classes as interfaces works because C++ supports <a href="/wiki/Multiple_inheritance" title="Multiple inheritance">multiple inheritance</a>. However, because many OOP languages do not support multiple inheritance, they often provide a separate interface mechanism. An example is the <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java programming language</a>.</p>
<h2><span class="mw-headline" id="Behavior_during_construction_and_destruction">Behavior during construction and destruction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=4" title="Edit section: Behavior during construction and destruction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Languages differ in their behavior while the <a href="/wiki/Constructor_(computer_science)" title="Constructor (computer science)" class="mw-redirect">constructor</a> or <a href="/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructor</a> of an object is running. For some languages, notably C++, the virtual dispatching mechanism has different semantics during construction and destruction of an object. While it is recommended that virtual function calls in constructors should be avoided for C++,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> in some other languages, for example C# and Java, the derived implementation can be called during construction and <a href="/wiki/Design_pattern_(computer_science)" title="Design pattern (computer science)" class="mw-redirect">design patterns</a> such as the <a href="/wiki/Abstract_Factory_Pattern" title="Abstract Factory Pattern" class="mw-redirect">Abstract Factory Pattern</a> actively promote this usage in languages supporting the ability.</p>
<h2><span class="mw-headline" id="Virtual_destructors">Virtual destructors</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=5" title="Edit section: Virtual destructors">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Object-oriented languages typically manage memory allocation and de-allocation automatically when objects are created and destroyed. However, some object-oriented languages allow a custom destructor method to be implemented, if desired. If the language in question uses automatic memory management, the custom destructor (generally called a finalizer in this context) that is called is certain to be the appropriate one for the object in question. For example, if an object of type Wolf that inherits Animal is created, and both have custom destructors, the one called will be the one declared in Wolf.</p>
<p>In manual memory management contexts, the situation can be more complex, particularly as relates to static dispatch. If an object of type Wolf is created but pointed to by an Animal pointer, and it is this Animal pointer type that is deleted, the destructor called may actually be the one defined for Animal and not the one for Wolf, unless the destructor is virtual. This is particularly the case with C++, where the behavior is a common source of programming errors.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Inheritance_(computer_science)" title="Inheritance (computer science)" class="mw-redirect">Inheritance</a></li>
<li><a href="/wiki/Superclass_(computer_science)" title="Superclass (computer science)" class="mw-redirect">Superclass</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Virtual_function&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web">Meyers, Scott (June 6, 2005). <a rel="nofollow" class="external text" href="http://www.artima.com/cppsource/nevercall.html">"Never Call Virtual Functions during Construction or Destruction"</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AVirtual+function&amp;rft.aufirst=Scott&amp;rft.aulast=Meyers&amp;rft.au=Meyers%2C+Scott&amp;rft.btitle=Never+Call+Virtual+Functions+during+Construction+or+Destruction&amp;rft.date=June+6%2C+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.artima.com%2Fcppsource%2Fnevercall.html&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
