<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Object composition</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>object composition</b> (not to be confused with <a href="/wiki/Function_composition_(computer_science)" title="Function composition (computer science)">function composition</a>) is a way to <a href="/wiki/Object_association" title="Object association" class="mw-redirect">combine</a> simple <a href="/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> or <a href="/wiki/Data_type" title="Data type">data types</a> into more complex ones. Compositions are a critical building block of many basic data structures, including the <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a>, the <a href="/wiki/Linked_list" title="Linked list">linked list</a>, and the <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a>, as well as the <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> used in object-oriented programming.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2014)">citation needed</span></a></i>]</sup></p>
<p>A real-world example of composition may be seen in the relation of an automobile to its parts, specifically: the <i><a href="/wiki/Automobile" title="Automobile" class="mw-redirect">automobile</a></i> 'has or is composed from' objects including <i><a href="/wiki/Steering_wheel" title="Steering wheel">steering wheel</a></i>, <i>seat</i>, <i><a href="/wiki/Gearbox" title="Gearbox" class="mw-redirect">gearbox</a></i> and <i><a href="/wiki/Engine" title="Engine">engine</a></i>.</p>
<p>When, in a language, objects are typed, types can often be divided into composite and noncomposite types, and composition can be regarded as a relationship between types: an object of a composite type (e.g. <i>car</i>) "<a href="/wiki/Has-a" title="Has-a">has an</a>" object of a simpler type (e.g. <i>wheel</i>).</p>
<p>Composition must be distinguished from <a href="/wiki/Subtyping" title="Subtyping">subtyping</a>, which is the process of adding detail to a general data type to create a more specific data type. For instance, cars may be a specific type of vehicle: <i>car</i> <a href="/wiki/Is-a" title="Is-a">is a</a> <i>vehicle</i>. Subtyping doesn't describe a relationship between different objects, but instead, says that objects of a type are simultaneously objects of another type.</p>
<p>In programming languages, composite objects are usually expressed by means of references from one object to another; depending on the language, such references may be known as <b>fields</b>, <b>members</b>, <b>properties</b> or <b>attributes</b>, and the resulting composition as a <b>structure</b>, <b><a href="/wiki/Storage_record" title="Storage record">storage record</a></b>, <b><a href="/wiki/Tuple" title="Tuple">tuple</a></b>, <b>user-defined type (UDT)</b>, or <b><a href="/wiki/Composite_type" title="Composite type" class="mw-redirect">composite type</a></b>. Fields are given a unique name so that each one can be distinguished from the others. However, having such references doesn't necessarily mean that an object is a composite. It is only called composite if the objects it refers to are really its parts, i.e. have no independent existence. For details, see the aggregation section below.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#UML_notation"><span class="tocnumber">1</span> <span class="toctext">UML notation</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Composite_types_in_C"><span class="tocnumber">2</span> <span class="toctext">Composite types in C</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Recursive_composition"><span class="tocnumber">3</span> <span class="toctext">Recursive composition</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Timeline_of_composition_in_various_languages"><span class="tocnumber">4</span> <span class="toctext">Timeline of composition in various languages</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Aggregation"><span class="tocnumber">5</span> <span class="toctext">Aggregation</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Containment"><span class="tocnumber">6</span> <span class="toctext">Containment</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Aggregation_in_COM"><span class="tocnumber">7</span> <span class="toctext">Aggregation in COM</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="UML_notation">UML notation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=1" title="Edit section: UML notation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a>, there are two ways of modelling composition: Composition and aggregation. Beware that in UML composition has a more narrow meaning than in ordinary language:</p>
<p>Composition is depicted as a <b>filled diamond</b> and a solid line.</p>
<p>Composition is a kind of association where the composite object has sole responsibility for the disposition of the component parts. The relationship between the composite and the component is a strong “has a” relationship, as the composite object takes ownership of the component. This means the composite is responsible for the creation and destruction of the component parts. An object may only be part of one composite. If the composite object is destroyed, all the component parts must be destroyed. The part has no life of itself and cannot be transferred to another object. Composition enforces encapsulation as the component parts usually are members of the composite object.</p>
<p>The more general form, <a href="/wiki/Object_composition#Aggregation" title="Object composition">aggregation</a>, is depicted as an <b>unfilled diamond</b> and a solid line.</p>
<p>Aggregation is a kind of association that specifies a whole/part relationship between the aggregate (whole) and component part. This relationship between the aggregate and component is a weak “has a” relationship as the component may survive the aggregate object. The component object may be accessed through other objects without going through the aggregate object. The aggregate object does not take part in the lifecycle of the component object, meaning the component object may outlive the aggregate object. The state of the component object still forms part of the aggregate object.</p>
<p>The image below shows both composition and aggregation. (Note that the examples show abstracted data models, disregarding the fact that in a real world carburetor -&gt; car association, there is a market for spare parts.) The C++ code below shows what the source code is likely to look like.</p>
<p><a href="/wiki/File:AggregationAndComposition.svg" class="image"><img alt="AggregationAndComposition.svg" src="//upload.wikimedia.org/wikipedia/en/thumb/9/9f/AggregationAndComposition.svg/250px-AggregationAndComposition.svg.png" width="250" height="89" srcset="//upload.wikimedia.org/wikipedia/en/thumb/9/9f/AggregationAndComposition.svg/375px-AggregationAndComposition.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/9/9f/AggregationAndComposition.svg/500px-AggregationAndComposition.svg.png 2x" data-file-width="400" data-file-height="143"></a></p>
<p>WHATSON? 0af4876f-affe-4c94-991b-579744849c41</p>
<pre class="de1">
<span class="co1">// Composition</span>
<span class="kw2">class</span> Car
<span class="br0">{</span>
<span class="kw2">private</span><span class="sy4">:</span>
 
    <span class="co1">// Car is the owner of carburetor.</span>
    <span class="co1">// Carburetor is created when Car is created,</span>
    <span class="co1">// it is destroyed when Car is destroyed.</span>
    Carburetor carb<span class="sy4">;</span>
 
<span class="br0">}</span><span class="sy4">;</span>
</pre>
<p>WHATSON? d7d94ef2-5862-4b4b-9fbd-2f1dc4be231a</p>
<pre class="de1">
<span class="co1">// Aggregation</span>
<span class="kw2">class</span> Pond
<span class="br0">{</span>
<span class="kw2">private</span><span class="sy4">:</span>
   std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>Duck<span class="sy2">*</span><span class="sy1">&gt;</span> ducks<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre>
<h2><span class="mw-headline" id="Composite_types_in_C">Composite types in C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=2" title="Edit section: Composite types in C">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This is an example of composition in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>.</p>
<p>WHATSON? 6484e76a-6be7-4334-8c9c-c9335d133851</p>
<pre class="de1">
<span class="kw4">struct</span> Person
<span class="br0">{</span>
 <span class="kw4">int</span> age<span class="sy0">;</span>
 <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">;</span>
 <span class="kw2">enum</span> <span class="br0">{</span>they<span class="sy0">,</span> she<span class="sy0">,</span> he<span class="br0">}</span> pronoun<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>In this example, the primitive types <code>int</code>, <code>char *</code>, and <code>enum {they, she, he}</code> are combined to form the composite structure <code>Person</code>. Each <code>Person</code> structure then "has an" age, name, and a pronoun they are referred to by.</p>
<h2><span class="mw-headline" id="Recursive_composition">Recursive composition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=3" title="Edit section: Recursive composition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Objects can be composited recursively with the use of <a href="/wiki/Recursive_type" title="Recursive type" class="mw-redirect">recursive types</a> or <a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a>. Consider a tree. Each node in a tree may be a branch or leaf; in other words, each node is a tree at the same time when it belongs to another tree.</p>
<p>One implementation for the recursive composition is to let each object have references to others of the same type. In C, for example, a binary tree can be defined like:</p>
<p>WHATSON? 10d1d774-ae13-4ca6-92b7-b699c783c6e7</p>
<pre class="de1">
<span class="kw4">struct</span> bintree
<span class="br0">{</span>
 <span class="kw4">struct</span> bintree <span class="sy0">*</span>left<span class="sy0">,</span> <span class="sy0">*</span>right<span class="sy0">;</span>
 <span class="co1">// some data</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>If pointers <code>left</code> and <code>right</code> are valid, the node is thought to be a branch referring to each tree to which <code>left</code> and <code>right</code> point. If not, the node is a leaf. In this way, the recursion can be terminated.</p>
<p>Another is to use a tagged union. For e.g. see <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a>.</p>
<h2><span class="mw-headline" id="Timeline_of_composition_in_various_languages">Timeline of composition in various languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=4" title="Edit section: Timeline of composition in various languages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> calls a record a <a href="/wiki/Struct_(C_programming_language)" title="Struct (C programming language)">struct</a> or structure; <a href="/wiki/Object-oriented" title="Object-oriented" class="mw-redirect">object-oriented</a> languages such as <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>, and <a href="/wiki/C%2B%2B" title="C++">C++</a> often keep their records hidden inside <a href="/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> (<a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a> instances); languages in the <a href="/wiki/ML_programming_language" title="ML programming language" class="mw-redirect">ML</a> family simply call them records. <a href="/wiki/COBOL" title="COBOL">COBOL</a> was the first <a href="/wiki/Programming_language" title="Programming language">programming language</a> to support records directly<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (February 2009)">citation needed</span></a></i>]</sup>; <a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a> got it from COBOL and <a href="/wiki/Pascal_programming_language" title="Pascal programming language" class="mw-redirect">Pascal</a> got it, more or less indirectly, from ALGOL 68. <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a> provides structures and classes (the latter via the <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a>).</p>
<p>WHATSON? 8f8b8245-6dc9-422f-8180-f7148a0d0269</p>
<pre class="de1">
<span class="nu0">01</span>  customer-record<span class="sy0">.</span>
  <span class="nu0">03</span>  customer-number     <span class="kw2">pic</span> <span class="nu0">9</span><span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span> <span class="kw2">comp</span><span class="sy0">.</span>
  <span class="nu0">03</span>  customer-name<span class="sy0">.</span>
    <span class="nu0">05</span>  given-names       <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  initial-<span class="nu0">2</span>         <span class="kw2">pic</span> x<span class="sy0">.</span>
    <span class="nu0">05</span>  surname           <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy0">.</span>
  <span class="nu0">03</span>  customer-address<span class="sy0">.</span>
    <span class="nu0">05</span>  street<span class="sy0">.</span>
      <span class="nu0">07</span>  house-number    <span class="kw2">pic</span> <span class="nu0">999</span> <span class="kw2">comp</span><span class="sy0">.</span>
      <span class="nu0">07</span>  street-name     <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  city              <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  country-code      <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  postcode          <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span><span class="sy0">.</span>
 <span class="nu0">03</span>  amount-owing         <span class="kw2">pic</span> <span class="nu0">9</span><span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span> <span class="kw2">comp</span><span class="sy0">.</span>
</pre>
<p>Arrays were the only composite data type in <a href="/wiki/Algol_60" title="Algol 60" class="mw-redirect">Algol 60</a>.</p>
<p>WHATSON? 898073e5-781b-4c38-bcea-91764f6adbdd</p>
<pre class="de1">
<span class="kw1">dcl</span> <span class="nu0">1</span> newtypet <span class="kw1">based</span> <span class="br0">(</span>P<span class="br0">)</span><span class="sy0">;</span>
 <span class="nu0">2</span> <span class="br0">(</span>a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="br0">)</span> <span class="kw1">fixed</span> <span class="kw1">bin</span><span class="br0">(</span><span class="nu0">31</span><span class="br0">)</span><span class="sy0">,</span>
 <span class="nu0">2</span> <span class="br0">(</span>i<span class="sy0">,</span> j<span class="sy0">,</span> k<span class="br0">)</span> <span class="kw1">float</span><span class="sy0">,</span>
 <span class="nu0">2</span> r <span class="kw1">ptr</span><span class="sy0">;</span>
<span class="kw1">allocate</span> newtypet<span class="sy0">;</span>
</pre>
<p>WHATSON? b1cc4ba5-3587-4a16-b0d8-0aa1459e02c5</p>
<pre class="de1">
int max <span class="sy1">=</span> 99<span class="sy1">;</span>
mode newtypet <span class="sy1">=</span> <span class="br0">[</span>0..9<span class="br0">]</span> <span class="br0">[</span>0..max<span class="br0">]</span>struct <span class="br0">(</span>
 long <span class="kw26">real</span> a<span class="sy1">,</span> b<span class="sy1">,</span> c<span class="sy1">,</span> short int i<span class="sy1">,</span> j<span class="sy1">,</span> k<span class="sy1">,</span> ref <span class="kw26">real</span> r
<span class="br0">)</span><span class="sy1">;</span>
newtypet newarrayt <span class="sy1">=</span> <span class="br0">(</span>1<span class="sy1">,</span> 2<span class="sy1">,</span> 3<span class="sy1">,</span> 4<span class="sy1">,</span> 5<span class="sy1">,</span> 6<span class="sy1">,</span> heap <span class="kw26">real</span> <span class="sy1">:=</span> 7<span class="br0">)</span>
</pre>
<p>For an example of all this, here is the traditional linked list declaration:</p>
<p>WHATSON? 457ee2e9-6354-4737-a037-64c9b9ddc02b</p>
<pre class="de1">
mode node <span class="sy1">=</span> union <span class="br0">(</span><span class="kw26">real</span><span class="sy1">,</span> int<span class="sy1">,</span> compl<span class="sy1">,</span> string<span class="br0">)</span><span class="sy1">,</span>
 list <span class="sy1">=</span> struct <span class="br0">(</span>node val<span class="sy1">,</span> ref list next<span class="br0">)</span><span class="sy1">;</span>
</pre>
<p>Note that for ALGOL 68 only the newtype name appears to the left of the equality, and most notably the construction is made – and can be read – from left to right without regard to priorities.</p>
<p>WHATSON? d1184a89-fb68-44bf-8aea-c15433cbe200</p>
<pre class="de1">
<span class="kw1">type</span>
 a <span class="sy3">=</span> <span class="kw4">array</span> <span class="br0">[</span><span class="nu0">1</span><span class="sy1">..</span><span class="nu0">10</span><span class="br0">]</span> <span class="kw1">of</span> <span class="kw4">integer</span><span class="sy1">;</span>
 b <span class="sy3">=</span> <span class="kw4">record</span>
 a<span class="sy1">,</span> b<span class="sy1">,</span> c<span class="sy1">:</span> <span class="kw4">real</span><span class="sy1">;</span>
 i<span class="sy1">,</span> j<span class="sy1">,</span> k<span class="sy1">:</span> <span class="kw4">integer</span><span class="sy1">;</span>
 <span class="kw1">end</span><span class="sy1">;</span>
</pre>
<p>WHATSON? f3104773-6ec1-42db-8a27-efd64c3bc170</p>
<pre class="de1">
<span class="co2">#define max 99</span>
<span class="kw4">struct</span> newtypet <span class="br0">{</span>
 <span class="kw4">double</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="sy0">;</span>
 <span class="kw4">float</span> r<span class="sy0">;</span>
 <span class="kw4">short</span> i<span class="sy0">,</span> j<span class="sy0">,</span> k<span class="sy0">;</span>
<span class="br0">}</span> newarrayt<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="br0">[</span>max <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
</pre>
<p>Fortran 77 has arrays, but lacked any formal record/structure definitions. Typically compound structures were built up using <code>EQUIVALENCE</code> or <code>COMMON</code> statements:</p>
<p>WHATSON? 2a77d644-5924-4d63-a237-2fa9a6b6b72b</p>
<pre class="de1">
      <span class="kw3">CHARACTER</span> <span class="kw1">NAME</span><span class="sy0">*</span><span class="nu0">32</span>, ADDR<span class="sy0">*</span><span class="nu0">32</span>, PHONE<span class="sy0">*</span><span class="nu0">16</span>
      <span class="kw3">REAL</span> OWING
      <span class="kw3">COMMON</span> <span class="sy0">/</span>CUST<span class="sy0">/</span><span class="kw1">NAME</span>, ADDR, PHONE, OWING
</pre>
<p>WHATSON? 7b5a259b-3765-43fd-a632-e4f14c679ddb</p>
<pre class="de1">
<span class="kw3">type</span> Cust <span class="kw1">is</span>
 <span class="kw3">record</span>
 Name : Name_Type;
 Addr : Addr_Type;
 Phone : Phone_Type;
 Owing : Integer <span class="kw3">range</span> <span class="nu0">1</span>..<span class="nu0">999999</span>;
 <span class="kw1">end</span> <span class="kw3">record</span>;
</pre>
<p>WHATSON? 67ba3248-2575-4caa-ad3c-c15197972107</p>
<pre class="de1">
<span class="kw4">const</span> <span class="kw4">int</span> max <span class="sy1">=</span> <span class="nu0">99</span><span class="sy4">;</span>
<span class="kw2">class</span><span class="br0">{</span>
 <span class="kw2">public</span><span class="sy4">:</span>
 <span class="kw4">double</span> a, b, c<span class="sy4">;</span>
 <span class="kw4">float</span> <span class="sy3">&amp;</span>r<span class="sy4">;</span>
 <span class="kw4">short</span> i, j, k<span class="sy4">;</span>
<span class="br0">}</span>newtypet<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="br0">[</span>max <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
</pre>
<p>WHATSON? 7669b440-8e30-4975-a0c5-85032d412557</p>
<pre class="de1">
<span class="kw2">max</span> <span class="sy0">=</span> <span class="nu0">99</span>
<span class="kw1">class</span> NewTypeT:
  <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
    <span class="kw2">self</span>.<span class="me1">a</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">b</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">c</span> <span class="sy0">=</span> <span class="nu0">0</span>
    <span class="kw2">self</span>.<span class="me1">i</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">j</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">k</span> <span class="sy0">=</span> <span class="nu0">0.0</span>
<span class="co1"># Initialise an example array of this class.</span>
newarrayt <span class="sy0">=</span> <span class="br0">[</span><span class="br0">[</span>NewTypeT<span class="br0">(</span><span class="br0">)</span> <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="kw2">max</span> + <span class="nu0">1</span><span class="br0">)</span><span class="br0">]</span> <span class="kw1">for</span> j <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">]</span>
</pre>
<p>Arrays and strings were inherited from FORTRAN 77, and a new reserved word was introduced: <b>type</b></p>
<p>WHATSON? ec6f43cc-6e43-486c-bc52-ae7140568cd2</p>
<pre class="de1">
<span class="kw3">type</span> newtypet
 <span class="kw3">double</span> <span class="kw4">precision</span> a, b, c
 <span class="kw3">integer</span><span class="sy0">*</span><span class="nu0">2</span> i, j, k
<span class="sy0">*</span> No <span class="kw3">pointer</span> <span class="kw3">type</span> REF <span class="kw3">REAL</span> R
 <span class="kw1">end</span> <span class="kw3">type</span>
 
<span class="kw3">type</span> <span class="br0">(</span>newtypet<span class="br0">)</span> t<span class="br0">(</span><span class="nu0">10</span>, <span class="nu0">100</span><span class="br0">)</span>
</pre>
<p>FORTRAN 90 updated and included <a href="/wiki/FORTRAN_IV" title="FORTRAN IV" class="mw-redirect">FORTRAN IV</a>'s concept called NAMELIST.</p>
<p>WHATSON? b3ff0c9b-6bab-4690-bb60-edf0b6ac621a</p>
<pre class="de1">
<span class="kw3">INTEGER</span> <span class="sy0">::</span> <span class="me2">jan</span> <span class="sy0">=</span> <span class="nu0">1</span>, feb <span class="sy0">=</span> <span class="nu0">2</span>, mar <span class="sy0">=</span> <span class="nu0">3</span>, apr <span class="sy0">=</span> <span class="nu0">4</span>
<span class="kw3">NAMELIST</span> <span class="sy0">/</span> week <span class="sy0">/</span> jan, feb, mar, apr
</pre>
<p>Common Lisp provides structures and the ANSI Common Lisp standard added CLOS classes.</p>
<p>WHATSON? b16fd961-749e-4841-b4bc-5bc45e71154a</p>
<pre class="de1">
<span class="br0">(</span>defclass some-class <span class="br0">(</span><span class="br0">)</span>
 <span class="br0">(</span><span class="br0">(</span>f <span class="sy0">:</span><span class="me1">type</span> <span class="kw1">float</span><span class="br0">)</span>
 <span class="br0">(</span>i <span class="sy0">:</span><span class="me1">type</span> <span class="kw1">integer</span><span class="br0">)</span>
 <span class="br0">(</span>a <span class="sy0">:</span><span class="me1">type</span> <span class="br0">(</span><span class="kw1">array</span> <span class="kw1">integer</span> <span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>For more details about composition in C/C++, see <a href="/wiki/Composite_type" title="Composite type" class="mw-redirect">Composite type</a>.</p>
<h2><span class="mw-headline" id="Aggregation">Aggregation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=5" title="Edit section: Aggregation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Aggregation differs from ordinary composition in that it does not imply ownership. In composition, when the owning object is destroyed, so are the contained objects. In aggregation, this is not necessarily true. For example, a <a href="/wiki/University" title="University">university</a> owns various departments (e.g., <a href="/wiki/Chemistry" title="Chemistry">chemistry</a>), and each department has a number of professors. If the university closes, the departments will no longer exist, but the professors in those departments will continue to exist. Therefore, a University can be seen as a composition of departments, whereas departments have an aggregation of professors. In addition, a Professor could work in more than one department, but a department could not be part of more than one university.</p>
<p>Composition is usually implemented such that an object contains another object. For example, in <a href="/wiki/C%2B%2B" title="C++">C++</a>:</p>
<p>WHATSON? 767443a3-a5ab-430c-a698-a025f91b330c</p>
<pre class="de1">
<span class="kw2">class</span> Professor<span class="sy4">;</span>
 
<span class="kw2">class</span> Department
<span class="br0">{</span>
    ...
    <span class="kw2">private</span><span class="sy4">:</span>
    <span class="co1">// Aggregation</span>
    Professor<span class="sy2">*</span> members<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy4">;</span>
    ...
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw2">class</span> University
<span class="br0">{</span>
    ...
    <span class="kw2">private</span><span class="sy4">:</span>
 
    std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span> Department <span class="sy1">&gt;</span> faculty<span class="sy4">;</span>
    ...
 
    <span class="me1">create_dept</span><span class="br0">(</span><span class="br0">)</span>
    <span class="br0">{</span>
        ...
        <span class="co1">// Composition (must limit to 20)</span>
        faculty.<span class="me1">push_back</span><span class="br0">(</span> Department<span class="br0">(</span>...<span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span>
        faculty.<span class="me1">push_back</span><span class="br0">(</span> Department<span class="br0">(</span>...<span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span>
        ...
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre>
<p>In aggregation, the object may only contain a reference or pointer to the object (and not have lifetime responsibility for it).</p>
<p>Sometimes aggregation is referred to as composition when the distinction between ordinary composition and aggregation is unimportant.</p>
<p>The above code would transform into the following UML Class diagram:</p>
<p><a href="/wiki/File:Aggregation-Composition3.png" class="image" title="417.px"><img alt="417.px" src="//upload.wikimedia.org/wikipedia/commons/d/d0/Aggregation-Composition3.png" width="417" height="59" data-file-width="417" data-file-height="59"></a></p>
<h2><span class="mw-headline" id="Containment">Containment</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=6" title="Edit section: Containment">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Composition that is used to store several instances of the composited data type is referred to as containment. Examples of such containers are arrays, <a href="/wiki/Linked_list" title="Linked list">linked lists</a>, <a href="/wiki/Binary_tree" title="Binary tree">binary trees</a> and <a href="/wiki/Associative_array" title="Associative array">associative arrays</a>.</p>
<p>In <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a>, containment is depicted with a multiplicity of 1 or 0..n (depending on the issue of ownership), indicating that the data type is composed of an unknown number of instances of the composited data type.</p>
<h2><span class="mw-headline" id="Aggregation_in_COM">Aggregation in COM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=7" title="Edit section: Aggregation in COM">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In Microsoft's <a href="/wiki/Component_Object_Model" title="Component Object Model">Component Object Model</a> aggregation means that an object exports, as if it were their owner, one or several <a href="/wiki/Interface_(computer_science)" title="Interface (computer science)" class="mw-redirect">interfaces</a> of another object it owns. Formally, this is more similar to composition or encapsulation than aggregation. However, instead of implementing the exported interfaces by calling the interfaces of the owned object, the interfaces of the owned object themselves are exported. The owned object is responsible for assuring that methods of those interfaces inherited from <a href="/wiki/IUnknown" title="IUnknown">IUnknown</a> actually invoke the corresponding methods of the owner. This is to guarantee that the reference count of the owner is correct and all interfaces of the owner are accessible through the exported interface, while no other (private) interfaces of the owned object are accessible.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=8" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/C%2B%2B_structure" title="C++ structure" class="mw-redirect">C++ structure</a></li>
<li><a href="/wiki/Composite_type" title="Composite type" class="mw-redirect">Composite type</a></li>
<li><a href="/wiki/Composition_over_inheritance" title="Composition over inheritance">Composition over inheritance</a></li>
<li><a href="/wiki/Has-a" title="Has-a">Has-a</a></li>
<li><a href="/wiki/Law_of_Demeter" title="Law of Demeter">Law of Demeter</a></li>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Inheritance_semantics" title="Inheritance semantics" class="mw-redirect">Inheritance semantics</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=9" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://msdn2.microsoft.com/en-us/library/ms686558.aspx">"Aggregation"</a>. <i>Platform SDK for Windows XP SP2</i>. Microsoft<span class="reference-accessdate">. Retrieved 2007-11-04</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+composition&amp;rft.atitle=Aggregation&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fmsdn2.microsoft.com%2Fen-us%2Flibrary%2Fms686558.aspx&amp;rft.jtitle=Platform+SDK+for+Windows+XP+SP2&amp;rft.pub=Microsoft&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<ul>
<li><a rel="nofollow" class="external text" href="http://ootips.org/uml-hasa.html">Association, Aggregation and Composition</a>, accessed in February 2009</li>
<li>Harald Störrle, UML2, Addison-Wesley 2005</li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Object composition</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>object composition</b> (not to be confused with <a href="/wiki/Function_composition_(computer_science)" title="Function composition (computer science)">function composition</a>) is a way to <a href="/wiki/Object_association" title="Object association" class="mw-redirect">combine</a> simple <a href="/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> or <a href="/wiki/Data_type" title="Data type">data types</a> into more complex ones. Compositions are a critical building block of many basic data structures, including the <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a>, the <a href="/wiki/Linked_list" title="Linked list">linked list</a>, and the <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a>, as well as the <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> used in object-oriented programming.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2014)">citation needed</span></a></i>]</sup></p>
<p>A real-world example of composition may be seen in the relation of an automobile to its parts, specifically: the <i><a href="/wiki/Automobile" title="Automobile" class="mw-redirect">automobile</a></i> 'has or is composed from' objects including <i><a href="/wiki/Steering_wheel" title="Steering wheel">steering wheel</a></i>, <i>seat</i>, <i><a href="/wiki/Gearbox" title="Gearbox" class="mw-redirect">gearbox</a></i> and <i><a href="/wiki/Engine" title="Engine">engine</a></i>.</p>
<p>When, in a language, objects are typed, types can often be divided into composite and noncomposite types, and composition can be regarded as a relationship between types: an object of a composite type (e.g. <i>car</i>) "<a href="/wiki/Has-a" title="Has-a">has an</a>" object of a simpler type (e.g. <i>wheel</i>).</p>
<p>Composition must be distinguished from <a href="/wiki/Subtyping" title="Subtyping">subtyping</a>, which is the process of adding detail to a general data type to create a more specific data type. For instance, cars may be a specific type of vehicle: <i>car</i> <a href="/wiki/Is-a" title="Is-a">is a</a> <i>vehicle</i>. Subtyping doesn't describe a relationship between different objects, but instead, says that objects of a type are simultaneously objects of another type.</p>
<p>In programming languages, composite objects are usually expressed by means of references from one object to another; depending on the language, such references may be known as <b>fields</b>, <b>members</b>, <b>properties</b> or <b>attributes</b>, and the resulting composition as a <b>structure</b>, <b><a href="/wiki/Storage_record" title="Storage record">storage record</a></b>, <b><a href="/wiki/Tuple" title="Tuple">tuple</a></b>, <b>user-defined type (UDT)</b>, or <b><a href="/wiki/Composite_type" title="Composite type" class="mw-redirect">composite type</a></b>. Fields are given a unique name so that each one can be distinguished from the others. However, having such references doesn't necessarily mean that an object is a composite. It is only called composite if the objects it refers to are really its parts, i.e. have no independent existence. For details, see the aggregation section below.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#UML_notation"><span class="tocnumber">1</span> <span class="toctext">UML notation</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Composite_types_in_C"><span class="tocnumber">2</span> <span class="toctext">Composite types in C</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Recursive_composition"><span class="tocnumber">3</span> <span class="toctext">Recursive composition</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Timeline_of_composition_in_various_languages"><span class="tocnumber">4</span> <span class="toctext">Timeline of composition in various languages</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Aggregation"><span class="tocnumber">5</span> <span class="toctext">Aggregation</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Containment"><span class="tocnumber">6</span> <span class="toctext">Containment</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Aggregation_in_COM"><span class="tocnumber">7</span> <span class="toctext">Aggregation in COM</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="UML_notation">UML notation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=1" title="Edit section: UML notation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a>, there are two ways of modelling composition: Composition and aggregation. Beware that in UML composition has a more narrow meaning than in ordinary language:</p>
<p>Composition is depicted as a <b>filled diamond</b> and a solid line.</p>
<p>Composition is a kind of association where the composite object has sole responsibility for the disposition of the component parts. The relationship between the composite and the component is a strong “has a” relationship, as the composite object takes ownership of the component. This means the composite is responsible for the creation and destruction of the component parts. An object may only be part of one composite. If the composite object is destroyed, all the component parts must be destroyed. The part has no life of itself and cannot be transferred to another object. Composition enforces encapsulation as the component parts usually are members of the composite object.</p>
<p>The more general form, <a href="/wiki/Object_composition#Aggregation" title="Object composition">aggregation</a>, is depicted as an <b>unfilled diamond</b> and a solid line.</p>
<p>Aggregation is a kind of association that specifies a whole/part relationship between the aggregate (whole) and component part. This relationship between the aggregate and component is a weak “has a” relationship as the component may survive the aggregate object. The component object may be accessed through other objects without going through the aggregate object. The aggregate object does not take part in the lifecycle of the component object, meaning the component object may outlive the aggregate object. The state of the component object still forms part of the aggregate object.</p>
<p>The image below shows both composition and aggregation. (Note that the examples show abstracted data models, disregarding the fact that in a real world carburetor -&gt; car association, there is a market for spare parts.) The C++ code below shows what the source code is likely to look like.</p>
<p><a href="/wiki/File:AggregationAndComposition.svg" class="image"><img alt="AggregationAndComposition.svg" src="//upload.wikimedia.org/wikipedia/en/thumb/9/9f/AggregationAndComposition.svg/250px-AggregationAndComposition.svg.png" width="250" height="89" srcset="//upload.wikimedia.org/wikipedia/en/thumb/9/9f/AggregationAndComposition.svg/375px-AggregationAndComposition.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/9/9f/AggregationAndComposition.svg/500px-AggregationAndComposition.svg.png 2x" data-file-width="400" data-file-height="143"></a></p>
<p>WHATSON? 28480acf-1f92-44f6-be05-3dca08cb0c6b</p>
<pre class="de1">
<span class="co1">// Composition</span>
<span class="kw2">class</span> Car
<span class="br0">{</span>
<span class="kw2">private</span><span class="sy4">:</span>
 
    <span class="co1">// Car is the owner of carburetor.</span>
    <span class="co1">// Carburetor is created when Car is created,</span>
    <span class="co1">// it is destroyed when Car is destroyed.</span>
    Carburetor carb<span class="sy4">;</span>
 
<span class="br0">}</span><span class="sy4">;</span>
</pre>
<p>WHATSON? 1586fc39-2701-4ce4-bb6b-ce0d8e05103d</p>
<pre class="de1">
<span class="co1">// Aggregation</span>
<span class="kw2">class</span> Pond
<span class="br0">{</span>
<span class="kw2">private</span><span class="sy4">:</span>
   std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>Duck<span class="sy2">*</span><span class="sy1">&gt;</span> ducks<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre>
<h2><span class="mw-headline" id="Composite_types_in_C">Composite types in C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=2" title="Edit section: Composite types in C">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This is an example of composition in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>.</p>
<p>WHATSON? e28e60f8-2395-41b3-844d-bdeb8378d792</p>
<pre class="de1">
<span class="kw4">struct</span> Person
<span class="br0">{</span>
 <span class="kw4">int</span> age<span class="sy0">;</span>
 <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">;</span>
 <span class="kw2">enum</span> <span class="br0">{</span>they<span class="sy0">,</span> she<span class="sy0">,</span> he<span class="br0">}</span> pronoun<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>In this example, the primitive types <code>int</code>, <code>char *</code>, and <code>enum {they, she, he}</code> are combined to form the composite structure <code>Person</code>. Each <code>Person</code> structure then "has an" age, name, and a pronoun they are referred to by.</p>
<h2><span class="mw-headline" id="Recursive_composition">Recursive composition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=3" title="Edit section: Recursive composition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Objects can be composited recursively with the use of <a href="/wiki/Recursive_type" title="Recursive type" class="mw-redirect">recursive types</a> or <a href="/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a>. Consider a tree. Each node in a tree may be a branch or leaf; in other words, each node is a tree at the same time when it belongs to another tree.</p>
<p>One implementation for the recursive composition is to let each object have references to others of the same type. In C, for example, a binary tree can be defined like:</p>
<p>WHATSON? a8e85816-d779-477f-b8ee-5c6079f07c75</p>
<pre class="de1">
<span class="kw4">struct</span> bintree
<span class="br0">{</span>
 <span class="kw4">struct</span> bintree <span class="sy0">*</span>left<span class="sy0">,</span> <span class="sy0">*</span>right<span class="sy0">;</span>
 <span class="co1">// some data</span>
<span class="br0">}</span><span class="sy0">;</span>
</pre>
<p>If pointers <code>left</code> and <code>right</code> are valid, the node is thought to be a branch referring to each tree to which <code>left</code> and <code>right</code> point. If not, the node is a leaf. In this way, the recursion can be terminated.</p>
<p>Another is to use a tagged union. For e.g. see <a href="/wiki/Tagged_union" title="Tagged union">tagged union</a>.</p>
<h2><span class="mw-headline" id="Timeline_of_composition_in_various_languages">Timeline of composition in various languages</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=4" title="Edit section: Timeline of composition in various languages">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> calls a record a <a href="/wiki/Struct_(C_programming_language)" title="Struct (C programming language)">struct</a> or structure; <a href="/wiki/Object-oriented" title="Object-oriented" class="mw-redirect">object-oriented</a> languages such as <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>, and <a href="/wiki/C%2B%2B" title="C++">C++</a> often keep their records hidden inside <a href="/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> (<a href="/wiki/Class_(computer_science)" title="Class (computer science)" class="mw-redirect">class</a> instances); languages in the <a href="/wiki/ML_programming_language" title="ML programming language" class="mw-redirect">ML</a> family simply call them records. <a href="/wiki/COBOL" title="COBOL">COBOL</a> was the first <a href="/wiki/Programming_language" title="Programming language">programming language</a> to support records directly<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (February 2009)">citation needed</span></a></i>]</sup>; <a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a> got it from COBOL and <a href="/wiki/Pascal_programming_language" title="Pascal programming language" class="mw-redirect">Pascal</a> got it, more or less indirectly, from ALGOL 68. <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a> provides structures and classes (the latter via the <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a>).</p>
<p>WHATSON? 77529f6a-5414-4feb-ac4d-7093f1e2dbb6</p>
<pre class="de1">
<span class="nu0">01</span>  customer-record<span class="sy0">.</span>
  <span class="nu0">03</span>  customer-number     <span class="kw2">pic</span> <span class="nu0">9</span><span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span> <span class="kw2">comp</span><span class="sy0">.</span>
  <span class="nu0">03</span>  customer-name<span class="sy0">.</span>
    <span class="nu0">05</span>  given-names       <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  initial-<span class="nu0">2</span>         <span class="kw2">pic</span> x<span class="sy0">.</span>
    <span class="nu0">05</span>  surname           <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy0">.</span>
  <span class="nu0">03</span>  customer-address<span class="sy0">.</span>
    <span class="nu0">05</span>  street<span class="sy0">.</span>
      <span class="nu0">07</span>  house-number    <span class="kw2">pic</span> <span class="nu0">999</span> <span class="kw2">comp</span><span class="sy0">.</span>
      <span class="nu0">07</span>  street-name     <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  city              <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  country-code      <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">.</span>
    <span class="nu0">05</span>  postcode          <span class="kw2">pic</span> x<span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span><span class="sy0">.</span>
 <span class="nu0">03</span>  amount-owing         <span class="kw2">pic</span> <span class="nu0">9</span><span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span> <span class="kw2">comp</span><span class="sy0">.</span>
</pre>
<p>Arrays were the only composite data type in <a href="/wiki/Algol_60" title="Algol 60" class="mw-redirect">Algol 60</a>.</p>
<p>WHATSON? ff7324bb-dead-499d-97d6-e58545cc1719</p>
<pre class="de1">
<span class="kw1">dcl</span> <span class="nu0">1</span> newtypet <span class="kw1">based</span> <span class="br0">(</span>P<span class="br0">)</span><span class="sy0">;</span>
 <span class="nu0">2</span> <span class="br0">(</span>a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="br0">)</span> <span class="kw1">fixed</span> <span class="kw1">bin</span><span class="br0">(</span><span class="nu0">31</span><span class="br0">)</span><span class="sy0">,</span>
 <span class="nu0">2</span> <span class="br0">(</span>i<span class="sy0">,</span> j<span class="sy0">,</span> k<span class="br0">)</span> <span class="kw1">float</span><span class="sy0">,</span>
 <span class="nu0">2</span> r <span class="kw1">ptr</span><span class="sy0">;</span>
<span class="kw1">allocate</span> newtypet<span class="sy0">;</span>
</pre>
<p>WHATSON? fd4f5a09-35f3-4c01-a3f0-c09bccaaaf44</p>
<pre class="de1">
int max <span class="sy1">=</span> 99<span class="sy1">;</span>
mode newtypet <span class="sy1">=</span> <span class="br0">[</span>0..9<span class="br0">]</span> <span class="br0">[</span>0..max<span class="br0">]</span>struct <span class="br0">(</span>
 long <span class="kw26">real</span> a<span class="sy1">,</span> b<span class="sy1">,</span> c<span class="sy1">,</span> short int i<span class="sy1">,</span> j<span class="sy1">,</span> k<span class="sy1">,</span> ref <span class="kw26">real</span> r
<span class="br0">)</span><span class="sy1">;</span>
newtypet newarrayt <span class="sy1">=</span> <span class="br0">(</span>1<span class="sy1">,</span> 2<span class="sy1">,</span> 3<span class="sy1">,</span> 4<span class="sy1">,</span> 5<span class="sy1">,</span> 6<span class="sy1">,</span> heap <span class="kw26">real</span> <span class="sy1">:=</span> 7<span class="br0">)</span>
</pre>
<p>For an example of all this, here is the traditional linked list declaration:</p>
<p>WHATSON? fd0a1ee6-fe15-428a-b054-d03227a811c4</p>
<pre class="de1">
mode node <span class="sy1">=</span> union <span class="br0">(</span><span class="kw26">real</span><span class="sy1">,</span> int<span class="sy1">,</span> compl<span class="sy1">,</span> string<span class="br0">)</span><span class="sy1">,</span>
 list <span class="sy1">=</span> struct <span class="br0">(</span>node val<span class="sy1">,</span> ref list next<span class="br0">)</span><span class="sy1">;</span>
</pre>
<p>Note that for ALGOL 68 only the newtype name appears to the left of the equality, and most notably the construction is made – and can be read – from left to right without regard to priorities.</p>
<p>WHATSON? e3d41c47-a8bf-4d11-8caa-61661aecad77</p>
<pre class="de1">
<span class="kw1">type</span>
 a <span class="sy3">=</span> <span class="kw4">array</span> <span class="br0">[</span><span class="nu0">1</span><span class="sy1">..</span><span class="nu0">10</span><span class="br0">]</span> <span class="kw1">of</span> <span class="kw4">integer</span><span class="sy1">;</span>
 b <span class="sy3">=</span> <span class="kw4">record</span>
 a<span class="sy1">,</span> b<span class="sy1">,</span> c<span class="sy1">:</span> <span class="kw4">real</span><span class="sy1">;</span>
 i<span class="sy1">,</span> j<span class="sy1">,</span> k<span class="sy1">:</span> <span class="kw4">integer</span><span class="sy1">;</span>
 <span class="kw1">end</span><span class="sy1">;</span>
</pre>
<p>WHATSON? 2d1faedd-5ba2-4086-b2ca-d1e232c12063</p>
<pre class="de1">
<span class="co2">#define max 99</span>
<span class="kw4">struct</span> newtypet <span class="br0">{</span>
 <span class="kw4">double</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="sy0">;</span>
 <span class="kw4">float</span> r<span class="sy0">;</span>
 <span class="kw4">short</span> i<span class="sy0">,</span> j<span class="sy0">,</span> k<span class="sy0">;</span>
<span class="br0">}</span> newarrayt<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="br0">[</span>max <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
</pre>
<p>Fortran 77 has arrays, but lacked any formal record/structure definitions. Typically compound structures were built up using <code>EQUIVALENCE</code> or <code>COMMON</code> statements:</p>
<p>WHATSON? e2ecb1e9-a914-43b5-9a69-17e105789a6c</p>
<pre class="de1">
      <span class="kw3">CHARACTER</span> <span class="kw1">NAME</span><span class="sy0">*</span><span class="nu0">32</span>, ADDR<span class="sy0">*</span><span class="nu0">32</span>, PHONE<span class="sy0">*</span><span class="nu0">16</span>
      <span class="kw3">REAL</span> OWING
      <span class="kw3">COMMON</span> <span class="sy0">/</span>CUST<span class="sy0">/</span><span class="kw1">NAME</span>, ADDR, PHONE, OWING
</pre>
<p>WHATSON? 5b708fd3-7cbd-4715-8129-53fb498ceb71</p>
<pre class="de1">
<span class="kw3">type</span> Cust <span class="kw1">is</span>
 <span class="kw3">record</span>
 Name : Name_Type;
 Addr : Addr_Type;
 Phone : Phone_Type;
 Owing : Integer <span class="kw3">range</span> <span class="nu0">1</span>..<span class="nu0">999999</span>;
 <span class="kw1">end</span> <span class="kw3">record</span>;
</pre>
<p>WHATSON? 285a8b54-e853-46ca-a190-98cb4b8d8398</p>
<pre class="de1">
<span class="kw4">const</span> <span class="kw4">int</span> max <span class="sy1">=</span> <span class="nu0">99</span><span class="sy4">;</span>
<span class="kw2">class</span><span class="br0">{</span>
 <span class="kw2">public</span><span class="sy4">:</span>
 <span class="kw4">double</span> a, b, c<span class="sy4">;</span>
 <span class="kw4">float</span> <span class="sy3">&amp;</span>r<span class="sy4">;</span>
 <span class="kw4">short</span> i, j, k<span class="sy4">;</span>
<span class="br0">}</span>newtypet<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="br0">[</span>max <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy4">;</span>
</pre>
<p>WHATSON? 94fdfe7c-4903-4c2e-8165-63443ca45980</p>
<pre class="de1">
<span class="kw2">max</span> <span class="sy0">=</span> <span class="nu0">99</span>
<span class="kw1">class</span> NewTypeT:
  <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
    <span class="kw2">self</span>.<span class="me1">a</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">b</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">c</span> <span class="sy0">=</span> <span class="nu0">0</span>
    <span class="kw2">self</span>.<span class="me1">i</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">j</span> <span class="sy0">=</span> <span class="kw2">self</span>.<span class="me1">k</span> <span class="sy0">=</span> <span class="nu0">0.0</span>
<span class="co1"># Initialise an example array of this class.</span>
newarrayt <span class="sy0">=</span> <span class="br0">[</span><span class="br0">[</span>NewTypeT<span class="br0">(</span><span class="br0">)</span> <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="kw2">max</span> + <span class="nu0">1</span><span class="br0">)</span><span class="br0">]</span> <span class="kw1">for</span> j <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">]</span>
</pre>
<p>Arrays and strings were inherited from FORTRAN 77, and a new reserved word was introduced: <b>type</b></p>
<p>WHATSON? baa7769f-25d7-4c08-a759-c65e42093f49</p>
<pre class="de1">
<span class="kw3">type</span> newtypet
 <span class="kw3">double</span> <span class="kw4">precision</span> a, b, c
 <span class="kw3">integer</span><span class="sy0">*</span><span class="nu0">2</span> i, j, k
<span class="sy0">*</span> No <span class="kw3">pointer</span> <span class="kw3">type</span> REF <span class="kw3">REAL</span> R
 <span class="kw1">end</span> <span class="kw3">type</span>
 
<span class="kw3">type</span> <span class="br0">(</span>newtypet<span class="br0">)</span> t<span class="br0">(</span><span class="nu0">10</span>, <span class="nu0">100</span><span class="br0">)</span>
</pre>
<p>FORTRAN 90 updated and included <a href="/wiki/FORTRAN_IV" title="FORTRAN IV" class="mw-redirect">FORTRAN IV</a>'s concept called NAMELIST.</p>
<p>WHATSON? 046f21c8-4ae4-4b55-8466-3cacb92355d9</p>
<pre class="de1">
<span class="kw3">INTEGER</span> <span class="sy0">::</span> <span class="me2">jan</span> <span class="sy0">=</span> <span class="nu0">1</span>, feb <span class="sy0">=</span> <span class="nu0">2</span>, mar <span class="sy0">=</span> <span class="nu0">3</span>, apr <span class="sy0">=</span> <span class="nu0">4</span>
<span class="kw3">NAMELIST</span> <span class="sy0">/</span> week <span class="sy0">/</span> jan, feb, mar, apr
</pre>
<p>Common Lisp provides structures and the ANSI Common Lisp standard added CLOS classes.</p>
<p>WHATSON? f6784394-5454-4d7c-ad62-131b8ac8d575</p>
<pre class="de1">
<span class="br0">(</span>defclass some-class <span class="br0">(</span><span class="br0">)</span>
 <span class="br0">(</span><span class="br0">(</span>f <span class="sy0">:</span><span class="me1">type</span> <span class="kw1">float</span><span class="br0">)</span>
 <span class="br0">(</span>i <span class="sy0">:</span><span class="me1">type</span> <span class="kw1">integer</span><span class="br0">)</span>
 <span class="br0">(</span>a <span class="sy0">:</span><span class="me1">type</span> <span class="br0">(</span><span class="kw1">array</span> <span class="kw1">integer</span> <span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre>
<p>For more details about composition in C/C++, see <a href="/wiki/Composite_type" title="Composite type" class="mw-redirect">Composite type</a>.</p>
<h2><span class="mw-headline" id="Aggregation">Aggregation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=5" title="Edit section: Aggregation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Aggregation differs from ordinary composition in that it does not imply ownership. In composition, when the owning object is destroyed, so are the contained objects. In aggregation, this is not necessarily true. For example, a <a href="/wiki/University" title="University">university</a> owns various departments (e.g., <a href="/wiki/Chemistry" title="Chemistry">chemistry</a>), and each department has a number of professors. If the university closes, the departments will no longer exist, but the professors in those departments will continue to exist. Therefore, a University can be seen as a composition of departments, whereas departments have an aggregation of professors. In addition, a Professor could work in more than one department, but a department could not be part of more than one university.</p>
<p>Composition is usually implemented such that an object contains another object. For example, in <a href="/wiki/C%2B%2B" title="C++">C++</a>:</p>
<p>WHATSON? 4fbe6881-a2ce-462b-bcc1-ed9e5491058a</p>
<pre class="de1">
<span class="kw2">class</span> Professor<span class="sy4">;</span>
 
<span class="kw2">class</span> Department
<span class="br0">{</span>
    ...
    <span class="kw2">private</span><span class="sy4">:</span>
    <span class="co1">// Aggregation</span>
    Professor<span class="sy2">*</span> members<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy4">;</span>
    ...
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw2">class</span> University
<span class="br0">{</span>
    ...
    <span class="kw2">private</span><span class="sy4">:</span>
 
    std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span> Department <span class="sy1">&gt;</span> faculty<span class="sy4">;</span>
    ...
 
    <span class="me1">create_dept</span><span class="br0">(</span><span class="br0">)</span>
    <span class="br0">{</span>
        ...
        <span class="co1">// Composition (must limit to 20)</span>
        faculty.<span class="me1">push_back</span><span class="br0">(</span> Department<span class="br0">(</span>...<span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span>
        faculty.<span class="me1">push_back</span><span class="br0">(</span> Department<span class="br0">(</span>...<span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span>
        ...
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre>
<p>In aggregation, the object may only contain a reference or pointer to the object (and not have lifetime responsibility for it).</p>
<p>Sometimes aggregation is referred to as composition when the distinction between ordinary composition and aggregation is unimportant.</p>
<p>The above code would transform into the following UML Class diagram:</p>
<p><a href="/wiki/File:Aggregation-Composition3.png" class="image" title="417.px"><img alt="417.px" src="//upload.wikimedia.org/wikipedia/commons/d/d0/Aggregation-Composition3.png" width="417" height="59" data-file-width="417" data-file-height="59"></a></p>
<h2><span class="mw-headline" id="Containment">Containment</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=6" title="Edit section: Containment">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Composition that is used to store several instances of the composited data type is referred to as containment. Examples of such containers are arrays, <a href="/wiki/Linked_list" title="Linked list">linked lists</a>, <a href="/wiki/Binary_tree" title="Binary tree">binary trees</a> and <a href="/wiki/Associative_array" title="Associative array">associative arrays</a>.</p>
<p>In <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a>, containment is depicted with a multiplicity of 1 or 0..n (depending on the issue of ownership), indicating that the data type is composed of an unknown number of instances of the composited data type.</p>
<h2><span class="mw-headline" id="Aggregation_in_COM">Aggregation in COM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=7" title="Edit section: Aggregation in COM">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In Microsoft's <a href="/wiki/Component_Object_Model" title="Component Object Model">Component Object Model</a> aggregation means that an object exports, as if it were their owner, one or several <a href="/wiki/Interface_(computer_science)" title="Interface (computer science)" class="mw-redirect">interfaces</a> of another object it owns. Formally, this is more similar to composition or encapsulation than aggregation. However, instead of implementing the exported interfaces by calling the interfaces of the owned object, the interfaces of the owned object themselves are exported. The owned object is responsible for assuring that methods of those interfaces inherited from <a href="/wiki/IUnknown" title="IUnknown">IUnknown</a> actually invoke the corresponding methods of the owner. This is to guarantee that the reference count of the owner is correct and all interfaces of the owner are accessible through the exported interface, while no other (private) interfaces of the owned object are accessible.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=8" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/C%2B%2B_structure" title="C++ structure" class="mw-redirect">C++ structure</a></li>
<li><a href="/wiki/Composite_type" title="Composite type" class="mw-redirect">Composite type</a></li>
<li><a href="/wiki/Composition_over_inheritance" title="Composition over inheritance">Composition over inheritance</a></li>
<li><a href="/wiki/Has-a" title="Has-a">Has-a</a></li>
<li><a href="/wiki/Law_of_Demeter" title="Law of Demeter">Law of Demeter</a></li>
<li><a href="/wiki/Implementation_inheritance" title="Implementation inheritance" class="mw-redirect">Implementation inheritance</a></li>
<li><a href="/wiki/Inheritance_semantics" title="Inheritance semantics" class="mw-redirect">Inheritance semantics</a></li>
<li><a href="/wiki/Virtual_inheritance" title="Virtual inheritance">Virtual inheritance</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Object_composition&amp;action=edit&amp;section=9" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://msdn2.microsoft.com/en-us/library/ms686558.aspx">"Aggregation"</a>. <i>Platform SDK for Windows XP SP2</i>. Microsoft<span class="reference-accessdate">. Retrieved 2007-11-04</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AObject+composition&amp;rft.atitle=Aggregation&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fmsdn2.microsoft.com%2Fen-us%2Flibrary%2Fms686558.aspx&amp;rft.jtitle=Platform+SDK+for+Windows+XP+SP2&amp;rft.pub=Microsoft&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<ul>
<li><a rel="nofollow" class="external text" href="http://ootips.org/uml-hasa.html">Association, Aggregation and Composition</a>, accessed in February 2009</li>
<li>Harald Störrle, UML2, Addison-Wesley 2005</li>
</ul>
