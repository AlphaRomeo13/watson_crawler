<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Unification (computer science)</span></h1>
<p><b>Unification</b>, in <a href="/wiki/Computer_science" title="Computer science">computer science</a> and <a href="/wiki/Logic" title="Logic">logic</a>, is an algorithmic process of <a href="/wiki/Equation_solving" title="Equation solving">solving</a> <a href="/wiki/Equations" title="Equations" class="mw-redirect">equations</a> between symbolic <a href="/wiki/Expression_(mathematics)" title="Expression (mathematics)">expressions</a>.</p>
<p>Depending on which expressions (also called <i>terms</i>) are allowed to occur in an equation set (also called <b>unification problem</b>), and which expressions are considered equal, several <b>frameworks</b> of unification are distinguished. If <i>higher-order variables</i>, that is, variables representing functions, are allowed in an expression, the process is called <b>higher-order unification</b>, otherwise <b>first-order unification</b>. If a solution is required to make both sides of each equation literally equal, the process is called <b>syntactical unification</b>, otherwise <b>semantical</b>, or <b>equational unification</b>, or <b>E-unification</b>, or <b>unification modulo theory</b>.</p>
<p>A <b>solution</b> of a unification problem is denoted as a <a href="/wiki/Substitution_(logic)" title="Substitution (logic)">substitution</a>, that is, a mapping assigning a symbolic value to each variable of the problem's expressions. A unification <b>algorithm</b> should compute for a given problem a <b>complete</b>, and <b>minimal</b> substitution set, that is, a set covering all its solutions, and containing no redundant members. Depending on the framework, a complete and minimal substitution set may have at most one, at most finitely many, or possibly infinitely many members, or may not exist at all.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>note 1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>1<span>]</span></a></sup> In some frameworks it is generally impossible to decide whether any solution exists. For first-order syntactical unification, Martelli and Montanari<sup id="cite_ref-Martelli.Montanari.1982_3-0" class="reference"><a href="#cite_note-Martelli.Montanari.1982-3"><span>[</span>2<span>]</span></a></sup> gave an algorithm that reports unsolvability or computes a complete and minimal singleton substitution set containing the so-called <b>most general unifier</b>.</p>
<p>For example, using <i>x</i>,<i>y</i>,<i>z</i> as variables, the singleton equation set { <i><a href="/wiki/Cons" title="Cons">cons</a></i>(<i>x</i>,<i>cons</i>(<i>x</i>,<i><a href="/wiki/Lisp_(programming_language)#Lists" title="Lisp (programming language)">nil</a></i>)) = <i>cons</i>(2,<i>y</i>) } is a syntactic first-order unification problem that has the substitution { <i>x</i> ↦ 2, <i>y</i> ↦ <i>cons</i>(2,<i>nil</i>) } as its only solution. The syntactic first-order unification problem { <i>y</i> = <i>cons</i>(2,<i>y</i>) } has no solution over the set of <a href="/wiki/Term_(logic)" title="Term (logic)">finite terms</a>; however, it has the single solution { <i>y</i> ↦ <i>cons</i>(2,<i>cons</i>(2,<i>cons</i>(2,...))) } over the set of <a href="/wiki/Tree_(set_theory)" title="Tree (set theory)">infinite trees</a>. The semantic first-order unification problem { <i>a</i>⋅<i>x</i> = <i>x</i>⋅<i>a</i> } has each substitution of the form { <i>x</i> ↦ <i>a</i>⋅...⋅<i>a</i> } as a solution in a <a href="/wiki/Semigroup" title="Semigroup">semigroup</a>, i.e. if (⋅) is considered <a href="/wiki/Associative" title="Associative" class="mw-redirect">associative</a>; the same problem, viewed in an <a href="/wiki/Abelian_group" title="Abelian group">abelian group</a>, where (⋅) is considered also <a href="/wiki/Commutative" title="Commutative" class="mw-redirect">commutative</a>, has any substitution at all as a solution. The singleton set { <i>a</i> = <i>y</i>(<i>x</i>) } is a syntactic second-order unification problem, since <i>y</i> is a function variable. One solution is { <i>x</i> ↦ <i>a</i>, <i>y</i> ↦ (<a href="/wiki/Identity_function" title="Identity function">identity function</a>) }; another one is { <i>y</i> ↦ (<a href="/wiki/Constant_function" title="Constant function">constant function</a> mapping each value to <i>a</i>) }, for arbitrary <i>x</i>.</p>
<p>The first formal investigation of unification can be attributed to <a href="/wiki/J._Alan_Robinson" title="J. Alan Robinson" class="mw-redirect">John Alan Robinson</a>,<sup id="cite_ref-Robinson.1965_4-0" class="reference"><a href="#cite_note-Robinson.1965-4"><span>[</span>3<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>4<span>]</span></a></sup> who used first-order syntactical unification as a basic building block of his <a href="/wiki/Resolution_(logic)" title="Resolution (logic)">resolution</a> procedure for first-order logic, a great step forward in <a href="/wiki/Automated_reasoning" title="Automated reasoning">automated reasoning</a> technology, as it eliminated one source of combinatorial explosion: searching for instantiation of terms. Today, automated reasoning is still the main application area of unification. Syntactical first-order unification is used in <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a> and programming language <a href="/wiki/Type_system" title="Type system">type system</a> implementation, especially in <a href="/wiki/Hindley%E2%80%93Milner" title="Hindley–Milner" class="mw-redirect">Hindley–Milner</a> based type inference algorithms. Semantic unification is used in <a href="/wiki/SMT_solver" title="SMT solver" class="mw-redirect">SMT solvers</a> and term rewriting algorithms. Higher-order unification is used in proof assistants, for example <a href="/wiki/Isabelle_(theorem_prover)" title="Isabelle (theorem prover)" class="mw-redirect">Isabelle</a> and <a href="/wiki/Twelf" title="Twelf">Twelf</a>, and restricted forms of higher-order unification (<b>higher-order pattern unification</b>) are used in some programming language implementations, such as <a href="/wiki/LambdaProlog" title="LambdaProlog" class="mw-redirect">lambdaProlog</a>, as higher-order patterns are expressive, yet their associated unification procedure retains theoretical properties closer to first-order unification.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Common_formal_definitions"><span class="tocnumber">1</span> <span class="toctext">Common formal definitions</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Prerequisites"><span class="tocnumber">1.1</span> <span class="toctext">Prerequisites</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#First-order_term"><span class="tocnumber">1.2</span> <span class="toctext">First-order term</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Higher-order_term"><span class="tocnumber">1.3</span> <span class="toctext">Higher-order term</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Substitution"><span class="tocnumber">1.4</span> <span class="toctext">Substitution</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Generalization.2C_specialization"><span class="tocnumber">1.5</span> <span class="toctext">Generalization, specialization</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Unification_problem.2C_solution_set"><span class="tocnumber">1.6</span> <span class="toctext">Unification problem, solution set</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Syntactic_unification_of_first-order_terms"><span class="tocnumber">2</span> <span class="toctext">Syntactic unification of first-order terms</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#A_unification_algorithm"><span class="tocnumber">2.1</span> <span class="toctext">A unification algorithm</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#Occurs_check"><span class="tocnumber">2.1.1</span> <span class="toctext">Occurs check</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Proof_of_termination"><span class="tocnumber">2.1.2</span> <span class="toctext">Proof of termination</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Examples_of_syntactic_unification_of_first-order_terms"><span class="tocnumber">2.2</span> <span class="toctext">Examples of syntactic unification of first-order terms</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Application:_Unification_in_logic_programming"><span class="tocnumber">2.3</span> <span class="toctext">Application: Unification in logic programming</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Application:_Type_inference"><span class="tocnumber">2.4</span> <span class="toctext">Application: Type inference</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="#Order-sorted_unification"><span class="tocnumber">3</span> <span class="toctext">Order-sorted unification</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Unification_of_infinite_terms"><span class="tocnumber">4</span> <span class="toctext">Unification of infinite terms</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#E-unification"><span class="tocnumber">5</span> <span class="toctext">E-unification</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Particular_background_knowledge_sets_E"><span class="tocnumber">5.1</span> <span class="toctext">Particular background knowledge sets E</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#One-sided_paramodulation"><span class="tocnumber">5.2</span> <span class="toctext">One-sided paramodulation</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Narrowing"><span class="tocnumber">5.3</span> <span class="toctext">Narrowing</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="#Higher-order_unification"><span class="tocnumber">6</span> <span class="toctext">Higher-order unification</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-23"><a href="#Notes"><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Prerequisites"><span class="tocnumber">1.1</span> <span class="toctext">Prerequisites</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#First-order_term"><span class="tocnumber">1.2</span> <span class="toctext">First-order term</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Higher-order_term"><span class="tocnumber">1.3</span> <span class="toctext">Higher-order term</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Substitution"><span class="tocnumber">1.4</span> <span class="toctext">Substitution</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Generalization.2C_specialization"><span class="tocnumber">1.5</span> <span class="toctext">Generalization, specialization</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Unification_problem.2C_solution_set"><span class="tocnumber">1.6</span> <span class="toctext">Unification problem, solution set</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#A_unification_algorithm"><span class="tocnumber">2.1</span> <span class="toctext">A unification algorithm</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#Occurs_check"><span class="tocnumber">2.1.1</span> <span class="toctext">Occurs check</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Proof_of_termination"><span class="tocnumber">2.1.2</span> <span class="toctext">Proof of termination</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Examples_of_syntactic_unification_of_first-order_terms"><span class="tocnumber">2.2</span> <span class="toctext">Examples of syntactic unification of first-order terms</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Application:_Unification_in_logic_programming"><span class="tocnumber">2.3</span> <span class="toctext">Application: Unification in logic programming</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Application:_Type_inference"><span class="tocnumber">2.4</span> <span class="toctext">Application: Type inference</span></a></li>
</ul>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#Occurs_check"><span class="tocnumber">2.1.1</span> <span class="toctext">Occurs check</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Proof_of_termination"><span class="tocnumber">2.1.2</span> <span class="toctext">Proof of termination</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Particular_background_knowledge_sets_E"><span class="tocnumber">5.1</span> <span class="toctext">Particular background knowledge sets E</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#One-sided_paramodulation"><span class="tocnumber">5.2</span> <span class="toctext">One-sided paramodulation</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Narrowing"><span class="tocnumber">5.3</span> <span class="toctext">Narrowing</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Common_formal_definitions">Common formal definitions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Common formal definitions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Prerequisites">Prerequisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Prerequisites">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Formally, a unification approach presupposes</p>
<ul>
<li>An infinite set <i>V</i> of <b>variables</b>. For higher-order unification, it is convenient to choose <i>V</i> disjoint from the set of <a href="/wiki/Lambda_term#Lambda_terms" title="Lambda term" class="mw-redirect">lambda-term bound variables</a>.</li>
<li>A set <i>T</i> of <b>terms</b> such that <i>V</i> ⊆ <i>T</i>. For first-order unification and higher-order unification, <i>T</i> is usually the set of <a href="/wiki/Term_(first-order_logic)#Terms" title="Term (first-order logic)" class="mw-redirect">first-order terms</a> (terms built from variable and function symbols) and <a href="/wiki/Lambda_term#Lambda_terms" title="Lambda term" class="mw-redirect">lambda terms</a> (terms containing some higher-order variables), respectively.</li>
<li>A mapping <i>vars</i>: <i>T</i> → <a href="/wiki/Power_set" title="Power set">ℙ</a>(<i>V</i>), assigning to each term <i>t</i> the set <i>vars</i>(<i>t</i>) ⊊ <i>V</i> of <b>free variables</b> occurring in <i>t</i>.</li>
<li>An <b><a href="/wiki/Equivalence_relation" title="Equivalence relation">equivalence relation</a></b> ≡ on <i>T</i>, indicating which terms are considered equal. For higher-order unification, usually <i>t</i> ≡ <i>u</i> if <i>t</i> and <i>u</i> are <a href="/wiki/Lambda_term#Alpha_equivalence" title="Lambda term" class="mw-redirect">alpha equivalent</a>. For first-order E-unification, ≡ reflects the background knowledge about certain function symbols; for example, if ⊕ is considered commutative, <i>t</i> ≡ <i>u</i> if <i>u</i> results from <i>t</i> by swapping the arguments of ⊕ at some (possibly all) occurrences. <sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>note 2<span>]</span></a></sup> If there is no background knowledge at all, then only literally, or syntactically, identical terms are considered equal; in this case, ≡ is called the <b><a href="/wiki/Free_theory" title="Free theory" class="mw-redirect">free theory</a></b> (because it is a <a href="/wiki/Free_object" title="Free object">free object</a>), the <b><a href="/wiki/Empty_theory" title="Empty theory" class="mw-redirect">empty theory</a></b> (because the set of equational <a href="/wiki/Sentence_(mathematical_logic)" title="Sentence (mathematical logic)">sentences</a>, or the background knowledge, is empty), the <b>theory of <a href="/wiki/Uninterpreted_function" title="Uninterpreted function">uninterpreted functions</a></b> (because unification is done on uninterpreted <a href="/wiki/Term_(logic)" title="Term (logic)">terms</a>), or the <b>theory of <a href="/wiki/Algebraic_specification" title="Algebraic specification">constructors</a></b> (because all function symbols just build up data terms, rather than operating on them).</li>
</ul>
<h3><span class="mw-headline" id="First-order_term">First-order term</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: First-order term">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Given a set <i>V</i> of variable symbols, a set <i>C</i> of constant symbols and sets <i>F</i><sub><i>n</i></sub> of <i>n</i>-ary function symbols, also called operator symbols, for each natural number <i>n</i> ≥ 1, the set of (unsorted first-order) terms <i>T</i> is <a href="/wiki/Recursive_definition" title="Recursive definition">recursively defined</a> to be the smallest set with the following properties:<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>5<span>]</span></a></sup></p>
<ul>
<li>every variable symbol is a term: <i>V</i> ⊆ <i>T</i>,</li>
<li>every constant symbol is a term: <i>C</i> ⊆ <i>T</i>,</li>
<li>from every <i>n</i> terms <i>t</i><sub>1</sub>,...,<i>t</i><sub><i>n</i></sub>, and every <i>n</i>-ary function symbol <i>f</i> ∈ <i>F</i><sub><i>n</i></sub>, a larger term <i>f</i>(<i>t</i><sub>1</sub>,...,<i>t</i><sub><i>n</i></sub>) can be built.</li>
</ul>
<p>For example, if <i>x</i> ∈ <i>V</i> is a variable symbol, 1 ∈ <i>C</i> is a constant symbol, and <i>add</i> ∈ <i>F</i><sub>2</sub> is a binary function symbol, then <i>x</i> ∈ <i>T</i>, 1 ∈ <i>T</i>, and (hence) <i>add</i>(<i>x</i>,1) ∈ <i>T</i> by the first, second, and third term building rule, respectively. The latter term is usually written as <i>x</i>+1, using <a href="/wiki/Infix_notation" title="Infix notation">infix notation</a> and the more common operator symbol + for convenience.</p>
<h3><span class="mw-headline" id="Higher-order_term">Higher-order term</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Higher-order term">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h3><span class="mw-headline" id="Substitution">Substitution</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Substitution">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <b>substitution</b> is a mapping σ: <i>V</i> → <i>T</i> from variables to terms; the notation { <i>x</i><sub>1</sub> ↦ <i>t</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub> ↦ <i>t</i><sub><i>k</i></sub> } refers to a substitution mapping each variable <i>x</i><sub><i>i</i></sub> to the term <i>t</i><sub><i>i</i></sub>, for <i>i</i>=1,...,<i>k</i>, and every other variable to itself. <b>Applying</b> that substitution to a term <i>t</i> is written in <a href="/wiki/Postfix_notation" title="Postfix notation" class="mw-redirect">postfix notation</a> as <span class="nowrap"><i>t</i> {<i>x</i><sub>1</sub> ↦ <i>t</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub> ↦ <i>t</i><sub><i>k</i></sub></span>}; it means to (simultaneously) replace every occurrence of each variable <i>x</i><sub><i>i</i></sub> in the term <i>t</i> by <i>t</i><sub><i>i</i></sub>. The result <i>t</i>σ of applying a substitution σ to a term <i>t</i> is called an <b>instance</b> of that term <i>t</i>. As a first-order example, applying the substitution <span class="nowrap">{ <i>x</i> ↦ <i>h</i>(<i>a</i>,<i>y</i>), <i>z</i> ↦ <i>b</i></span> } to the term</p>
<h3><span class="mw-headline" id="Generalization.2C_specialization">Generalization, specialization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Generalization, specialization">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If a term <i>t</i> has an instance equivalent to a term <i>u</i>, that is, if <i>t</i>σ ≡ <i>u</i> for some substitution σ, then <i>t</i> is called <b>more general</b> than <i>u</i>, and <i>u</i> is called <b>more special</b> than, or <b>subsumed</b> by, <i>t</i>. For example, <i>x</i> ⊕ <i>a</i> is more general than <i>a</i> ⊕ <i>b</i> if ⊕ is <a href="/wiki/Commutative_property" title="Commutative property">commutative</a>, since then (<i>x</i> ⊕ <i>a</i>) {<i>x</i>↦<i>b</i>} = <i>b</i> ⊕ <i>a</i> ≡ <i>a</i> ⊕ <i>b</i>.</p>
<p>If ≡ is literal (syntactic) identity of terms, a term may be both more general and more special than another one only if both terms differ just in their variable names, not in their syntactic structure; such terms are called <b>variants</b>, or <b>renamings</b> of each other. For example, <span class="nowrap"><i>f</i>(<i>x</i><sub>1</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>1</sub>),<i>y</i><sub>1</sub>)</span> is a variant of <span class="nowrap"><i>f</i>(<i>x</i><sub>2</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>2</sub>),<i>y</i><sub>2</sub>)</span>, since <span class="nowrap"><i>f</i>(<i>x</i><sub>1</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>1</sub>),<i>y</i><sub>1</sub>)</span> { <span class="nowrap"><i>x</i><sub>1</sub> ↦ <i>x</i><sub>2</sub>, <i>y</i><sub>1</sub> ↦ <i>y</i><sub>2</sub>, <i>z</i><sub>1</sub> ↦ <i>z</i><sub>2</sub></span> } = <span class="nowrap"><i>f</i>(<i>x</i><sub>2</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>2</sub>),<i>y</i><sub>2</sub>)</span> and <span class="nowrap"><i>f</i>(<i>x</i><sub>2</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>2</sub>),<i>y</i><sub>2</sub>)</span> { <span class="nowrap"><i>x</i><sub>2</sub> ↦ <i>x</i><sub>1</sub>, <i>y</i><sub>2</sub> ↦ <i>y</i><sub>1</sub>, <i>z</i><sub>2</sub> ↦ <i>z</i><sub>1</sub></span> } = <span class="nowrap"><i>f</i>(<i>x</i><sub>1</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>1</sub>),<i>y</i><sub>1</sub>)</span>. However, <span class="nowrap"><i>f</i>(<i>x</i><sub>1</sub>,<i>a</i>,<i>g</i>(<i>z</i><sub>1</sub>),<i>y</i><sub>1</sub>)</span> is <i>not</i> a variant of <span class="nowrap"><i>f</i>(<i>x</i><sub>2</sub>,<i>a</i>,<i>g</i>(<i>x</i><sub>2</sub>),<i>x</i><sub>2</sub>)</span>, since no substitution can transform the latter term into the former one. The latter term is therefore properly more special than the former one.</p>
<p>For arbitrary ≡, a term may be both more general and more special than a structurally different term. For example, if ⊕ is <a href="/wiki/Idempotent" title="Idempotent" class="mw-redirect">idempotent</a>, that is, if always <i>x</i> ⊕ <i>x</i> ≡ <i>x</i>, then the term <i>x</i> ⊕ <i>y</i> is more general than (<i>x</i> ⊕ <i>y</i>) {<i>x</i> ↦ <i>z</i>, <i>y</i> ↦ <i>z</i>} = <i>z</i> ⊕ <i>z</i> ≡ <i>z</i>, and vice versa <i>z</i> is more general than <i>z</i> {<i>z</i> ↦ <i>x</i> ⊕ <i>y</i>} = <i>x</i> ⊕ <i>y</i>, although <i>x</i>⊕<i>y</i> and <i>z</i> are of different structure.</p>
<p>A substitution σ is <b>more special</b> than, or <b>subsumed</b> by, a substitution τ if <i>x</i>σ is more special than <i>x</i>τ for each variable <i>x</i>. For example, { <i>x</i> ↦ <i>f</i>(<i>u</i>), <i>y</i> ↦ <i>f</i>(<i>f</i>(<i>u</i>)) } is more special than { <i>x</i> ↦ <i>z</i>, <i>y</i> ↦ <i>f</i>(<i>z</i>) }, since <i>f</i>(<i>u</i>) and <i>f</i>(<i>f</i>(<i>u</i>)) is more special than <i>z</i> and <i>f</i>(<i>z</i>), respectively.</p>
<h3><span class="mw-headline" id="Unification_problem.2C_solution_set">Unification problem, solution set</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Unification problem, solution set">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A <b>unification problem</b> is a finite set { <i>l</i><sub>1</sub> ≐ <i>r</i><sub>1</sub>, ..., <i>l</i><sub><i>n</i></sub> ≐ <i>r</i><sub><i>n</i></sub> } of potential equations, where <i>l</i><sub><i>i</i></sub>, <i>r</i><sub><i>i</i></sub> ∈ <i>T</i>. A substitution σ is a <b>solution</b> of that problem if <i>l</i><sub><i>i</i></sub>σ ≡ <i>r</i><sub><i>i</i></sub>σ for <i>i</i>=1,...,<i>n</i>. Such a substitution is also called a <b>unifier</b> of the unification problem. For example, if ⊕ is <a href="/wiki/Associative_property" title="Associative property">associative</a>, the unification problem { <i>x</i> ⊕ <i>a</i> ≐ <i>a</i> ⊕ <i>x</i> } has the solutions {<i>x</i> ↦ <i>a</i>}, {<i>x</i> ↦ <i>a</i> ⊕ <i>a</i>}, {<i>x</i> ↦ <i>a</i> ⊕ <i>a</i> ⊕ <i>a</i>}, etc., while the problem { <i>x</i> ⊕ <i>a</i> ≐ <i>a</i> } has no solution.</p>
<p>For a given unification problem, a set <i>S</i> of unifiers is called <b>complete</b> if each solution substitution is subsumed by some substitution σ ∈ <i>S</i>; the set <i>S</i> is called <b>minimal</b> if none of its members subsumes another one.</p>
<h2><span class="mw-headline" id="Syntactic_unification_of_first-order_terms">Syntactic unification of first-order terms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: Syntactic unification of first-order terms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><i>Syntactic unification of first-order terms</i> is the most widely used unification framework. It is based on <i>T</i> being the set of <i>first-order terms</i> (over some given set <i>V</i> of variables, <i>C</i> of constants and <i>F</i><sub><i>n</i></sub> of <i>n</i>-ary function symbols) and on ≡ being <i>syntactic equality</i>. In this framework, each solvable unification problem {<i>l</i><sub>1</sub> ≐ <i>r</i><sub>1</sub>, ..., <i>l</i><sub><i>n</i></sub> ≐ <i>r</i><sub><i>n</i></sub>} has a complete, and obviously minimal, <a href="/wiki/Singleton_(mathematics)" title="Singleton (mathematics)">singleton</a> solution set {σ}. Its member σ is called the <b>most general unifier (mgu)</b> of the problem. The terms on the left and the right hand side of each potential equation become syntactically equal when the mgu is applied i.e. <i>l</i><sub>1</sub>σ = <i>r</i><sub>1</sub>σ ∧ ... ∧ <i>l</i><sub><i>n</i></sub>σ = <i>r</i><sub><i>n</i></sub>σ. Any unifier of the problem is subsumed<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>note 3<span>]</span></a></sup> by the mgu σ. The mgu is unique up to variants: if <i>S</i><sub>1</sub> and <i>S</i><sub>2</sub> are both complete and minimal solution sets of the same syntactical unification problem, then <i>S</i><sub>1</sub> = { σ<sub>1</sub> } and <i>S</i><sub>2</sub> = { σ<sub>2</sub> } for some substitutions σ<sub>1</sub> and σ<sub>2</sub>, and <i>x</i>σ<sub>1</sub> is a variant of <i>x</i>σ<sub>2</sub> for each variable <i>x</i> occurring in the problem.</p>
<p>For example, the unification problem { <i>x</i> ≐ <i>z</i>, <i>y</i> ≐ <i>f</i>(<i>x</i>) } has a unifier { <i>x</i> ↦ <i>z</i>, <i>y</i> ↦ <i>f</i>(<i>z</i>) }, because</p>
<p>This is also the most general unifier. Other unifiers for the same problem are e.g. { <i>x</i> ↦ <i>f</i>(<i>x</i><sub>1</sub>), <i>y</i> ↦ <i>f</i>(<i>f</i>(<i>x</i><sub>1</sub>)), <i>z</i> ↦ <i>f</i>(<i>x</i><sub>1</sub>) }, { <i>x</i> ↦ <i>f</i>(<i>f</i>(<i>x</i><sub>1</sub>)), <i>y</i> ↦ <i>f</i>(<i>f</i>(<i>f</i>(<i>x</i><sub>1</sub>))), <i>z</i> ↦ <i>f</i>(<i>f</i>(<i>x</i><sub>1</sub>)) }, and so on; there are infinitely many similar unifiers.</p>
<p>As another example, the problem <i>g</i>(<i>x</i>,<i>x</i>) ≐ <i>f</i>(<i>y</i>) has no solution with respect to ≡ being literal identity, since any substitution applied to the left and right hand side will keep the outermost <i>g</i> and <i>f</i>, respectively, and terms with different outermost function symbols are syntactically different.</p>
<h3><span class="mw-headline" id="A_unification_algorithm">A unification algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: A unification algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The first algorithm given by Robinson (1965) was rather inefficient; cf. box. The following faster algorithm originated from Martelli, Montanari (1982).<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>9<span>]</span></a></sup> This paper also lists preceding attempts to find an efficient syntactical unification algorithm,<sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>10<span>]</span></a></sup><sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>11<span>]</span></a></sup><sup id="cite_ref-Martelli.Montanari.1976_15-0" class="reference"><a href="#cite_note-Martelli.Montanari.1976-15"><span>[</span>12<span>]</span></a></sup><sup id="cite_ref-Paterson.Wegman.1978_16-0" class="reference"><a href="#cite_note-Paterson.Wegman.1978-16"><span>[</span>13<span>]</span></a></sup><sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>14<span>]</span></a></sup><sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>15<span>]</span></a></sup> and states that linear-time algorithms were discovered independently by Martelli, Montanari (1976)<sup id="cite_ref-Martelli.Montanari.1976_15-1" class="reference"><a href="#cite_note-Martelli.Montanari.1976-15"><span>[</span>12<span>]</span></a></sup> and Paterson, Wegman (1978).<sup id="cite_ref-Paterson.Wegman.1978_16-1" class="reference"><a href="#cite_note-Paterson.Wegman.1978-16"><span>[</span>13<span>]</span></a></sup><sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span>[</span>16<span>]</span></a></sup></p>
<p>Given a finite set <i>G</i> = { <i>s</i><sub>1</sub> ≐ <i>t</i><sub>1</sub>, ..., <i>s</i><sub><i>n</i></sub> ≐ <i>t</i><sub><i>n</i></sub> } of potential equations, the algorithm applies rules to transform it to an equivalent set of equations of the form { <i>x</i><sub>1</sub> ≐ <i>u</i><sub>1</sub>, ..., <i>x</i><sub><i>m</i></sub> ≐ <i>u</i><sub><i>m</i></sub> } where <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>m</i></sub> are distinct variables and <i>u</i><sub>1</sub>, ..., <i>u</i><sub><i>m</i></sub> are terms containing none of the <i>x</i><sub><i>i</i></sub>. A set of this form can be read as a substitution. If there is no solution the algorithm terminates with ⊥; other authors use "Ω", "{}", or "<i>fail</i>" in that case. The operation of substituting all occurrences of variable <i>x</i> in problem <i>G</i> with term <i>t</i> is denoted <i>G</i> {<i>x</i> ↦ <i>t</i>}. For simplicity, constant symbols are regarded as function symbols having zero arguments.</p>
<h4><span class="mw-headline" id="Occurs_check">Occurs check</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: Occurs check">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>An attempt to unify a variable <i>x</i> with a term containing <i>x</i> as a strict subterm <i>x</i>≐<i>f</i>(...,<i>x</i>,...) would lead to an infinite term as solution for <i>x</i>, since <i>x</i> would occur as a subterm of itself. In the set of (finite) first-order terms as defined above, the equation <i>x</i>≐<i>f</i>(...,<i>x</i>,...) has no solution; hence the <i>eliminate</i> rule may only be applied if <i>x</i> ∉ <i>vars</i>(<i>t</i>). Since that additional check, called <i>occurs check</i>, slows down the algorithm, it is omitted e.g. in most Prolog systems. From a theoretical point of view, omitting the check amounts to solving equations over infinite trees, see <a href="#Unification_of_infinite_terms">below</a>.</p>
<h4><span class="mw-headline" id="Proof_of_termination">Proof of termination</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: Proof of termination">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>For the proof of termination of the algorithm consider a triple &lt;<i>n</i><sub><i>var</i></sub>,<i>n</i><sub><i>lhs</i></sub>,<i>n</i><sub><i>eqn</i></sub>&gt; where <i>n</i><sub><i>var</i></sub> is the number of variables that occur more than once in the equation set, <i>n</i><sub><i>lhs</i></sub> is the number of function symbols and constants on the left hand sides of potential equations, and <i>n</i><sub><i>eqn</i></sub> is the number of equations. When rule <i>eliminate</i> is applied, <i>n</i><sub><i>var</i></sub> decreases, since <i>x</i> is eliminated from <i>G</i> and kept only in { <i>x</i> ≐ <i>t</i> }. Applying any other rule can never increase <i>n</i><sub><i>var</i></sub> again. When rule <i>decompose</i>, <i>conflict</i>, or <i>swap</i> is applied, <i>n</i><sub><i>lhs</i></sub> decreases, since at least the left hand side's outermost <i>f</i> disappears. Applying any of the remaining rules <i>delete</i> or <i>check</i> can't increase <i>n</i><sub><i>lhs</i></sub>, but decreases <i>n</i><sub><i>eqn</i></sub>. Hence, any rule application decreases the triple &lt;<i>n</i><sub><i>var</i></sub>,<i>n</i><sub><i>lhs</i></sub>,<i>n</i><sub><i>eqn</i></sub>&gt; with respect to the <a href="/wiki/Lexicographical_order" title="Lexicographical order">lexicographical order</a>, which is possible only a finite number of times.</p>
<p><a href="/wiki/Conor_McBride" title="Conor McBride">Conor McBride</a> observes<sup id="cite_ref-20" class="reference"><a href="#cite_note-20"><span>[</span>17<span>]</span></a></sup> that “by expressing the structure which unification exploits” in a <a href="/wiki/Dependent_type" title="Dependent type">dependently typed</a> language such as <a href="/wiki/Epigram_(programming_language)" title="Epigram (programming language)">Epigram</a>, <a href="/wiki/John_Alan_Robinson" title="John Alan Robinson">Robinson</a>'s algorithm can be made <a href="/wiki/Structural_induction" title="Structural induction">recursive on the number of variables</a>, in which case a separate termination proof becomes unnecessary.</p>
<h3><span class="mw-headline" id="Examples_of_syntactic_unification_of_first-order_terms">Examples of syntactic unification of first-order terms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Examples of syntactic unification of first-order terms">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the Prolog syntactical convention a symbol starting with an upper case letter is a variable name; a symbol that starts with a lowercase letter is a function symbol; the comma is used as the logical <i>and</i> operator. For maths notation, <i>x,y,z</i> are used as variables, <i>f,g</i> as function symbols, and <i>a,b</i> as constants.</p>
<p>Succeeds in traditional Prolog and in Prolog II, unifying <i>x</i> with infinite term <i>x=f(f(f(f(...))))</i>.</p>
<p>The most general unifier of a syntactic first-order unification problem of <a href="/wiki/Term_(logic)#Operations_with_terms" title="Term (logic)">size</a> <i>n</i> may have a size of 2<sup><i>n</i></sup>. For example, the problem { (((<i>a</i>*<i>z</i>)*<i>y</i>)*<i>x</i>)*<i>w</i> ≐ <i>w</i>*(<i>x</i>*(<i>y</i>*(<i>z</i>*<i>a</i>))) } has the most general unifier { <i>z</i> ↦ <i>a</i>, <i>y</i> ↦ <i>a</i>*<i>a</i>, <i>x</i> ↦ (<i>a</i>*<i>a</i>)*(<i>a</i>*<i>a</i>), <i>w</i> ↦ ((<i>a</i>*<i>a</i>)*(<i>a</i>*<i>a</i>))*((<i>a</i>*<i>a</i>)*(<i>a</i>*<i>a</i>)) }, cf. picture. In order to avoid exponential time complexity caused by such blow-up, advanced unification algorithms work on <a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">directed acyclic graphs</a> (dags) rather than trees.<sup id="cite_ref-21" class="reference"><a href="#cite_note-21"><span>[</span>18<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Application:_Unification_in_logic_programming">Application: Unification in logic programming</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: Application: Unification in logic programming">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The concept of unification is one of the main ideas behind <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a>, best known through the language <a href="/wiki/Prolog" title="Prolog">Prolog</a>. It represents the mechanism of binding the contents of variables and can be viewed as a kind of one-time assignment. In Prolog, this operation is denoted by the equality symbol <tt>=</tt>, but is also done when instantiating variables (see below). It is also used in other languages by the use of the equality symbol <tt>=</tt>, but also in conjunction with many operations including <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt>. <a href="/wiki/Type_inference" title="Type inference">Type inference</a> algorithms are typically based on unification.</p>
<p>In Prolog:</p>
<ol>
<li>A <a href="/wiki/Variable_(programming)" title="Variable (programming)" class="mw-redirect">variable</a> which is uninstantiated—i.e. no previous unifications were performed on it—can be unified with an atom, a term, or another uninstantiated variable, thus effectively becoming its alias. In many modern Prolog dialects and in <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a>, a variable cannot be unified with a term that contains it; this is the so-called <i><a href="/wiki/Occurs_check" title="Occurs check">occurs check</a></i>.</li>
<li>Two atoms can only be unified if they are identical.</li>
<li>Similarly, a term can be unified with another term if the top function symbols and <a href="/wiki/Arity" title="Arity">arities</a> of the terms are identical and if the parameters can be unified simultaneously. Note that this is a recursive behavior.</li>
</ol>
<h3><span class="mw-headline" id="Application:_Type_inference">Application: Type inference</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Application: Type inference">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Unification is used during type inference, for instance in the functional programming language <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>. On one hand, the programmer does not need to provide type information for every function, on the other hand it is used to detect typing errors. The Haskell expression 1:['a','b','c'] is not correctly typed, because the list construction function ":" is of type a-&gt;[a]-&gt;[a] and for the first argument "1" the polymorphic type variable "a" has to denote the type Int whereas "['a','b','c']" is of type [Char], but "a" cannot be both Char and Int at the same time.</p>
<p>Like for prolog an algorithm for type inference can be given:</p>
<ol>
<li>Any type variable unifies with any type expression, and is instantiated to that expression. A specific theory might restrict this rule with an occurs check.</li>
<li>Two type constants unify only if they are the same type.</li>
<li>Two type constructions unify only if they are applications of the same type constructor and all of their component types recursively unify.</li>
</ol>
<p>Due to its declarative nature, the order in a sequence of unifications is (usually) unimportant.</p>
<p>Note that in the terminology of <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a>, an atom is a basic proposition and is unified similarly to a Prolog term.</p>
<h2><span class="mw-headline" id="Order-sorted_unification">Order-sorted unification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=15" title="Edit section: Order-sorted unification">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><i><a href="/wiki/Many-sorted_logic#Order-sorted_logic" title="Many-sorted logic">Order-sorted logic</a></i> allows one to assign a <i>sort</i>, or <i>type</i>, to each term, and to declare a sort <i>s</i><sub>1</sub> a <i>subsort</i> of another sort <i>s</i><sub>2</sub>, commonly written as <i>s</i><sub>1</sub> ⊆ <i>s</i><sub>2</sub>. For example, when reаsoning about biological creatures, it is useful to declare a sort <i>dog</i> to be a subsort of a sort <i>animal</i>. Wherever a term of some sort <i>s</i> is required, a term of any subsort of <i>s</i> may be supplied instead. For example, assuming a function declaration <i>mother</i>: <i>animal</i> → <i>animal</i>, and a constant declaration <i>lassie</i>: <i>dog</i>, the term <i>mother</i>(<i>lassie</i>) is perfectly valid and has the sort <i>animal</i>. In order to supply the information that the mother of a dog is a dog in turn, another declaration <i>mother</i>: <i>dog</i> → <i>dog</i> may be issued; this is called <i>function overloading</i>, similar to <a href="/wiki/Overloading_(programming)" title="Overloading (programming)" class="mw-redirect">overloading in programming languages</a>.</p>
<p>Walther gave a unification algorithm for terms in order-sorted logic, requiring for any two declared sorts <i>s</i><sub>1</sub>, <i>s</i><sub>2</sub> their intersection <i>s</i><sub>1</sub> ∩ <i>s</i><sub>2</sub> to be declared, too: if <i>x</i><sub>1</sub> and <i>x</i><sub>2</sub> is a variable of sort <i>s</i><sub>1</sub> and <i>s</i><sub>2</sub>, respectively, the equation <i>x</i><sub>1</sub> ≐ <i>x</i><sub>2</sub> has the solution { <i>x</i><sub>1</sub> = <i>x</i>, <i>x</i><sub>2</sub> = <i>x</i> }, where <i>x</i>: <i>s</i><sub>1</sub> ∩ <i>s</i><sub>2</sub>. <sup id="cite_ref-22" class="reference"><a href="#cite_note-22"><span>[</span>19<span>]</span></a></sup> After incorporating this algorithm into a clause-based automated theorem prover, he could solve a benchmark problem by translating it into order-sorted logic, thereby boiling it down an order of magnitude, as many unary predicates turned into sorts.</p>
<p>Smolka generalized order-sorted logic to allow for <a href="/wiki/Parametric_polymorphism" title="Parametric polymorphism">parametric polymorphism</a>. <sup id="cite_ref-23" class="reference"><a href="#cite_note-23"><span>[</span>20<span>]</span></a></sup> In his framework, subsort declarations are propagated to complex type expressions. As a programming example, a parametric sort <i>list</i>(<i>X</i>) may be declared (with <i>X</i> being a type parameter as in a <a href="/wiki/Template_(C%2B%2B)#Function_templates" title="Template (C++)">C++ template</a>), and from a subsort declaration <i>int</i> ⊆ <i>float</i> the relation <i>list</i>(<i>int</i>) ⊆ <i>list</i>(<i>float</i>) is automatically inferred, meaning that each list of integers is also a list of floats.</p>
<p>Schmidt-Schauß generalized order-sorted logic to allow for term declarations. <sup id="cite_ref-24" class="reference"><a href="#cite_note-24"><span>[</span>21<span>]</span></a></sup> As an example, assuming subsort declarations <i>even</i> ⊆ <i>int</i> and <i>odd</i> ⊆ <i>int</i>, a term declaration like ∀<i>i</i>:<i>int</i>. (<i>i</i>+i):<i>even</i> allows to declare a property of integer addition that could not be expressed by ordinary overloading.</p>
<h2><span class="mw-headline" id="Unification_of_infinite_terms">Unification of infinite terms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=16" title="Edit section: Unification of infinite terms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Background on infinite trees:</p>
<ul>
<li><span class="citation journal"><a href="/wiki/Bruno_Courcelle" title="Bruno Courcelle">B. Courcelle</a> (1983). <a rel="nofollow" class="external text" href="http://www.diku.dk/hjemmesider/ansatte/henglein/papers/courcelle1983.pdf">"Fundamental Properties of Infinite Trees"</a>. <i>Theoret. Comput. Sci.</i> <b>25</b>: 95–169. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0304-3975%2883%2990059-2">10.1016/0304-3975(83)90059-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Fundamental+Properties+of+Infinite+Trees&amp;rft.au=B.+Courcelle&amp;rft.aulast=B.+Courcelle&amp;rft.date=1983&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.diku.dk%2Fhjemmesider%2Fansatte%2Fhenglein%2Fpapers%2Fcourcelle1983.pdf&amp;rft_id=info%3Adoi%2F10.1016%2F0304-3975%2883%2990059-2&amp;rft.jtitle=Theoret.+Comput.+Sci.&amp;rft.pages=95-169&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=25" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Michael J. Maher (Jul 1988). "Complete Axiomatizations of the Algebras of Finite, Rational and Infinite Trees". <i>Proc. IEEE 3rd Annual Symp. on Logic in Computer Science, Edinburgh</i>. pp. 348–357.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Proc.+IEEE+3rd+Annual+Symp.+on+Logic+in+Computer+Science%2C+Edinburgh&amp;rft.aulast=Michael+J.+Maher&amp;rft.au=Michael+J.+Maher&amp;rft.btitle=Complete+Axiomatizations+of+the+Algebras+of+Finite%2C+Rational+and+Infinite+Trees&amp;rft.date=Jul+1988&amp;rft.genre=bookitem&amp;rft.pages=348-357&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Joxan Jaffar, Peter J. Stuckey (1986). "Semantics of Infinite Tree Logic Programming". <i>Theoretical Computer Science</i> <b>46</b>: 141–158. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0304-3975%2886%2990027-7">10.1016/0304-3975(86)90027-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Semantics+of+Infinite+Tree+Logic+Programming&amp;rft.au=Joxan+Jaffar%2C+Peter+J.+Stuckey&amp;rft.aulast=Joxan+Jaffar%2C+Peter+J.+Stuckey&amp;rft.date=1986&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2F0304-3975%2886%2990027-7&amp;rft.jtitle=Theoretical+Computer+Science&amp;rft.pages=141-158&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=46" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<p>Unification algorithm, Prolog II:</p>
<ul>
<li><span class="citation book"><a href="/wiki/Alain_Colmerauer" title="Alain Colmerauer">A. Colmerauer</a> (1982). K.L. Clark and S.-A. Tarnlund, ed. <i>Prolog and Infinite Trees</i>. Academic Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.au=A.+Colmerauer&amp;rft.aulast=A.+Colmerauer&amp;rft.btitle=Prolog+and+Infinite+Trees&amp;rft.date=1982&amp;rft.genre=book&amp;rft.pub=Academic+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Alain Colmerauer (1984). "Equations and Inequations on Finite and Infinite Trees". In ICOT. <i>Proc. Int. Conf. on Fifth Generation Computer Systems</i>. pp. 85–99.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Proc.+Int.+Conf.+on+Fifth+Generation+Computer+Systems&amp;rft.au=Alain+Colmerauer&amp;rft.aulast=Alain+Colmerauer&amp;rft.btitle=Equations+and+Inequations+on+Finite+and+Infinite+Trees&amp;rft.date=1984&amp;rft.genre=bookitem&amp;rft.pages=85-99&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<p>Applications:</p>
<ul>
<li><span class="citation journal">Francis Giannesini, Jacques Cohen (1984). "Parser Generation and Grammar Manipulation using Prolog's Infinite Trees". <i>J. Logic Programming</i> <b>3</b>: 253–265.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Parser+Generation+and+Grammar+Manipulation+using+Prolog%27s+Infinite+Trees&amp;rft.au=Francis+Giannesini%2C+Jacques+Cohen&amp;rft.aulast=Francis+Giannesini%2C+Jacques+Cohen&amp;rft.date=1984&amp;rft.genre=article&amp;rft.jtitle=J.+Logic+Programming&amp;rft.pages=253-265&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=3" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="E-unification">E-unification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=17" title="Edit section: E-unification">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><b>E-unification</b> is the problem of finding solutions to a given set of <a href="/wiki/Equations" title="Equations" class="mw-redirect">equations</a>, taking into account some equational background knowledge <i>E</i>. The latter is given as a set of universal <a href="/wiki/Equality_(mathematics)" title="Equality (mathematics)">equalities</a>. For some particular sets <i>E</i>, equation solving <a href="/wiki/Algorithms" title="Algorithms" class="mw-redirect">algorithms</a> (a.k.a. <i>E-unification algorithms</i>) have been devised; for others it has been proven that no such algorithms can exist.</p>
<p>For example, if <i>a</i> and <i>b</i> are distinct constants, the <a href="/wiki/Equation" title="Equation">equation</a> <i>x</i>*<i>a</i> ≐ <i>y</i>*<i>b</i> has no solution with respect to purely <a href="/wiki/Unification_(computer_science)#Syntactic_unification_problem_on_first-order_terms" title="Unification (computer science)">syntactic unification</a>, where nothing is known about the operator *. However, if the * is known to be <a href="/wiki/Commutativity" title="Commutativity" class="mw-redirect">commutative</a>, then the substitution { <i>x</i> ↦ <i>b</i>, <i>y</i> ↦ <i>a</i> } solves the above equation, since</p>
<p>The background knowledge <i>E</i> could state the commutativity of * by the universal equality "<i>u</i>*<i>v</i> = <i>v</i>*<i>u</i> for all <i>u</i>, <i>v</i>".</p>
<h3><span class="mw-headline" id="Particular_background_knowledge_sets_E">Particular background knowledge sets E</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=18" title="Edit section: Particular background knowledge sets E">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>It is said that <i>unification is decidable</i> for a theory, if a unification algorithm has been devised for it that terminates for <i>any</i> input problem. It is said that <i>unification is <a href="/wiki/Decidable_problem#Decidability" title="Decidable problem" class="mw-redirect">semi-decidable</a></i> for a theory, if a unification algorithm has been devised for it that terminates for any <i>solvable</i> input problem, but may keep searching forever for solutions of an unsolvable input problem.</p>
<p><b>Unification is decidable</b> for the following theories:</p>
<ul>
<li><b>A</b><sup id="cite_ref-25" class="reference"><a href="#cite_note-25"><span>[</span>22<span>]</span></a></sup></li>
<li><b>A</b>,<b>C</b><sup id="cite_ref-26" class="reference"><a href="#cite_note-26"><span>[</span>23<span>]</span></a></sup></li>
<li><b>A</b>,<b>C</b>,<b>I</b><sup id="cite_ref-Fages.1987_27-0" class="reference"><a href="#cite_note-Fages.1987-27"><span>[</span>24<span>]</span></a></sup></li>
<li><b>A</b>,<b>C</b>,<b>N<sub>l</sub></b><sup id="cite_ref-LRequivC_28-0" class="reference"><a href="#cite_note-LRequivC-28"><span>[</span>note 4<span>]</span></a></sup><sup id="cite_ref-Fages.1987_27-1" class="reference"><a href="#cite_note-Fages.1987-27"><span>[</span>24<span>]</span></a></sup></li>
<li><b>A</b>,<b>I</b><sup id="cite_ref-29" class="reference"><a href="#cite_note-29"><span>[</span>25<span>]</span></a></sup></li>
<li><b>A</b>,<b>N<sub>l</sub></b>,<b>N<sub>r</sub></b> (monoid)<sup id="cite_ref-30" class="reference"><a href="#cite_note-30"><span>[</span>26<span>]</span></a></sup></li>
<li><b>C</b><sup id="cite_ref-31" class="reference"><a href="#cite_note-31"><span>[</span>27<span>]</span></a></sup></li>
<li><a href="/wiki/Boolean_ring" title="Boolean ring">Boolean rings</a><sup id="cite_ref-32" class="reference"><a href="#cite_note-32"><span>[</span>28<span>]</span></a></sup><sup id="cite_ref-33" class="reference"><a href="#cite_note-33"><span>[</span>29<span>]</span></a></sup></li>
<li><a href="/wiki/Abelian_group" title="Abelian group">Abelian groups</a>, even if the signature is expanded by arbitrary additional symbols (but not axioms)<sup id="cite_ref-Baader_and_Snyder_2001.2C_p._486_34-0" class="reference"><a href="#cite_note-Baader_and_Snyder_2001.2C_p._486-34"><span>[</span>30<span>]</span></a></sup></li>
<li><a href="/wiki/Kripke_semantics#Correspondence_and_completeness" title="Kripke semantics">K4</a> <a href="/wiki/Modal_algebra" title="Modal algebra">modal algebras</a><sup id="cite_ref-35" class="reference"><a href="#cite_note-35"><span>[</span>31<span>]</span></a></sup></li>
</ul>
<p><b>Unification is semi-decidable</b> for the following theories:</p>
<ul>
<li><b>A</b>,<b>D<sub>l</sub></b>,<b>D<sub>r</sub></b><sup id="cite_ref-36" class="reference"><a href="#cite_note-36"><span>[</span>32<span>]</span></a></sup></li>
<li><b>A</b>,<b>C</b>,<b>D<sub>l</sub></b><sup id="cite_ref-LRequivC_28-1" class="reference"><a href="#cite_note-LRequivC-28"><span>[</span>note 4<span>]</span></a></sup><sup id="cite_ref-37" class="reference"><a href="#cite_note-37"><span>[</span>33<span>]</span></a></sup></li>
<li><a href="/wiki/Commutative_ring" title="Commutative ring">Commutative rings</a><sup id="cite_ref-Baader_and_Snyder_2001.2C_p._486_34-1" class="reference"><a href="#cite_note-Baader_and_Snyder_2001.2C_p._486-34"><span>[</span>30<span>]</span></a></sup></li>
</ul>
<h3><span class="mw-headline" id="One-sided_paramodulation">One-sided paramodulation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=19" title="Edit section: One-sided paramodulation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If there is a <a href="/wiki/Term_rewriting#Termination_and_convergence" title="Term rewriting" class="mw-redirect">convergent term rewriting system</a> <i>R</i> available for <i>E</i>, the <b>one-sided paramodulation</b> algorithm<sup id="cite_ref-38" class="reference"><a href="#cite_note-38"><span>[</span>34<span>]</span></a></sup> can be used to enumerate all solutions of given equations.</p>
<p>Starting with <i>G</i> being the unification problem to be solved and <i>S</i> being the identity substitution, rules are applied nondeterministically until the empty set appears as the actual <i>G</i>, in which case the actual <i>S</i> is a unifying substitution. Depending on the order the paramodulation rules are applied, on the choice of the actual equation from <i>G</i>, and on the choice of <i>R</i>’s rules in <i>mutate</i>, different computations paths are possible. Only some lead to a solution, while others end at a <i>G</i> ≠ {} where no further rule is applicable (e.g. <i>G</i> = { <i>f</i>(...) ≐ <i>g</i>(...) }).</p>
<p>For an example, a term rewrite system <i>R</i> is used defining the <i>append</i> operator of lists built from <i>cons</i> and <i>nil</i>; where <i>cons</i>(<i>x</i>,<i>y</i>) is written in infix notation as <i>x</i>.<i>y</i> for brevity; e.g. <i>app</i>(<i>a</i>.<i>b</i>.<i>nil</i>,<i>c</i>.<i>d</i>.<i>nil</i>) → <i>a</i>.<i>app</i>(<i>b</i>.<i>nil</i>,<i>c</i>.<i>d</i>.<i>nil</i>) → <i>a</i>.<i>b</i>.<i>app</i>(<i>nil</i>,<i>c</i>.<i>d</i>.<i>nil</i>) → <i>a</i>.<i>b</i>.<i>c</i>.<i>d</i>.<i>nil</i> demonstrates the concatenation of the lists <i>a</i>.<i>b</i>.<i>nil</i> and <i>c</i>.<i>d</i>.<i>nil</i>, employing the rewrite rule 2,2, and 1. The equational theory <i>E</i> corresponding to <i>R</i> is the <a href="/wiki/Closure_(mathematics)#P_closures_of_binary_relations" title="Closure (mathematics)">congruence closure</a> of <i>R</i>, both viewed as binary relations on terms. For example, <i>app</i>(<i>a</i>.<i>b</i>.<i>nil</i>,<i>c</i>.<i>d</i>.<i>nil</i>) ≡ <i>a</i>.<i>b</i>.<i>c</i>.<i>d</i>.<i>nil</i> ≡ <i>app</i>(<i>a</i>.<i>b</i>.<i>c</i>.<i>d</i>.<i>nil</i>,<i>nil</i>). The paramodulation algorithm enumerates solutions to equations with respect to that <i>E</i> when fed with the example <i>R</i>.</p>
<p>A successful example computation path for the unification problem { <i>app</i>(<i>x</i>,<i>app</i>(<i>y</i>,<i>x</i>)) ≐ <i>a</i>.<i>a</i>.<i>nil</i> } is shown below. To avoid variable name clashes, rewrite rules are consistently renamed each time before their use by rule <i>mutate</i>; <i>v</i><sub>2</sub>, <i>v</i><sub>3</sub>, ... are computer-generated variable names for this purpose. In each line, the chosen equation from <i>G</i> is highlighted in red. Each time the <i>mutate</i> rule is applied, the chosen rewrite rule (<i>1</i> or <i>2</i>) is indicated in parentheses. From the last line, the unifying substitution <i>S</i> = { <i>y</i> ↦ <i>nil</i>, <i>x</i> ↦ <i>a</i>.<i>nil</i> } can be obtained. In fact, <i>app</i>(<i>x</i>,<i>app</i>(<i>y</i>,<i>x</i>)) {<i>y</i>↦<i>nil</i>, <i>x</i>↦ <i>a</i>.<i>nil</i> } = <i>app</i>(<i>a</i>.<i>nil</i>,<i>app</i>(<i>nil</i>,<i>a</i>.<i>nil</i>)) ≡ <i>app</i>(<i>a</i>.<i>nil</i>,<i>a</i>.<i>nil</i>) ≡ <i>a</i>.<i>app</i>(<i>nil</i>,<i>a</i>.<i>nil</i>) ≡ <i>a</i>.<i>a</i>.<i>nil</i> solves the given problem. A second successful computation path, obtainable by choosing "mutate(1), mutate(2), mutate(2), mutate(1)" leads to the substitution <i>S</i> = { <i>y</i> ↦ <i>a</i>.<i>a</i>.<i>nil</i>, <i>x</i> ↦ <i>nil</i> }; it is not shown here. No other path leads to a success.</p>
<h3><span class="mw-headline" id="Narrowing">Narrowing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=20" title="Edit section: Narrowing">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If <i>R</i> is a <a href="/wiki/Term_rewriting#Termination_and_convergence" title="Term rewriting" class="mw-redirect">convergent term rewriting system</a> for <i>E</i>, an approach alternative to the previous section consists in successive application of "<b>narrowing steps</b>"; this will eventually enumerate all solutions of a given equation. A narrowing step (cf. picture) consists in</p>
<ul>
<li>choosing a nonvariable subterm of the current term,</li>
<li><a href="#Syntactic_unification_of_first-order_terms">syntactically unifying</a> it with the left hand side of a rule from <i>R</i>, and</li>
<li>replacing the instantiated rule's right hand side into the instantiated term.</li>
</ul>
<p>Formally, if <i>l</i> → <i>r</i> is a <a href="/wiki/Term_(logic)#Structural_equality" title="Term (logic)">renamed copy</a> of a rewrite rule from <i>R</i>, having no variables in common with a term <i>s</i>, and the <a href="/wiki/Term_(logic)#Operations_with_terms" title="Term (logic)">subterm</a> <i>s</i>|<sub><i>p</i></sub> is not a variable and is unifiable with <i>l</i> via the <a href="#Syntactic_unification_of_first-order_terms">mgu</a> σ, then <i>s</i> can be <b>narrowed</b> to the term <i>t</i> = <i>s</i>σ[<i>r</i>σ]<sub><i>p</i></sub>, i.e. to the term <i>s</i>σ, with the subterm at <i>p</i> <a href="/wiki/Term_(logic)#Operations_with_terms" title="Term (logic)">replaced</a> by <i>r</i>σ. The situation that <i>s</i> can be narrowed to <i>t</i> is commonly denoted as <i>s</i> ~› <i>t</i>. Intuitively, a sequence of narrowing steps <i>t</i><sub>1</sub> ~› <i>t</i><sub>2</sub> ~› ... ~› <i>t</i><sub><i>n</i></sub> can be thought of as a sequence of rewrite steps <i>t</i><sub>1</sub> → <i>t</i><sub>2</sub> → ... → <i>t</i><sub><i>n</i></sub>, but with the initial term <i>t</i><sub>1</sub> being further and further instantiated, as necessary to make each of the used rules applicable.</p>
<p>The <a href="#One-sided_paramodulation">above</a> example paramodulation computation corresponds to the following narrowing sequence ("↓" indicating instatiation here):</p>
<p>The last term, <i>v</i><sub>2</sub>.<i>v</i><sub>2</sub>.<i>nil</i> can be syntactically unified with the original right hand side term <i>a</i>.<i>a</i>.<i>nil</i>.</p>
<p>The <i>narrowing lemma</i><sup id="cite_ref-39" class="reference"><a href="#cite_note-39"><span>[</span>35<span>]</span></a></sup> ensures that whenever an instance of a term <i>s</i> can be rewritten to a term <i>t</i> by a convergent term rewriting system, then <i>s</i> and <i>t</i> can be narrowed and rewritten to a term <i>s</i>’ and <i>t</i>’, respectively, such that <i>t</i>’ is an instance of <i>s</i>’. Formally: whenever <i>s</i>σ →<sup>*</sup> <i>t</i> holds for some substitution σ, then there exist terms <i>s</i>’, <i>t</i>’ such that <i>s</i> ~›<sup>*</sup> <i>s</i>’ and <i>t</i> →<sup>*</sup> <i>t</i>’ and <i>s</i>’τ = <i>t</i>’ for some substitution τ.</p>
<h2><span class="mw-headline" id="Higher-order_unification">Higher-order unification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=21" title="Edit section: Higher-order unification">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Many applications require one to consider the unification of typed lambda-terms instead of first-order terms. Such unification is often called <i>higher-order unification</i>. A well studied branch of higher-order unification is the problem of unifying simply typed lambda terms modulo the equality determined by αβη conversions. Such unification problems do not have most general unifiers. While higher-order unification is <a href="/wiki/Undecidable_problem" title="Undecidable problem">undecidable</a>,<sup id="cite_ref-40" class="reference"><a href="#cite_note-40"><span>[</span>36<span>]</span></a></sup><sup id="cite_ref-41" class="reference"><a href="#cite_note-41"><span>[</span>37<span>]</span></a></sup><sup id="cite_ref-42" class="reference"><a href="#cite_note-42"><span>[</span>38<span>]</span></a></sup> <a href="/wiki/G%C3%A9rard_Huet" title="Gérard Huet">Gérard Huet</a> gave a <a href="/wiki/Semi-decidable" title="Semi-decidable" class="mw-redirect">semi-decidable</a> (pre-)unification algorithm<sup id="cite_ref-43" class="reference"><a href="#cite_note-43"><span>[</span>39<span>]</span></a></sup> that allows a systematic search of the space of unifiers (generalizing the unification algorithm of Martelli-Montanari<sup id="cite_ref-Martelli.Montanari.1982_3-2" class="reference"><a href="#cite_note-Martelli.Montanari.1982-3"><span>[</span>2<span>]</span></a></sup> with rules for terms containing higher-order variables) that seems to work sufficiently well in practice. Huet<sup id="cite_ref-44" class="reference"><a href="#cite_note-44"><span>[</span>40<span>]</span></a></sup> and Gilles Dowek<sup id="cite_ref-45" class="reference"><a href="#cite_note-45"><span>[</span>41<span>]</span></a></sup> have written articles surveying this topic.</p>
<p><a href="/w/index.php?title=Dale_Miller_(computer_scientist)&amp;action=edit&amp;redlink=1" class="new" title="Dale Miller (computer scientist) (page does not exist)">Dale Miller</a> has described what is now called <a href="/w/index.php?title=Higher-order_pattern_unification&amp;action=edit&amp;redlink=1" class="new" title="Higher-order pattern unification (page does not exist)">higher-order pattern unification</a>.<sup id="cite_ref-46" class="reference"><a href="#cite_note-46"><span>[</span>42<span>]</span></a></sup> This subset of higher-order unification is decidable and solvable unification problems have most-general unifiers. Many computer systems that contain higher-order unification, such as the higher-order logic programming languages <a href="/wiki/%CE%9BProlog" title="ΛProlog">λProlog</a> and <a href="/wiki/Twelf" title="Twelf">Twelf</a>, often implement only the pattern fragment and not full higher-order unification.</p>
<p>In computational linguistics, one of the most influential theories of <a href="/wiki/Elliptical_construction" title="Elliptical construction" class="mw-redirect">ellipsis</a> is that ellipses are represented by free variables whose values are then determined using Higher-Order Unification (HOU). For instance, the semantic representation of "Jon likes Mary and Peter does too" is like(j; m)R(p) and the value of R (the semantic representation of the ellipsis) is determined by the equation like(j; m) = R(j). The process of solving such equations is called Higher-Order Unification.<sup id="cite_ref-47" class="reference"><a href="#cite_note-47"><span>[</span>43<span>]</span></a></sup></p>
<p>For example, the unification problem { <i>f</i>(<i>a</i>, <i>b</i>, <i>a</i>) ≐ <i>d</i>(<i>b</i>, <i>a</i>, <i>c</i>) }, where the only variable is <i>f</i>, has the solutions {<i>f</i> ↦ λ<i>x</i>.λ<i>y</i>.λ<i>z</i>.<i>d</i>(<i>y</i>, <i>x</i>, <i>c</i>) }, {<i>f</i> ↦ λ<i>x</i>.λ<i>y</i>.λ<i>z</i>.<i>d</i>(<i>y</i>, <i>z</i>, <i>c</i>) }, {<i>f</i> ↦ λ<i>x</i>.λ<i>y</i>.λ<i>z</i>.<i>d</i>(<i>y</i>, <i>a</i>, <i>c</i>) }, {<i>f</i> ↦ λ<i>x</i>.λ<i>y</i>.λ<i>z</i>.<i>d</i>(<i>b</i>, <i>x</i>, <i>c</i>) }, {<i>f</i> ↦ λ<i>x</i>.λ<i>y</i>.λ<i>z</i>.<i>d</i>(<i>b</i>, <i>z</i>, <i>c</i>) } and {<i>f</i> ↦ λ<i>x</i>.λ<i>y</i>.λ<i>z</i>.<i>d</i>(<i>b</i>, <i>a</i>, <i>c</i>) }.</p>
<p><a href="/wiki/Wayne_Snyder" title="Wayne Snyder">Wayne Snyder</a> gave a generalization of both higher-order unification and E-unification, i.e. an algorithm to unify lambda-terms modulo an equational theory.<sup id="cite_ref-48" class="reference"><a href="#cite_note-48"><span>[</span>44<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=22" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Admissible_rule" title="Admissible rule">Admissible rule</a></li>
<li><a href="/wiki/Explicit_substitution" title="Explicit substitution">Explicit substitution</a> in <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a></li>
<li>Mathematical <a href="/wiki/Equation_solving" title="Equation solving">Equation solving</a></li>
<li><a href="/wiki/Dis-unification_(computer_science)" title="Dis-unification (computer science)">Dis-unification</a>: solving inequations between symbolic expression</li>
<li><a href="/wiki/Anti-unification_(computer_science)" title="Anti-unification (computer science)">Anti-unification</a>: computing a least general generalization (lgg) of two terms, dual to computing a most general instance (mgu)</li>
</ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=23" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">in this case, still a complete substitution set exists (e.g. the set of all solutions at all); however, each such set contains redundant members.</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">E.g. <i>a</i> ⊕ (<i>b</i> ⊕ <i>f</i>(<i>x</i>)) ≡ <i>a</i> ⊕ (<i>f</i>(<i>x</i>) ⊕ <i>b</i>) ≡ (<i>b</i> ⊕ <i>f</i>(<i>x</i>)) ⊕ <i>a</i> ≡ (<i>f</i>(<i>x</i>) ⊕ <i>b</i>) ⊕ <i>a</i></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text">formally: each unifier τ satisfies ∀<i>x</i>: <i>x</i>τ = (<i>x</i>σ)ρ for some substitution ρ</span></li>
<li id="cite_note-LRequivC-28"><span class="mw-cite-backlink">^ <a href="#cite_ref-LRequivC_28-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-LRequivC_28-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">in the presence of equality <b>C</b>, equalities <b>N<sub>l</sub></b> and <b>N<sub>r</sub></b> are equivalent, similar for <b>D<sub>l</sub></b> and <b>D<sub>r</sub></b></span></li>
</ol>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Unification_(computer_science)&amp;action=edit&amp;section=24" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Franz_Baader" title="Franz Baader">Franz Baader</a> and <a href="/wiki/Tobias_Nipkow" title="Tobias Nipkow">Tobias Nipkow</a>, <i><a rel="nofollow" class="external text" href="http://www.in.tum.de/~nipkow/TRaAT/">Term Rewriting and All That</a>.</i> Cambridge University Press, 1998.</li>
<li>Franz Baader and <a href="/wiki/Wayne_Snyder" title="Wayne Snyder">Wayne Snyder</a>, <i><a rel="nofollow" class="external text" href="http://www.cs.bu.edu/~snyder/publications/UnifChapter.pdf">Unification Theory</a>.</i> In <a href="/wiki/John_Alan_Robinson" title="John Alan Robinson">John Alan Robinson</a> and <a href="/wiki/Andrei_Voronkov" title="Andrei Voronkov">Andrei Voronkov</a>, editors, <a href="/wiki/Handbook_of_Automated_Reasoning" title="Handbook of Automated Reasoning">Handbook of Automated Reasoning</a>, volume I, pages 447–533. Elsevier Science Publishers, 2001.</li>
<li><a href="/wiki/Joseph_Goguen" title="Joseph Goguen">Joseph Goguen</a>, <i><a rel="nofollow" class="external text" href="http://www-cse.ucsd.edu/~goguen/projs/sem.html">What is Unification?</a>.</i></li>
<li><a href="/wiki/Nachum_Dershowitz" title="Nachum Dershowitz">Nachum Dershowitz</a> and <a href="/wiki/Jean-Pierre_Jouannaud" title="Jean-Pierre Jouannaud">Jean-Pierre Jouannaud</a>, <i>Rewrite Systems</i>, in: <a href="/wiki/Jan_van_Leeuwen" title="Jan van Leeuwen">Jan van Leeuwen</a> (ed.), <i>Handbook of Theoretical Computer Science</i>, vol.B <i>Formal Models and Semantics</i>, Elsevier, 1990, pp. 243–320</li>
<li><span class="citation journal">Kevin Knight (Mar 1989). <a rel="nofollow" class="external text" href="http://www.isi.edu/natural-language/people/unification-knight.pdf">"Unification: A Multidisciplinary Survey"</a>. <i>ACM Computing Surveys</i> <b>21</b> (1): 93–124. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F62029.62030">10.1145/62029.62030</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Unification%3A+A+Multidisciplinary+Survey&amp;rft.au=Kevin+Knight&amp;rft.aulast=Kevin+Knight&amp;rft.date=Mar+1989&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.isi.edu%2Fnatural-language%2Fpeople%2Funification-knight.pdf&amp;rft_id=info%3Adoi%2F10.1145%2F62029.62030&amp;rft.issue=1&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.pages=93-124&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=21" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation mathworld" id="Reference-Mathworld-Unification">Alex Sakharov, <a rel="nofollow" class="external text" href="http://mathworld.wolfram.com/Unification.html">"Unification"</a>, <i><a href="/wiki/MathWorld" title="MathWorld">MathWorld</a></i>.</span></li>
</ul>
<ol class="references">
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation journal">Fages, François; Huet, Gérard (1986). "Complete Sets of Unifiers and Matchers in Equational Theories". <i>Theoretical Computer Science</i> <b>43</b>: 189–200. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0304-3975%2886%2990175-1">10.1016/0304-3975(86)90175-1</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Complete+Sets+of+Unifiers+and+Matchers+in+Equational+Theories&amp;rft.au=Fages%2C+Fran%C3%A7ois&amp;rft.aufirst=Fran%C3%A7ois&amp;rft.au=Huet%2C+G%C3%A9rard&amp;rft.aulast=Fages&amp;rft.date=1986&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2F0304-3975%2886%2990175-1&amp;rft.jtitle=Theoretical+Computer+Science&amp;rft.pages=189-200&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=43" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Martelli.Montanari.1982-3"><span class="mw-cite-backlink">^ <a href="#cite_ref-Martelli.Montanari.1982_3-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Martelli.Montanari.1982_3-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Martelli.Montanari.1982_3-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Martelli, Alberto; Montanari, Ugo (Apr 1982). "An Efficient Unification Algorithm". <i>ACM Trans. Program. Lang. Syst.</i> <b>4</b> (2): 258–282. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1145%2F357162.357169">10.1145/357162.357169</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=An+Efficient+Unification+Algorithm&amp;rft.aufirst=Alberto&amp;rft.aulast=Martelli&amp;rft.au=Martelli%2C+Alberto&amp;rft.au=Montanari%2C+Ugo&amp;rft.date=Apr+1982&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1145%2F357162.357169&amp;rft.issue=2&amp;rft.jtitle=ACM+Trans.+Program.+Lang.+Syst.&amp;rft.pages=258-282&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=4" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Robinson.1965-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-Robinson.1965_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Robinson.1965_4-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Robinson.1965_4-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-Robinson.1965_4-3"><sup><i><b>d</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">J.A. Robinson (Jan 1965). "A Machine-Oriented Logic Based on the Resolution Principle". <i>Journal of the ACM</i> <b>12</b> (1): 23–41.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=A+Machine-Oriented+Logic+Based+on+the+Resolution+Principle&amp;rft.au=J.A.+Robinson&amp;rft.aulast=J.A.+Robinson&amp;rft.date=Jan+1965&amp;rft.genre=article&amp;rft.issue=1&amp;rft.jtitle=Journal+of+the+ACM&amp;rft.pages=23-41&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=12" class="Z3988"><span style="display:none;"> </span></span>; Here: sect.5.8, p.32</span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation journal">J.A. Robinson (1971). <a rel="nofollow" class="external text" href="http://aitopics.org/sites/default/files/classic/Machine%20Intelligence%206/MI6-Ch4-Robinson.pdf">"Computational logic: The unification computation"</a>. <i>Machine Intelligence</i> <b>6</b>: 63–72.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Computational+logic%3A+The+unification+computation&amp;rft.au=J.A.+Robinson&amp;rft.aulast=J.A.+Robinson&amp;rft.date=1971&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Faitopics.org%2Fsites%2Fdefault%2Ffiles%2Fclassic%2FMachine%2520Intelligence%25206%2FMI6-Ch4-Robinson.pdf&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=63-72&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation book"><a href="/wiki/Chen_Chung_Chang" title="Chen Chung Chang">C.C. Chang</a>; <a href="/wiki/Howard_Jerome_Keisler" title="Howard Jerome Keisler">H. Jerome Keisler</a> (1977). A. Heyting and H.J. Keisler and A. Mostowski and A. Robinson and P. Suppes, ed. <i>Model Theory</i>. Studies in Logic and the Foundation of Mathematics <b>73</b>. North Holland.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.au=C.C.+Chang&amp;rft.au=H.+Jerome+Keisler&amp;rft.aulast=C.C.+Chang&amp;rft.btitle=Model+Theory&amp;rft.date=1977&amp;rft.genre=book&amp;rft.pub=North+Holland&amp;rft.series=Studies+in+Logic+and+the+Foundation+of+Mathematics&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=73" class="Z3988"><span style="display:none;"> </span></span>; here: Sect.1.3</span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text">Robinson (1965);<sup id="cite_ref-Robinson.1965_4-1" class="reference"><a href="#cite_note-Robinson.1965-4"><span>[</span>3<span>]</span></a></sup> nr.2.5, 2.14, p.25</span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text">Robinson (1965);<sup id="cite_ref-Robinson.1965_4-2" class="reference"><a href="#cite_note-Robinson.1965-4"><span>[</span>3<span>]</span></a></sup> nr.5.6, p.32</span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text">Robinson (1965);<sup id="cite_ref-Robinson.1965_4-3" class="reference"><a href="#cite_note-Robinson.1965-4"><span>[</span>3<span>]</span></a></sup> nr.5.8, p.32</span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text">Alg.1, p.261. Their rule <b>(a)</b> corresponds to rule <b>swap</b> here, <b>(b)</b> to <b>delete</b>, <b>(c)</b> to both <b>decompose</b> and <b>conflict</b>, and <b>(d)</b> to both <b>eliminate</b> and <b>check</b>.</span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text"><span class="citation report">Lewis Denver Baxter (Feb 1976). <a rel="nofollow" class="external text" href="https://cs.uwaterloo.ca/research/tr/1976/CS-76-13.pdf">﻿A practically linear unification algorithm﻿</a> (Res. Report). <b>CS-76-13</b>. Univ. of Waterloo, Ontario<span class="printonly">. <a rel="nofollow" class="external free" href="https://cs.uwaterloo.ca/research/tr/1976/CS-76-13.pdf">https://cs.uwaterloo.ca/research/tr/1976/CS-76-13.pdf</a></span>.</span></span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text"><span class="citation thesis"><a href="/wiki/G%C3%A9rard_Huet" title="Gérard Huet">Gérard Huet</a> (Sep 1976). <i>Resolution d'Equations dans des Langages d'Ordre 1,2,...ω</i> (These d'etat). Universite de Paris VII.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.au=G%C3%A9rard+Huet&amp;rft.aulast=G%C3%A9rard+Huet&amp;rft.btitle=Resolution+d%27Equations+dans+des+Langages+d%27Ordre+1%2C2%2C...%CF%89&amp;rft.date=Sep+1976&amp;rft.genre=book&amp;rft.pub=Universite+de+Paris+VII&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Martelli.Montanari.1976-15"><span class="mw-cite-backlink">^ <a href="#cite_ref-Martelli.Montanari.1976_15-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Martelli.Montanari.1976_15-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation report">Alberto Martelli and Ugo Montanari (Jul 1976). <a rel="nofollow" class="external text" href="http://puma.isti.cnr.it/publichtml/section_cnr_iei/cnr_iei_1976-B4-041.html">﻿Unification in linear time and space: A structured presentation﻿</a> (Internal Note). <b>IEI-B76-16</b>. Consiglio Nazionale delle Ricerche, Pisa<span class="printonly">. <a rel="nofollow" class="external free" href="http://puma.isti.cnr.it/publichtml/section_cnr_iei/cnr_iei_1976-B4-041.html">http://puma.isti.cnr.it/publichtml/section_cnr_iei/cnr_iei_1976-B4-041.html</a></span>.</span></span></li>
<li id="cite_note-Paterson.Wegman.1978-16"><span class="mw-cite-backlink">^ <a href="#cite_ref-Paterson.Wegman.1978_16-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Paterson.Wegman.1978_16-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Paterson.Wegman.1978_16-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation journal"><a href="/wiki/Michael_Stewart_Paterson" title="Michael Stewart Paterson" class="mw-redirect">Michael Stewart Paterson</a> and M.N. Wegman (Apr 1978). <a rel="nofollow" class="external text" href="http://www.sciencedirect.com/science/article/pii/0022000078900430/pdf?md5=404ce04b363525aef2a1277b2ec249d1&amp;pid=1-s2.0-0022000078900430-main.pdf">"Linear unification"</a>. <i>J. Comput. Syst. Sci.</i> <b>16</b> (2): 158–167.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Linear+unification&amp;rft.aulast=Michael+Stewart+Paterson+and+M.N.+Wegman&amp;rft.au=Michael+Stewart+Paterson+and+M.N.+Wegman&amp;rft.date=Apr+1978&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2F0022000078900430%2Fpdf%3Fmd5%3D404ce04b363525aef2a1277b2ec249d1%26pid%3D1-s2.0-0022000078900430-main.pdf&amp;rft.issue=2&amp;rft.jtitle=J.+Comput.+Syst.+Sci.&amp;rft.pages=158-167&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=16" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><span class="citation book"><a href="/wiki/J.A._Robinson" title="J.A. Robinson" class="mw-redirect">J.A. Robinson</a> (Jan 1976). <a href="/wiki/Woodrow_W._Bledsoe" title="Woodrow W. Bledsoe" class="mw-redirect">Woodrow W. Bledsoe</a>, Michael M. Richter, ed. <a rel="nofollow" class="external text" href="http://oda.mfo.de/bsz325106819.html"><i>Proc. Theorem Proving Workshop Oberwolfach</i></a>. Oberwolfach Workshop Report. 1976/3.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.au=J.A.+Robinson&amp;rft.aulast=J.A.+Robinson&amp;rft.btitle=Proc.+Theorem+Proving+Workshop+Oberwolfach&amp;rft.date=Jan+1976&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Foda.mfo.de%2Fbsz325106819.html&amp;rft.series=Oberwolfach+Workshop+Report&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=1976%2F3" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text"><span class="citation journal">M. Venturini-Zilli (Oct 1975). "Complexity of the unification algorithm for first-order expressions". <i>Calcolo</i> <b>12</b> (4): 361–372.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Complexity+of+the+unification+algorithm++for+first-order+expressions&amp;rft.aulast=M.+Venturini-Zilli&amp;rft.au=M.+Venturini-Zilli&amp;rft.date=Oct+1975&amp;rft.genre=article&amp;rft.issue=4&amp;rft.jtitle=Calcolo&amp;rft.pages=361-372&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=12" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text">See Martelli, Montanari (1982),<sup id="cite_ref-Martelli.Montanari.1982_3-1" class="reference"><a href="#cite_note-Martelli.Montanari.1982-3"><span>[</span>2<span>]</span></a></sup> sect.1, p.259. Paterson's and Wegman's paper is dated 1978; however, the journal publisher received it in Sep.1976.</span></li>
<li id="cite_note-20"><span class="mw-cite-backlink"><b><a href="#cite_ref-20">^</a></b></span> <span class="reference-text"><span class="citation journal">McBride, Conor (October 2003). <a rel="nofollow" class="external text" href="http://strictlypositive.org/unify.ps.gz">"First-Order Unification by Structural Recursion"</a>. <i>Journal of Functional Programming</i> <b>13</b> (6): 1061–1076. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1017%2FS0956796803004957">10.1017/S0956796803004957</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0956-7968">0956-7968</a><span class="reference-accessdate">. Retrieved 30 March 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=First-Order+Unification+by+Structural+Recursion&amp;rft.aufirst=Conor&amp;rft.aulast=McBride&amp;rft.au=McBride%2C+Conor&amp;rft.date=October+2003&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fstrictlypositive.org%2Funify.ps.gz&amp;rft_id=info%3Adoi%2F10.1017%2FS0956796803004957&amp;rft.issn=0956-7968&amp;rft.issue=6&amp;rft.jtitle=Journal+of+Functional+Programming&amp;rft.pages=1061-1076&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=13" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-21"><span class="mw-cite-backlink"><b><a href="#cite_ref-21">^</a></b></span> <span class="reference-text">e.g. Paterson, Wegman (1978),<sup id="cite_ref-Paterson.Wegman.1978_16-2" class="reference"><a href="#cite_note-Paterson.Wegman.1978-16"><span>[</span>13<span>]</span></a></sup> sect.2, p.159</span></li>
<li id="cite_note-22"><span class="mw-cite-backlink"><b><a href="#cite_ref-22">^</a></b></span> <span class="reference-text"><span class="citation journal">Walther, Christoph (1985). <a rel="nofollow" class="external text" href="http://www.inferenzsysteme.informatik.tu-darmstadt.de/media/is/publikationen/Schuberts_Steamroller_by_Many-Sorted_Resolution-AIJ-25-2-1985.pdf">"A Mechanical Solution of Schubert's Steamroller by Many-Sorted Resolution"</a>. <i>Artif. Intell.</i> <b>26</b> (2): 217–224. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0004-3702%2885%2990029-3">10.1016/0004-3702(85)90029-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=A+Mechanical+Solution+of+Schubert%27s+Steamroller+by+Many-Sorted+Resolution&amp;rft.aufirst=Christoph&amp;rft.aulast=Walther&amp;rft.au=Walther%2C+Christoph&amp;rft.date=1985&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.inferenzsysteme.informatik.tu-darmstadt.de%2Fmedia%2Fis%2Fpublikationen%2FSchuberts_Steamroller_by_Many-Sorted_Resolution-AIJ-25-2-1985.pdf&amp;rft_id=info%3Adoi%2F10.1016%2F0004-3702%2885%2990029-3&amp;rft.issue=2&amp;rft.jtitle=Artif.+Intell.&amp;rft.pages=217-224&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=26" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-23"><span class="mw-cite-backlink"><b><a href="#cite_ref-23">^</a></b></span> <span class="reference-text"><span class="citation conference">Smolka, Gert (Nov 1988). "Logic Programming with Polymorphically Order-Sorted Types". "Int. Workshop Algebraic and Logic Programming". LNCS <b>343</b>. Springer. pp. 53–70.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Int.+Workshop+Algebraic+and+Logic+Programming&amp;rft.aufirst=Gert&amp;rft.aulast=Smolka&amp;rft.au=Smolka%2C+Gert&amp;rft.btitle=Logic+Programming+with+Polymorphically+Order-Sorted+Types&amp;rft.date=Nov+1988&amp;rft.genre=bookitem&amp;rft.pages=53-70&amp;rft.pub=Springer&amp;rft.series=LNCS&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=343" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-24"><span class="mw-cite-backlink"><b><a href="#cite_ref-24">^</a></b></span> <span class="reference-text"><span class="citation book">Schmidt-Schauß, Manfred (Apr 1988). <i>Computational Aspects of an Order-Sorted Logic with Term Declarations</i>. LNAI <b>395</b>. Springer.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.aufirst=Manfred&amp;rft.aulast=Schmidt-Schau%C3%9F&amp;rft.au=Schmidt-Schau%C3%9F%2C+Manfred&amp;rft.btitle=Computational+Aspects+of+an+Order-Sorted+Logic+with+Term+Declarations&amp;rft.date=Apr+1988&amp;rft.genre=book&amp;rft.pub=Springer&amp;rft.series=LNAI&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=395" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-25"><span class="mw-cite-backlink"><b><a href="#cite_ref-25">^</a></b></span> <span class="reference-text"><a href="/wiki/Gordon_D._Plotkin" title="Gordon D. Plotkin" class="mw-redirect">Gordon D. Plotkin</a>, <i>Lattice Theoretic Properties of Subsumption</i>, Memorandum MIP-R-77, Univ. Edinburgh, Jun 1970</span></li>
<li id="cite_note-26"><span class="mw-cite-backlink"><b><a href="#cite_ref-26">^</a></b></span> <span class="reference-text"><a href="/wiki/Mark_E._Stickel" title="Mark E. Stickel">Mark E. Stickel</a>, <i>A Unification Algorithm for Associative-Commutative Functions</i>, J. Assoc. Comput. Mach., vol.28, no.3, pp. 423–434, 1981</span></li>
<li id="cite_note-Fages.1987-27"><span class="mw-cite-backlink">^ <a href="#cite_ref-Fages.1987_27-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Fages.1987_27-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">F. Fages, <i>Associative-Commutative Unification</i>, J. Symbolic Comput., vol.3, no.3, pp. 257–275, 1987</span></li>
<li id="cite_note-29"><span class="mw-cite-backlink"><b><a href="#cite_ref-29">^</a></b></span> <span class="reference-text">Franz Baader, <i>Unification in Idempotent Semigroups is of Type Zero</i>, J. Automat. Reasoning, vol.2, no.3, 1986</span></li>
<li id="cite_note-30"><span class="mw-cite-backlink"><b><a href="#cite_ref-30">^</a></b></span> <span class="reference-text">J. Makanin, <i>The Problem of Solvability of Equations in a Free Semi-Group</i>, Akad. Nauk SSSR, vol.233, no.2, 1977</span></li>
<li id="cite_note-31"><span class="mw-cite-backlink"><b><a href="#cite_ref-31">^</a></b></span> <span class="reference-text"><span class="citation journal">F. Fages (1987). "Associative-Commutative Unification". <i>J. Symbolic Comput.</i> <b>3</b> (3): 257–275. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fs0747-7171%2887%2980004-4">10.1016/s0747-7171(87)80004-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Associative-Commutative+Unification&amp;rft.au=F.+Fages&amp;rft.aulast=F.+Fages&amp;rft.date=1987&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2Fs0747-7171%2887%2980004-4&amp;rft.issue=3&amp;rft.jtitle=J.+Symbolic+Comput.&amp;rft.pages=257-275&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=3" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-32"><span class="mw-cite-backlink"><b><a href="#cite_ref-32">^</a></b></span> <span class="reference-text"><span class="citation book">Martin, U., Nipkow, T. (1986). "Unification in Boolean Rings". In Jörg H. Siekmann. <i>Proc. 8th CADE</i>. LNCS <b>230</b>. Springer. pp. 506–513.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Proc.+8th+CADE&amp;rft.aulast=Martin%2C+U.%2C+Nipkow%2C+T.&amp;rft.au=Martin%2C+U.%2C+Nipkow%2C+T.&amp;rft.btitle=Unification+in+Boolean+Rings&amp;rft.date=1986&amp;rft.genre=bookitem&amp;rft.pages=506-513&amp;rft.pub=Springer&amp;rft.series=LNCS&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=230" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-33"><span class="mw-cite-backlink"><b><a href="#cite_ref-33">^</a></b></span> <span class="reference-text"><span class="citation journal">A. Boudet, J.P. Jouannaud, M. Schmidt-Schauß (1989). <a rel="nofollow" class="external text" href="http://www.sciencedirect.com/science/article/pii/S0747717189800549/pdf?md5=713ed362e4b6f2db53923cc5ed47c818&amp;pid=1-s2.0-S0747717189800549-main.pdf">"Unification of Boolean Rings and Abelian Groups"</a>. <i>Journal of Symbolic Computation</i> <b>8</b>: 449–477. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fs0747-7171%2889%2980054-9">10.1016/s0747-7171(89)80054-9</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Unification+of+Boolean+Rings+and+Abelian+Groups&amp;rft.au=A.+Boudet%2C+J.P.+Jouannaud%2C+M.+Schmidt-Schau%C3%9F&amp;rft.aulast=A.+Boudet%2C+J.P.+Jouannaud%2C+M.+Schmidt-Schau%C3%9F&amp;rft.date=1989&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2FS0747717189800549%2Fpdf%3Fmd5%3D713ed362e4b6f2db53923cc5ed47c818%26pid%3D1-s2.0-S0747717189800549-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2Fs0747-7171%2889%2980054-9&amp;rft.jtitle=Journal+of+Symbolic+Computation&amp;rft.pages=449-477&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=8" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Baader_and_Snyder_2001.2C_p._486-34"><span class="mw-cite-backlink">^ <a href="#cite_ref-Baader_and_Snyder_2001.2C_p._486_34-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Baader_and_Snyder_2001.2C_p._486_34-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Baader and Snyder (2001), p. 486.</span></li>
<li id="cite_note-35"><span class="mw-cite-backlink"><b><a href="#cite_ref-35">^</a></b></span> <span class="reference-text">F. Baader and S. Ghilardi, <i>Unification in modal and description logics</i>, Logic Journal of the IGPL 19 (2011), no. 6, pp. 705–730.</span></li>
<li id="cite_note-36"><span class="mw-cite-backlink"><b><a href="#cite_ref-36">^</a></b></span> <span class="reference-text">P. Szabo, <i>Unifikationstheorie erster Ordnung</i> (<i>First Order Unification Theory</i>), Thesis, Univ. Karlsruhe, West Germany, 1982</span></li>
<li id="cite_note-37"><span class="mw-cite-backlink"><b><a href="#cite_ref-37">^</a></b></span> <span class="reference-text">Jörg H. Siekmann, <i>Universal Unification</i>, Proc. 7th Int. Conf. on Automated Deduction, Springer LNCS vol.170, pp. 1–42, 1984</span></li>
<li id="cite_note-38"><span class="mw-cite-backlink"><b><a href="#cite_ref-38">^</a></b></span> <span class="reference-text">N. Dershowitz and G. Sivakumar, <i>Solving Goals in Equational Languages</i>, Proc. 1st Int. Workshop on Conditional Term Rewriting Systems, Springer LNCS vol.308, pp. 45–55, 1988</span></li>
<li id="cite_note-39"><span class="mw-cite-backlink"><b><a href="#cite_ref-39">^</a></b></span> <span class="reference-text"><span class="citation book">Fay (1979). "First-Order Unification in an Equational Theory". <i>Proc. 4th Workshop on Automated Deduction</i>. pp. 161–167.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Proc.+4th+Workshop+on+Automated+Deduction&amp;rft.au=Fay&amp;rft.aulast=Fay&amp;rft.btitle=First-Order+Unification+in+an+Equational+Theory&amp;rft.date=1979&amp;rft.genre=bookitem&amp;rft.pages=161-167&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-40"><span class="mw-cite-backlink"><b><a href="#cite_ref-40">^</a></b></span> <span class="reference-text"><span class="citation journal"><a href="/wiki/Warren_D._Goldfarb" title="Warren D. Goldfarb" class="mw-redirect">Warren D. Goldfarb</a> (1981). <a rel="nofollow" class="external text" href="http://www.sciencedirect.com/science/article/pii/0304397581900402/pdf?md5=ebe7687d034498bb76c4ea9c5df56f84&amp;pid=1-s2.0-0304397581900402-main.pdf">"The Undecidability of the Second-Order Unification Problem"</a>. <i>TCS</i> <b>13</b>: 225–230. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0304-3975%2881%2990040-2">10.1016/0304-3975(81)90040-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=The+Undecidability+of+the+Second-Order+Unification+Problem&amp;rft.aulast=Warren+D.+Goldfarb&amp;rft.au=Warren+D.+Goldfarb&amp;rft.date=1981&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2F0304397581900402%2Fpdf%3Fmd5%3Debe7687d034498bb76c4ea9c5df56f84%26pid%3D1-s2.0-0304397581900402-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2F0304-3975%2881%2990040-2&amp;rft.jtitle=TCS&amp;rft.pages=225-230&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=13" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-41"><span class="mw-cite-backlink"><b><a href="#cite_ref-41">^</a></b></span> <span class="reference-text"><span class="citation journal">Gérard P. Huet (1973). <a rel="nofollow" class="external text" href="http://www.sciencedirect.com/science/article/pii/S001999587390301X/pdf?md5=0833289609c3d777bdec01d5d6ced2aa&amp;pid=1-s2.0-S001999587390301X-main.pdf">"The Undecidability of Unification in Third Order Logic"</a>. <i>Information and Control</i> <b>22</b>: 257–267. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2FS0019-9958%2873%2990301-X">10.1016/S0019-9958(73)90301-X</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=The+Undecidability+of+Unification+in+Third+Order+Logic&amp;rft.au=G%C3%A9rard+P.+Huet&amp;rft.aulast=G%C3%A9rard+P.+Huet&amp;rft.date=1973&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2FS001999587390301X%2Fpdf%3Fmd5%3D0833289609c3d777bdec01d5d6ced2aa%26pid%3D1-s2.0-S001999587390301X-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2FS0019-9958%2873%2990301-X&amp;rft.jtitle=Information+and+Control&amp;rft.pages=257-267&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=22" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-42"><span class="mw-cite-backlink"><b><a href="#cite_ref-42">^</a></b></span> <span class="reference-text">Claudio Lucchesi: The Undecidability of the Unification Problem for Third Order Languages (Research Report CSRR 2059; Department of Computer Science, University of Waterloo, 1972)</span></li>
<li id="cite_note-43"><span class="mw-cite-backlink"><b><a href="#cite_ref-43">^</a></b></span> <span class="reference-text">Gérard Huet: A Unification Algorithm for typed Lambda-Calculus []</span></li>
<li id="cite_note-44"><span class="mw-cite-backlink"><b><a href="#cite_ref-44">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=695200">Gérard Huet: Higher Order Unification 30 Years Later</a></span></li>
<li id="cite_note-45"><span class="mw-cite-backlink"><b><a href="#cite_ref-45">^</a></b></span> <span class="reference-text">Gilles Dowek: Higher-Order Unification and Matching. Handbook of Automated Reasoning 2001: 1009–1062</span></li>
<li id="cite_note-46"><span class="mw-cite-backlink"><b><a href="#cite_ref-46">^</a></b></span> <span class="reference-text"><span class="citation journal">Miller, Dale (1991). <a rel="nofollow" class="external text" href="http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/jlc91.pdf">"A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification"</a>. <i>Journal of Logic and Computation</i>: 497–536.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=A+Logic+Programming+Language+with+Lambda-Abstraction%2C+Function+Variables%2C+and+Simple+Unification&amp;rft.aufirst=Dale&amp;rft.aulast=Miller&amp;rft.au=Miller%2C+Dale&amp;rft.date=1991&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.lix.polytechnique.fr%2FLabo%2FDale.Miller%2Fpapers%2Fjlc91.pdf&amp;rft.jtitle=Journal+of+Logic+and+Computation&amp;rft.pages=497-536&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-47"><span class="mw-cite-backlink"><b><a href="#cite_ref-47">^</a></b></span> <span class="reference-text"><span class="citation book">Claire Gardent; <a href="/wiki/Michael_Kohlhase" title="Michael Kohlhase">Michael Kohlhase</a>; Karsten Konrad (1997). <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.9018&amp;rep=rep1&amp;type=pdf">"A Multi-Level, Higher-Order Unification Approach to Ellipsis"</a>. <i>Submitted to European <a href="/wiki/Association_for_Computational_Linguistics" title="Association for Computational Linguistics">Association for Computational Linguistics</a> (EACL)</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Submitted+to+European+Association+for+Computational+Linguistics+%28EACL%29&amp;rft.au=Claire+Gardent&amp;rft.au=Karsten+Konrad&amp;rft.aulast=Claire+Gardent&amp;rft.au=Michael+Kohlhase&amp;rft.btitle=A+Multi-Level%2C+Higher-Order+Unification+Approach+to+Ellipsis&amp;rft.date=1997&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.55.9018%26rep%3Drep1%26type%3Dpdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-48"><span class="mw-cite-backlink"><b><a href="#cite_ref-48">^</a></b></span> <span class="reference-text"><span class="citation book">Wayne Snyder (Jul 1990). "Higher order E-unification". <i>Proc. 10th <a href="/wiki/Conference_on_Automated_Deduction" title="Conference on Automated Deduction">Conference on Automated Deduction</a></i>. LNAI <b>449</b>. Springer. pp. 573–587.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AUnification+%28computer+science%29&amp;rft.atitle=Proc.+10th+Conference+on+Automated+Deduction&amp;rft.aulast=Wayne+Snyder&amp;rft.au=Wayne+Snyder&amp;rft.btitle=Higher+order+E-unification&amp;rft.date=Jul+1990&amp;rft.genre=bookitem&amp;rft.pages=573-587&amp;rft.pub=Springer&amp;rft.series=LNAI&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=449" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
