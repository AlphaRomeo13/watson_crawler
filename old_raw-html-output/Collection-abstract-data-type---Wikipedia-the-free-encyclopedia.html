<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Collection (abstract data type)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <b>collection</b> or <b>container</b> is a grouping of some variable number of data items (possibly zero) that have some shared significance to the problem being solved and need to be operated upon together in some controlled fashion. Generally, the data items will be of the same type or, in languages supporting inheritance, derived from some common ancestor type. A collection is a concept applicable to <a href="/wiki/Abstract_data_type" title="Abstract data type">abstract data types</a>, and does not prescribe a specific implementation as a concrete <a href="/wiki/Data_structure" title="Data structure">data structure</a>, though often there is a conventional choice; see <a href="/wiki/Container_(type_theory)" title="Container (type theory)">container (type theory)</a> for <a href="/wiki/Type_theory" title="Type theory">type theory</a> discussion.</p>
<p>Some different kinds of collections are <a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">lists</a>, <a href="/wiki/Set_(computer_science)" title="Set (computer science)" class="mw-redirect">sets</a>, <a href="/wiki/Multiset" title="Multiset">bags</a> (or multisets), <a href="/wiki/Tree_(data_structure)" title="Tree (data structure)">trees</a> and <a href="/wiki/Graph_(data_structure)" title="Graph (data structure)" class="mw-redirect">graphs</a>. An <a href="/wiki/Enumerated_type" title="Enumerated type">enumerated type</a> may be either a list or a set.</p>
<p>A fixed-size table (or array) is usually not considered a collection because it holds a fixed number of items, although tables/arrays commonly play a role in the implementation of collections. Variable-sized arrays are generally considered collections, and fixed-size arrays may likewise considered a collection, albeit with limitations.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Linear_collections"><span class="tocnumber">1</span> <span class="toctext">Linear collections</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Lists"><span class="tocnumber">1.1</span> <span class="toctext">Lists</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Priority_queues"><span class="tocnumber">1.2</span> <span class="toctext">Priority queues</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Associative_collections"><span class="tocnumber">2</span> <span class="toctext">Associative collections</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Sets"><span class="tocnumber">2.1</span> <span class="toctext">Sets</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Multisets"><span class="tocnumber">2.2</span> <span class="toctext">Multisets</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Associative_arrays"><span class="tocnumber">2.3</span> <span class="toctext">Associative arrays</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Graphs"><span class="tocnumber">3</span> <span class="toctext">Graphs</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Trees"><span class="tocnumber">3.1</span> <span class="toctext">Trees</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Abstract_concept_vs._implementation"><span class="tocnumber">4</span> <span class="toctext">Abstract concept vs. implementation</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Implementations"><span class="tocnumber">5</span> <span class="toctext">Implementations</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Lists"><span class="tocnumber">1.1</span> <span class="toctext">Lists</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Priority_queues"><span class="tocnumber">1.2</span> <span class="toctext">Priority queues</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Sets"><span class="tocnumber">2.1</span> <span class="toctext">Sets</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Multisets"><span class="tocnumber">2.2</span> <span class="toctext">Multisets</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Associative_arrays"><span class="tocnumber">2.3</span> <span class="toctext">Associative arrays</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Trees"><span class="tocnumber">3.1</span> <span class="toctext">Trees</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Linear_collections">Linear collections</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=1" title="Edit section: Linear collections">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Many collections behave as if they are storing data in a line, ordered in some way, with access to one or both ends. The actual data structure implementing such a collection need not be linear – for example, a priority queue is often implemented as a heap, which is a kind of tree. Important such collections include:</p>
<ul>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Array_data_type" title="Array data type">Array</a></li>
<li><a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">Stack</a> (FILO, LIFO)</li>
<li><a href="/wiki/Queue_(abstract_data_type)" title="Queue (abstract data type)">Queue</a> (FIFO, LILO)</li>
<li><a href="/wiki/Priority_queue" title="Priority queue">Priority queue</a> (often implemented as a <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a>)</li>
<li><a href="/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queue</a> (deque)</li>
<li><a href="/wiki/Double-ended_priority_queue" title="Double-ended priority queue">Double-ended priority queue</a> (DEPQ)</li>
</ul>
<h3><span class="mw-headline" id="Lists">Lists</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=2" title="Edit section: Lists">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a <b>list</b>, the order of data items is significant. Duplicate data items are permitted. Examples of operations on lists are searching for an item in the list and determining its location (if it is present), removing an item from the list, adding an item at a specific location, etc. If the principal operations on the list are to be the addition of items at one end and the removal of items at the other, it will generally be called a <a href="/wiki/Queue_(data_structure)" title="Queue (data structure)" class="mw-redirect">queue</a> or <a href="/wiki/FIFO" title="FIFO">FIFO</a>. If the principal operations are the addition and removal of items at just one end, it will be called a <a href="/wiki/Stack_(data_structure)" title="Stack (data structure)" class="mw-redirect">stack</a> or <a href="/wiki/LIFO_(computing)" title="LIFO (computing)">LIFO</a>. In both cases, items are maintained within the collection in the same order (unless they are removed and re-inserted somewhere else) and so these are special cases of the list collection. Other specialized operations on lists include sorting, where, again, the order of items is of great importance.</p>
<h3><span class="mw-headline" id="Priority_queues">Priority queues</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=3" title="Edit section: Priority queues">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Also called heaps, keep track of the 'minimum' or 'maximum' element in the collection, according to some ordering criterion. The ordering of other elements does not matter. One may think of a priority queue as a list that always keeps the minimum or maximum at the head, while the remaining elements are kept in a bag.</p>
<h2><span class="mw-headline" id="Associative_collections">Associative collections</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=4" title="Edit section: Associative collections">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Other collections can instead be interpreted as sort of function: given an input "key", the collection yields an output value. Important examples are sets, multisets, and associative arrays. A set can be interpreted as a specialized multiset, which in turn is a specialized map, in each case by limiting the possible values – considering a set as represented by its <a href="/wiki/Indicator_function" title="Indicator function">indicator function</a>.</p>
<h3><span class="mw-headline" id="Sets">Sets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=5" title="Edit section: Sets">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In a <a href="/wiki/Set_(computer_science)" title="Set (computer science)" class="mw-redirect">set</a>, the order of data items is of no consequence, but duplicate items are not permitted. Examples of operations on sets are the addition and removal of items and searching for an item in the set. Some languages support sets directly. In others, sets can be implemented by a <a href="/wiki/Hash_table" title="Hash table">hash table</a> with dummy values; only the keys are used in representing the set.</p>
<h3><span class="mw-headline" id="Multisets">Multisets</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=6" title="Edit section: Multisets">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A "bag" or <a href="/wiki/Multiset_(abstract_data_type)" title="Multiset (abstract data type)" class="mw-redirect">multiset</a>, is like a set – the order of data items is of no consequence. But in this case, duplicate items are permitted. Examples of operations on bags are the addition and removal of items and determining how many of a particular item are present in the bag. Bags can be transformed into lists by the action of sorting.</p>
<h3><span class="mw-headline" id="Associative_arrays">Associative arrays</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=7" title="Edit section: Associative arrays">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An <a href="/wiki/Associative_array" title="Associative array">associative array</a> ("map", "dictionary", "lookup table") acts like a dictionary, providing a "value" (like a definition) in response to a lookup on a "key" (like a word). The "value" might be a reference to a compound data structure. A <a href="/wiki/Hash_table" title="Hash table">hash table</a> is usually an efficient implementation, and thus this data type is often known as a "hash".</p>
<h2><span class="mw-headline" id="Graphs">Graphs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=8" title="Edit section: Graphs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In a <b>graph</b>, data items have associations with one or more other data items in the collection and are somewhat like trees without the concept of a root or the parent-child relationship so that all data items are peers. Examples of operations on graphs are traversals and searches which explore the associations of data items looking for some specific property. Graphs are frequently used to model real-world situations and to solve related problems. An example is the <a href="/wiki/Spanning_tree_protocol" title="Spanning tree protocol" class="mw-redirect">Spanning tree protocol</a>, which creates a graph (or mesh) representation of a data network and figures out which associations between switching nodes need to be broken to turn it into a tree and thus prevent data going around in loops.</p>
<h3><span class="mw-headline" id="Trees">Trees</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=9" title="Edit section: Trees">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A special kind of graph is a tree. In a <b>tree</b>, a 'root' data item has associated with it some number of data items which in turn have associated with them some number of other items in what is frequently viewed as parent-child relationships. Every item (other than the root) has a single parent (the root has no parent) and some number of children, possibly zero. Examples of operations on trees are the addition of data items so as to maintain a specific property of the tree to perform sorting, etc. and traversals to visit data items in a specific sequence.</p>
<p>Tree collections can be used to naturally store hierarchical data, which is presented in a tree-like manner, such as menu systems and files in directories on a data storage system.</p>
<p>Specialized trees are used in various algorithms. For example, the <a href="/wiki/Heap_sort" title="Heap sort" class="mw-redirect">heap sort</a> uses a kind of tree called a <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a>.</p>
<h2><span class="mw-headline" id="Abstract_concept_vs._implementation">Abstract concept vs. implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=10" title="Edit section: Abstract concept vs. implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>As described here, a collection and the various kinds of collections are abstract concepts. There exists in the literature considerable confusion between the abstract concepts of computer science and their specific implementations in various languages or kinds of languages. Assertions that collections, lists, sets, trees, etc. are data structures, abstract data types or classes must be read with this in mind. Collections are first and foremost abstractions that are useful in formulating solutions to computing problems. Viewed in this light, they retain important links to underlying mathematical concepts which can be lost when the focus is on the implementation.</p>
<p>For example, a priority queue is often implemented as a heap, while an associative array is often implemented as a hash table, so these abstract types are often referred to by this preferred implementation, as a "heap" or a "hash", though this is not strictly correct.</p>
<h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=11" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some collections may be <a href="/wiki/Primitive_data_type" title="Primitive data type">primitive data types</a> in a language, such as lists, while more complex collections are implemented as <a href="/wiki/Composite_data_type" title="Composite data type">composite data types</a> in libraries, sometimes in the <a href="/wiki/Standard_library" title="Standard library">standard library</a>. Examples include:</p>
<ul>
<li>C++: known as <a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Container</a> (see article for details), implemented in <a href="/wiki/C%2B%2B_Standard_Library" title="C++ Standard Library">C++ Standard Library</a> and earlier <a href="/wiki/Standard_Template_Library" title="Standard Template Library">Standard Template Library</a></li>
<li>Java: implemented in the <a href="/wiki/Java_collections_framework" title="Java collections framework">Java collections framework</a></li>
<li>Python: some built-in, others implemented in the <a rel="nofollow" class="external text" href="https://docs.python.org/3/library/collections.html">collections</a> library</li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Collection_(abstract_data_type)&amp;action=edit&amp;section=12" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://commons.apache.org/collections/">Apache Commons Collections</a></li>
<li><a rel="nofollow" class="external text" href="http://sibirjak.com/osflash/projects/as3commons-collections/">AS3Commons Collections Framework</a> ActionScript3 implementation of the most common collections.</li>
<li><a rel="nofollow" class="external text" href="http://www.collectionspy.com">CollectionSpy</a> — A profiler for Java's Collections Framework.</li>
<li><a rel="nofollow" class="external text" href="http://code.google.com/p/guava-libraries/">Guava</a></li>
<li><a rel="nofollow" class="external text" href="http://jezuk.co.uk/cgi-bin/view/mango">Mango Java library</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Data_structures" title="Template:Data structures"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Data_structures" title="Template talk:Data structures"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Data_structures&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><strong class="selflink">Collection</strong></li>
<li><a href="/wiki/Container_(abstract_data_type)" title="Container (abstract data type)">Container</a></li>
</ul>
<ul>
<li><a href="/wiki/Associative_array" title="Associative array">Associative array</a></li>
<li><a href="/wiki/Double-ended_priority_queue" title="Double-ended priority queue">Double-ended priority queue</a></li>
<li><a href="/wiki/Double-ended_queue" title="Double-ended queue">Double-ended queue</a></li>
<li><a href="/wiki/List_(abstract_data_type)" title="List (abstract data type)">List</a></li>
<li><a href="/wiki/Associative_array" title="Associative array">Map</a></li>
<li><a href="/wiki/Multimap" title="Multimap">Multimap</a></li>
<li><a href="/wiki/Priority_queue" title="Priority queue">Priority queue</a></li>
<li><a href="/wiki/Queue_(abstract_data_type)" title="Queue (abstract data type)">Queue</a></li>
<li><a href="/wiki/Set_(abstract_data_type)" title="Set (abstract data type)">Set</a>
<ul>
<li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">multiset</a></li>
</ul>
</li>
<li><a href="/wiki/Disjoint-set_data_structure" title="Disjoint-set data structure">Disjoint Sets</a></li>
<li><a href="/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">Stack</a></li>
</ul>
<ul>
<li><a href="/wiki/Set_(abstract_data_type)#Multiset" title="Set (abstract data type)">multiset</a></li>
</ul>
<ul>
<li><a href="/wiki/Bit_array" title="Bit array">Bit array</a></li>
<li><a href="/wiki/Circular_buffer" title="Circular buffer">Circular buffer</a></li>
<li><a href="/wiki/Dynamic_array" title="Dynamic array">Dynamic array</a></li>
<li><a href="/wiki/Hash_table" title="Hash table">Hash table</a></li>
<li><a href="/wiki/Hashed_array_tree" title="Hashed array tree">Hashed array tree</a></li>
<li><a href="/wiki/Sparse_array" title="Sparse array">Sparse array</a></li>
</ul>
<ul>
<li><a href="/wiki/Association_list" title="Association list">Association list</a></li>
<li><a href="/wiki/Linked_list" title="Linked list">Linked list</a></li>
<li><a href="/wiki/Skip_list" title="Skip list">Skip list</a></li>
<li><a href="/wiki/Unrolled_linked_list" title="Unrolled linked list">Unrolled linked list</a></li>
<li><a href="/wiki/XOR_linked_list" title="XOR linked list">XOR linked list</a></li>
</ul>
<ul>
<li><a href="/wiki/B-tree" title="B-tree">B-tree</a></li>
<li><a href="/wiki/Binary_search_tree" title="Binary search tree">Binary search tree</a>
<ul>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">red-black</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">splay</a></li>
</ul>
</li>
<li><a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">Heap</a>
<ul>
<li><a href="/wiki/Binary_heap" title="Binary heap">binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">binomial</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
</ul>
</li>
<li><a href="/wiki/R-tree" title="R-tree">R-tree</a>
<ul>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert</a></li>
</ul>
</li>
<li><a href="/wiki/Trie" title="Trie">Trie</a>
<ul>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/AA_tree" title="AA tree">AA</a></li>
<li><a href="/wiki/AVL_tree" title="AVL tree">AVL</a></li>
<li><a href="/wiki/Red%E2%80%93black_tree" title="Red–black tree">red-black</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing</a></li>
<li><a href="/wiki/Splay_tree" title="Splay tree">splay</a></li>
</ul>
<ul>
<li><a href="/wiki/Binary_heap" title="Binary heap">binary</a></li>
<li><a href="/wiki/Binomial_heap" title="Binomial heap">binomial</a></li>
<li><a href="/wiki/Fibonacci_heap" title="Fibonacci heap">Fibonacci</a></li>
</ul>
<ul>
<li><a href="/wiki/R*_tree" title="R* tree">R*</a></li>
<li><a href="/wiki/R%2B_tree" title="R+ tree">R+</a></li>
<li><a href="/wiki/Hilbert_R-tree" title="Hilbert R-tree">Hilbert</a></li>
</ul>
<ul>
<li><a href="/wiki/Hash_tree_(persistent_data_structure)" title="Hash tree (persistent data structure)">Hash tree</a></li>
</ul>
<ul>
<li><a href="/wiki/Binary_decision_diagram" title="Binary decision diagram">Binary decision diagram</a></li>
<li><a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">Directed acyclic graph</a></li>
<li><a href="/wiki/Directed_acyclic_word_graph" title="Directed acyclic word graph">Directed acyclic word graph</a></li>
</ul>
<ul>
<li><a href="/wiki/List_of_data_structures" title="List of data structures">List of data structures</a></li>
</ul>
