<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Finalizer</span></h1>
<p>In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, a <b>finalizer</b> or <b>finalize method</b> is a special <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> that performs <a href="/wiki/Finalization" title="Finalization">finalization</a>, generally some form of cleanup. A finalizer is executed during <a href="/wiki/Object_destruction" title="Object destruction" class="mw-redirect">object destruction</a>, prior to the object being <a href="/wiki/Deallocation" title="Deallocation" class="mw-redirect">deallocated</a>, and is complementary to an <a href="/wiki/Initializer" title="Initializer" class="mw-redirect">initializer</a>, which is executed during <a href="/wiki/Object_creation" title="Object creation" class="mw-redirect">object creation</a>, following <a href="/wiki/Memory_allocation" title="Memory allocation" class="mw-redirect">allocation</a>. Finalizers are strongly discouraged by many, due to difficulty in proper use and the complexity they add, and alternatives are suggested instead, primarily the <a href="/wiki/Dispose_pattern" title="Dispose pattern">dispose pattern</a><sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> – see <a href="#Problems">problems with finalizers</a>.</p>
<p>The term "finalizer" is primarily used in <a href="/wiki/Object-oriented_language" title="Object-oriented language" class="mw-redirect">object-oriented languages</a> that use <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">garbage collection</a>, of which the archetype is <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>. This is contrasted with a "<a href="/wiki/Destructor_(computer_science)" title="Destructor (computer science)" class="mw-redirect">destructor</a>", which is a method called for finalization in languages with deterministic object lifetimes, archetypically <a href="/wiki/C%2B%2B" title="C++">C++</a>.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup><sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> These are generally exclusive – a language will have either finalizers (if garbage collected) or destructors (if deterministic), but in rare cases a language may have both, as in <a href="/wiki/C%2B%2B/CLI" title="C++/CLI">C++/CLI</a>, and in case of <a href="/wiki/Reference_counting" title="Reference counting">reference counting</a> (instead of tracing garbage collection), terminology varies. In technical usage, "finalizer" may also be used to refer to destructors, as these also perform finalization, and some subtler distinctions are drawn – see <a href="#Terminology">terminology</a>. For this article, "finalizer" refers only to a method used for finalization in a garbage-collected language; for discussion of finalization generally, see <a href="/wiki/Finalization" title="Finalization">finalization</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Use"><span class="tocnumber">1</span> <span class="toctext">Use</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Resource_management"><span class="tocnumber">2</span> <span class="toctext">Resource management</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Problems"><span class="tocnumber">3</span> <span class="toctext">Problems</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Syntax"><span class="tocnumber">4</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Implementation"><span class="tocnumber">5</span> <span class="toctext">Implementation</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Terminology"><span class="tocnumber">6</span> <span class="toctext">Terminology</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Use">Use</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=1" title="Edit section: Use">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Finalizers are generally used to perform some form of cleanup, similar to destructors, but differ in that destructors are executed deterministically, while finalizers are executed at the discretion of the garbage collector, which is usually not deterministic. However, a finalizer can include arbitrary code; a particularly complex use is to automatic return the object to an <a href="/wiki/Object_pool" title="Object pool" class="mw-redirect">object pool</a>.</p>
<p>Finalizers are generally both much less necessary and much less used than destructors. They are much less necessary because garbage collection automates <a href="/wiki/Memory_management" title="Memory management">memory management</a>, and much less used because they are not generally executed deterministically – they may not be called in a timely manner, or even at all, and the execution environment cannot be predicted – and thus any cleanup that must be done in a deterministic way must instead be done by some other method, most frequently manually via the <a href="/wiki/Dispose_pattern" title="Dispose pattern">dispose pattern</a>. Notably, both Java and Python do not guarantee that finalizers will ever be called, and thus they cannot be relied on for cleanup.</p>
<p>Due to the lack of programmer control over their execution, it is usually recommended to avoid finalizers for any but the most trivial operations. In particular, operations often performed in destructors are not usually appropriate for finalizers. A common <a href="/wiki/Anti-pattern" title="Anti-pattern">anti-pattern</a> is to write finalizers as if they were destructors, which is both unnecessary and ineffectual, due to differences between finalizers and destructors. This is particularly common among <a href="/wiki/C%2B%2B" title="C++">C++</a> programmers, as destructors are heavily used in idiomatic C++, following the <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a> (RAII) idiom.</p>
<h2><span class="mw-headline" id="Resource_management">Resource management</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=2" title="Edit section: Resource management">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A common <a href="/wiki/Anti-pattern" title="Anti-pattern">anti-pattern</a> is to use finalizers to release resources, by analogy with the <a href="/wiki/Resource_Acquisition_Is_Initialization" title="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a> (RAII) idiom of C++: acquire a resource in the initializer (constructor), and release it in the finalizer (destructor). This does not work, for a number of reasons. Most basically, finalizers may never be called, and even if called, may not be called in a timely manner – thus using finalizers to release resources will generally cause <a href="/wiki/Resource_leak" title="Resource leak">resource leaks</a>. Further, finalizers are not called in a prescribed order, while resources often need to be released in a specific order, frequently the opposite order in which they were acquired. Also, as finalizers are called at the discretion of the garbage collector, they will often only be called under managed memory pressure (when there is little managed memory available), regardless of resource pressure – if scarce resources are held by garbage but there is plenty of managed memory available, garbage collection may not occur, thus not reclaiming these resources.</p>
<p>Thus instead of using finalizers for automatic resource management, in garbage-collected languages one instead must manually manage resources, generally by using the <a href="/wiki/Dispose_pattern" title="Dispose pattern">dispose pattern</a>. In this case resources may still be acquired in the initializer, which is called explicitly on object instantiation, but are released in the dispose method. The dispose method may be called explicitly, or implicitly by language constructs such as C#'s <code>using</code>, Java's <code>try</code>-with-resources, or Python's <code>with</code>.</p>
<p>However, in certain cases both the dispose pattern and finalizers are used for releasing resources. This is primarily found in CLR languages such as C#, where finalization is used as a backup for disposal: when a resource is acquired, the acquiring object is queued for finalization so that the resource is released on object destruction, even if the resource is not released by manual disposal.</p>
<h2><span class="mw-headline" id="Problems">Problems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=3" title="Edit section: Problems">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Finalizers can cause a significant number of problems, and are thus strongly discouraged by a number of authorities.<sup id="cite_ref-certjava_4-0" class="reference"><a href="#cite_note-certjava-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup> These problems include:<sup id="cite_ref-certjava_4-1" class="reference"><a href="#cite_note-certjava-4"><span>[</span>4<span>]</span></a></sup></p>
<ul>
<li>Finalizers may not be called in a timely manner, hence causing long-lasting resource leaks.</li>
<li>Finalizers may never be called, hence they cannot be relied upon to persist state.</li>
<li>Finalizers may result in <a href="/wiki/Object_resurrection" title="Object resurrection">object resurrection</a>, which is often a programming error and whose very possibility significantly slows down and complicates garbage collection.</li>
<li>Finalizers are run based on garbage collection, which is generally based on managed memory pressure – they are not run in case of other resource scarcity, and thus are not suited for managing other scarce resources.</li>
<li>Finalizers do not run in a specified order, and cannot rely on <a href="/wiki/Class_invariant" title="Class invariant">class invariants</a> (as they may refer to other objects that have already been finalized).</li>
<li>Slow finalizers may delay other finalizers.</li>
<li>Exceptions within finalizers generally cannot be handled, because the finalizer is run in an unspecified environment, and may be either ignored or cause uncontrolled program termination.</li>
<li>Finalizers may reference and accidentally finalize live objects, violating program invariants.</li>
<li>Finalizers may cause synchronization issue, even in otherwise sequential (single-threaded) programs, as finalization may be done concurrently (concretely, in one or more separate threads).<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></li>
<li>Finalizers may cause deadlock if synchronization mechanisms such as locks are used, due to not being run in a specified order and possibly being run concurrently.</li>
<li>Finalizers that are run during program termination cannot rely on the usual runtime environment, and thus may fail due to incorrect assumptions – for this reason finalizers are often not run during termination.</li>
</ul>
<p>Further, finalizers may fail to run due to object remaining reachable beyond when they are expected to be garbage, either due to programming errors or due to unexpected reachability. For example, when Python catches an exception (or an exception is not caught in interactive mode), it keeps a reference to the stack frame where the exception was raised, which keeps objects referenced from that stack frame alive.</p>
<p>Finalizers in a superclass can also slow down garbage collection in a subclass, as the finalizer can potentially refer to fields in the subclass, and thus the field cannot be garbage collected until the following cycle, once the finalizer has run.<sup id="cite_ref-certjava_4-2" class="reference"><a href="#cite_note-certjava-4"><span>[</span>4<span>]</span></a></sup> This can be avoided by using <a href="/wiki/Composition_over_inheritance" title="Composition over inheritance">composition over inheritance</a>.</p>
<h2><span class="mw-headline" id="Syntax">Syntax</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=4" title="Edit section: Syntax">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Programming languages that use finalizers include <a href="/wiki/C%2B%2B/CLI" title="C++/CLI">C++/CLI</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, and <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>. Syntax varies significantly by language.</p>
<p>In Java a finalizer is a method called <code>finalize</code>, which overrides the <code>Object.finalize</code> method.<sup id="cite_ref-java_Object.finalize_7-0" class="reference"><a href="#cite_note-java_Object.finalize-7"><span>[</span>7<span>]</span></a></sup></p>
<p>In Python, a finalizer is a method called <code>__del__</code>.</p>
<p>In C#, a finalizer (called "destructor" in earlier versions of the standard) is a method whose name is the class name with <code>~</code> prefixed, as in <code>~Foo</code> – this is the same syntax as C++, and these methods were originally called "destructors", by analogy with C++, despite having different behavior, but were renamed to "finalizers" due to the confusion this caused.<sup id="cite_ref-csharpname_8-0" class="reference"><a href="#cite_note-csharpname-8"><span>[</span>8<span>]</span></a></sup></p>
<p>In C++/CLI, which has both destructors and finalizers, a destructor is a method whose name is the class name with <code>~</code> prefixed, as in <code>~Foo</code> (as in C++), and a finalizer is a method whose name is the class name with <code>!</code> prefixed, as in <code>!Foo</code>.</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=5" title="Edit section: Implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A finalizer is called when an <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> is garbage collected – after an object has become garbage (unreachable), but before its memory is deallocated. Finalization occurs non-deterministically, at the discretion of the garbage collector, and might never occur. This contrasts with destructors, which are called deterministically as soon as an object is no longer in use, and are always called, except in case of uncontrolled program termination. Finalizers are most frequently <a href="/wiki/Instance_method" title="Instance method" class="mw-redirect">instance methods</a>, due to needing to do object-specific operations.</p>
<p>The garbage collector must also account for the possibility of object resurrection. Most commonly this is done by first executing finalizers, then checking whether any objects have been resurrected, and if so, aborting their destruction. This additional check is potentially expensive – a simple implementation re-checks all garbage if even a single object has a finalizer – and thus both slows down and complicates garbage collection. For this reason, objects with finalizers may be collected less frequently than objects without finalizers (only on certain cycles), exacerbating problems caused by relying on prompt finalization, such as resource leaks.</p>
<p>If an object is resurrected, there is the further question of whether its finalizer is called again, when it is next destroyed – unlike destructors, finalizers are potentially called multiple times. If finalizers are called for resurrected objects, objects may repeatedly resurrect themselves and be indestructible; this occurs in the CPython implementation of Python prior to Python 3.4, and in CLR languages such as C#. To avoid this, in many languages, including Java, Objective-C (at least in recent Apple implementations), and Python from Python 3.4, objects are finalized at most once, which requires tracking if the object has been finalized yet.</p>
<p>In other cases, notably CLR languages like C#, finalization is tracked separately from the objects themselves, and objects can be repeatedly registered or deregistered for finalization.</p>
<h2><span class="mw-headline" id="Terminology">Terminology</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=6" title="Edit section: Terminology">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The terminology of "finalizer" and "finalization" versus "destructor" and "destruction" varies between authors and is sometimes unclear.</p>
<p>In common usage, a <i>destructor</i> is a method called deterministically on object destruction, and the archetype is C++ destructors; while a finalizer is called non-deterministically by the garbage collector, and the archetype is Java <code>finalize</code> methods.</p>
<p>For languages that implement garbage collection via <a href="/wiki/Reference_counting" title="Reference counting">reference counting</a>, terminology varies, with some languages such as <a href="/wiki/Objective-C" title="Objective-C">Objective-C</a> and Perl using "destructor", and other languages such as Python using "finalizer" (per spec, Python is garbage collected, but the reference <a href="/wiki/CPython" title="CPython">CPython</a> implementation uses reference counting). This reflects the fact that reference counting results in semi-deterministic object lifetime: for objects that are not part of a cycle, objects are destroyed deterministically when the reference count drops to zero, but objects that are part of a cycle are destroyed non-deterministically, as part of a separate form of garbage collection.</p>
<p>In certain narrow technical usage, "constructor" and "destructor" are language-level terms, meaning "methods defined in a class", while "initializer" and "finalizer" are implementation-level terms, meaning "methods called during object creation or destruction". Thus for example the original specification for the C# language referred to "destructors", even though C# is garbage-collected, but the specification for the <a href="/wiki/Common_Language_Infrastructure" title="Common Language Infrastructure">Common Language Infrastructure</a> (CLI), and the implementation of its runtime environment as the <a href="/wiki/Common_Language_Runtime" title="Common Language Runtime">Common Language Runtime</a> (CLR), referred to "finalizers". This is reflected in the C# language committee's notes, which read in part: "The C# compiler compiles destructors to ... [probably] instance finalizer[s]".<sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup><sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup> This terminology is confusing, and thus more recent versions of the C# spec refer to the language-level method as "finalizers".<sup id="cite_ref-csharpname_8-1" class="reference"><a href="#cite_note-csharpname-8"><span>[</span>8<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">Garbage collection</a>, specifically the section on <a href="/wiki/Garbage_collection_(computer_science)#Determinism" title="Garbage collection (computer science)">Determinism</a></li>
<li><a href="/wiki/Object_lifetime" title="Object lifetime">Object lifetime</a></li>
<li><a href="/wiki/Initialization_(programming)" title="Initialization (programming)">Initialization</a> Process &amp; related Initializer Pattern</li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><a href="#CITEREFJaggerPerrySestoft2007">Jagger, Perry &amp; Sestoft 2007</a>, p. <a rel="nofollow" class="external text" href="http://books.google.com/books?id=g6axWRRpJZwC&amp;pg=PA542&amp;dq=destructor+finalizer#v=onepage">542</a></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><i><a href="/wiki/Design_Patterns" title="Design Patterns">Design Patterns</a>,</i> (1994), "<b>destructor</b> In C++, an operation that is automatically invoked to finalize an object that is about to be deleted."</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><a href="#CITEREFJaggerPerrySestoft2007">Jagger, Perry &amp; Sestoft 2007</a>, p. <a rel="nofollow" class="external text" href="http://books.google.com/books?id=g6axWRRpJZwC&amp;pg=PA542&amp;dq=destructor+finalizer#v=onepage">542</a></span></li>
<li id="cite_note-certjava-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-certjava_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-certjava_4-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-certjava_4-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">"<a rel="nofollow" class="external text" href="https://www.securecoding.cert.org/confluence/display/java/MET12-J.+Do+not+use+finalizers">MET12-J. Do not use finalizers</a>", Dhruv Mohindra, <a rel="nofollow" class="external text" href="https://www.securecoding.cert.org/confluence/display/java">The CERT Oracle Secure Coding Standard for Java</a>, <a rel="nofollow" class="external text" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18580918">05. Methods (MET)</a></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="https://docs.python.org/3/reference/datamodel.html#object.__del__">object.__del__(self)</a>, <i><a rel="nofollow" class="external text" href="https://docs.python.org/3/reference/">The Python Language Reference</a>,</i> <a rel="nofollow" class="external text" href="https://docs.python.org/3/reference/datamodel.html">3. Data model</a>: "... <code>__del__()</code> methods should do the absolute minimum needed to maintain external invariants."</span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Hans-J. Boehm, Finalization, Threads, and the Java™ Technology-Based Memory Model, JavaOne Conference, 2005.</span></li>
<li id="cite_note-java_Object.finalize-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-java_Object.finalize_7-0">^</a></b></span> <span class="reference-text">java.lang, Class Object: <a rel="nofollow" class="external text" href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#finalize()">finalize</a></span></li>
<li id="cite_note-csharpname-8"><span class="mw-cite-backlink">^ <a href="#cite_ref-csharpname_8-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-csharpname_8-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a href="#CITEREFJaggerPerrySestoft2007">Jagger, Perry &amp; Sestoft 2007</a>, p. <a rel="nofollow" class="external text" href="http://books.google.com/books?id=g6axWRRpJZwC&amp;pg=PA542&amp;dq=destructor+finalizer#v=onepage">542</a></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text">In full: "We're going to use the term "destructor" for the member which executes when an instance is reclaimed. Classes can have destructors; structs can't. Unlike in C++, a destructor cannot be called explicitly. Destruction is non-deterministic – you can't reliably know when the destructor will execute, except to say that it executes at some point after all references to the object have been released. The destructors in an inheritance chain are called in order, from most descendant to least descendant. There is no need (and no way) for the derived class to explicitly call the base destructor. The C# compiler compiles destructors to the appropriate CLR representation. For this version that probably means an instance finalizer that is distinguished in metadata. CLR may provide static finalizers in the future; we do not see any barrier to C# using static finalizers.", May 12th, 1999.</span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://blogs.msdn.com/b/ericlippert/archive/2010/01/21/what-s-the-difference-between-a-destructor-and-a-finalizer.aspx">What’s the difference between a destructor and a finalizer?</a>, Eric Lippert, <i>Eric Lippert’s Blog: Fabulous Adventures In Coding,</i> 21 Jan 2010</span></li>
</ol>
<ul>
<li><span class="citation book">Jagger, Jon; Perry, Nigel; Sestoft, Peter (2007). <a rel="nofollow" class="external text" href="http://www.elsevier.com/books/annotated-c-standard/jagger/978-0-12-372511-0"><i>Annotated C# Standard</i></a>. Morgan Kaufmann. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-12-372511-0" title="Special:BookSources/978-0-12-372511-0">978-0-12-372511-0</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AFinalizer&amp;rft.aufirst=Jon&amp;rft.au=Jagger%2C+Jon&amp;rft.aulast=Jagger&amp;rft.au=Perry%2C+Nigel&amp;rft.au=Sestoft%2C+Peter&amp;rft.btitle=Annotated+C%23+Standard&amp;rft.date=2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.elsevier.com%2Fbooks%2Fannotated-c-standard%2Fjagger%2F978-0-12-372511-0&amp;rft.isbn=978-0-12-372511-0&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_isbn/978012372511&amp;action=edit">edit</a></span></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Finalizer&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>"<a rel="nofollow" class="external text" href="http://c2.com/cgi/wiki?FinalizeInsteadOfProperDestructor">Finalize Instead Of Proper Destructor</a>", <i><a href="/wiki/WikiWikiWeb" title="WikiWikiWeb">WikiWikiWeb</a></i> – comparison of Java finalizers with C++ destructors</li>
</ul>
