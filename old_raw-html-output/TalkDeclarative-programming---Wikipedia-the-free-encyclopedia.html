<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Talk:Declarative programming</span></h1>
<ul>
<li class="nv-view"><a href="/wiki/Template:WikiProject_Computing" title="Template:WikiProject Computing"><span title="View this template" style="">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:WikiProject_Computing" title="Template talk:WikiProject Computing"><span title="Discuss this template" style="">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:WikiProject_Computing&amp;action=edit"><span title="Edit this template" style="">e</span></a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:WikiProject_Computer_science" title="Template:WikiProject Computer science"><span title="View this template" style="">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:WikiProject_Computer_science" title="Template talk:WikiProject Computer science"><span title="Discuss this template" style="">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:WikiProject_Computer_science&amp;action=edit"><span title="Edit this template" style="">e</span></a></li>
</ul>
<ul>
<li><small><a class="external text" href="//en.wikipedia.org/w/index.php?title=Wikipedia_talk:WikiProject_Computer_science/to_do&amp;action=edit">edit</a></small></li>
<li><small><a class="external text" href="//en.wikipedia.org/w/index.php?title=Wikipedia_talk:WikiProject_Computer_science/to_do&amp;action=history">history</a></small></li>
<li><small><a class="external text" href="//en.wikipedia.org/w/index.php?title=Wikipedia_talk:WikiProject_Computer_science/to_do&amp;action=watch">watch</a></small></li>
<li><small><a class="external text" href="//en.wikipedia.org/w/index.php?title=Talk:Declarative_programming&amp;action=purge">purge</a></small></li>
</ul>
<ul style="font-size:100%;margin:0;padding:0.3em 0 0.3em 25px;">
<li><b><i><a href="/wiki/Wikipedia:Requested_articles" title="Wikipedia:Requested articles">Article requests</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Wikipedia:Requested_articles/Applied_arts_and_sciences/Computer_science,_computing,_and_Internet" title="Wikipedia:Requested articles/Applied arts and sciences/Computer science, computing, and Internet">Requested articles/Applied arts and sciences/Computer science, computing, and Internet</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Cleanup" title="Wikipedia:Cleanup">Cleanup</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Category:Computer_science_articles_needing_attention" title="Category:Computer science articles needing attention">Computer science articles needing attention</a></li>
<li><a href="/wiki/Category:Computer_science_articles_needing_expert_attention" title="Category:Computer science articles needing expert attention">Computer science articles needing expert attention</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Collaborations" title="Wikipedia:Collaborations">Collaborate</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Category:Computer_science_COTW_candidates" title="Category:Computer science COTW candidates">Computer science COTW candidates</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:How_to_copy-edit" title="Wikipedia:How to copy-edit" class="mw-redirect">Copyedit</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Computing" title="Computing">Computing</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Writing_better_articles" title="Wikipedia:Writing better articles">Expand</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Computer_science" title="Computer science">Computer science</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Manual_of_Style_(infoboxes)" title="Wikipedia:Manual of Style (infoboxes)" class="mw-redirect">Infobox</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Category:Computer_science_articles_without_infoboxes" title="Category:Computer science articles without infoboxes">Computer science articles without infoboxes</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Maintenance" title="Wikipedia:Maintenance">Maintain</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Portal:Computer_science" title="Portal:Computer science">Portal:Computer science</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Requested_pictures" title="Wikipedia:Requested pictures">Photo</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li>Find pictures for the biographies of computer scientists (see <a href="/wiki/Academic_genealogy_of_computer_scientists" title="Academic genealogy of computer scientists">Academic genealogy of computer scientists</a>)</li>
<li><a href="/wiki/Category:Computing_articles_needing_images" title="Category:Computing articles needing images">Computing articles needing images</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Stub" title="Wikipedia:Stub">Stubs</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Category:Computer_science_stubs" title="Category:Computer science stubs">Computer science stubs</a></li>
</ul>
</div>
</li>
<li><b><i><a href="/wiki/Wikipedia:Unreferenced" title="Wikipedia:Unreferenced" class="mw-redirect">Unreferenced</a></i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li><a href="/wiki/Wikipedia:WikiProject_Computer_science/Unreferenced_BLPs" title="Wikipedia:WikiProject Computer science/Unreferenced BLPs">WikiProject Computer science/Unreferenced BLPs</a></li>
</ul>
</div>
</li>
<li><b><i>Project-related</i><span class="Unicode"> </span>:</b>
<div>
<ul>
<li>Tag all relevant articles in <a href="/wiki/Category:Computer_science" title="Category:Computer science">Category:Computer science</a> and sub-categories with {{<a href="/wiki/Template:WikiProject_Computer_science" title="Template:WikiProject Computer science">WikiProject Computer science</a>}}</li>
</ul>
</div>
</li>
</ul>
<ul>
<li><a href="/wiki/Wikipedia:Requested_articles/Applied_arts_and_sciences/Computer_science,_computing,_and_Internet" title="Wikipedia:Requested articles/Applied arts and sciences/Computer science, computing, and Internet">Requested articles/Applied arts and sciences/Computer science, computing, and Internet</a></li>
</ul>
<ul>
<li><a href="/wiki/Category:Computer_science_articles_needing_attention" title="Category:Computer science articles needing attention">Computer science articles needing attention</a></li>
<li><a href="/wiki/Category:Computer_science_articles_needing_expert_attention" title="Category:Computer science articles needing expert attention">Computer science articles needing expert attention</a></li>
</ul>
<ul>
<li><a href="/wiki/Category:Computer_science_COTW_candidates" title="Category:Computer science COTW candidates">Computer science COTW candidates</a></li>
</ul>
<ul>
<li><a href="/wiki/Computing" title="Computing">Computing</a></li>
</ul>
<ul>
<li><a href="/wiki/Computer_science" title="Computer science">Computer science</a></li>
</ul>
<ul>
<li><a href="/wiki/Category:Computer_science_articles_without_infoboxes" title="Category:Computer science articles without infoboxes">Computer science articles without infoboxes</a></li>
</ul>
<ul>
<li><a href="/wiki/Portal:Computer_science" title="Portal:Computer science">Portal:Computer science</a></li>
</ul>
<ul>
<li>Find pictures for the biographies of computer scientists (see <a href="/wiki/Academic_genealogy_of_computer_scientists" title="Academic genealogy of computer scientists">Academic genealogy of computer scientists</a>)</li>
<li><a href="/wiki/Category:Computing_articles_needing_images" title="Category:Computing articles needing images">Computing articles needing images</a></li>
</ul>
<ul>
<li><a href="/wiki/Category:Computer_science_stubs" title="Category:Computer science stubs">Computer science stubs</a></li>
</ul>
<ul>
<li><a href="/wiki/Wikipedia:WikiProject_Computer_science/Unreferenced_BLPs" title="Wikipedia:WikiProject Computer science/Unreferenced BLPs">WikiProject Computer science/Unreferenced BLPs</a></li>
</ul>
<ul>
<li>Tag all relevant articles in <a href="/wiki/Category:Computer_science" title="Category:Computer science">Category:Computer science</a> and sub-categories with {{<a href="/wiki/Template:WikiProject_Computer_science" title="Template:WikiProject Computer science">WikiProject Computer science</a>}}</li>
</ul>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Dead_link"><span class="tocnumber">1</span> <span class="toctext">Dead link</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Business_Rules_Link"><span class="tocnumber">2</span> <span class="toctext">Business Rules Link</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#declarative_program_is_not_Turing-complete"><span class="tocnumber">3</span> <span class="toctext">declarative program is not Turing-complete</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Makefiles:_imperative"><span class="tocnumber">4</span> <span class="toctext">Makefiles: imperative</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Limitations_of_declarative_languages_.28with_citations.29"><span class="tocnumber">5</span> <span class="toctext">Limitations of declarative languages (with citations)</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Realistic_UTMs_.28spreadsheets_--_not.29.3B_this_page_bifurcated_at_best"><span class="tocnumber">6</span> <span class="toctext">Realistic UTMs (spreadsheets -- not); this page bifurcated at best</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#O.28n.2A.2A2.29.3F_or_cite.3F"><span class="tocnumber">7</span> <span class="toctext">O(n**2)? or cite?</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Heavy_re-org"><span class="tocnumber">8</span> <span class="toctext">Heavy re-org</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#References.2C_See_also.2C_External_links"><span class="tocnumber">9</span> <span class="toctext">References, See also, External links</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Declarative_UI"><span class="tocnumber">10</span> <span class="toctext">Declarative UI</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#not_Turing-complete_.3D_drawback_.3F"><span class="tocnumber">11</span> <span class="toctext">not Turing-complete = drawback ?</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#HTML_is_not_presentational_anymore..."><span class="tocnumber">12</span> <span class="toctext">HTML is not presentational anymore...</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#HTML_is_not_a_programming_language"><span class="tocnumber">13</span> <span class="toctext">HTML is not a programming language</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Another_angle_on_this"><span class="tocnumber">14</span> <span class="toctext">Another angle on this</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Merged_and_rewritten"><span class="tocnumber">15</span> <span class="toctext">Merged and rewritten</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Functional_programming_is_not_declarative"><span class="tocnumber">16</span> <span class="toctext">Functional programming is not declarative</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Dead_link">Dead link</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=1" title="Edit section: Dead link">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a rel="nofollow" class="external free" href="http://phoenix.inria.fr/wiki/doku.php?id=an_overview_on_dsls">http://phoenix.inria.fr/wiki/doku.php?id=an_overview_on_dsls</a></p>
<p>A lot of this material was taken from old versions of the <a href="/wiki/Combinatorial_search" title="Combinatorial search">Combinatorial_search</a> node. I think I have permission to do this as this and the <a href="/wiki/Combinatorial_search" title="Combinatorial search">Combinatorial_search</a> node are actually part of a homework assignment. <a href="/wiki/User:Maxomai" title="User:Maxomai">maxomai</a></p>
<p>I thought C++ and Java are OOP languages.</p>
<p>Aren't there any object oriented declarative languages? And if so, what's the reason?</p>
<p>Wouldn't CSS and XSLT qualify as good examples of declarative languages, too? — <a href="/wiki/User:Brianiac" title="User:Brianiac">Brianiac</a> 18:05, 15 Nov 2004 (UTC)</p>
<p>Yes, XML is also declarative.</p>
<p>If you classify OO as imperative, you will have to classify all programming paradigm that runs in an Imperative architecture as Imperative. --<a href="/w/index.php?title=User:Lssilva&amp;action=edit&amp;redlink=1" class="new" title="User:Lssilva (page does not exist)">Lssilva</a> 12:50, 3 Jan 2005 (UTC)</p>
<p>Just put a header on the applications section, and added Enterprise Programming as an example application. --<a href="/wiki/User:Harburg" title="User:Harburg">harburg</a> 22:04, 6 Jan 2005 (UTC)</p>
<p>It doesn't seem to be entirely clear what Declarative programming is. Why do some consider the distinction Functional vs. Imperative, and not Declarative vs. Imperative (for instance: <a rel="nofollow" class="external free" href="http://www.haskell.org/complex/why_does_haskell_matter.html">http://www.haskell.org/complex/why_does_haskell_matter.html</a> and <a class="external text" href="http://en.wikipedia.org/wiki/Functional_programming#Comparison_with_imperative_programming">imperative programming comparison</a>)? Is functional programming really a form of declarative programming (I have my doubts, but perhaps the definitions for functional programming, I've come across are also mistaken).</p>
<p>Perhaps it needs to be made clear where exactly the boundaries of imperative and declarative programming are. Makefiles, for instance, seem to be declarative (I stand under correction though), but can easily be extended (or, rather, hooked onto) with any number of approaches. I assume that imperative languages could also be extended with declarative languages too (regular expressions within certain imperative languages, may be a case in point).</p>
<p>See also the discussion on <a class="external text" href="http://en.wikipedia.org/wiki/Talk:Declarative_programming_language#clarification">Declarative Programming Languages</a>.</p>
<p>The reason why people don't consider the distiction is that functional languages are not declarative. That is in error on this page. I thought I should post discussion before changing that. In <a href="/w/index.php?title=Concepts_of_Programming_Lanuages&amp;action=edit&amp;redlink=1" class="new" title="Concepts of Programming Lanuages (page does not exist)">Concepts of Programming Lanuages</a>, Robert Sebesta constrasts declarative programming from procedural, and indicates functional languages are primarily procedural. This article and the procedural article seem to include very little on the two ideas, and give the wrong impression of the concepts because editors have written on things they are more familiar with like OO or what a procedure is. ProLog is probably the best example of a declarative lanuage. It does not use procedures to calculate things, it simply indicates what it expects (there is no details on "how"). -has</p>
<p><br></p>
<h2><span class="mw-headline" id="Business_Rules_Link">Business Rules Link</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=2" title="Edit section: Business Rules Link">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Anyone else think that the link to business rules seems a bit out of place? <a href="/w/index.php?title=User:AliaGemma&amp;action=edit&amp;redlink=1" class="new" title="User:AliaGemma (page does not exist)">AliaGemma</a> 04:20, 12 January 2007 (UTC)</p>
<p><br></p>
<h2><span class="mw-headline" id="declarative_program_is_not_Turing-complete">declarative program is not Turing-complete</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=3" title="Edit section: declarative program is not Turing-complete">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I'm willing to stand corrected, since I don't know most of the languages listed in the examples. But if you do revert my new paragraph, you should explain how SQL (not a programming language but a "data sublanguage", in the words of C. J. Date) and XML (even more specialized -- what I would call a "data storage sublanguage") and XSLT (yet more specialized -- a conversion utility for XML) and Prolog (according to Wikipedia, "In Prolog you supply a database of facts and rules; you can then perform queries on the database") got into the list of examples (well, XML is not in the list in the Article but it is categorized as a declarative language in Talk) without any mention of the fact that they are not UTMs.</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 01:11, 13 December 2005 (UTC)</p>
<p>I had to take this whole paragraph out:</p>
<p>" Many of the dialects being created based on the <a href="/wiki/XML" title="XML">XML</a> format can be described as declarative due largely to the increasing popularity of the declarative programming paradigm. "</p>
<p>because:</p>
<p>1. XML is a language, not a format (and not a programming language).</p>
<p>2. All extensions of XML are no more and no less declarative than XML.</p>
<p>3. I see no evidence that declarative programming is becoming more popular in comparison with imperative languages. Cite. Writing XML files is not programming; it's equivalent to writing DML in SQL. Writing DTDs is not programming; challenging it may be, but it's equivalent to writing DDL in SQL.</p>
<p>4. Popularity would be no reason that XML dialects could be described as declarative.</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 01:29, 13 December 2005 (UTC)</p>
<h2><span class="mw-headline" id="Makefiles:_imperative">Makefiles: imperative</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=4" title="Edit section: Makefiles: imperative">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Someone asked about makefiles above -- so:</p>
<p>Although the dependency lines of a makefile are declarative, the block of command lines that follow each dependency line are procedural (imperative), because in effect they constitute a shell script.</p>
<p>Just as the data declarations of a Java program, however elaborate, do not make the Java program declarative, the dependency lines of a makefile do not make the makefile declarative.</p>
<p>In short, makefiles are imperative.</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 03:21, 13 December 2005 (UTC)</p>
<p>I disagree. Makefiles are both declarative (the rules) and imperative (the actions). I don't think it's reasonable to say that anything that is even the slightest bit imperative is therefore imperative without qualification. That would be like saying HTML is imperative because it can embed javascript, or SQL is imperative because the database might have triggers.</p>
<p><a href="/wiki/User:Kimbly" title="User:Kimbly">Kimbly</a> 19:30, 31 December 2005 (UTC)</p>
<h2><span class="mw-headline" id="Limitations_of_declarative_languages_.28with_citations.29">Limitations of declarative languages (with citations)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=5" title="Edit section: Limitations of declarative languages (with citations)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I reverted recent changes to "Disadvantages", pending (a) someone citing a demonstration that some language among the examples given is Turing-complete, and providing a frank discussion of why so many of them are not Turing-complete; or (b) someone providing a frank discussion of the non-Turing-completeness of imperative languages, which restricts them to solving a tiny fraction of the infinity of problems that are solvable by Turing-complete languages. Note Wikipedia policy on Cite. When I say "a tiny fraction", I mean "a tiny fraction, however large in magnitude" -- I do not mean declarative languages are unimpressive or are toys or are useless or not clean or beautiful.</p>
<p>I removed the phrase "how widely applicable" because I don't see that it addresses the issue that imperative languages are highly restricted (not UTMs). That is a big deal, not a minor flaw. Similarly, I saw the phrase "the interpreter" but I didn't see any discussion addressing the point that this interpreter is otherwise known as "the semi-special-purpose program that you buy or download for free" (MySQL, msql, JESS, etc.).</p>
<p>Here's how it works -- correct me if I'm wrong -- cite if you correct me -- I will cite. With a declarative (general-purpose or Turing-complete) language, you buy a compiler (possibly free; Java, Perl, C++, Delphi, assembler, etc.), and write a special-purpose program to solve your special problem. With an imperative language, you buy a sort-of-special-purpose program (possibly free; see list below). Along with the sort-of-special-purpose program, you get a system for feeding your special data to the program; that system is called a "declarative language". Then the sort-of-special-purpose program chews on your special data to solve your special problem. I cite: MySQL FAQ page; msql FAQ page; any book on XML or SQL; JESS FAQ page; any SQL FAQ page; any expert system or AI system FAQ page. I cite C. J. Date's statement that SQL is not really a language but is instead "a data sub-languages". I believe that declarative languages are confined to solving these types of problems: formal logic queries; data storage (XML in all its varieties), data access (SQL, Quel, etc.); optimization; rule systems (given the rules I put in, is X allowed?). I probably missed one or two -- I would appreciate help completing the list of problem types solvable by the current crop of declarative languages. It's market-driven, so the list is ever changing.</p>
<p>Singapore's airport gate and baggage-machine scheduler is run by an optimization engine (I have forgotten the brand) that balances a tremendous number of factors. For all I know, it saves them a billion dollars a year. It's extremely powerful. Singapore would never want to pay anyone to write the equivalent logic in a UTM. But it's not a Turing machine. It can't balance your checkbook.</p>
<p>(Don't you just love how, if you try to arrow down past the last line of your editing and the last line is not blank, Wikipedia appends a blank line and puts your cursor on it -- a nice touch that Microsoft Word for well over ten years now has still not figured out?)</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 00:44, 19 December 2005 (UTC)</p>
<h2><span class="mw-headline" id="Realistic_UTMs_.28spreadsheets_--_not.29.3B_this_page_bifurcated_at_best">Realistic UTMs (spreadsheets -- not); this page bifurcated at best</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=6" title="Edit section: Realistic UTMs (spreadsheets -- not); this page bifurcated at best">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Maybe we need to concentrate on the concept of a Realistic Universal Turing Machine (RUTM).</p>
<p>A real UTM (infinite paper tape, bi-directional motor, etc.) is not an RUTM -- too clumsy. Nobody discusses UTML, the language of a real (unrealistic) UTM.</p>
<p>A spreadsheet is a UTM, but not an RUTM, because although it's a UTM, it's too specialized (not general-purpose-realistic enough) for anyone to use it as a general-purpose computing language. Therefore no one write graphics drivers for a spreadsheet, so we can't draw little pictures inside the cells; similarly, no one writes regular expression evaluators for spreadsheets, nor all the other libraries that an RUTM tends to accumulate.</p>
<p>So . . . is Haskell an RUTM?</p>
<p><i>Yes, it absolutely is. For practice, look at <a rel="nofollow" class="external free" href="http://www.haskell.org/libraries/">http://www.haskell.org/libraries/</a>. For theory, look into Monads, Concurrent Haskell, Software Transactional Memory, etc.</i> <a href="/wiki/User:Kimbly" title="User:Kimbly">Kimbly</a> 19:39, 31 December 2005 (UTC)</p>
<p>And who outside the ivory tower cares about non-R-UTMs, unless they're going to bust out and change the landscape of real-world programming forever?</p>
<p>I believe it's easy to find examples of non-UTM (declarative) languages: Every XML language is non-UTM. Regular expressions are non-UTM. The language of Windows (or KBE, etc.) is a powerful but awkward and nontextual and non-UTM langauge whose lexicals are click, double-click, drop-down, type "ABC", choose menu item, right-drag, mouse-wheel-down, Page Up, etc. Any data entry system that slaps your hand or corrects you when you type something wrong is probably a non-UTM language. Usually they're so simple that we don't call them languages, but that choice is arbitrary. Your telephone dial has a language -- 55512345 is identical to 5551234 in that language; 555123 is syntactically invalid; years ago, 16795551212 was invalid (when the middle digit of an area code was constrained to 0 or 1). There's no meaningful line to draw between these non-UTM languages and Singapore's expert systems rule "Baggage conveyor type 103B223Q cannot unload Boeing 767s".</p>
<p>At best, I think the Declarative Programming page as it stood last week was seriously bifurcated. Bifurcated between the semi-special-purpose engines that I listed a few inches up and *_possibly_* the near-R-UTM languages that some still claim exist; e.g. perhaps Haskell. The crack should either be repaired seamlessly (smooth continuum from your phone-pad's language (lexicals: [0-9*#], Hangup, etc.) to XML to Haskell), or explicated thoroughly (Declarative Languages type S and Declarative Languages type G?).</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 03:58, 19 December 2005 (UTC)</p>
<h2><span class="mw-headline" id="O.28n.2A.2A2.29.3F_or_cite.3F">O(n**2)? or cite?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=7" title="Edit section: O(n**2)? or cite?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I reverted but also clarified my original by giving the time to solution as O(n**2).</p>
<p>Coastalpedia (or anyone else) -- if you feel that the order of the problem is less than n squared, please put your reasoning in and provide a citation. I think Wikipedia needs something more solid than "But that belief is simply wrong" -- the unobvious needs to be substantiated. Has the "belief" been mathematically proven to be wrong? Or is that an empiricaly result, widely confirmed? What exactly is the time to solution? Is it (my guess) that for a lucky client (with a fairly simple problem) the order is slightly over n, and for an unlucky client, the folks who optimized the solution engine haven't gotten it much below n squared.</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 20:48, 23 December 2005 (UTC)</p>
<p>How can I explain this when you are willing to make assumptions about O(n**2) (or any other order)? No system (other than perhaps naive student projects) does a full search space enumeration to perform constraint satisfaction. Even back in the mid 80s, Prolog systems knew about trimming search spaces. The cite for ALS provides one example of something quite finely tuned well past the point of any "inconvenience". Frankly, it's fundamentally wrong to assume that declarative systems require an interpreter. A constraint satisfaction system? Sure. Interpreter? No.</p>
<p>For that matter, this article contains a number of errors, especially in the conflation of terms, such as the conflation of functional and declarative. This article desperately needs to go back to basics, get the terms defined orthogonally, and build it back up on a solid foundation.</p>
<p><a href="/w/index.php?title=User:Coastalpedia&amp;action=edit&amp;redlink=1" class="new" title="User:Coastalpedia (page does not exist)">Coastalpedia</a> 07:57, 24 December 2005 (UTC)</p>
<h2><span class="mw-headline" id="Heavy_re-org">Heavy re-org</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=8" title="Edit section: Heavy re-org">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I thank Coastalpedia for the example of ASL. I agree on the need for a basic rewrite, so I took a stab at it. I hope I have treated ASL fairly in the rewrite.</p>
<p>I leaned toward the term "conditions", which I found in the first paragraph, but I kept the names of the constituents (data, functions, rules, term-rewriting) that I found in the article. In particular, "functional" is now a secondary concept. But I think there is still some article in in Wikipedia that claims that "functional" and "declarative" are opposites.</p>
<p>I leaned toward the term "engine", but I left the synonyms (interpreter, executor, compiler) in for at least one mention each.</p>
<p>I removed the word "pure", which seemed more confusing than helpful (why pure functional? why not pure logic? why not a mix?).</p>
<p><a href="/w/index.php?title=User:T00h00&amp;action=edit&amp;redlink=1" class="new" title="User:T00h00 (page does not exist)">TH</a> 01:37, 30 December 2005 (UTC)</p>
<h2><span class="mw-headline" id="References.2C_See_also.2C_External_links">References, See also, External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=9" title="Edit section: References, See also, External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This article is highly controversial, judging by the <a class="external text" href="http://en.wikipedia.org/w/index.php?title=Declarative_programming&amp;action=history">edit history</a>. <a href="/wiki/Wikipedia:Citing_sources" title="Wikipedia:Citing sources">References</a> are a good tool to show we have facts and are discussing <a href="/wiki/Wikipedia:Neutral_point_of_view" title="Wikipedia:Neutral point of view">notable points of view</a>. If you disagree, you don't need to remove references, you can add to them ones that support your view! I don't know many <a href="/wiki/Wikipedia:Reliable_sources" title="Wikipedia:Reliable sources" class="mw-redirect">good references</a> but I like the clear albeit strict definitions in FOLDOC even though they only have <a rel="nofollow" class="external text" href="http://ftp.sunet.se/foldoc/foldoc.cgi?declarative+language">"declarative language"</a> instead of "declarative programming".</p>
<p>Another concern of mine is the article's wrong relation of the topic to some close ones. I don't understand why we want to make false claims about <a href="/wiki/Domain-specific_language" title="Domain-specific language">domain-specific languages</a>, <a href="/wiki/Turing_completeness" title="Turing completeness">turing completeness</a>, language classification here. If you want to claim no DSL is turing complete, why not say it on the page on DSLs and get reverted? If you want to claim <a href="/wiki/HTML" title="HTML">HTML</a> can be used for programming, why not say it on the page on <a href="/wiki/Programming_language" title="Programming language">programming languages</a> and get reverted? I hope the sections <a href="/wiki/Declarative_programming#See_also" title="Declarative programming">See also</a> and <a href="/wiki/Declarative_programming#External_links" title="Declarative programming">External links</a> can help give the article a distinguished scope between all the other topics.</p>
<p>Of course everybody disagrees what the scope should be :-) Declarative programming is a way to programming, a <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming paradigm</a>? Declarative programming is <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>? Declarative programming is the opposite of <a href="/wiki/Imperative_programming" title="Imperative programming">imperative programming</a> in the sense that the first lacks the concentration on the program state of execution? Declarative programming is also the opposite of <a href="/wiki/Procedural_programming" title="Procedural programming">procedural programming</a> (or <a href="/w/index.php?title=Sequential_programming&amp;action=edit&amp;redlink=1" class="new" title="Sequential programming (page does not exist)">sequential programming</a> more generally) in the sense that the first lacks the step-after-step instructions of program execution? This all is what I read from the <a href="/wiki/FOLDOC" title="FOLDOC" class="mw-redirect">FOLDOC</a> articles, what about you people? --<a href="/wiki/User:TuukkaH" title="User:TuukkaH">TuukkaH</a> 21:01, 1 January 2006 (UTC)</p>
<h2><span class="mw-headline" id="Declarative_UI">Declarative UI</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=10" title="Edit section: Declarative UI">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I think it could be relevant to add a section about Declarative UIs (like XUL, XAML, etc..), and maybe add a link to <a href="/wiki/User_interface_markup_language" title="User interface markup language">User interface markup language</a> article. - <a href="/wiki/User:Hervegirod" title="User:Hervegirod">Hervegirod</a> 09:58, 14 May 2006 (UTC)</p>
<p><br></p>
<h2><span class="mw-headline" id="not_Turing-complete_.3D_drawback_.3F">not Turing-complete = drawback ?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=11" title="Edit section: not Turing-complete = drawback ?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>From the article: "One drawback of DSLs is that they are often not Turing-complete." This suggests that Turing-completeness should be mandatory for programming languages. IMHO it is no drawback, if a language is not Turing-complete; unless, you want to use the language to solve problems that require Turing-completeness.</p>
<p>But <a href="/wiki/Domain-specific_programming_language" title="Domain-specific programming language" class="mw-redirect">DSLs</a> a restricted to a certain domain and usually the Turing-completeness is not required. Would you say the drawback of an electric drill is that you cannot cut paper with it? No. Sometimes the it is a drawback if the language IS Turing-complete, because certain things (source code analysis,etc.) are undecidable over Turing-complete languages (<a href="/wiki/Halting_problem" title="Halting problem">Halting problem</a>) while there might be feasible for 'incomplete' DSLs.</p>
<p>--<a href="/wiki/User:Riedel" title="User:Riedel">Riedel</a> 09:44, 22 July 2006 (UTC)</p>
<p>"One drawback of DSLs is that they are often not Turing-complete. That is, there are certain things they cannot do. Just as you cannot use a spreadsheet to send e-mail, you cannot use e-mail to calculate your bank balance." You're saying that a spreadsheet could send email if only it were Turing-complete? Ali 2007-03-08</p>
<p><br>
IMO two concerns are being mixed here -- computational power of a model/language (which is what Turing completeness talks about), and the underlying facilities and primitives of an interpreter/compiler/runtime environment (usually related to IO, files, etc). For example: as Turing-complete as pure lambda calculus is, it's just meaningless to ponder whether you can or cannot send email with it. While you might be tempted to say "you can't!", nothing precludes a particular LC interpreter to say that if an expression ultimately reduces to the form "((e &lt;dest&gt;) &lt;text&gt;)" then, as a side effect, an email is sent to the address in &lt;dest&gt; containing the text in &lt;text&gt; (the precise encoding of text in lambda expressions is left as an exercise). -- Ariel "askyle" Birnbaum, 2008-02-06 <small>—Preceding <a href="/wiki/Wikipedia:Signatures" title="Wikipedia:Signatures">unsigned</a> comment added by <a href="/wiki/Special:Contributions/192.114.107.4" title="Special:Contributions/192.114.107.4">192.114.107.4</a> (<a href="/wiki/User_talk:192.114.107.4" title="User talk:192.114.107.4">talk</a>) 08:01, 6 February 2008 (UTC)</small></p>
<h2><span class="mw-headline" id="HTML_is_not_presentational_anymore...">HTML is not presentational anymore...</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=12" title="Edit section: HTML is not presentational anymore...">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The W3C made this pretty clear. Most presentational elements have been deprecated as of HTML 4.01 Strict (Transitional is called Transitional for a reason) and those that are still in are on their way out.</p>
<p>The HTML example is currently as follows:</p>
<p>This is thus fundamentally wrong. HTML doesn't describe what the page looks like, that's the job of stylesheets (CSS, XSLT, etc), it describes what the page consists of. It structures the content of the website and denotes relations (hence "Hypertext") between the document and other files or entities.</p>
<p>According to the second definition, HTML is definitely not a declarative programming language. Another snippet says:</p>
<p>When you write a web page, you declare its structure and content (i.e. semantics) in HTML. CSS describes the styling.</p>
<p>Also, unlike someone stated earlier on this Talk page, XML is not a declarative programming language in any sense, because it is only a syntax. XML dialects can be declarative, but XML itself does not have any semantics beyond the XML headers. In that sense, XML is merely a standardised format for markup languages, not a markup language of that format itself. It's not much more of a language than <a href="/wiki/ASCII" title="ASCII">ASCII</a> or <a href="/wiki/Comma-separated_values" title="Comma-separated values">comma-separated values</a>.</p>
<p>Further, the first definition of declarative languages is a bit vague. It could be used to label any data format that is not an imperative programming language a declarative programming language. This clashes with the definition of a "programming language".</p>
<p>Calling semantic HTML (granted, prior to HTML 4.01 it did have a lot of presentation mixed into it) a programming language is misleading at best. To quote the article "<a href="/wiki/Programming_language" title="Programming language">programming language</a>":</p>
<p>As an aside: SGML has "processing instructions", but I wouldn't rate them as anything but a more generic form of the modifier glyphs found in Unicode.</p>
<p>Apparently the first definition in this article rates anything with even a hint of embedded meta-data as a declarative programming language. This use is not only vague, but I would say that it is heavily disputed and non-standard. I've removed the passages about HTML from this article and <a href="/wiki/Declarative_programming_language" title="Declarative programming language" class="mw-redirect">Declarative programming language</a> (a bit of redundant an article, IMO). Feel free to put them back in, but only if you can find a less authorative wording. — <a href="/wiki/User:Ashmodai" title="User:Ashmodai">Ashmodai</a> <sup>(<a href="/wiki/User_talk:Ashmodai" title="User talk:Ashmodai">talk</a> · <a href="/wiki/Special:Contributions/Ashmodai" title="Special:Contributions/Ashmodai">contribs</a>)</sup> 10:45, 27 August 2006 (UTC)</p>
<h2><span class="mw-headline" id="HTML_is_not_a_programming_language">HTML is not a programming language</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=13" title="Edit section: HTML is not a programming language">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Based on this (rather) simple affirmation, I just don't understand why HTML is cited as an example in that article: an example such this could be misleading for all the non-experts (Oh, then HTML is a declarative programming language? Cool!) <small>—Preceding <a href="/wiki/Wikipedia:Signatures" title="Wikipedia:Signatures">unsigned</a> comment added by <a href="/wiki/Special:Contributions/87.17.195.204" title="Special:Contributions/87.17.195.204">87.17.195.204</a> (<a href="/w/index.php?title=User_talk:87.17.195.204&amp;action=edit&amp;redlink=1" class="new" title="User talk:87.17.195.204 (page does not exist)">talk</a>) 10:43, 19 September 2007 (UTC)</small></p>
<p>Why do you not provide a different example then? Insisting on HTML not being a proper programming language does not help anyone, it is just the usual "I am a true programmer" attitude. The HTML example is very good; you can immediately understand what declarative definitions are about. Anyone in doubt about HTML being a programmin language will be cured by a quick click on the referenced page. <a href="/wiki/Special:Contributions/129.187.228.194" title="Special:Contributions/129.187.228.194">129.187.228.194</a> (<a href="/w/index.php?title=User_talk:129.187.228.194&amp;action=edit&amp;redlink=1" class="new" title="User talk:129.187.228.194 (page does not exist)">talk</a>) 13:30, 6 May 2008 (UTC)</p>
<h2><span class="mw-headline" id="Another_angle_on_this">Another angle on this</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=14" title="Edit section: Another angle on this">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This article is written as if declarative programming were strictly a property of languages. In fact, it is also a technique that can be deployed in an imperative language. For example, you can write a C++ function that does some task (or tasks) based on the contents of a (typically static const) array (or other structure) initialized as part of the code. A developer can then effectively accomplish certain programming tasks by changing the content of that array: effectively, declarative programming. I've certainly used this technique, but I am not offhand familiar with a citable reference. If someone has something citable, this probably would merit mention. - <a href="/wiki/User:Jmabel" title="User:Jmabel">Jmabel</a> | <a href="/wiki/User_talk:Jmabel" title="User talk:Jmabel">Talk</a> 22:00, 1 February 2008 (UTC)</p>
<p>Like <a rel="nofollow" class="external text" href="http://my.safaribooksonline.com/0735619670/ch18">table-driven methods</a> in Code Complete? <a href="/w/index.php?title=User:Skilldrick&amp;action=edit&amp;redlink=1" class="new" title="User:Skilldrick (page does not exist)">Skilldrick</a> (<a href="/w/index.php?title=User_talk:Skilldrick&amp;action=edit&amp;redlink=1" class="new" title="User talk:Skilldrick (page does not exist)">talk</a>) 10:36, 29 July 2010 (UTC)</p>
<h2><span class="mw-headline" id="Merged_and_rewritten">Merged and rewritten</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=15" title="Edit section: Merged and rewritten">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I merged <a href="/wiki/Declarative_programming_language" title="Declarative programming language" class="mw-redirect">declarative programming language</a> into this article, and rewrote huge parts of it. There were some pretty horrible things in both articles. Factually wrong things ("Purely declarative languages don't compute anything") to obnoxious things (parts of the article seemed to be written by someone I can only assume was well-meaning but didn't understand the topic) or just horribly written or irrelevant. Hopefully my replacement is better!</p>
<p>Article still badly in need of references for things, though.</p>
<p>Would someone more enterprising than me consider refactoring this (and the the talk page from <a href="/wiki/Talk:Declarative_programming_language" title="Talk:Declarative programming language">Talk:declarative programming language</a>) or archiving them or something? This talk page is excessively long and discussions exist on things that seem to be long dead. <a href="/w/index.php?title=User:Tejoka&amp;action=edit&amp;redlink=1" class="new" title="User:Tejoka (page does not exist)">Tejoka</a> (<a href="/w/index.php?title=User_talk:Tejoka&amp;action=edit&amp;redlink=1" class="new" title="User talk:Tejoka (page does not exist)">talk</a>) 06:58, 5 October 2008 (UTC)</p>
<h2><span class="mw-headline" id="Functional_programming_is_not_declarative">Functional programming is not declarative</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Talk:Declarative_programming&amp;action=edit&amp;section=16" title="Edit section: Functional programming is not declarative">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To quote the relevant section from the article:</p>
<p>These two paragraphs are completely bogus. Let's take them apart:</p>
<ul>
<li>"<i>Functional programming, [...], attempts to minimize or eliminate side effects, and is therefore considered declarative.</i>"
<dl>
<dd>
<dl>
<dd>No, that's neither a sufficient, nor a necessary, condition for declarative programming! For example, a side-effect, like setting a memory location or writing to a file, could be described in a declarative way (e.g. using pre- and post-conditions).</dd>
</dl>
</dd>
</dl>
</li>
<li>"<i>While functional languages typically do appear to specify "how" [...]</i>"
<dl>
<dd>
<dl>
<dd>They don't just <i>appear</i> to specify "how", they actually <i>do</i>! Every valid functional program represents an algorithm, and algorithms describe <b>how</b> to compute a result.</dd>
</dl>
</dd>
</dl>
</li>
<li>"<i>a compiler for a purely functional programming language is free to extensively rewrite the operational behavior of a function, so long as the same result is returned for the same inputs</i>."
<dl>
<dd>
<dl>
<dd>So does a compiler for an imperative programming language; in fact, for basically every language, the compiler is allowed to do that (it's generally called "optimization").</dd>
</dl>
</dd>
</dl>
</li>
<li>"<i>or to perform substantial optimizations (such as deforestation) that a compiler may not be able to safely apply to a language with side effects.</i>"
<dl>
<dd>
<dl>
<dd>Most FP languages are not side-effect free, so the same limitations exist for them as for imperative languages.</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p>The main problem with this section is that it tries to demonstrate that FP languages are declarative, which is not the case (although I often read this false claim). If no one objects, I'll remove it completely. – <a href="/wiki/User:Adrianwn" title="User:Adrianwn">Adrian Willenbücher</a> (<a href="/wiki/User_talk:Adrianwn" title="User talk:Adrianwn">talk</a>) 09:39, 22 September 2011 (UTC)</p>
<ul>
<li>By your reasoning, only <b>pure, non-strict</b> functional programming languages are declarative. That's quite a difference to functional programming languages in general.</li>
<li>In what way is Prolog not declarative? That's the archetype of declarative programming languages.</li>
<li><i>"Some arguments that functional languages are declarative would be that in lazy functional languages the programmer does not have to worry in which order the computations are performed, they are automatically executed in an order that 'just works'."</i></li>
</ul>
<ul>
<li>Just because the order of evaluation isn't determined by the programmer, doesn't mean that the programmer doesn't define the "how". Consider the following Haskell code:</li>
</ul>
<p>WHATSON? d404db32-d9db-4023-a82b-aa0a9ed0c607</p>
<pre class="de1">
fac <span class="nu0">0</span> <span class="sy0">=</span> <span class="nu0">0</span>
fac n <span class="sy0">=</span> n <span class="sy0">*</span> fac <span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
</pre>
<ul>
<li>C doesn't define an order of evaluation either, and yet you wouldn't say that it is declarative, would you?</li>
</ul>
<p>WHATSON? 324b5dd6-7487-4434-9682-22ce22cf91d1</p>
<pre class="de1">
fac n <span class="sy0">=</span> <span class="kw3">product</span> <span class="br0">[</span><span class="nu0">1</span> .. n<span class="br0">]</span>
</pre>
<p>– <a href="/wiki/User:Adrianwn" title="User:Adrianwn">Adrian Willenbücher</a> (<a href="/wiki/User_talk:Adrianwn" title="User talk:Adrianwn">talk</a>) 12:44, 27 September 2011 (UTC)</p>
<p>It even claims that functional is declarative because the compiler might rewrite the functions. Well in that case, C is declarative too! Whoopsie. <a href="/wiki/Special:Contributions/2001:470:1F04:3DF:0:0:0:2" title="Special:Contributions/2001:470:1F04:3DF:0:0:0:2">2001:470:1F04:3DF:0:0:0:2</a> (<a href="/w/index.php?title=User_talk:2001:470:1F04:3DF:0:0:0:2&amp;action=edit&amp;redlink=1" class="new" title="User talk:2001:470:1F04:3DF:0:0:0:2 (page does not exist)">talk</a>) 22:07, 5 July 2013 (UTC)</p>
