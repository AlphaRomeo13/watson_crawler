<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Inductive logic programming</span></h1>
<ul>
<li><a href="/wiki/Action_language" title="Action language">Action</a></li>
<li><a href="/wiki/Agent-oriented_programming" title="Agent-oriented programming">Agent-oriented</a></li>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Automata-based_programming" title="Automata-based programming">Automata-based</a></li>
<li><a href="/wiki/Concurrent_computing" title="Concurrent computing">Concurrent computing</a>
<ul>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
</ul>
</li>
<li><a href="/wiki/Data-driven_programming" title="Data-driven programming">Data-driven</a></li>
<li><a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a> (contrast: <a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a>)
<ul>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a></li>
<li><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
</li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional</a>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
</li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic</a>
<ul>
<li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><strong class="selflink">Inductive logic</strong></li>
</ul>
</li>
<li><a href="/wiki/Relational_programming" title="Relational programming">Relational</a></li>
</ul>
</li>
<li><a href="/wiki/End-user_development" title="End-user development">End-user programming</a></li>
<li><a href="/wiki/Event-driven_programming" title="Event-driven programming">Event-driven</a>
<ul>
<li><a href="/wiki/Service-oriented_architecture" title="Service-oriented architecture">Service-oriented</a></li>
<li><a href="/wiki/Time-driven_programming" title="Time-driven programming">Time-driven</a></li>
</ul>
</li>
<li><a href="/wiki/Expression-oriented_programming_language" title="Expression-oriented programming language">Expression-oriented</a></li>
<li><a href="/wiki/Feature-oriented_programming" title="Feature-oriented programming">Feature-oriented</a></li>
<li><a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a> (contrast: <a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a>)</li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a> (contrast: <a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a>)
<ul>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
</ul>
</li>
<li><a href="/wiki/Language-oriented_programming" title="Language-oriented programming">Language-oriented</a>
<ul>
<li><a href="/wiki/Natural_language_programming" title="Natural language programming">Natural language programming</a></li>
<li><a href="/wiki/Service-oriented_modeling#Discipline-specific_modeling" title="Service-oriented modeling">Discipline-specific</a></li>
<li><a href="/wiki/Domain-specific_language" title="Domain-specific language">Domain-specific</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
</li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
</ul>
</li>
<li><a href="/wiki/Metaprogramming" title="Metaprogramming">Metaprogramming</a>
<ul>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a></li>
<li><a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">Reflective</a>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a> (contrast: <a href="/wiki/Structured_programming" title="Structured programming">Structured</a>)
<ul>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
</ul>
</li>
<li><a href="/wiki/Nondeterministic_programming" title="Nondeterministic programming">Nondeterministic</a></li>
<li><a href="/wiki/Parallel_computing" title="Parallel computing">Parallel computing</a>
<ul>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Tacit_programming" title="Tacit programming">Point-free style</a>
<ul>
<li><a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
</ul>
</li>
<li><a href="/wiki/Semantic-oriented_programming" title="Semantic-oriented programming">Semantic</a></li>
<li><a href="/wiki/Structured_programming" title="Structured programming">Structured</a> (contrast: <a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a>)
<ul>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a> (contrast: <a href="/wiki/Monolithic_application" title="Monolithic application">Monolithic</a>)</li>
<li><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented (OOP)</a>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
</li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
</ul>
</li>
<li><a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a> (contrast: <a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a>)</li>
<li><a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">Probabilistic</a></li>
<li><a href="/wiki/Concept_programming" title="Concept programming">Concept</a></li>
</ul>
<ul>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
</ul>
<ul>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a></li>
<li><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
</li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional</a>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
</li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic</a>
<ul>
<li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><strong class="selflink">Inductive logic</strong></li>
</ul>
</li>
<li><a href="/wiki/Relational_programming" title="Relational programming">Relational</a></li>
</ul>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
<ul>
<li><a href="/wiki/Abductive_logic_programming" title="Abductive logic programming">Abductive logic</a></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><strong class="selflink">Inductive logic</strong></li>
</ul>
<ul>
<li><a href="/wiki/Service-oriented_architecture" title="Service-oriented architecture">Service-oriented</a></li>
<li><a href="/wiki/Time-driven_programming" title="Time-driven programming">Time-driven</a></li>
</ul>
<ul>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
</ul>
<ul>
<li><a href="/wiki/Natural_language_programming" title="Natural language programming">Natural language programming</a></li>
<li><a href="/wiki/Service-oriented_modeling#Discipline-specific_modeling" title="Service-oriented modeling">Discipline-specific</a></li>
<li><a href="/wiki/Domain-specific_language" title="Domain-specific language">Domain-specific</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
</li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
</ul>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
<ul>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a></li>
<li><a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">Reflective</a>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
<ul>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
</ul>
<ul>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
</ul>
<ul>
<li><a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
</ul>
<ul>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a> (contrast: <a href="/wiki/Monolithic_application" title="Monolithic application">Monolithic</a>)</li>
<li><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented (OOP)</a>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
</li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
</ul>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Programming_paradigms" title="Template:Programming paradigms"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Programming_paradigms" title="Template talk:Programming paradigms"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p><b>Inductive logic programming</b> (<b>ILP</b>) is a subfield of <a href="/wiki/Machine_learning" title="Machine learning">machine learning</a> which uses <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a> as a uniform representation for examples, background knowledge and hypotheses. Given an encoding of the known background knowledge and a set of examples represented as a logical database of facts, an ILP system will derive a hypothesised logic program which entails all the positive and none of the negative examples.</p>
<p>Schema: <i>positive examples</i> + <i>negative examples</i> + <i>background knowledge</i> =&gt; <i>hypothesis</i>.</p>
<p>Inductive logic programming is particularly useful in <a href="/wiki/Bioinformatics" title="Bioinformatics">bioinformatics</a> and <a href="/wiki/Natural_language_processing" title="Natural language processing">natural language processing</a>. <a href="/wiki/Ehud_Shapiro" title="Ehud Shapiro">Ehud Shapiro</a> laid the theoretical foundation for inductive logic programming<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup> and built its first implementation (Model Inference System) in 1981:<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup> a Prolog program that inductively inferred logic programs from positive and negative examples. The term <i>Inductive Logic Programming</i> was first introduced<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup> in a paper by <a href="/wiki/Stephen_Muggleton" title="Stephen Muggleton">Stephen Muggleton</a> in 1991.<sup id="cite_ref-muggleton1995inverse_5-0" class="reference"><a href="#cite_note-muggleton1995inverse-5"><span>[</span>5<span>]</span></a></sup> The term "<i>inductive</i>" here refers to <a href="/wiki/Inductive_reasoning" title="Inductive reasoning">philosophical</a> (i.e. suggesting a theory to explain observed facts) rather than <a href="/wiki/Mathematical_induction" title="Mathematical induction">mathematical</a> (i.e. proving a property for all members of a well-ordered set) induction.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Formal_definition"><span class="tocnumber">1</span> <span class="toctext">Formal definition</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Example"><span class="tocnumber">2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Inductive_Logic_Programming_system"><span class="tocnumber">3</span> <span class="toctext">Inductive Logic Programming system</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Hypothesis_search"><span class="tocnumber">3.1</span> <span class="toctext">Hypothesis search</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Implementations"><span class="tocnumber">3.2</span> <span class="toctext">Implementations</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">4</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Further_reading"><span class="tocnumber">6</span> <span class="toctext">Further reading</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Hypothesis_search"><span class="tocnumber">3.1</span> <span class="toctext">Hypothesis search</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Implementations"><span class="tocnumber">3.2</span> <span class="toctext">Implementations</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Formal_definition">Formal definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=1" title="Edit section: Formal definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <i>background knowledge</i> is given as a logic theory <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png">, commonly in the form of <a href="/wiki/Horn_clauses" title="Horn clauses" class="mw-redirect">Horn clauses</a> used in <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a>. The <i>positive</i> and <i>negative</i> examples are given as a conjunction <img class="mwe-math-fallback-image-inline tex" alt="E^+" src="//upload.wikimedia.org/math/1/6/1/161e252fb1b33229023d3642054e5116.png"> and <img class="mwe-math-fallback-image-inline tex" alt="E^-" src="//upload.wikimedia.org/math/c/a/d/cad6f99216cd7130cf0f8e9b5f5bac78.png"> of unnegated and negated <a href="/wiki/Ground_expression" title="Ground expression">ground</a> <a href="/wiki/Literal_(mathematical_logic)" title="Literal (mathematical logic)">literals</a>, respectively. A <i>correct hypothesis</i> <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> is a logic proposition satisfying the following requirements.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<p>"<i>Necessity</i>" does not impose a restriction on <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png">, but forbids any generation of a hypothesis as long as the positive facts are explainable without it. "<i>Sufficiency</i>" requires any generated hypothesis <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> to explain all positive examples <img class="mwe-math-fallback-image-inline tex" alt="E^+" src="//upload.wikimedia.org/math/1/6/1/161e252fb1b33229023d3642054e5116.png">. "<i>Weak consistency</i>" forbids generation of any hypothesis <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> that contradicts the background knowledge <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png">. "<i>Strong consistency</i>" also forbids generation of any hypothesis <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> that is inconsistent with the negative examples <img class="mwe-math-fallback-image-inline tex" alt="E^-" src="//upload.wikimedia.org/math/c/a/d/cad6f99216cd7130cf0f8e9b5f5bac78.png">, given the background knowledge <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png">; it implies "<i>Weak consistency</i>"; if no negative examples are given, both requirements coincide. Džeroski <sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> requires only "<i>Sufficiency</i>" (called "Completeness" there) and "<i>Strong consistency</i>".</p>
<h2><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=2" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following well-known example about learning definitions of family relations uses the abbreviations <img class="mwe-math-fallback-image-inline tex" alt="\textit{par}: \textit{parent}" src="//upload.wikimedia.org/math/4/f/3/4f39059b476edca5531bc4a85915eb13.png">, <img class="mwe-math-fallback-image-inline tex" alt="\textit{fem}: \textit{female}" src="//upload.wikimedia.org/math/d/4/f/d4f1ea11bc46f68e9f9092ec63e7b741.png">, <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}: \textit{daughter}" src="//upload.wikimedia.org/math/a/0/b/a0b08a326a19b28f048430b9db1404eb.png">, <img class="mwe-math-fallback-image-inline tex" alt="g:\textit{George}" src="//upload.wikimedia.org/math/c/0/0/c00a4c85a1de628c40db4776173e9f67.png">, <img class="mwe-math-fallback-image-inline tex" alt="h:\textit{Helen}" src="//upload.wikimedia.org/math/2/5/c/25cd3a36b83720d4b86a31010693e82f.png">, <img class="mwe-math-fallback-image-inline tex" alt="m:\textit{Mary}" src="//upload.wikimedia.org/math/3/9/c/39cb9d068cca9fbbf12ba7757238722a.png">, <img class="mwe-math-fallback-image-inline tex" alt="t:\textit{Tom}" src="//upload.wikimedia.org/math/a/7/d/a7d551f78a6ad19adc5a9e451e175d29.png">, <img class="mwe-math-fallback-image-inline tex" alt="n:\textit{Nancy}" src="//upload.wikimedia.org/math/0/f/9/0f9b7bc4310108b61bf0e3dc0cdb1f25.png">, and <img class="mwe-math-fallback-image-inline tex" alt="e:\textit{Eve}" src="//upload.wikimedia.org/math/3/a/6/3a62bdb8fa00bc40c064ed63b0ad03ea.png">. It starts from the background knowledge (cf. picture)</p>
<p>the positive examples</p>
<p>and the trivial proposition <img class="mwe-math-fallback-image-inline tex" alt="\textit{true}" src="//upload.wikimedia.org/math/7/1/b/71b1bde213e6fe43fd6ab8a7f3c172da.png"> to denote the absence of negative examples.</p>
<p>Plotkin's <sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup><sup id="cite_ref-9" class="reference"><a href="#cite_note-9"><span>[</span>9<span>]</span></a></sup> "<i>relative least general generalization (rlgg)</i>" approach to <i>inductive logic programming</i> shall be used to obtain a suggestion about how to formally define the daughter relation <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}" src="//upload.wikimedia.org/math/e/a/8/ea8a29b9393ab61b5ad8f8b3b9a7e0d6.png">.</p>
<p>This approach uses the following steps.</p>
<ul>
<li>Relativize each positive example literal with the complete background knowledge:
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h) \leftarrow \textit{par}(h,m) \land \textit{par}(h,t) \land \textit{par}(g,m) \land \textit{par}(t,e) \land \textit{par}(n,e) \land \textit{fem}(h) \land \textit{fem}(m) \land \textit{fem}(n) \land \textit{fem}(e)" src="//upload.wikimedia.org/math/3/5/1/351a2c4c39df1003f6bfc51eb83c1816.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t) \leftarrow \textit{par}(h,m) \land \textit{par}(h,t) \land \textit{par}(g,m) \land \textit{par}(t,e) \land \textit{par}(n,e) \land \textit{fem}(h) \land \textit{fem}(m) \land \textit{fem}(n) \land \textit{fem}(e)" src="//upload.wikimedia.org/math/6/6/8/668178d803068fcdb5a2f7843a88bce0.png">,</li>
</ul>
</li>
<li>Convert into <a href="/wiki/Clause_normal_form" title="Clause normal form" class="mw-redirect">clause normal form</a>:
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h) \lor \lnot \textit{par}(h,m) \lor \lnot \textit{par}(h,t) \lor \lnot \textit{par}(g,m) \lor \lnot \textit{par}(t,e) \lor \lnot \textit{par}(n,e) \lor \lnot \textit{fem}(h) \lor \lnot \textit{fem}(m) \lor \lnot \textit{fem}(n) \lor \lnot \textit{fem}(e)" src="//upload.wikimedia.org/math/a/6/8/a6879cc5a1d4b6ffe4f57d37e3ea6ac1.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t) \lor \lnot \textit{par}(h,m) \lor \lnot \textit{par}(h,t) \lor \lnot \textit{par}(g,m) \lor \lnot \textit{par}(t,e) \lor \lnot \textit{par}(n,e) \lor \lnot \textit{fem}(h) \lor \lnot \textit{fem}(m) \lor \lnot \textit{fem}(n) \lor \lnot \textit{fem}(e)" src="//upload.wikimedia.org/math/4/2/1/4216f0acd13193c305d5ec466f75ef0c.png">,</li>
</ul>
</li>
<li><a href="/wiki/Anti-unification_(computer_science)" title="Anti-unification (computer science)">Anti-unify</a> each compatible <sup id="cite_ref-10" class="reference"><a href="#cite_note-10"><span>[</span>10<span>]</span></a></sup> pair <sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup> of literals:
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(x_{me},x_{ht})" src="//upload.wikimedia.org/math/7/3/0/7306d4d69afebb37745969b4df8c4f79.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h)" src="//upload.wikimedia.org/math/e/4/c/e4c0ace8180ad04f335ae5e099998dc8.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t)" src="//upload.wikimedia.org/math/5/0/4/504832aa2b3eeaafe11458f5ac509452.png">,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(x_{ht},x_{me})" src="//upload.wikimedia.org/math/b/6/2/b629d8e52ee6239b2b3b4d2e7a3c5900.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(h,m)" src="//upload.wikimedia.org/math/4/c/a/4ca6c856806d93b9df61a4012e6bc3be.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(t,e)" src="//upload.wikimedia.org/math/f/1/2/f128d9cb9ecad7871aba3d4c532cc7bf.png">,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{fem}(x_{me})" src="//upload.wikimedia.org/math/0/8/d/08d1702316a3b2c56f0bdb2893cb96dc.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{fem}(m)" src="//upload.wikimedia.org/math/6/c/0/6c00b5ffb144414bc9865df9e69a202a.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{fem}(e)" src="//upload.wikimedia.org/math/2/b/6/2b60eec3599e4472ca94dfbe741230e1.png">,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png">, similar for all other background-knowledge literals</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(x_{gt},x_{me})" src="//upload.wikimedia.org/math/a/c/8/ac8484536ea54a1b226a765bffd2a3e8.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(t,e)" src="//upload.wikimedia.org/math/f/1/2/f128d9cb9ecad7871aba3d4c532cc7bf.png">, and many more negated literals</li>
</ul>
</li>
<li>Delete all negated literals containing variables that don't occur in a positive literal:
<ul>
<li>after deleting all negated literals containing other variables than <img class="mwe-math-fallback-image-inline tex" alt="x_{me},x_{ht}" src="//upload.wikimedia.org/math/6/d/e/6deb8d634db55cfef5fc1e98b6705301.png">, only <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(x_{me},x_{ht}) \lor \lnot \textit{par}(x_{ht},x_{me}) \lor \lnot \textit{fem}(x_{me})" src="//upload.wikimedia.org/math/1/a/1/1a1c3bb387289cf7a0050b939d0fa427.png"> remains, together with all ground literals from the background knowledge</li>
</ul>
</li>
<li>Convert clauses back to Horn form:
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(x_{me},x_{ht}) \leftarrow \textit{par}(x_{ht},x_{me}) \land \textit{fem}(x_{me}) \land (\text{all background knowledge facts})" src="//upload.wikimedia.org/math/d/3/4/d34fb9023c5262f78d773be9c20e7c5f.png"></li>
</ul>
</li>
</ul>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h) \leftarrow \textit{par}(h,m) \land \textit{par}(h,t) \land \textit{par}(g,m) \land \textit{par}(t,e) \land \textit{par}(n,e) \land \textit{fem}(h) \land \textit{fem}(m) \land \textit{fem}(n) \land \textit{fem}(e)" src="//upload.wikimedia.org/math/3/5/1/351a2c4c39df1003f6bfc51eb83c1816.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t) \leftarrow \textit{par}(h,m) \land \textit{par}(h,t) \land \textit{par}(g,m) \land \textit{par}(t,e) \land \textit{par}(n,e) \land \textit{fem}(h) \land \textit{fem}(m) \land \textit{fem}(n) \land \textit{fem}(e)" src="//upload.wikimedia.org/math/6/6/8/668178d803068fcdb5a2f7843a88bce0.png">,</li>
</ul>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h) \lor \lnot \textit{par}(h,m) \lor \lnot \textit{par}(h,t) \lor \lnot \textit{par}(g,m) \lor \lnot \textit{par}(t,e) \lor \lnot \textit{par}(n,e) \lor \lnot \textit{fem}(h) \lor \lnot \textit{fem}(m) \lor \lnot \textit{fem}(n) \lor \lnot \textit{fem}(e)" src="//upload.wikimedia.org/math/a/6/8/a6879cc5a1d4b6ffe4f57d37e3ea6ac1.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t) \lor \lnot \textit{par}(h,m) \lor \lnot \textit{par}(h,t) \lor \lnot \textit{par}(g,m) \lor \lnot \textit{par}(t,e) \lor \lnot \textit{par}(n,e) \lor \lnot \textit{fem}(h) \lor \lnot \textit{fem}(m) \lor \lnot \textit{fem}(n) \lor \lnot \textit{fem}(e)" src="//upload.wikimedia.org/math/4/2/1/4216f0acd13193c305d5ec466f75ef0c.png">,</li>
</ul>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(x_{me},x_{ht})" src="//upload.wikimedia.org/math/7/3/0/7306d4d69afebb37745969b4df8c4f79.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h)" src="//upload.wikimedia.org/math/e/4/c/e4c0ace8180ad04f335ae5e099998dc8.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t)" src="//upload.wikimedia.org/math/5/0/4/504832aa2b3eeaafe11458f5ac509452.png">,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(x_{ht},x_{me})" src="//upload.wikimedia.org/math/b/6/2/b629d8e52ee6239b2b3b4d2e7a3c5900.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(h,m)" src="//upload.wikimedia.org/math/4/c/a/4ca6c856806d93b9df61a4012e6bc3be.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(t,e)" src="//upload.wikimedia.org/math/f/1/2/f128d9cb9ecad7871aba3d4c532cc7bf.png">,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{fem}(x_{me})" src="//upload.wikimedia.org/math/0/8/d/08d1702316a3b2c56f0bdb2893cb96dc.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{fem}(m)" src="//upload.wikimedia.org/math/6/c/0/6c00b5ffb144414bc9865df9e69a202a.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{fem}(e)" src="//upload.wikimedia.org/math/2/b/6/2b60eec3599e4472ca94dfbe741230e1.png">,</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png">, similar for all other background-knowledge literals</li>
<li><img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(x_{gt},x_{me})" src="//upload.wikimedia.org/math/a/c/8/ac8484536ea54a1b226a765bffd2a3e8.png"> from <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(g,m)" src="//upload.wikimedia.org/math/8/2/a/82a4265c8e089672c4ec1267c8d2789e.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\lnot \textit{par}(t,e)" src="//upload.wikimedia.org/math/f/1/2/f128d9cb9ecad7871aba3d4c532cc7bf.png">, and many more negated literals</li>
</ul>
<ul>
<li>after deleting all negated literals containing other variables than <img class="mwe-math-fallback-image-inline tex" alt="x_{me},x_{ht}" src="//upload.wikimedia.org/math/6/d/e/6deb8d634db55cfef5fc1e98b6705301.png">, only <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(x_{me},x_{ht}) \lor \lnot \textit{par}(x_{ht},x_{me}) \lor \lnot \textit{fem}(x_{me})" src="//upload.wikimedia.org/math/1/a/1/1a1c3bb387289cf7a0050b939d0fa427.png"> remains, together with all ground literals from the background knowledge</li>
</ul>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(x_{me},x_{ht}) \leftarrow \textit{par}(x_{ht},x_{me}) \land \textit{fem}(x_{me}) \land (\text{all background knowledge facts})" src="//upload.wikimedia.org/math/d/3/4/d34fb9023c5262f78d773be9c20e7c5f.png"></li>
</ul>
<p>The resulting Horn clause is the hypothesis <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> obtained by the rlgg approach. Ignoring the background knowledge facts, the clause informally reads "<i><img class="mwe-math-fallback-image-inline tex" alt="x_{me}" src="//upload.wikimedia.org/math/3/4/0/340dd96708bc02575bb85ae8454edb7c.png"> is called a daughter of <img class="mwe-math-fallback-image-inline tex" alt="x_{ht}" src="//upload.wikimedia.org/math/8/d/9/8d95b1e3a42e73c1e3bf1f3373a5ffb8.png"> if <img class="mwe-math-fallback-image-inline tex" alt="x_{ht}" src="//upload.wikimedia.org/math/8/d/9/8d95b1e3a42e73c1e3bf1f3373a5ffb8.png"> is the parent of <img class="mwe-math-fallback-image-inline tex" alt="x_{me}" src="//upload.wikimedia.org/math/3/4/0/340dd96708bc02575bb85ae8454edb7c.png"> and <img class="mwe-math-fallback-image-inline tex" alt="x_{me}" src="//upload.wikimedia.org/math/3/4/0/340dd96708bc02575bb85ae8454edb7c.png"> is female</i>", which is a commonly accepted definition.</p>
<p>Concerning the <a href="#Formal_definition">above</a> requirements, "<i>Necessity</i>" was satisfied because the predicate <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}" src="//upload.wikimedia.org/math/e/a/8/ea8a29b9393ab61b5ad8f8b3b9a7e0d6.png"> doesn't appear in the background knowledge, which hence cannot imply any property containing this predicate, such as the positive examples are. "<i>Sufficiency</i>" is satisfied by the computed hypothesis <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png">, since it, together with <img class="mwe-math-fallback-image-inline tex" alt="\textit{par}(h,m) \land \textit{fem}(m)" src="//upload.wikimedia.org/math/0/d/f/0df7bebe2cd0af5ee379079dddaed8aa.png"> from the background knowledge, implies the first positive example <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(m,h)" src="//upload.wikimedia.org/math/e/4/c/e4c0ace8180ad04f335ae5e099998dc8.png">, and similarly <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> and <img class="mwe-math-fallback-image-inline tex" alt="\textit{par}(t,e) \land \textit{fem}(e)" src="//upload.wikimedia.org/math/f/8/f/f8f9ac69e65f6470b70da8ebe6caac69.png"> from the background knowledge implies the second positive example <img class="mwe-math-fallback-image-inline tex" alt="\textit{dau}(e,t)" src="//upload.wikimedia.org/math/5/0/4/504832aa2b3eeaafe11458f5ac509452.png">. "<i>Weak consistency</i>" is satisfied by <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png">, since <img class="mwe-math-fallback-image-inline tex" alt="h" src="//upload.wikimedia.org/math/2/5/1/2510c39011c5be704182423e3a695e91.png"> holds in the (finite) <a href="/wiki/Herbrand_structure" title="Herbrand structure">Herbrand structure</a> described by the background knowledge; similar for "<i>Strong consistency</i>".</p>
<p>The common definition of the grandmother relation, viz. <img class="mwe-math-fallback-image-inline tex" alt="\textit{gra}(x,z) \leftarrow \textit{fem}(x) \land \textit{par}(x,y) \land \textit{par}(y,z)" src="//upload.wikimedia.org/math/8/c/b/8cb70554467de30f322ef86ab42b72c5.png">, cannot be learned using the above approach, since the variable <img class="mwe-math-fallback-image-inline tex" alt="y" src="//upload.wikimedia.org/math/4/1/5/415290769594460e2e485922904f345d.png"> occurs in the clause body only; the corresponding literals would have been deleted in the 4th step of the approach. To overcome this flaw, that step has to be modified such that it can be parametrized with different <i>literal post-selection heuristics</i>. Historically, the GOLEM implementation is based on the rlgg approach.</p>
<h2><span class="mw-headline" id="Inductive_Logic_Programming_system">Inductive Logic Programming system</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=3" title="Edit section: Inductive Logic Programming system">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Inductive Logic Programming system is a program that takes as an input logic theories <img class="mwe-math-fallback-image-inline tex" alt="B, E^+, E^-" src="//upload.wikimedia.org/math/0/6/c/06c4058dd959f722b84f8d196140e5c0.png"> and outputs a correct hypothesis <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> wrt theories <img class="mwe-math-fallback-image-inline tex" alt="B, E^+, E^-" src="//upload.wikimedia.org/math/0/6/c/06c4058dd959f722b84f8d196140e5c0.png"> An algorithm of an ILP system consists of two parts: hypothesis search and hypothesis selection. First a hypothesis is searched with an inductive logic programming procedure, then a subset of the found hypotheses (in most systems one hypothesis) is chosen by a selection algorithm. A selection algorithm scores each of the found hypotheses and returns the ones with the highest score. An example of score function include minimal compression length where a hypothesis with a lowest <a href="/wiki/Kolmogorov_complexity" title="Kolmogorov complexity">Kolmogorov complexity</a> has the highest score and is returned. An ILP system is complete iff for any input logic theories <img class="mwe-math-fallback-image-inline tex" alt="B, E^+, E^-" src="//upload.wikimedia.org/math/0/6/c/06c4058dd959f722b84f8d196140e5c0.png"> any correct hypothesis <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> wrt to these input theories can be found with its hypothesis search procedure.</p>
<h3><span class="mw-headline" id="Hypothesis_search">Hypothesis search</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=4" title="Edit section: Hypothesis search">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Modern ILP systems like Progol,<sup id="cite_ref-muggleton1995inverse_5-1" class="reference"><a href="#cite_note-muggleton1995inverse-5"><span>[</span>5<span>]</span></a></sup> Hail <sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup> and Imparo <sup id="cite_ref-13" class="reference"><a href="#cite_note-13"><span>[</span>13<span>]</span></a></sup> find a hypothesis <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png"> using the principle of the inverse entailment<sup id="cite_ref-muggleton1995inverse_5-2" class="reference"><a href="#cite_note-muggleton1995inverse-5"><span>[</span>5<span>]</span></a></sup> for theories <img class="mwe-math-fallback-image-inline tex" alt="B" src="//upload.wikimedia.org/math/9/d/5/9d5ed678fe57bcca610140957afab571.png">, <img class="mwe-math-fallback-image-inline tex" alt="E" src="//upload.wikimedia.org/math/3/a/3/3a3ea00cfc35332cedf6e5e9a32e94da.png">, <img class="mwe-math-fallback-image-inline tex" alt="H" src="//upload.wikimedia.org/math/c/1/d/c1d9f50f86825a1a2302ec2449c17196.png">: <img class="mwe-math-fallback-image-inline tex" alt="B \land H \models E \iff B \land \neg E \models \neg H" src="//upload.wikimedia.org/math/6/e/9/6e9aef4f938df14ac5f89a7b432e74a4.png">. First they construct an intermediate theory <img class="mwe-math-fallback-image-inline tex" alt="F" src="//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png"> called a bridge theory satisfying the conditions <img class="mwe-math-fallback-image-inline tex" alt="B \land \neg E \models F" src="//upload.wikimedia.org/math/b/9/7/b97eee12d318afc581995ecb2af77455.png"> and <img class="mwe-math-fallback-image-inline tex" alt="F \models \neg H" src="//upload.wikimedia.org/math/5/a/f/5af5aca698130d8166ea4442eddb3d4c.png">. Then as <img class="mwe-math-fallback-image-inline tex" alt="H \models \neg F" src="//upload.wikimedia.org/math/d/b/f/dbfcd53023d9810dad4654d6c7397355.png">, they generalize the negation of the bridge theory <img class="mwe-math-fallback-image-inline tex" alt="F" src="//upload.wikimedia.org/math/8/0/0/800618943025315f869e4e1f09471012.png"> with the anti-entailment.<sup id="cite_ref-14" class="reference"><a href="#cite_note-14"><span>[</span>14<span>]</span></a></sup> However, the operation of the anti-entailment since being highly non-deterministic is computationally more expensive. Therefore an alternative hypothesis search can be conducted using the operation of the inverse subsumption (anti-subsumption) instead which is less non-deterministic than anti-entailment.</p>
<p>Questions of completeness of a hypothesis search procedure of specific ILP system arise. For example, Progol's hypothesis search procedure based on the inverse entailment inference rule is not complete by <b>Yamamoto's example</b>.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>15<span>]</span></a></sup> On the other hand, Imparo is complete by both anti-entailment procedure <sup id="cite_ref-kimber2009induction_16-0" class="reference"><a href="#cite_note-kimber2009induction-16"><span>[</span>16<span>]</span></a></sup> and its extended inverse subsumption <sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>17<span>]</span></a></sup> procedure.</p>
<h3><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=5" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li>1BC and 1BC2: first-order naive Bayesian classifiers: (<a rel="nofollow" class="external free" href="http://www.cs.bris.ac.uk/Research/MachineLearning/1BC/">http://www.cs.bris.ac.uk/Research/MachineLearning/1BC/</a>)</li>
<li>ACE (A Combined Engine) (<a rel="nofollow" class="external free" href="http://dtai.cs.kuleuven.be/ACE/">http://dtai.cs.kuleuven.be/ACE/</a>)</li>
<li>Aleph (<a rel="nofollow" class="external free" href="http://web.comlab.ox.ac.uk/oucl/research/areas/machlearn/Aleph/">http://web.comlab.ox.ac.uk/oucl/research/areas/machlearn/Aleph/</a>)</li>
<li>Atom (<a rel="nofollow" class="external free" href="http://www.ahlgren.info/research/atom/">http://www.ahlgren.info/research/atom/</a>)</li>
<li>Claudien (<a rel="nofollow" class="external free" href="http://dtai.cs.kuleuven.be/claudien/">http://dtai.cs.kuleuven.be/claudien/</a>)</li>
<li>DL-Learner (<a rel="nofollow" class="external free" href="http://dl-learner.org">http://dl-learner.org</a>)</li>
<li>DMax (<a rel="nofollow" class="external free" href="http://dtai.cs.kuleuven.be/dmax/">http://dtai.cs.kuleuven.be/dmax/</a>)</li>
<li><a href="/wiki/First_Order_Inductive_Learner" title="First Order Inductive Learner">FOIL</a> (<a rel="nofollow" class="external free" href="ftp://ftp.cs.su.oz.au/pub/foil6.sh">ftp://ftp.cs.su.oz.au/pub/foil6.sh</a>)</li>
<li><a href="/wiki/Golem_(ILP)" title="Golem (ILP)">Golem (ILP)</a> (<a rel="nofollow" class="external free" href="http://www.doc.ic.ac.uk/~shm/Software/golem">http://www.doc.ic.ac.uk/~shm/Software/golem</a>)</li>
<li>Imparo<sup id="cite_ref-kimber2009induction_16-1" class="reference"><a href="#cite_note-kimber2009induction-16"><span>[</span>16<span>]</span></a></sup></li>
<li>Inthelex (INcremental THEory Learner from EXamples) (<a rel="nofollow" class="external free" href="http://lacam.di.uniba.it:8000/systems/inthelex/">http://lacam.di.uniba.it:8000/systems/inthelex/</a>)</li>
<li>Lime (<a rel="nofollow" class="external free" href="http://cs.anu.edu.au/people/Eric.McCreath/lime.html">http://cs.anu.edu.au/people/Eric.McCreath/lime.html</a>)</li>
<li>Mio (<a rel="nofollow" class="external free" href="http://libra.msra.cn/Publication/3392493/mio-user-s-manual">http://libra.msra.cn/Publication/3392493/mio-user-s-manual</a>)</li>
<li>MIS (Model Inference System) by Ehud Shapiro</li>
<li><a href="/wiki/PROGOL" title="PROGOL">PROGOL</a> (<a rel="nofollow" class="external free" href="http://www.doc.ic.ac.uk/~shm/Software/progol5.0">http://www.doc.ic.ac.uk/~shm/Software/progol5.0</a>)</li>
<li>RSD (<a rel="nofollow" class="external free" href="http://labe.felk.cvut.cz/~zelezny/rsd/">http://labe.felk.cvut.cz/~zelezny/rsd/</a>)</li>
<li>Warmr (now included in ACE)</li>
<li>ProGolem (<a rel="nofollow" class="external free" href="http://ilp.doc.ic.ac.uk/ProGolem/">http://ilp.doc.ic.ac.uk/ProGolem/</a>) <sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>18<span>]</span></a></sup><sup id="cite_ref-19" class="reference"><a href="#cite_note-19"><span>[</span>19<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Inductive_inference" title="Inductive inference" class="mw-redirect">Inductive inference</a></li>
<li><a href="/wiki/Inductive_reasoning" title="Inductive reasoning">Inductive reasoning</a></li>
<li><a href="/wiki/Inductive_programming" title="Inductive programming">Inductive programming</a></li>
<li><a href="/wiki/Inductive_probability" title="Inductive probability">Inductive probability</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Shapiro, Ehud Y. Inductive inference of theories from facts, Research Report 192, Yale University, Department of Computer Science, 1981. Reprinted in J.-L. Lassez, G. Plotkin (Eds.), Computational Logic, The MIT Press, Cambridge, MA, 1991, pp. 199–254.</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Shapiro, Ehud Y. (1983). <i>Algorithmic program debugging</i>. Cambridge, Mass: MIT Press. <a href="/wiki/ISBN" title="ISBN" class="mw-redirect">ISBN</a> <a href="/wiki/Special:BookSources/0-262-19218-7" title="Special:BookSources/0-262-19218-7">0-262-19218-7</a></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">Shapiro, Ehud Y. "The model inference system." Proceedings of the 7th international joint conference on Artificial intelligence-Volume 2. Morgan Kaufmann Publishers Inc., 1981.</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text">Luc De Raedt. A Perspective on Inductive Logic Programming. The Workshop on Current and Future Trends in Logic Programming, Shakertown, to appear in Springer LNCS, 1999. <a href="/wiki/CiteSeerX" title="CiteSeerX" class="mw-redirect">CiteSeerX</a>: <span class="url"><a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.1790">10.1.1.56.1790</a></span></span></li>
<li id="cite_note-muggleton1995inverse-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-muggleton1995inverse_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-muggleton1995inverse_5-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-muggleton1995inverse_5-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Muggleton, S. (1991). "Inductive logic programming". <i>New Generation Computing</i> <b>8</b> (4): 295–318. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2FBF03037089">10.1007/BF03037089</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=Inductive+logic+programming&amp;rft.aufirst=S.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.&amp;rft.date=1991&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1007%2FBF03037089&amp;rft.issue=4&amp;rft.jtitle=New+Generation+Computing&amp;rft.pages=295-318&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=8" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1007.2FBF03037089&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span class="citation journal">Muggleton, Stephen (1999). "Inductive Logic Programming: Issues, Results and the Challenge of Learning Language in Logic". <i>Artificial Intelligence</i> <b>114</b>: 283–296. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fs0004-3702%2899%2900067-3">10.1016/s0004-3702(99)00067-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=Inductive+Logic+Programming%3A+Issues%2C+Results+and+the+Challenge+of+Learning+Language+in+Logic&amp;rft.aufirst=Stephen&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+Stephen&amp;rft.date=1999&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2Fs0004-3702%2899%2900067-3&amp;rft.jtitle=Artificial+Intelligence&amp;rft.pages=283-296&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=114" class="Z3988"><span style="display:none;"> </span></span>; here: Sect.2.1</span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span id="CITEREFD.C5.BEeroski1996" class="citation">Džeroski, Sašo (1996), "Inductive Logic Programming and Knowledge Discovery in Databases", in Fayyad, U.M.; Piatetsky-Shapiro, G.; Smith, P. et al., <i>Advances in Knowledge Discovery and Data Mining</i>, MIT Press, pp. 117–152</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=Advances+in+Knowledge+Discovery+and+Data+Mining&amp;rft.au=D%C5%BEeroski%2C+Sa%C5%A1o&amp;rft.aufirst=Sa%C5%A1o&amp;rft.aulast=D%C5%BEeroski&amp;rft.btitle=Inductive+Logic+Programming+and+Knowledge+Discovery+in+Databases&amp;rft.date=1996&amp;rft.genre=bookitem&amp;rft.pages=117-152&amp;rft.pub=MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span> <span style="display:none;font-size:100%" class="error citation-comment"><code style="color:inherit; border:inherit; padding:inherit;">|displayeditors=</code> suggested (<a href="/wiki/Help:CS1_errors#displayeditors" title="Help:CS1 errors">help</a>)</span>; here: Sect.5.2.4</span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><span class="citation journal">Plotkin, Gordon D. (1970). Meltzer, B.; Michie, D., eds. "A Note on Inductive Generalization". <i>Machine Intelligence</i> (Edinburgh University Press) <b>5</b>: 153–163.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=A+Note+on+Inductive+Generalization&amp;rft.aufirst=Gordon+D.&amp;rft.aulast=Plotkin&amp;rft.au=Plotkin%2C+Gordon+D.&amp;rft.date=1970&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=153-163&amp;rft.pub=Edinburgh+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=5" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-9"><span class="mw-cite-backlink"><b><a href="#cite_ref-9">^</a></b></span> <span class="reference-text"><span class="citation journal">Plotkin, Gordon D. (1971). Meltzer, B.; Michie, D., eds. "A Further Note on Inductive Generalization". <i>Machine Intelligence</i> (Edinburgh University Press) <b>6</b>: 101–124.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=A+Further+Note+on+Inductive+Generalization&amp;rft.aufirst=Gordon+D.&amp;rft.aulast=Plotkin&amp;rft.au=Plotkin%2C+Gordon+D.&amp;rft.date=1971&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.pages=101-124&amp;rft.pub=Edinburgh+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=6" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-10"><span class="mw-cite-backlink"><b><a href="#cite_ref-10">^</a></b></span> <span class="reference-text">i.e. sharing the same predicate symbol and negated/unnegated status</span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text">in general: <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png">-tuple when <img class="mwe-math-fallback-image-inline tex" alt="n" src="//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"> positive example literals are given</span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text">Ray, O., Broda, K., &amp; Russo, A. M. (2003). Hybrid abductive inductive learning. In LNCS: Vol. 2835. Pro- ceedings of the 13th international conference on inductive logic programming (pp. 311–328). Berlin: Springer.</span></li>
<li id="cite_note-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-13">^</a></b></span> <span class="reference-text">Kimber, T., Broda, K., &amp; Russo, A. (2009). Induction on failure: learning connected Horn theories. In LNCS: Vol. 5753. Proceedings of the 10th international conference on logic programing and nonmonotonic reasoning (pp. 169–181). Berlin: Springer.</span></li>
<li id="cite_note-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-14">^</a></b></span> <span class="reference-text">Yoshitaka Yamamoto, Katsumi Inoue, and Koji Iwanuma. Inverse subsumption for complete explana- tory induction. Machine learning, 86(1):115–139, 2012.</span></li>
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text">Akihiro Yamamoto. Which hypotheses can be found with inverse entailment? In Inductive Logic Programming, pages 296–308. Springer, 1997.</span></li>
<li id="cite_note-kimber2009induction-16"><span class="mw-cite-backlink">^ <a href="#cite_ref-kimber2009induction_16-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-kimber2009induction_16-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text">Timothy Kimber. Learning definite and normal logic programs by induction on failure. PhD thesis, Imperial College London, 2012.</span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text">David Toth (2014). Imparo is complete by inverse subsumption. arXiv:1407.3836</span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text"><span class="citation journal">Muggleton, Stephen; Santos, Jose; Tamaddoni-Nezhad, Alireza (2009). <a rel="nofollow" class="external text" href="http://www.doc.ic.ac.uk/~jcs06/papers/ilp09/progolem.pdf">"ProGolem: a system based on relative minimal generalization"</a>. <i>ILP</i>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=ProGolem%3A+a+system+based+on+relative+minimal+generalization&amp;rft.aufirst=Stephen&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+Stephen&amp;rft.au=Santos%2C+Jose&amp;rft.au=Tamaddoni-Nezhad%2C+Alireza&amp;rft.date=2009&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.doc.ic.ac.uk%2F~jcs06%2Fpapers%2Filp09%2Fprogolem.pdf&amp;rft.jtitle=ILP&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-19"><span class="mw-cite-backlink"><b><a href="#cite_ref-19">^</a></b></span> <span class="reference-text"><span class="citation journal">Santos, Jose; Nassif, Houssam; Page, David; Muggleton, Stephen; Sternberg, Mike (2012). <a rel="nofollow" class="external text" href="http://www.doc.ic.ac.uk/~jcs06/Hexose/hexose.pdf">"Automated identification of features of protein-ligand interactions using Inductive Logic Programming: a hexose binding case study"</a>. <i>BMC Bioinformatics</i> <b>13</b>: 162.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=Automated+identification+of+features+of+protein-ligand+interactions+using+Inductive+Logic+Programming%3A+a+hexose+binding+case+study&amp;rft.aufirst=Jose&amp;rft.aulast=Santos&amp;rft.au=Muggleton%2C+Stephen&amp;rft.au=Nassif%2C+Houssam&amp;rft.au=Page%2C+David&amp;rft.au=Santos%2C+Jose&amp;rft.au=Sternberg%2C+Mike&amp;rft.date=2012&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.doc.ic.ac.uk%2F~jcs06%2FHexose%2Fhexose.pdf&amp;rft.jtitle=BMC+Bioinformatics&amp;rft.pages=162&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=13" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Inductive_logic_programming&amp;action=edit&amp;section=8" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation journal">Muggleton, S.; De Raedt, L. (1994). "Inductive Logic Programming: Theory and methods". <i>The Journal of Logic Programming</i>. 19-20: 629–679. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0743-1066%2894%2990035-3">10.1016/0743-1066(94)90035-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.atitle=Inductive+Logic+Programming%3A+Theory+and+methods&amp;rft.au=De+Raedt%2C+L.&amp;rft.aufirst=S.&amp;rft.aulast=Muggleton&amp;rft.au=Muggleton%2C+S.&amp;rft.date=1994&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2F0743-1066%2894%2990035-3&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.pages=629-679&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=19-20" class="Z3988"><span style="display:none;"> </span></span> <span class="plainlinks noprint" style="font-size:smaller"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Cite_doi/10.1016.2F0743-1066.2894.2990035-3&amp;action=edit&amp;editintro=Template:Cite_doi/editintro2">edit</a></span></li>
<li><span class="citation book">Lavrac, N.; Dzeroski, S. (1994). <a rel="nofollow" class="external text" href="http://www-ai.ijs.si/SasoDzeroski/ILPBook/"><i>Inductive Logic Programming: Techniques and Applications</i></a>. New York: Ellis Horwood. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-13-457870-8" title="Special:BookSources/0-13-457870-8">0-13-457870-8</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+logic+programming&amp;rft.au=Dzeroski%2C+S.&amp;rft.aufirst=N.&amp;rft.aulast=Lavrac&amp;rft.au=Lavrac%2C+N.&amp;rft.btitle=Inductive+Logic+Programming%3A+Techniques+and+Applications&amp;rft.date=1994&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww-ai.ijs.si%2FSasoDzeroski%2FILPBook%2F&amp;rft.isbn=0-13-457870-8&amp;rft.place=New+York&amp;rft.pub=Ellis+Horwood&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li>Visual example of inducing the grandparenthood relation by the <a href="#Implementations">Atom system</a>. <a rel="nofollow" class="external free" href="http://john-ahlgren.blogspot.com/2014/03/inductive-reasoning-visualized.html">http://john-ahlgren.blogspot.com/2014/03/inductive-reasoning-visualized.html</a></li>
</ul>
