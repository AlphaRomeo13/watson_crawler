<h1>Defining Methods</h1>
<p>Here is an example of a typical method declaration:</p>
<p>WHATSON? 691664c9-1bbe-474a-8f87-fc69f8d1074b</p>
<pre>
public double calculateAnswer(double wingSpan, int numberOfEngines,
                              double length, double grossTons) {
    //do the calculation here
}
</pre>
<p>The only required elements of a method declaration are the method's return type, name, a pair of parentheses, <code>()</code>, and a body between braces, <code>{}</code>.</p>
<p>More generally, method declarations have six components, in order:</p>
<ol>
<li>Modifierssuch as <code>public</code>, <code>private</code>, and others you will learn about later.</li>
<li>The return typethe data type of the value returned by the method, or <code>void</code> if the method does not return a value.</li>
<li>The method namethe rules for field names apply to method names as well, but the convention is a little different.</li>
<li>The parameter list in parenthesisa comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, <code>()</code>. If there are no parameters, you must use empty parentheses.</li>
<li>An exception listto be discussed later.</li>
<li>The method body, enclosed between bracesthe method's code, including the declaration of local variables, goes here.</li>
</ol>
<p>Modifiers, return types, and parameters will be discussed later in this 
lesson.
 Exceptions are discussed in a later 
lesson. 
</p>
<p>The signature of the method declared above is:</p>
<p>WHATSON? 119805dc-e682-458a-a5c1-a95a0b40e85c</p>
<pre>
calculateAnswer(double, int, double, double)
</pre>
<h2>Naming a Method</h2>
<p>Although a method name can be any legal identifier, code conventions restrict method names. By convention, method names should be a verb in lowercase or a multi-word name that begins with a verb in lowercase, followed by adjectives, nouns, etc. In multi-word names, the first letter of each of the second and following words should be capitalized. Here are some examples:</p>
<p>WHATSON? 406d20ac-f4e3-42a4-abbe-cd8e62a3ce8f</p>
<pre>
run
runFast
getBackground
getFinalData
compareTo
setX
isEmpty
</pre>
<p>Typically, a method has a unique name within its class. However, a method might have the same name as other methods due to <i>method overloading</i>.</p>
<h2>Overloading Methods</h2>
<p>The Java programming language supports <i>overloading</i> methods, and Java can distinguish between methods with different <i>method signatures</i>. This means that methods within a class can have the same name if they have different parameter lists (there are some qualifications to this that will be discussed in 
the lesson titled 
"Interfaces and Inheritance").</p>
<p>Suppose that you have a class that can use calligraphy to draw various types of data (strings, integers, and so on) and that contains a method for drawing each data type. It is cumbersome to use a new name for each methodfor example, <code>drawString</code>, <code>drawInteger</code>, <code>drawFloat</code>, and so on. In the Java programming language, you can use the same name for all the drawing methods but pass a different argument list to each method. Thus, the data drawing class might declare four methods named <code>draw</code>, each of which has a different parameter list.</p>
<p>WHATSON? 82b01ac4-f5cd-4abf-b2c6-94e300128b13</p>
<pre>
public class DataArtist {
    ...
    public void draw(String s) {
        ...
    }
    public void draw(int i) {
        ...
    }
    public void draw(double f) {
        ...
    }
    public void draw(int i, double f) {
        ...
    }
}
</pre>
<p>Overloaded methods are differentiated by the number and the type of the arguments passed into the method. In the code sample, <code>draw(String s)</code> and <code>draw(int i)</code> are distinct and unique methods because they require different argument types.</p>
<p>You cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.</p>
<p>The compiler does not consider return type when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type.</p>
