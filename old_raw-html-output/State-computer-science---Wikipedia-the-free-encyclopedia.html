<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">State (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a> and <a href="/wiki/Automata_theory" title="Automata theory">automata theory</a>, the <b>state</b> of a <a href="/wiki/Digital_logic" title="Digital logic" class="mw-redirect">digital logic</a> circuit or <a href="/wiki/Computer_program" title="Computer program">computer program</a> is a technical term for all the stored <a href="/wiki/Information" title="Information">information</a>, at a given instant in time, to which the circuit or program has access.<sup id="cite_ref-Harris_1-0" class="reference"><a href="#cite_note-Harris-1"><span>[</span>1<span>]</span></a></sup> The <a href="/wiki/Input/output" title="Input/output">output</a> of a digital circuit or computer program at any time is completely determined by its current <a href="/wiki/Input/output" title="Input/output">inputs</a> and its state.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Digital_logic_circuit_state"><span class="tocnumber">1</span> <span class="toctext">Digital logic circuit state</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Program_state"><span class="tocnumber">2</span> <span class="toctext">Program state</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Finite_state_machines"><span class="tocnumber">3</span> <span class="toctext">Finite state machines</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Types_of_states"><span class="tocnumber">4</span> <span class="toctext">Types of states</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Digital_logic_circuit_state">Digital logic circuit state</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=State_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Digital logic circuit state">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Digital_logic" title="Digital logic" class="mw-redirect">Digital logic</a> circuits can be divided into two types: <a href="/wiki/Combinational_logic" title="Combinational logic">combinational logic</a>, whose output <a href="/wiki/Digital_signal" title="Digital signal">signals</a> are dependent only on its present input signals, and <a href="/wiki/Sequential_logic" title="Sequential logic">sequential logic</a>, whose outputs are a function of both the current inputs and the past history of inputs.<sup id="cite_ref-Kaeslin_2-0" class="reference"><a href="#cite_note-Kaeslin-2"><span>[</span>2<span>]</span></a></sup> In sequential logic, information from past inputs is stored in electronic memory elements, such as <a href="/wiki/Flip-flop_(electronics)" title="Flip-flop (electronics)">flip-flops</a> and <a href="/wiki/Latch_(electronics)" title="Latch (electronics)" class="mw-redirect">latches</a>. The stored contents of these memory elements, at a given point in time, is collectively referred to as the circuit's "<i>state</i>" and contains all the information about the past to which the circuit has access.<sup id="cite_ref-Srinath_3-0" class="reference"><a href="#cite_note-Srinath-3"><span>[</span>3<span>]</span></a></sup></p>
<p>For example, the state of a <a href="/wiki/Microprocessor" title="Microprocessor">microprocessor</a> (computer chip) is the contents of all the memory elements in it: the <a href="/wiki/Accumulator_(computing)" title="Accumulator (computing)">accumulators</a>, <a href="/wiki/Processor_register" title="Processor register">storage registers</a>, <a href="/wiki/Data_cache" title="Data cache" class="mw-redirect">data caches</a>, and <a href="/wiki/Flag_(computing)" title="Flag (computing)" class="mw-redirect">flags</a>. When computers such as laptops go into a "<a href="/wiki/Hibernation_(computing)" title="Hibernation (computing)">hibernation</a>" mode to save energy by shutting down the processor, the state of the processor is stored on the computer's <a href="/wiki/Hard_disk" title="Hard disk" class="mw-redirect">disk</a>, so it can be restored when the computer comes out of hibernation, and the processor can take up operations where it left off.</p>
<h2><span class="mw-headline" id="Program_state">Program state</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=State_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Program state">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Similarly, a computer program stores data in <a href="/wiki/Variable_(computer_science)" title="Variable (computer science)">variables</a>, which represent storage locations in the computer's <a href="/wiki/Computer_memory" title="Computer memory">memory</a>. The contents of these memory locations, at any given point in the program's execution, is called the program's <i>state</i>.<sup id="cite_ref-Laplante_4-0" class="reference"><a href="#cite_note-Laplante-4"><span>[</span>4<span>]</span></a></sup><sup id="cite_ref-Misra_5-0" class="reference"><a href="#cite_note-Misra-5"><span>[</span>5<span>]</span></a></sup><sup id="cite_ref-Prata_6-0" class="reference"><a href="#cite_note-Prata-6"><span>[</span>6<span>]</span></a></sup></p>
<p><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative programming</a> is a <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming paradigm</a> (way of designing a <a href="/wiki/Programming_language" title="Programming language">programming language</a>) that describes computation in terms of the program state and statements that change the program state. In contrast, in <a href="/wiki/Declarative_programming" title="Declarative programming">declarative programming</a> languages the program describes the desired results, and doesn't specify changes to the state directly.</p>
<p>A more specialized definition of state is used in some computer programs that operate <a href="/wiki/Serial_communication" title="Serial communication">serially</a> (sequentially) on streams of data, such as <a href="/wiki/Parser" title="Parser" class="mw-redirect">parsers</a>, <a href="/wiki/Firewall_(computing)" title="Firewall (computing)">firewalls</a>, <a href="/wiki/Communication_protocol" title="Communication protocol" class="mw-redirect">communication protocols</a> and <a href="/wiki/Encryption" title="Encryption">encryption</a> programs. In some of these programs, information about previous data characters or packets received is stored in variables and used to affect the processing of the current character or packet. This is called a "<a href="/wiki/Stateless_protocol" title="Stateless protocol">stateful protocol</a>" and the data carried over from the previous processing cycle is called the "state". In others, the program has no information about the previous data stream and starts "fresh" with each data input; this is called a "<a href="/wiki/Stateless_protocol" title="Stateless protocol">stateless protocol</a>".</p>
<h2><span class="mw-headline" id="Finite_state_machines">Finite state machines</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=State_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Finite state machines">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The output of a sequential circuit or computer program at any time is completely determined by its current inputs and current state. Since each <a href="/wiki/Binary_digit" title="Binary digit" class="mw-redirect">binary</a> memory element has only two possible states, 0 or 1, the total number of different states a circuit can assume is finite, and fixed by the number of memory elements. If there are <i>N</i> binary memory elements, a digital circuit can have at most 2<sup><i>N</i></sup> distinct states. The concept of state is formalized in an abstract mathematical <a href="/wiki/Model_of_computation" title="Model of computation">model of computation</a> called a <a href="/wiki/Finite_state_machine" title="Finite state machine" class="mw-redirect">finite state machine</a>, used to design both sequential digital circuits and computer programs.</p>
<h2><span class="mw-headline" id="Types_of_states">Types of states</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=State_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Types of states">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following states are distinguished:</p>
<ul>
<li><b>Compatible states</b> are states in a <a href="/wiki/State_machine" title="State machine" class="mw-redirect">state machine</a> that do not conflict for any input values. Thus for every input, both states must have the same output, and both states must have the same successor (or unspecified successors), or both must not change. Compatible states are redundant, if occurring in the same state machine.</li>
<li><b>Distinguishable states</b> are states in a state machine that have at least one input sequence causing different output sequences - no matter which state is the initial state.</li>
<li><b>Equivalent states</b> are states in a state machine which, for every possible input sequence, the same output sequence will be produced - no matter which state is the initial state.</li>
</ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=State_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Data_(computing)" title="Data (computing)">Data (computing)</a></li>
<li><a href="/wiki/Finite_state_machine" title="Finite state machine" class="mw-redirect">Finite state machine</a> (FSM)</li>
<li><a href="/wiki/Mode_(computer_interface)" title="Mode (computer interface)">Mode (computer interface)</a></li>
<li><a href="/wiki/Soft_state_(computer_science)" title="Soft state (computer science)" class="mw-redirect">Soft state (computer science)</a></li>
<li><a href="/wiki/State_diagram" title="State diagram">State diagram</a></li>
<li><a href="/wiki/State_monad" title="State monad" class="mw-redirect">State monad</a></li>
<li><a href="/wiki/State_space_(dynamical_system)" title="State space (dynamical system)" class="mw-redirect">State space (dynamical system)</a></li>
<li><a href="/wiki/Stateless_protocol" title="Stateless protocol">Stateless protocol</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=State_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-Harris-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-Harris_1-0">^</a></b></span> <span class="reference-text"><span class="citation book">Harris, David Money; Sarah L. Harris (2007). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=5X7JV5-n0FIC&amp;pg=PA115&amp;lpg=PA115&amp;dq=state+definition+digital&amp;source=bl&amp;ots=UR5dOM0l02&amp;sig=hh41cAzR_-srVbTf5DrQ7YTZrJM&amp;hl=en&amp;sa=X&amp;ei=qwArUMaAHuP9iwKJ9YDADQ&amp;ved=0CGAQ6AEwBw#v=onepage&amp;q=state&amp;f=false"><i>Digital Design and Computer Architecture</i></a>. USA: Morgan Kaufmann. p. 103. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0123704979" title="Special:BookSources/0123704979">0123704979</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AState+%28computer+science%29&amp;rft.aufirst=David+Money&amp;rft.au=Harris%2C+David+Money&amp;rft.aulast=Harris&amp;rft.au=Sarah+L.+Harris&amp;rft.btitle=Digital+Design+and+Computer+Architecture&amp;rft.date=2007&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3D5X7JV5-n0FIC%26pg%3DPA115%26lpg%3DPA115%26dq%3Dstate%2Bdefinition%2Bdigital%26source%3Dbl%26ots%3DUR5dOM0l02%26sig%3Dhh41cAzR_-srVbTf5DrQ7YTZrJM%26hl%3Den%26sa%3DX%26ei%3DqwArUMaAHuP9iwKJ9YDADQ%26ved%3D0CGAQ6AEwBw%23v%3Donepage%26q%3Dstate%26f%3Dfalse&amp;rft.isbn=0123704979&amp;rft.pages=103&amp;rft.place=USA&amp;rft.pub=Morgan+Kaufmann&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Kaeslin-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-Kaeslin_2-0">^</a></b></span> <span class="reference-text"><span class="citation book">Kaeslin, Hubert (2008). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=gdRStcYgf2oC&amp;pg=PA783&amp;lpg=PA783&amp;dq=state+definition+digital&amp;source=bl&amp;ots=MIAK2x-71J&amp;sig=t1apKSXU1R2qy36V2djD1fOAbt4&amp;hl=en&amp;sa=X&amp;ei=6ykrUOvqN6XNiwKcsoD4BQ&amp;ved=0CDgQ6AEwATgU#v=onepage&amp;q=state&amp;f=false"><i>Digital Integrated Circuit Design: From VLSI Architectures to CMOS Fabrication</i></a>. UK: Cambridge University Press. p. 735. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0521882672" title="Special:BookSources/0521882672">0521882672</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AState+%28computer+science%29&amp;rft.aufirst=Hubert&amp;rft.au=Kaeslin%2C+Hubert&amp;rft.aulast=Kaeslin&amp;rft.btitle=Digital+Integrated+Circuit+Design%3A+From+VLSI+Architectures+to+CMOS+Fabrication&amp;rft.date=2008&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DgdRStcYgf2oC%26pg%3DPA783%26lpg%3DPA783%26dq%3Dstate%2Bdefinition%2Bdigital%26source%3Dbl%26ots%3DMIAK2x-71J%26sig%3Dt1apKSXU1R2qy36V2djD1fOAbt4%26hl%3Den%26sa%3DX%26ei%3D6ykrUOvqN6XNiwKcsoD4BQ%26ved%3D0CDgQ6AEwATgU%23v%3Donepage%26q%3Dstate%26f%3Dfalse&amp;rft.isbn=0521882672&amp;rft.pages=735&amp;rft.place=UK&amp;rft.pub=Cambridge+University+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Srinath-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-Srinath_3-0">^</a></b></span> <span class="reference-text"><span class="citation book">Srinath, N. K. (August 2005). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=FIYGSv3-C6IC&amp;pg=PA46"><i>8085 Microprocessor: Programming and Interfacing</i></a>. Prentice-Hall of India Pvt. Ltd. p. 326. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-8120327856" title="Special:BookSources/978-8120327856">978-8120327856</a><span class="reference-accessdate">. Retrieved 7 December 2012</span>. "page 46"</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AState+%28computer+science%29&amp;rft.aufirst=N.+K.&amp;rft.aulast=Srinath&amp;rft.au=Srinath%2C+N.+K.&amp;rft.btitle=8085+Microprocessor%3A+Programming+and+Interfacing&amp;rft.date=August+2005&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DFIYGSv3-C6IC%26pg%3DPA46&amp;rft.isbn=978-8120327856&amp;rft.pages=326&amp;rft.pub=Prentice-Hall+of+India+Pvt.+Ltd&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Laplante-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-Laplante_4-0">^</a></b></span> <span class="reference-text"><span class="citation book">Laplante, Philip A. (2000). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=U1M3clUwCfEC&amp;pg=PA24&amp;dq=%22Program+state%22+%22"><i>Dictionary of Computer Science, Engineering and Technology</i></a>. USA: CRC Press. p. 466. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0849326915" title="Special:BookSources/0849326915">0849326915</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AState+%28computer+science%29&amp;rft.aufirst=Philip+A.&amp;rft.au=Laplante%2C+Philip+A.&amp;rft.aulast=Laplante&amp;rft.btitle=Dictionary+of+Computer+Science%2C+Engineering+and+Technology&amp;rft.date=2000&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DU1M3clUwCfEC%26pg%3DPA24%26dq%3D%2522Program%2Bstate%2522%2B%2522&amp;rft.isbn=0849326915&amp;rft.pages=466&amp;rft.place=USA&amp;rft.pub=CRC+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Misra-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-Misra_5-0">^</a></b></span> <span class="reference-text"><span class="citation book">Misra, Jayadev (2001). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=eZtxLnc3NbYC&amp;pg=PA14&amp;dq=%22Program+state%22+variables"><i>A Discipline of Multiprogramming: Programming Theory for Distributed Applications</i></a>. Springer. p. 14. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0387952063" title="Special:BookSources/0387952063">0387952063</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AState+%28computer+science%29&amp;rft.aufirst=Jayadev&amp;rft.aulast=Misra&amp;rft.au=Misra%2C+Jayadev&amp;rft.btitle=A+Discipline+of+Multiprogramming%3A+Programming+Theory+for+Distributed+Applications&amp;rft.date=2001&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DeZtxLnc3NbYC%26pg%3DPA14%26dq%3D%2522Program%2Bstate%2522%2Bvariables&amp;rft.isbn=0387952063&amp;rft.pages=14&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Prata-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-Prata_6-0">^</a></b></span> <span class="reference-text"><span class="citation book">Prata, Stephen Prata (2004). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=MYWQbufdVU4C&amp;pg=PT113&amp;dq=%22Program+state%22+variables"><i>C Primer Plus, 5th Ed.</i></a>. Pearson Education. pp. 113–114. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0132713608" title="Special:BookSources/0132713608">0132713608</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AState+%28computer+science%29&amp;rft.aufirst=Stephen+Prata&amp;rft.aulast=Prata&amp;rft.au=Prata%2C+Stephen+Prata&amp;rft.btitle=C+Primer+Plus%2C+5th+Ed.&amp;rft.date=2004&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DMYWQbufdVU4C%26pg%3DPT113%26dq%3D%2522Program%2Bstate%2522%2Bvariables&amp;rft.isbn=0132713608&amp;rft.pages=113-114&amp;rft.pub=Pearson+Education&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
