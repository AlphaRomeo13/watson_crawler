<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Abductive logic programming</span></h1>
<ul>
<li><a href="/wiki/Action_language" title="Action language">Action</a></li>
<li><a href="/wiki/Agent-oriented_programming" title="Agent-oriented programming">Agent-oriented</a></li>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Automata-based_programming" title="Automata-based programming">Automata-based</a></li>
<li><a href="/wiki/Concurrent_computing" title="Concurrent computing">Concurrent computing</a>
<ul>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
</ul>
</li>
<li><a href="/wiki/Data-driven_programming" title="Data-driven programming">Data-driven</a></li>
<li><a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a> (contrast: <a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a>)
<ul>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a></li>
<li><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
</li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional</a>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
</li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic</a>
<ul>
<li><strong class="selflink">Abductive logic</strong></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
</ul>
</li>
<li><a href="/wiki/Relational_programming" title="Relational programming">Relational</a></li>
</ul>
</li>
<li><a href="/wiki/End-user_development" title="End-user development">End-user programming</a></li>
<li><a href="/wiki/Event-driven_programming" title="Event-driven programming">Event-driven</a>
<ul>
<li><a href="/wiki/Service-oriented_architecture" title="Service-oriented architecture">Service-oriented</a></li>
<li><a href="/wiki/Time-driven_programming" title="Time-driven programming">Time-driven</a></li>
</ul>
</li>
<li><a href="/wiki/Expression-oriented_programming_language" title="Expression-oriented programming language">Expression-oriented</a></li>
<li><a href="/wiki/Feature-oriented_programming" title="Feature-oriented programming">Feature-oriented</a></li>
<li><a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a> (contrast: <a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a>)</li>
<li><a href="/wiki/Generic_programming" title="Generic programming">Generic</a></li>
<li><a href="/wiki/Imperative_programming" title="Imperative programming">Imperative</a> (contrast: <a href="/wiki/Declarative_programming" title="Declarative programming">Declarative</a>)
<ul>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
</ul>
</li>
<li><a href="/wiki/Language-oriented_programming" title="Language-oriented programming">Language-oriented</a>
<ul>
<li><a href="/wiki/Natural_language_programming" title="Natural language programming">Natural language programming</a></li>
<li><a href="/wiki/Service-oriented_modeling#Discipline-specific_modeling" title="Service-oriented modeling">Discipline-specific</a></li>
<li><a href="/wiki/Domain-specific_language" title="Domain-specific language">Domain-specific</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
</li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
</ul>
</li>
<li><a href="/wiki/Metaprogramming" title="Metaprogramming">Metaprogramming</a>
<ul>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a></li>
<li><a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">Reflective</a>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a> (contrast: <a href="/wiki/Structured_programming" title="Structured programming">Structured</a>)
<ul>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
</ul>
</li>
<li><a href="/wiki/Nondeterministic_programming" title="Nondeterministic programming">Nondeterministic</a></li>
<li><a href="/wiki/Parallel_computing" title="Parallel computing">Parallel computing</a>
<ul>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Tacit_programming" title="Tacit programming">Point-free style</a>
<ul>
<li><a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
</ul>
</li>
<li><a href="/wiki/Semantic-oriented_programming" title="Semantic-oriented programming">Semantic</a></li>
<li><a href="/wiki/Structured_programming" title="Structured programming">Structured</a> (contrast: <a href="/wiki/Non-structured_programming" title="Non-structured programming">Non-structured</a>)
<ul>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a> (contrast: <a href="/wiki/Monolithic_application" title="Monolithic application">Monolithic</a>)</li>
<li><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented (OOP)</a>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
</li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
</ul>
</li>
<li><a href="/wiki/Value-level_programming" title="Value-level programming">Value-level</a> (contrast: <a href="/wiki/Function-level_programming" title="Function-level programming">Function-level</a>)</li>
<li><a href="/wiki/Probabilistic_programming_language" title="Probabilistic programming language">Probabilistic</a></li>
<li><a href="/wiki/Concept_programming" title="Concept programming">Concept</a></li>
</ul>
<ul>
<li><a href="/wiki/Relativistic_programming" title="Relativistic programming">Relativistic programming</a></li>
</ul>
<ul>
<li><a href="/wiki/Constraint_programming" title="Constraint programming">Constraint</a></li>
<li><a href="/wiki/Dataflow_programming" title="Dataflow programming">Dataflow</a>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
</li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional</a>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
</li>
<li><a href="/wiki/Logic_programming" title="Logic programming">Logic</a>
<ul>
<li><strong class="selflink">Abductive logic</strong></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
</ul>
</li>
<li><a href="/wiki/Relational_programming" title="Relational programming">Relational</a></li>
</ul>
<ul>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based</a></li>
<li>Cell-oriented (<a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a>)</li>
<li><a href="/wiki/Reactive_programming" title="Reactive programming">Reactive</a></li>
</ul>
<ul>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
</ul>
<ul>
<li><strong class="selflink">Abductive logic</strong></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set</a></li>
<li><a href="/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic</a></li>
<li><a href="/wiki/Functional_logic_programming" title="Functional logic programming">Functional logic</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic</a></li>
</ul>
<ul>
<li><a href="/wiki/Service-oriented_architecture" title="Service-oriented architecture">Service-oriented</a></li>
<li><a href="/wiki/Time-driven_programming" title="Time-driven programming">Time-driven</a></li>
</ul>
<ul>
<li><a href="/wiki/Procedural_programming" title="Procedural programming">Procedural</a></li>
</ul>
<ul>
<li><a href="/wiki/Natural_language_programming" title="Natural language programming">Natural language programming</a></li>
<li><a href="/wiki/Service-oriented_modeling#Discipline-specific_modeling" title="Service-oriented modeling">Discipline-specific</a></li>
<li><a href="/wiki/Domain-specific_language" title="Domain-specific language">Domain-specific</a></li>
<li><a href="/wiki/Grammar-oriented_programming" title="Grammar-oriented programming">Grammar-oriented</a>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
</li>
<li><a href="/wiki/Intentional_programming" title="Intentional programming">Intentional</a></li>
</ul>
<ul>
<li><a href="/wiki/Dialecting" title="Dialecting">Dialecting</a></li>
</ul>
<ul>
<li><a href="/wiki/Automatic_programming" title="Automatic programming">Automatic</a></li>
<li><a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">Reflective</a>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Homoiconicity" title="Homoiconicity">Homoiconic</a></li>
<li><a href="/wiki/Template_metaprogramming" title="Template metaprogramming">Template</a>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Attribute-oriented_programming" title="Attribute-oriented programming">Attribute-oriented</a></li>
</ul>
<ul>
<li><a href="/wiki/Policy-based_design" title="Policy-based design">Policy-based</a></li>
</ul>
<ul>
<li><a href="/wiki/Array_programming" title="Array programming">Array</a></li>
</ul>
<ul>
<li><a href="/wiki/Process-oriented_programming" title="Process-oriented programming">Process-oriented</a></li>
</ul>
<ul>
<li><a href="/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative</a></li>
</ul>
<ul>
<li><a href="/wiki/Block_(programming)" title="Block (programming)">Block-structured</a></li>
<li><a href="/wiki/Modular_programming" title="Modular programming">Modular</a> (contrast: <a href="/wiki/Monolithic_application" title="Monolithic application">Monolithic</a>)</li>
<li><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented (OOP)</a>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
</li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursive</a></li>
</ul>
<ul>
<li>By <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>:
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
</li>
<li><a href="/wiki/Class-based_programming" title="Class-based programming">Class-based</a></li>
<li><a href="/wiki/Prototype-based_programming" title="Prototype-based programming">Prototype-based</a></li>
</ul>
<ul>
<li><a href="/wiki/Aspect-oriented_programming" title="Aspect-oriented programming">Aspect-oriented</a></li>
<li><a href="/wiki/Role-oriented_programming" title="Role-oriented programming">Role-oriented</a></li>
<li><a href="/wiki/Subject-oriented_programming" title="Subject-oriented programming">Subject-oriented</a></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:Programming_paradigms" title="Template:Programming paradigms"><span title="View this template" style=";">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:Programming_paradigms" title="Template talk:Programming paradigms"><span title="Discuss this template" style=";">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&amp;action=edit"><span title="Edit this template" style=";">e</span></a></li>
</ul>
<p><b>Abductive logic programming</b> (<b>ALP</b>) is a high level <a href="/wiki/Knowledge_representation" title="Knowledge representation" class="mw-redirect">knowledge-representation</a> framework that can be used to solve problems declaratively based on <a href="/wiki/Abductive_reasoning" title="Abductive reasoning">abductive reasoning</a>. It extends normal <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a> by allowing some predicates to be incompletely defined, declared as abducible predicates. Problem solving is effected by deriving hypotheses on these abducible predicates (abductive hypotheses) as solutions of problems to be solved. These problems can be either observations that need to be explained (as in classical abduction) or goals to be achieved (as in normal <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a>). It can be used to solve problems in Diagnosis, <a href="/wiki/Planning" title="Planning">Planning</a>, Natural Language and <a href="/wiki/Machine_Learning" title="Machine Learning" class="mw-redirect">Machine Learning</a>. It has also been used to interpret <a href="/wiki/Negation_as_failure" title="Negation as failure">Negation as failure</a> as a form of abductive reasoning.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Informal_meaning_and_problem_solving"><span class="tocnumber">2</span> <span class="toctext">Informal meaning and problem solving</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example_1"><span class="tocnumber">2.1</span> <span class="toctext">Example 1</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Example_2"><span class="tocnumber">2.2</span> <span class="toctext">Example 2</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Example_3"><span class="tocnumber">2.3</span> <span class="toctext">Example 3</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Formal_semantics"><span class="tocnumber">3</span> <span class="toctext">Formal semantics</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Implementation_and_systems"><span class="tocnumber">4</span> <span class="toctext">Implementation and systems</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#External_links"><span class="tocnumber">7</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Example_1"><span class="tocnumber">2.1</span> <span class="toctext">Example 1</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Example_2"><span class="tocnumber">2.2</span> <span class="toctext">Example 2</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Example_3"><span class="tocnumber">2.3</span> <span class="toctext">Example 3</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Syntax">Syntax</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Abductive logic programs have three components, <img class="mwe-math-fallback-image-inline tex" alt="&lt;P,A,IC&gt;," src="//upload.wikimedia.org/math/5/4/e/54e3807351c7bc206103c9314e112b9d.png"> where:</p>
<ul>
<li>P is a logic program of exactly the same form as in Logic Programming</li>
<li>A is a set of predicate names, called the abducible predicates</li>
<li>IC is a set of first order classical formulae.</li>
</ul>
<p>Normally, the logic program P does not contain any clauses whose head (or conclusion) refers to an abducible predicate. (This restriction can be made without loss of generality.) Also in practice, many times the <a href="/wiki/Integrity_constraints" title="Integrity constraints" class="mw-redirect">integrity constraints</a> in IC are often restricted to the form of denials, i.e. clauses of the form:</p>
<p>WHATSON? eaf76ee3-7883-4813-b705-1107e8823d3b</p>
<pre>
   false:- A1,...,An, not B1, ..., not Bm.
</pre>
<p>Such a constraint means that it is not possible for all A1,...,An to be true and at the same time all of B1,...,Bm to be false.</p>
<h2><span class="mw-headline" id="Informal_meaning_and_problem_solving">Informal meaning and problem solving</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=2" title="Edit section: Informal meaning and problem solving">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The clauses in P define a set of non-abducible predicates and through this they provide a description (or model) of the problem domain. The integrity constraints in IC specify general properties of the problem domain that need to be respected in any solution of our problem.</p>
<p>A problem, G, which expresses either an observation that needs to be explained or a goal that is desired, is represented by a conjunction of positive and negative (NAF) literals. Such problems are solved by computing "abductive explanations" of G.</p>
<p>An abductive explanation of a problem G is a set of positive (and sometimes also negative) ground instances of the abducible predicates, such that, when these are added to the logic program P, the problem G and the integrity constraints IC both hold. Thus abductive explanations extend the logic program P by the addition of full or partial definitions of the abducible predicates. In this way, abductive explanations form solutions of the problem according to the description of the problem domain in P and IC. The extension or completion of the problem description given by the abductive explanations provides new information, hitherto not contained in the solution to the problem. Quality criteria to prefer one solution over another, often expressed via integrity constraints, can be applied to select specific abductive explanations of the problem G.</p>
<p>Computation in ALP combines the backwards reasoning of normal logic programming (to reduce problems to sub-problems) with a kind of integrity checking to show that the abductive explanations satisfy the integrity constraints.</p>
<p>The following two examples, written in simple structured English rather than in the strict syntax of ALP, illustrate the notion of abductive explanation in ALP and its relation to problem solving.</p>
<h3><span class="mw-headline" id="Example_1">Example 1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=3" title="Edit section: Example 1">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The abductive logic program, <img class="mwe-math-fallback-image-inline tex" alt="\langle P,A,\mathit{IC} \rangle" src="//upload.wikimedia.org/math/b/4/f/b4f27dfd9bc5311ceca2d217dae0197d.png">, has in <img class="mwe-math-fallback-image-inline tex" alt="P" src="//upload.wikimedia.org/math/4/4/c/44c29edb103a2872f519ad0c9a0fdaaa.png"> the following sentences:</p>
<p>WHATSON? b2887414-38dc-4939-b4f4-540a3f99f8b1</p>
<pre>
  Grass is wet <b>if</b> it rained.<br>  Grass is wet <b>if</b> the sprinkler was on.<br>  The sun was shining.
</pre>
<p>The abducible predicates in <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> are "it rained" and "the sprinkler was on" and the only integrity constraint in <img class="mwe-math-fallback-image-inline tex" alt="\mathit{IC}" src="//upload.wikimedia.org/math/0/6/3/063cb097acad9fe2dc41a37d63c1fbf0.png"> is:</p>
<p>WHATSON? 901ee3fc-a9d7-45d7-8a4a-1360f1eda2b5</p>
<pre>
  false <b>if</b> it rained and the sun was shining.
</pre>
<p>The observation that the grass is wet has two potential explanations, "it rained" and "the sprinkler was on", which entail the observation. However, only the second potential explanation, "the sprinkler was on", satisfies the integrity constraint.</p>
<h3><span class="mw-headline" id="Example_2">Example 2</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=4" title="Edit section: Example 2">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Consider the abductive logic program consisting of the following (simplified) clauses:</p>
<p>WHATSON? 1beed3da-f0e4-41d7-9321-3c6f99f576fe</p>
<pre>
  X is a citizen <b>if</b> X is born in the USA.<br>  X is a citizen <b>if</b> X is born outside the USA <b>and</b> X is a resident of the USA <b>and</b> X is naturalized.<br>  X is a citizen <b>if</b> X is born outside the USA <b>and</b> Y is the mother of X <b>and</b> Y is a citizen <b>and</b> X is registered.<br>  Mary is the mother of John.<br>  Mary is a citizen.
</pre>
<p>together with the five abducible predicates, "is born in the USA", "is born outside the USA", "is a resident of the USA", "is naturalized" and "is registered" and the integrity constraint:</p>
<p>WHATSON? a72ee35e-32e6-444d-bd3b-fb5e9d061168</p>
<pre>
  false <b>if</b> John is a resident of the USA.
</pre>
<p>The goal "John is citizen" has two abductive solutions, one of which is "John is born in the USA", the other of which is "John is born outside the USA" and "John is registered". The potential solution of becoming a citizen by residence and naturalization fails because it violates the integrity constraint.</p>
<p>A more complex example that is also written in the more formal syntax of ALP is the following.</p>
<h3><span class="mw-headline" id="Example_3">Example 3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=5" title="Edit section: Example 3">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The abductive logic program below describes a simple model of the lactose metabolism of the bacterium E. Coli. The program P describes the fact that E. coli can feed on the sugar lactose if it makes two enzymes permease and galactosidase. Like all enzymes (E), these are made if they are coded by a gene (G) that is expressed. These enzymes are coded by two genes (lac(y) and lac(z)) in cluster of genes (lac(X)) – called an operon – that is expressed when the amounts (amt) of glucose are low and lactose are high or when they are both at medium level. The abducibles, A, declare all ground instances of the predicates "amount" as assumable. This reflects the fact that in the model the amounts at any time of the various substances are unknown. This is incomplete information that is to be determined in each problem case. The integrity constraints state that the amount of a substance (S) can only take one value.</p>
<p>Domain Knowledge (P)</p>
<p>WHATSON? b448be16-2957-40e0-94fc-8028467f327c</p>
<pre>
  feed(lactose):-make(permease),make(galactosidase).<br>  make(Enzyme):-code(Gene,Enzyme),express(Gene).<br>  express(lac(X)):-amount(glucose,low),amount(lactose,hi).<br>  express(lac(X)):-amount(glucose,medium),amount(lactose,medium).<br>  code(lac(y),permease).<br>  code(lac(z),galactosidase).<br>  temperature(low):-amount(glucose,low).
</pre>
<p>Integrity Constraints (IC)</p>
<p>WHATSON? 94c9f413-2e14-41c5-9a59-970f9679ba2e</p>
<pre>
  false :- amount(S,V1), amount(S,V2), V1 <img class="mwe-math-fallback-image-inline tex" alt="\neq" src="//upload.wikimedia.org/math/b/d/0/bd0d5f08997b7a4ad8598963f7e50231.png"> V2.
</pre>
<p>Abducibles (A)</p>
<p>WHATSON? f7be3b91-bc19-41b4-9707-6c7a5ed90dc1</p>
<pre>
  abducible_predicate(amount).
</pre>
<p>The problem goal is <img class="mwe-math-fallback-image-inline tex" alt="G=feed(lactose)" src="//upload.wikimedia.org/math/a/6/3/a63c990052d3d2e7d07311adee1452a6.png">. This can arise either as an observation to be explained or as a state of affairs to be achieved by finding a plan. This goal has two abductive explanations:</p>
<p><img class="mwe-math-fallback-image-inline tex" alt="\Delta_1=\{amount(lactose,hi), amount(glucose,low)\}" src="//upload.wikimedia.org/math/4/a/4/4a40475d40a28a50719c209c589aa06d.png"></p>
<p><img class="mwe-math-fallback-image-inline tex" alt="\Delta_2=\{amount(lactose,medium), amount(glucose,medium)\}" src="//upload.wikimedia.org/math/d/a/a/daaa9210f687ee101c6ddd56bacf6ecd.png"></p>
<p>The decision which of the two to adopt could depend on addition information that is available, e.g. it may be known that when the level of glucose is low then the organism exhibits a certain behaviour - in the model such additional information is that the temperature of the organism is low - and by observing the truth or falsity of this it is possible to choose the first or second explanation respectively.</p>
<p>Once an explanation has been chosen, then this becomes part of the theory, which can be used to draw new conclusions. The explanation and more generally these new conclusions form the solution of the problem.</p>
<h2><span class="mw-headline" id="Formal_semantics">Formal semantics</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=6" title="Edit section: Formal semantics">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The formal semantics of the central notion of an abductive explanation in ALP, can be defined in the following way.</p>
<p>Given an abductive logic program, <img class="mwe-math-fallback-image-inline tex" alt="\langle P,A,\mathit{IC}\rangle" src="//upload.wikimedia.org/math/b/4/f/b4f27dfd9bc5311ceca2d217dae0197d.png">, an abductive explanation for a problem <img class="mwe-math-fallback-image-inline tex" alt="G" src="//upload.wikimedia.org/math/d/f/c/dfcf28d0734569a6a693bc8194de62bf.png"> is a set <img class="mwe-math-fallback-image-inline tex" alt="\Delta" src="//upload.wikimedia.org/math/6/5/9/659d23f0ed16cdb87b1d41c7b58b52f4.png"> of ground atoms on abducible predicates such that:</p>
<ul>
<li><img class="mwe-math-fallback-image-inline tex" alt="P \cup \Delta \models G" src="//upload.wikimedia.org/math/0/7/a/07a3d7d58afca0cb2c51ee850111c4df.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="P \cup \Delta \models IC" src="//upload.wikimedia.org/math/4/4/a/44a90d816a5bbd14a4322c78775bd615.png"></li>
<li><img class="mwe-math-fallback-image-inline tex" alt="P \cup \Delta" src="//upload.wikimedia.org/math/9/0/b/90b9b6c3a5730ca01146acf4d155923e.png"> is <a href="/wiki/Consistent" title="Consistent" class="mw-redirect">consistent</a></li>
</ul>
<p>This definition leaves open the choice of the underlying semantics of logic programming through which we give the exact meaning of the entailment relation <img class="mwe-math-fallback-image-inline tex" alt="\models" src="//upload.wikimedia.org/math/e/7/6/e766ce0de4bbe899d7ea2ebe40b3e0ee.png"> and the notion of consistency of the (extended) logic programs. Any of the different semantics of logic programming such as the completion, stable or well-founded semantics can (and have been used in practice) to give different notions of abductive explanations and thus different forms of ALP frameworks.</p>
<p>The above definition takes a particular view on the formalization of the role of the integrity constraints <img class="mwe-math-fallback-image-inline tex" alt="\mathit{IC}" src="//upload.wikimedia.org/math/0/6/3/063cb097acad9fe2dc41a37d63c1fbf0.png"> as restrictions on the possible abductive solutions. It requires that these are entailed by the logic program extended with an abductive solution, thus meaning that in any model of the extended logic program (which we can think off as an ensuing world given <img class="mwe-math-fallback-image-inline tex" alt="\Delta" src="//upload.wikimedia.org/math/6/5/9/659d23f0ed16cdb87b1d41c7b58b52f4.png">) the requirements of the integrity constraints are met. In some cases this may be unnecessarily strong and the weaker requirement of consistency, namely that <img class="mwe-math-fallback-image-inline tex" alt="P \cup \mathit{IC} \cup \Delta" src="//upload.wikimedia.org/math/c/4/f/c4f8165a7215f00cc81adfc912e585a0.png"> is consistent, can be sufficient, meaning that there exists at least one model (possible ensuing world) of the extended program where the integrity constraints hold. In practice, in many cases these two ways of formalizing the role of the integrity constraints coincide as the logic program and its extensions always have a unique model. Many of the ALP systems use the entailment view of the integrity constraints as this can be easily implemented without the need for any extra specialized procedures for the satisfaction of the integrity constraints since this view treats the constraints in the same way as the problem goal. Note also that in many practical cases the third condition in this formal definition of an abductive explanation in ALP is either trivially satisfied or it is contained in the second condition via the use of specific integrity constraints that capture consistency.</p>
<h2><span class="mw-headline" id="Implementation_and_systems">Implementation and systems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=7" title="Edit section: Implementation and systems">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Most of the implementations of ALP extend the SLD resolution based computational model of logic programming. ALP can also be implemented by means on its link with Answer Set Programming (ASP), where the ASP systems can be employed. Examples of systems of the former approach are ACLP, A-system, CIFF, SCIFF, ABDUAL and ProLogICA.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=8" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Abductive_reasoning" title="Abductive reasoning">Abductive reasoning</a></li>
<li><a href="/wiki/Answer_set_programming" title="Answer set programming">Answer set programming</a></li>
<li><a href="/wiki/Inductive_logic_programming" title="Inductive logic programming">Inductive logic programming</a></li>
<li><a href="/wiki/Negation_as_failure" title="Negation as failure">Negation as failure</a></li>
<li><a href="/wiki/Argumentation" title="Argumentation" class="mw-redirect">Argumentation</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=9" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation book">Poole, D.; Goebel, R.; Aleliunas, R. (1987). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=WRy1XVarSd4C&amp;pg=PA331">"Theorist: a logical reasoning system for defaults and diagnosis"</a>. In Cercone, Nick; McCalla, Gordon. <i>The Knowledge Frontier: Essays in the Representation of Knowledge</i>. Springer. pp. 331–352. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-0-387-96557-4" title="Special:BookSources/978-0-387-96557-4">978-0-387-96557-4</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=The+Knowledge+Frontier%3A+Essays+in+the+Representation+of+Knowledge&amp;rft.au=Aleliunas%2C+R.&amp;rft.aufirst=D.&amp;rft.au=Goebel%2C+R.&amp;rft.aulast=Poole&amp;rft.au=Poole%2C+D.&amp;rft.btitle=Theorist%3A+a+logical+reasoning+system+for+defaults+and+diagnosis&amp;rft.date=1987&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DWRy1XVarSd4C%26pg%3DPA331&amp;rft.isbn=978-0-387-96557-4&amp;rft.pages=331-352&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Kakas, A.C.; Mancarella, P. (1990). "Generalised Stable Models: A Semantics for Abduction". In Aiello, L.C. <i>ECAI 90: proceedings of the 9th European Conference on Artificial Intelligence</i>. Pitman. pp. 385–391. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/027308822X" title="Special:BookSources/027308822X">027308822X</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=ECAI+90%3A+proceedings+of+the+9th+European+Conference+on+Artificial+Intelligence&amp;rft.aufirst=A.C.&amp;rft.au=Kakas%2C+A.C.&amp;rft.aulast=Kakas&amp;rft.au=Mancarella%2C+P.&amp;rft.btitle=Generalised+Stable+Models%3A+A+Semantics+for+Abduction&amp;rft.date=1990&amp;rft.genre=bookitem&amp;rft.isbn=027308822X&amp;rft.pages=385-391&amp;rft.pub=Pitman&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Console, L.; Dupre, D.T.; Torasso, P. (1991). <a rel="nofollow" class="external text" href="http://logcom.oxfordjournals.org/content/1/5/661.short">"On the Relationship between Abduction and Deduction"</a>. <i>J Logic Computation</i> <b>1</b> (5): 661–690. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1093%2Flogcom%2F1.5.661">10.1093/logcom/1.5.661</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=On+the+Relationship+between+Abduction+and+Deduction&amp;rft.au=Console%2C+L.&amp;rft.au=Dupre%2C+D.T.&amp;rft.aufirst=L.&amp;rft.aulast=Console&amp;rft.au=Torasso%2C+P.&amp;rft.date=1991&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flogcom.oxfordjournals.org%2Fcontent%2F1%2F5%2F661.short&amp;rft_id=info%3Adoi%2F10.1093%2Flogcom%2F1.5.661&amp;rft.issue=5&amp;rft.jtitle=J+Logic+Computation&amp;rft.pages=661-690&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=1" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Kakas, A.C.; Kowalski, R.A.; Toni, F. (1993). <a rel="nofollow" class="external text" href="http://logcom.oxfordjournals.org/content/2/6/719.short">"Abductive Logic Programming"</a>. <i>J Logic Computation</i> <b>2</b> (6): 719–770. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1093%2Flogcom%2F2.6.719">10.1093/logcom/2.6.719</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=Abductive+Logic+Programming&amp;rft.aufirst=A.C.&amp;rft.au=Kakas%2C+A.C.&amp;rft.au=Kowalski%2C+R.A.&amp;rft.aulast=Kakas&amp;rft.au=Toni%2C+F.&amp;rft.date=1993&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flogcom.oxfordjournals.org%2Fcontent%2F2%2F6%2F719.short&amp;rft_id=info%3Adoi%2F10.1093%2Flogcom%2F2.6.719&amp;rft.issue=6&amp;rft.jtitle=J+Logic+Computation&amp;rft.pages=719-770&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=2" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Denecker, Marc; De Schreye, Danny (February 1998). "SLDNFA: An Abductive Procedure for Abductive Logic Programs". <i>J. Logic Programming</i> <b>34</b> (2): 111–167. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2FS0743-1066%2897%2900074-5">10.1016/S0743-1066(97)00074-5</a>. <a href="/wiki/CiteSeer#CiteSeerX" title="CiteSeer">CiteSeerX</a>: <span class="url"><a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.6503">10.1.1.21.6503</a></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=SLDNFA%3A+An+Abductive+Procedure+for+Abductive+Logic+Programs&amp;rft.au=Denecker%2C+Marc&amp;rft.au=De+Schreye%2C+Danny&amp;rft.aufirst=Marc&amp;rft.aulast=Denecker&amp;rft.date=February+1998&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1016%2FS0743-1066%2897%2900074-5&amp;rft.issue=2&amp;rft.jtitle=J.+Logic+Programming&amp;rft.pages=111-167&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=34" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Denecker, M.; Kakas, A.C. (July 2000). <a rel="nofollow" class="external text" href="http://www.sciencedirect.com/science/article/pii/S0743106699000783">"Special issue: abductive logic programming"</a>. <i>J. Logic Programming</i> <b>44</b> (1-3): 1–4. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2FS0743-1066%2899%2900078-3">10.1016/S0743-1066(99)00078-3</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=Special+issue%3A+abductive+logic+programming&amp;rft.au=Denecker%2C+M.&amp;rft.aufirst=M.&amp;rft.au=Kakas%2C+A.C.&amp;rft.aulast=Denecker&amp;rft.date=July+2000&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2FS0743106699000783&amp;rft_id=info%3Adoi%2F10.1016%2FS0743-1066%2899%2900078-3&amp;rft.issue=1-3&amp;rft.jtitle=J.+Logic+Programming&amp;rft.pages=1-4&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=44" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation book">Denecker, M.; Kakas, A.C. (2002). <a rel="nofollow" class="external text" href="http://books.google.com/books?id=15umWyDVsRMC&amp;pg=PA402">"Abduction in Logic Programming"</a>. In Kakas, A.C.; Sadri, F. <i>Computational Logic: Logic Programming and Beyond: Essays in Honour of Robert A. Kowalski</i>. Lecture notes in computer science <b>2407</b>. Springer. pp. 402–437. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-43959-2" title="Special:BookSources/978-3-540-43959-2">978-3-540-43959-2</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=Computational+Logic%3A+Logic+Programming+and+Beyond%3A+Essays+in+Honour+of+Robert+A.+Kowalski&amp;rft.au=Denecker%2C+M.&amp;rft.aufirst=M.&amp;rft.au=Kakas%2C+A.C.&amp;rft.aulast=Denecker&amp;rft.btitle=Abduction+in+Logic+Programming&amp;rft.date=2002&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3D15umWyDVsRMC%26pg%3DPA402&amp;rft.isbn=978-3-540-43959-2&amp;rft.pages=402-437&amp;rft.pub=Springer&amp;rft.series=Lecture+notes+in+computer+science&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=2407" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Poole, D. (1993). <a rel="nofollow" class="external text" href="https://www.cs.ubc.ca/~poole/papers/pha-bn.pdf">"Probabilistic Horn abduction and Bayesian networks"</a> (PDF). <i>Artificial Intelligence,</i> <b>64</b> (1): 81–129. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2F0004-3702%2893%2990061-F">10.1016/0004-3702(93)90061-F</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=Probabilistic+Horn+abduction+and+Bayesian+networks&amp;rft.aufirst=D.&amp;rft.aulast=Poole&amp;rft.au=Poole%2C+D.&amp;rft.date=1993&amp;rft.genre=article&amp;rft_id=https%3A%2F%2Fwww.cs.ubc.ca%2F~poole%2Fpapers%2Fpha-bn.pdf&amp;rft_id=info%3Adoi%2F10.1016%2F0004-3702%2893%2990061-F&amp;rft.issue=1&amp;rft.jtitle=Artificial+Intelligence%2C&amp;rft.pages=81-129&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=64" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation journal">Esposito, F.; Ferilli, S.; Basile, T.M.A.; Di Mauro, N. (February 2007). <a rel="nofollow" class="external text" href="http://www.di.uniba.it/~ndm/publications/files/esposito07kais.pdf">"Inference of abduction theories for handling incompleteness in first-order learning"</a> (PDF). <i>Knowl. Inf. Syst.</i> <b>11</b> (2): 217–242. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2Fs10115-006-0019-5">10.1007/s10115-006-0019-5</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AAbductive+logic+programming&amp;rft.atitle=Inference+of+abduction+theories+for+handling+incompleteness+in+first-order+learning&amp;rft.au=Basile%2C+T.M.A.&amp;rft.au=Di+Mauro%2C+N.&amp;rft.au=Esposito%2C+F.&amp;rft.au=Ferilli%2C+S.&amp;rft.aufirst=F.&amp;rft.aulast=Esposito&amp;rft.date=February+2007&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.di.uniba.it%2F~ndm%2Fpublications%2Ffiles%2Fesposito07kais.pdf&amp;rft_id=info%3Adoi%2F10.1007%2Fs10115-006-0019-5&amp;rft.issue=2&amp;rft.jtitle=Knowl.+Inf.+Syst.&amp;rft.pages=217-242&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=11" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Abductive_logic_programming&amp;action=edit&amp;section=10" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.cs.ucy.ac.cy/aclp/">ACLP</a></li>
<li><a rel="nofollow" class="external text" href="http://www-lia.deis.unibo.it/Software/ACL/">ACL</a></li>
<li><a rel="nofollow" class="external text" href="http://lia.deis.unibo.it/sciff/">SCIFF</a></li>
<li><a rel="nofollow" class="external text" href="http://dtai.cs.kuleuven.be/krr/Asystem/asystem.html">Asystem</a></li>
</ul>
