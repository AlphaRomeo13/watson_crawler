<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Message passing</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>message passing</b> sends a message to a process (which may be an <a href="/wiki/Actor_model" title="Actor model">actor</a> or <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a>) and relies on the process and the supporting infrastructure to select and invoke the actual code to run. Message passing differs from conventional programming where a process, subroutine, or function is directly invoked by name. Message passing is key to some <a href="/wiki/Concurrency_(computer_science)#Models" title="Concurrency (computer science)">models of concurrency</a> and <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>.</p>
<p>Message passing is used ubiquitously in modern computer software. It is used as a way for the objects that make up a program to work with each other and as a way for objects and systems running on different computers (e.g., the Internet) to interact. Message passing may be implemented by various mechanisms, including <a href="/wiki/Channel_(programming)" title="Channel (programming)">channels</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Synchronous_versus_asynchronous_message_passing"><span class="tocnumber">2</span> <span class="toctext">Synchronous versus asynchronous message passing</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Distributed_objects"><span class="tocnumber">3</span> <span class="toctext">Distributed objects</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Message_passing_versus_calling"><span class="tocnumber">4</span> <span class="toctext">Message passing versus calling</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Mathematical_models"><span class="tocnumber">5</span> <span class="toctext">Mathematical models</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Examples"><span class="tocnumber">6</span> <span class="toctext">Examples</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Further_reading"><span class="tocnumber">10</span> <span class="toctext">Further reading</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Message passing is a technique for invoking behavior (i.e., running a program) on a computer. In contrast to the traditional technique of calling a program by name, message passing uses an <a href="/wiki/Object_model" title="Object model">object model</a> to distinguish the general function from the specific implementations. The invoking program sends a message and relies on the object to select and execute the appropriate code. The justifications for using an intermediate layer essentially falls into two categories: encapsulation and distribution.</p>
<p><a href="/wiki/Encapsulation_(computer_science)" title="Encapsulation (computer science)" class="mw-redirect">Encapsulation</a> is the idea that software objects should be able to invoke services on other objects without knowing or caring about how those services are implemented. Encapsulation can reduce the amount of coding logic and make systems more maintainable. E.g., rather than having IF-THEN statements that determine which subroutine or function to call a developer can just send a message to the object and the object will select the appropriate code based on its type.</p>
<p>One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of various complications in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called <code>Shape</code> with subclasses such as <code>Rectangle</code> and <code>Ellipse</code> (which in turn have subclasses <code>Square</code> and <code>Circle</code>) and then to simply send a message to any <code>Shape</code> asking it to compute its area. Each <code>Shape</code> object will then invoke the appropriate code with the formula appropriate for that kind of object.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>Distributed message passing provides developers with a layer of the architecture that provides common services to build systems made up of sub-systems that run on disparate computers in different locations and at different times. When sending a distributed object a message the messaging layer can take care of issues such as:</p>
<ul>
<li>Finding the appropriate object, including objects running on different computers, using different operating systems and programming languages, at different locations from where the message originated.</li>
<li>Saving the message on a queue if the appropriate object to handle the message is not currently running and then invoking the message when the object is available. Also, storing the result if needed until the sending object is ready to receive it.</li>
<li>Controlling various transactional requirements for distributed transactions, e.g. ensuring <a href="/wiki/ACID" title="ACID">ACID</a> properties on data.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="Synchronous_versus_asynchronous_message_passing">Synchronous versus asynchronous message passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=2" title="Edit section: Synchronous versus asynchronous message passing">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>One of the most important distinctions among message passing systems is whether they use synchronous or asynchronous message passing. Synchronous message passing occurs between objects that are running at the same time. With asynchronous message passing it is possible for the receiving object to be busy or not running when the requesting object sends the message.</p>
<p>Synchronous message passing is what typical object-oriented programming languages such as Java and Smalltalk use. Asynchronous message passing requires additional capabilities for storing and retransmitting data for systems that may not run concurrently.</p>
<p>The advantage to synchronous message passing is that it is conceptually less complex. Synchronous message passing is analogous to a function call in which the message sender is the function caller and the message receiver is the called function. Function calling is easy and familiar. Just as the function caller stops until the called function completes, the sending process stops until the receiving process completes. This alone makes synchronous message unworkable for some applications. For example, if synchronous message passing would be used exclusively, large, distributed systems generally would not perform well enough to be usable. Such large, distributed systems may need to continue to operate while some of their subsystems are down; subsystems may need to go offline for some kind of maintenance, or have times when subsystems are not open to receiving input from other systems.</p>
<p>Imagine a busy business office having 100 desktop computers that send emails to each other using synchronous message passing exclusively. Because the office system does not use asynchronous message passing, one worker turning off their computer can cause the other 99 computers to freeze until the worker turns their computer back on to process a single email.</p>
<p>Asynchronous message passing is generally implemented so that all the complexities that naturally occur when trying to synchronize systems and data are handled by an intermediary level of software. Commercial vendors who develop software products to support these intermediate levels usually call their software "<a href="/wiki/Middleware" title="Middleware">middleware</a>". One of the most common types of middleware to support asynchronous messaging is called <a href="/wiki/Message-oriented_middleware" title="Message-oriented middleware">Message Oriented Middleware (MOM)</a></p>
<p>With asynchronous message passing, the sending system does not wait for a response. Continuing the function call analogy, asynchronous message passing would be a function call that returns immediately, without waiting for the called function to execute. Such an asynchronous function call would merely deliver the arguments, if any, to the called function, and tell the called function to execute, and then return to continue its own execution. Asynchronous message passing simply sends the message to the message bus. The bus stores the message until the receiving process requests messages sent to it. When the receiving process arrives at the result, it sends the result to the message bus. And the message bus holds the message until the original process (or some designated next process) picks up its messages from the message bus.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p>Synchronous communication can be built on top of asynchronous communication by using a <a href="/wiki/Synchronizer_(algorithm)" title="Synchronizer (algorithm)">Synchronizer</a>. For example, the α-Synchronizer works by ensuring that the sender always waits for an acknowledgement message from the receiver. The sender only sends the next message after the acknowledgement has been received.</p>
<p>The buffer required in asynchronous communication can cause problems when it is full. A decision has to be made whether to block the sender or whether to discard future messages. If the sender is blocked, it may lead to an unexpected <a href="/wiki/Deadlock" title="Deadlock">deadlock</a>. If messages are dropped, then communication is no longer reliable. These are all examples of the kinds of problems that middleware vendors try to address.</p>
<h2><span class="mw-headline" id="Distributed_objects">Distributed objects</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=3" title="Edit section: Distributed objects">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In addition to the distinction between synchronous and asynchronous message passing the other primary distinguishing feature of message passing systems is whether they use distributed or local objects. With distributed objects the sender and receiver may exist on different computers, running different operating systems, using different programming languages, etc. In this case the bus layer takes care of details about converting data from one system to another, sending and receiving data across the network, etc. The Remote Procedure Call (RPC) protocol in Unix was an early example of this. Note that with this type of message passing it is not a requirement that either the sender or receiver are implemented using object-oriented programming. It is possible to wrap systems developed using procedural languages and treat them as large grained objects capable of sending and receiving messages.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<p>Examples of systems that support distributed objects are: <a href="/wiki/ONC_RPC" title="ONC RPC" class="mw-redirect">ONC RPC</a>, <a href="/wiki/CORBA" title="CORBA" class="mw-redirect">CORBA</a>, <a href="/wiki/Java_RMI" title="Java RMI" class="mw-redirect">Java RMI</a>, <a href="/wiki/Distributed_Component_Object_Model" title="Distributed Component Object Model">DCOM</a>, <a href="/wiki/SOAP_(protocol)" title="SOAP (protocol)" class="mw-redirect">SOAP</a>, <a href="/wiki/.NET_Remoting" title=".NET Remoting">.NET Remoting</a>, <a href="/wiki/CTOS" title="CTOS" class="mw-redirect">CTOS</a>, <a href="/wiki/QNX" title="QNX">QNX Neutrino RTOS</a>, <a href="/wiki/OpenBinder" title="OpenBinder">OpenBinder</a>, and <a href="/wiki/D-Bus" title="D-Bus">D-Bus</a>. Distributed object systems have been called "shared nothing" systems because the message passing abstraction hides underlying state changes that may be used in the implementation of sending messages.</p>
<h2><span class="mw-headline" id="Message_passing_versus_calling">Message passing versus calling</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=4" title="Edit section: Message passing versus calling">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Distributed or asynchronous message passing has some overhead associated with it compared to the simpler way of simply calling a procedure. In a traditional <a href="/wiki/Calling_convention" title="Calling convention">procedure call</a>, arguments are passed to the receiver typically by one or more <a href="/wiki/General_purpose_register" title="General purpose register" class="mw-redirect">general purpose registers</a> or in a <a href="/wiki/Parameter_(computer_science)" title="Parameter (computer science)" class="mw-redirect">parameter list</a> containing the addresses of each of the arguments. This form of communication differs from message passing in at least three crucial areas:</p>
<ul>
<li>total memory usage</li>
<li><a href="/wiki/Bit_rate" title="Bit rate">transfer time</a></li>
<li>locality</li>
</ul>
<p>In message passing, each of the arguments has to copy the existing argument into a portion of the new message. This applies regardless of the size of the argument and in some cases the arguments can be as large as a document which can be megabytes worth of data. The argument has to be copied in its entirety and transmitted to the receiving object.</p>
<p>By contrast, for a standard procedure call, only an address (a few bits) needs to be passed for each argument and may even be passed in a <a href="/wiki/General_purpose_register" title="General purpose register" class="mw-redirect">general purpose register</a> requiring zero additional storage and zero transfer time.</p>
<p>This of course is not possible for distributed systems since an (absolute) address – in the callers address space – is normally meaningless to the remote program (however, a <a href="/wiki/Relative_address" title="Relative address" class="mw-redirect">relative address</a> might in fact be usable if the receiver had an <i>exact</i> copy of, at least some of, the sender's memory in advance). Web <a href="/wiki/Web_browsing" title="Web browsing" class="mw-redirect">browsers</a> and <a href="/wiki/Web_server" title="Web server">web servers</a> are examples of processes that communicate by message passing. A <a href="/wiki/URL" title="URL" class="mw-redirect">URL</a> is an example of a way of referencing resources that does not depend on exposing the internals of a process.</p>
<p>A <a href="/wiki/Subroutine" title="Subroutine">subroutine</a> call or <a href="/wiki/Method_(computer_programming)" title="Method (computer programming)">method</a> invocation will not exit until the invoked computation has terminated. Asynchronous message passing, by contrast, can result in a response arriving a significant time after the request message was sent.</p>
<p>A message handler will, in general, process messages from more than one sender. This means its state can change for reasons unrelated to the behaviour of a single sender or client process. This is in contrast to the typical behaviour of an object upon which methods are being invoked: the latter is expected to remain in the same state between method invocations. In other words, the message handler behaves analogously to a <a href="/wiki/Volatile_variable" title="Volatile variable" class="mw-redirect">volatile object</a>.</p>
<h2><span class="mw-headline" id="Mathematical_models">Mathematical models</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=5" title="Edit section: Mathematical models">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The prominent mathematical models of message passing are the <a href="/wiki/Actor_model" title="Actor model">Actor model</a> and <a href="/wiki/Pi_calculus" title="Pi calculus" class="mw-redirect">Pi calculus</a>.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup><sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> In mathematical terms a message is the single means to pass control to an object. If the object responds to the message, it has a <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> for that message.</p>
<p><a href="/wiki/Alan_Kay" title="Alan Kay">Alan Kay</a> has argued that message passing is more important than objects in OOP, and that objects themselves are often over-emphasized. The <a href="/wiki/Live_distributed_object" title="Live distributed object">live distributed objects</a> programming model builds upon this observation; it uses the concept of a <a href="/wiki/Distributed_data_flow" title="Distributed data flow">distributed data flow</a> to characterize the behavior of a complex distributed system in terms of message patterns, using high-level, functional-style specifications.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=6" title="Edit section: Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Actor_model_implementation" title="Actor model implementation">Actor model implementation</a></li>
<li><a href="/wiki/Amorphous_computing" title="Amorphous computing">Amorphous computing</a></li>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based programming</a></li>
<li><a href="/wiki/SOAP_(protocol)" title="SOAP (protocol)" class="mw-redirect">SOAP (protocol)</a></li>
</ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Active_message" title="Active message">Active message</a></li>
<li><a href="/wiki/Distributed_computing" title="Distributed computing">Distributed computing</a></li>
<li><a href="/wiki/Event_loop" title="Event loop">Event loop</a></li>
<li><a href="/wiki/Inter-process_communication" title="Inter-process communication">Inter-process communication</a></li>
<li><a href="/wiki/Message-oriented_middleware" title="Message-oriented middleware">Message-oriented middleware</a></li>
<li><a href="/wiki/Messaging_pattern" title="Messaging pattern">Messaging pattern</a></li>
<li><a href="/wiki/Message_passing_in_computer_clusters" title="Message passing in computer clusters">Message passing in computer clusters</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation book">Goldberg, Adele; David Robson (1989). <i>Smalltalk-80 The Language</i>. Addison Wesley. pp. 5–16. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-201-13688-0" title="Special:BookSources/0-201-13688-0">0-201-13688-0</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.au=David+Robson&amp;rft.aufirst=Adele&amp;rft.au=Goldberg%2C+Adele&amp;rft.aulast=Goldberg&amp;rft.btitle=Smalltalk-80+The+Language&amp;rft.date=1989&amp;rft.genre=book&amp;rft.isbn=0-201-13688-0&amp;rft.pages=5-16&amp;rft.pub=Addison+Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation book">Orfali, Robert (1996). <i>The Essential Client/Server Survival Guide</i>. New York: Wiley Computer Publishing. pp. 1–22. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-15325-7" title="Special:BookSources/0-471-15325-7">0-471-15325-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.aufirst=Robert&amp;rft.aulast=Orfali&amp;rft.au=Orfali%2C+Robert&amp;rft.btitle=The+Essential+Client%2FServer+Survival+Guide&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-15325-7&amp;rft.pages=1-22&amp;rft.place=New+York&amp;rft.pub=Wiley+Computer+Publishing&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation book">Orfali, Robert (1996). <i>The Essential Client/Server Survival Guide</i>. New York: Wiley Computer Publishing. pp. 95–133. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-15325-7" title="Special:BookSources/0-471-15325-7">0-471-15325-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.aufirst=Robert&amp;rft.aulast=Orfali&amp;rft.au=Orfali%2C+Robert&amp;rft.btitle=The+Essential+Client%2FServer+Survival+Guide&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-15325-7&amp;rft.pages=95-133&amp;rft.place=New+York&amp;rft.pub=Wiley+Computer+Publishing&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Orfali, Robert (1996). <i>The Essential Client/Server Survival Guide</i>. New York: Wiley Computer Publishing. pp. 375–397. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-15325-7" title="Special:BookSources/0-471-15325-7">0-471-15325-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.aufirst=Robert&amp;rft.aulast=Orfali&amp;rft.au=Orfali%2C+Robert&amp;rft.btitle=The+Essential+Client%2FServer+Survival+Guide&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-15325-7&amp;rft.pages=375-397&amp;rft.place=New+York&amp;rft.pub=Wiley+Computer+Publishing&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation journal">Milner, Robin (Jan 1993). <a rel="nofollow" class="external text" href="https://dl.acm.org/citation.cfm?id=151240">"Elements of interaction: Turing award lecture"</a>. <i>Communications of the ACM</i> <b>36</b> (1).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Elements+of+interaction%3A+Turing+award+lecture&amp;rft.aufirst=Robin&amp;rft.aulast=Milner&amp;rft.au=Milner%2C+Robin&amp;rft.date=Jan+1993&amp;rft.genre=article&amp;rft_id=https%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D151240&amp;rft.issue=1&amp;rft.jtitle=Communications+of+the+ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=36" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span id="CITEREFHewitt_et_al.1973" class="citation journal">Carl Hewitt; Peter Bishop; Richard Steiger (1973). "A Universal Modular Actor Formalism for Artificial Intelligence". IJCAI.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.au=Carl+Hewitt&amp;rft.aulast=Carl+Hewitt&amp;rft.au=Peter+Bishop&amp;rft.au=Richard+Steiger&amp;rft.btitle=A+Universal+Modular+Actor+Formalism+for+Artificial+Intelligence&amp;rft.date=1973&amp;rft.genre=book&amp;rft.pub=IJCAI&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web">Kay, Allen. <a rel="nofollow" class="external text" href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">"prototypes vs classes was: Re: Sun's HotSpot"</a>. <i>lists.squeakfoundation.org</i><span class="reference-accessdate">. Retrieved 2 January 2014</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=prototypes+vs+classes+was%3A+Re%3A+Sun%27s+HotSpot&amp;rft.aufirst=Allen&amp;rft.au=Kay%2C+Allen&amp;rft.aulast=Kay&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flists.squeakfoundation.org%2Fpipermail%2Fsqueak-dev%2F1998-October%2F017019.html&amp;rft.jtitle=lists.squeakfoundation.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://bartoszmilewski.wordpress.com/2010/08/02/beyond-locks-and-messages-the-future-of-concurrent-programming/">Future of Concurrent Programming</a></li>
<li><a rel="nofollow" class="external text" href="http://www.netlib.org/utk/lsi/pcwLSI/text/node58.html#SECTION00720000000000000000">A Packet History of Message Passing</a></li>
</ul>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=10" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation conference">Ramachandran, U.; M. Solomon; M. Vernon (1987). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=30371&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Hardware support for interprocess communication"</a>. "Proceedings of the 14th annual international symposium on Computer architecture". ACM Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Proceedings+of+the+14th+annual+international+symposium+on+Computer+architecture&amp;rft.aufirst=U.&amp;rft.aulast=Ramachandran&amp;rft.au=M.+Solomon&amp;rft.au=M.+Vernon&amp;rft.au=Ramachandran%2C+U.&amp;rft.btitle=Hardware+support+for+interprocess+communication&amp;rft.date=1987&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D30371%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=ACM+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Dally, William. <a rel="nofollow" class="external text" href="http://cva.stanford.edu/projects/j-machine/">"The Jellybean Machine"</a><span class="reference-accessdate">. Retrieved 7 June 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.au=Dally%2C+William&amp;rft.aufirst=William&amp;rft.aulast=Dally&amp;rft.btitle=The+Jellybean+Machine&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fcva.stanford.edu%2Fprojects%2Fj-machine%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation conference">McQuillan, John M.; David C. Walden (1975). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=810905&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Some considerations for a high performance message-based interprocess communication system"</a>. "Proceedings of the 1975 ACM SIGCOMM/SIGOPS workshop on Interprocess communications". ACM Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Proceedings+of+the+1975+ACM+SIGCOMM%2FSIGOPS+workshop+on+Interprocess+communications&amp;rft.au=David+C.+Walden&amp;rft.aufirst=John+M.&amp;rft.aulast=McQuillan&amp;rft.au=McQuillan%2C+John+M.&amp;rft.btitle=Some+considerations+for+a+high+performance+message-based+interprocess+communication+system&amp;rft.date=1975&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D810905%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=ACM+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation conference">Shimizu, Toshiyuki; Takeshi Horie; Hiroaki Ishihata (1992). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=140385&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Low-latency message communication support for the AP1000"</a>. "Proceedings of the 19th annual international symposium on Computer architecture". ACM Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Proceedings+of+the+19th+annual+international+symposium+on+Computer+architecture&amp;rft.aufirst=Toshiyuki&amp;rft.au=Hiroaki+Ishihata&amp;rft.aulast=Shimizu&amp;rft.au=Shimizu%2C+Toshiyuki&amp;rft.au=Takeshi+Horie&amp;rft.btitle=Low-latency+message+communication+support+for+the+AP1000&amp;rft.date=1992&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D140385%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=ACM+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:IPC" title="Template:IPC"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:IPC" title="Template talk:IPC"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:IPC&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Computer_file" title="Computer file">File</a></li>
<li><a href="/wiki/Mmap" title="Mmap">Memory-mapped file</a></li>
<li><strong class="selflink">Message passing</strong></li>
<li><a href="/wiki/Message_queue" title="Message queue">Message queue and mailbox</a></li>
<li><a href="/wiki/Named_pipe" title="Named pipe">Named pipe</a></li>
<li><a href="/wiki/Anonymous_pipe" title="Anonymous pipe">Anonymous pipe</a></li>
<li><a href="/wiki/Pipeline_(Unix)" title="Pipeline (Unix)">Pipe</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Shared_memory" title="Shared memory">Shared memory</a></li>
<li><a href="/wiki/Unix_signal" title="Unix signal">Signal</a></li>
<li>Sockets
<ul>
<li><a href="/wiki/Internet_socket" title="Internet socket" class="mw-redirect">Internet</a></li>
<li><a href="/wiki/Unix_domain_socket" title="Unix domain socket">Unix</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Internet_socket" title="Internet socket" class="mw-redirect">Internet</a></li>
<li><a href="/wiki/Unix_domain_socket" title="Unix domain socket">Unix</a></li>
</ul>
<ul>
<li><a href="/wiki/Apple_events" title="Apple events" class="mw-redirect">Apple events</a></li>
<li><a href="/wiki/Component_Object_Model#COM.2B" title="Component Object Model">COM+</a></li>
<li><a href="/wiki/Common_Object_Request_Broker_Architecture" title="Common Object Request Broker Architecture">CORBA</a></li>
<li><a href="/wiki/D-Bus" title="D-Bus">D-Bus</a></li>
<li><a href="/wiki/Data_Distribution_Service" title="Data Distribution Service">DDS</a></li>
<li><a href="/wiki/Distributed_Computing_Environment" title="Distributed Computing Environment">DCE</a></li>
<li><a href="/wiki/Internet_Communications_Engine" title="Internet Communications Engine">ICE</a></li>
<li><a href="/wiki/Open_Network_Computing_Remote_Procedure_Call" title="Open Network Computing Remote Procedure Call">ONC RPC</a></li>
<li><a href="/wiki/POSIX" title="POSIX">POSIX</a> (various methods)</li>
<li><a href="/wiki/SOAP" title="SOAP">SOAP</a></li>
<li><a href="/wiki/Representational_State_Transfer" title="Representational State Transfer" class="mw-redirect">REST</a></li>
<li><a href="/wiki/Apache_Thrift" title="Apache Thrift">Thrift</a></li>
<li><a href="/wiki/TIPC" title="TIPC">TIPC</a></li>
<li><a href="/wiki/XML-RPC" title="XML-RPC">XML-RPC</a></li>
</ul>
<ul>
<li><a href="/wiki/D-Bus" title="D-Bus">D-Bus</a></li>
<li><a href="/wiki/Libevent" title="Libevent">libevent</a></li>
<li><a href="/wiki/SIMPL" title="SIMPL">SIMPL</a></li>
<li><a href="/wiki/LINX_(IPC)" title="LINX (IPC)">LINX</a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Message passing</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>message passing</b> sends a message to a process (which may be an <a href="/wiki/Actor_model" title="Actor model">actor</a> or <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a>) and relies on the process and the supporting infrastructure to select and invoke the actual code to run. Message passing differs from conventional programming where a process, subroutine, or function is directly invoked by name. Message passing is key to some <a href="/wiki/Concurrency_(computer_science)#Models" title="Concurrency (computer science)">models of concurrency</a> and <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>.</p>
<p>Message passing is used ubiquitously in modern computer software. It is used as a way for the objects that make up a program to work with each other and as a way for objects and systems running on different computers (e.g., the Internet) to interact. Message passing may be implemented by various mechanisms, including <a href="/wiki/Channel_(programming)" title="Channel (programming)">channels</a>.</p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Synchronous_versus_asynchronous_message_passing"><span class="tocnumber">2</span> <span class="toctext">Synchronous versus asynchronous message passing</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Distributed_objects"><span class="tocnumber">3</span> <span class="toctext">Distributed objects</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Message_passing_versus_calling"><span class="tocnumber">4</span> <span class="toctext">Message passing versus calling</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Mathematical_models"><span class="tocnumber">5</span> <span class="toctext">Mathematical models</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Examples"><span class="tocnumber">6</span> <span class="toctext">Examples</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Further_reading"><span class="tocnumber">10</span> <span class="toctext">Further reading</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Message passing is a technique for invoking behavior (i.e., running a program) on a computer. In contrast to the traditional technique of calling a program by name, message passing uses an <a href="/wiki/Object_model" title="Object model">object model</a> to distinguish the general function from the specific implementations. The invoking program sends a message and relies on the object to select and execute the appropriate code. The justifications for using an intermediate layer essentially falls into two categories: encapsulation and distribution.</p>
<p><a href="/wiki/Encapsulation_(computer_science)" title="Encapsulation (computer science)" class="mw-redirect">Encapsulation</a> is the idea that software objects should be able to invoke services on other objects without knowing or caring about how those services are implemented. Encapsulation can reduce the amount of coding logic and make systems more maintainable. E.g., rather than having IF-THEN statements that determine which subroutine or function to call a developer can just send a message to the object and the object will select the appropriate code based on its type.</p>
<p>One of the first examples of how this can be used was in the domain of computer graphics. There are all sorts of various complications in manipulating graphic objects. For example, simply using the right formula to compute the area of an enclosed shape will vary depending on if the shape is a triangle, rectangle, elipse, or circle. In traditional computer programming this would result in long IF-THEN statements testing what sort of object the shape was and calling the appropriate code. The object-oriented way to handle this is to define a class called <code>Shape</code> with subclasses such as <code>Rectangle</code> and <code>Ellipse</code> (which in turn have subclasses <code>Square</code> and <code>Circle</code>) and then to simply send a message to any <code>Shape</code> asking it to compute its area. Each <code>Shape</code> object will then invoke the appropriate code with the formula appropriate for that kind of object.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup></p>
<p>Distributed message passing provides developers with a layer of the architecture that provides common services to build systems made up of sub-systems that run on disparate computers in different locations and at different times. When sending a distributed object a message the messaging layer can take care of issues such as:</p>
<ul>
<li>Finding the appropriate object, including objects running on different computers, using different operating systems and programming languages, at different locations from where the message originated.</li>
<li>Saving the message on a queue if the appropriate object to handle the message is not currently running and then invoking the message when the object is available. Also, storing the result if needed until the sending object is ready to receive it.</li>
<li>Controlling various transactional requirements for distributed transactions, e.g. ensuring <a href="/wiki/ACID" title="ACID">ACID</a> properties on data.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup></li>
</ul>
<h2><span class="mw-headline" id="Synchronous_versus_asynchronous_message_passing">Synchronous versus asynchronous message passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=2" title="Edit section: Synchronous versus asynchronous message passing">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>One of the most important distinctions among message passing systems is whether they use synchronous or asynchronous message passing. Synchronous message passing occurs between objects that are running at the same time. With asynchronous message passing it is possible for the receiving object to be busy or not running when the requesting object sends the message.</p>
<p>Synchronous message passing is what typical object-oriented programming languages such as Java and Smalltalk use. Asynchronous message passing requires additional capabilities for storing and retransmitting data for systems that may not run concurrently.</p>
<p>The advantage to synchronous message passing is that it is conceptually less complex. Synchronous message passing is analogous to a function call in which the message sender is the function caller and the message receiver is the called function. Function calling is easy and familiar. Just as the function caller stops until the called function completes, the sending process stops until the receiving process completes. This alone makes synchronous message unworkable for some applications. For example, if synchronous message passing would be used exclusively, large, distributed systems generally would not perform well enough to be usable. Such large, distributed systems may need to continue to operate while some of their subsystems are down; subsystems may need to go offline for some kind of maintenance, or have times when subsystems are not open to receiving input from other systems.</p>
<p>Imagine a busy business office having 100 desktop computers that send emails to each other using synchronous message passing exclusively. Because the office system does not use asynchronous message passing, one worker turning off their computer can cause the other 99 computers to freeze until the worker turns their computer back on to process a single email.</p>
<p>Asynchronous message passing is generally implemented so that all the complexities that naturally occur when trying to synchronize systems and data are handled by an intermediary level of software. Commercial vendors who develop software products to support these intermediate levels usually call their software "<a href="/wiki/Middleware" title="Middleware">middleware</a>". One of the most common types of middleware to support asynchronous messaging is called <a href="/wiki/Message-oriented_middleware" title="Message-oriented middleware">Message Oriented Middleware (MOM)</a></p>
<p>With asynchronous message passing, the sending system does not wait for a response. Continuing the function call analogy, asynchronous message passing would be a function call that returns immediately, without waiting for the called function to execute. Such an asynchronous function call would merely deliver the arguments, if any, to the called function, and tell the called function to execute, and then return to continue its own execution. Asynchronous message passing simply sends the message to the message bus. The bus stores the message until the receiving process requests messages sent to it. When the receiving process arrives at the result, it sends the result to the message bus. And the message bus holds the message until the original process (or some designated next process) picks up its messages from the message bus.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<p>Synchronous communication can be built on top of asynchronous communication by using a <a href="/wiki/Synchronizer_(algorithm)" title="Synchronizer (algorithm)">Synchronizer</a>. For example, the α-Synchronizer works by ensuring that the sender always waits for an acknowledgement message from the receiver. The sender only sends the next message after the acknowledgement has been received.</p>
<p>The buffer required in asynchronous communication can cause problems when it is full. A decision has to be made whether to block the sender or whether to discard future messages. If the sender is blocked, it may lead to an unexpected <a href="/wiki/Deadlock" title="Deadlock">deadlock</a>. If messages are dropped, then communication is no longer reliable. These are all examples of the kinds of problems that middleware vendors try to address.</p>
<h2><span class="mw-headline" id="Distributed_objects">Distributed objects</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=3" title="Edit section: Distributed objects">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In addition to the distinction between synchronous and asynchronous message passing the other primary distinguishing feature of message passing systems is whether they use distributed or local objects. With distributed objects the sender and receiver may exist on different computers, running different operating systems, using different programming languages, etc. In this case the bus layer takes care of details about converting data from one system to another, sending and receiving data across the network, etc. The Remote Procedure Call (RPC) protocol in Unix was an early example of this. Note that with this type of message passing it is not a requirement that either the sender or receiver are implemented using object-oriented programming. It is possible to wrap systems developed using procedural languages and treat them as large grained objects capable of sending and receiving messages.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4"><span>[</span>4<span>]</span></a></sup></p>
<p>Examples of systems that support distributed objects are: <a href="/wiki/ONC_RPC" title="ONC RPC" class="mw-redirect">ONC RPC</a>, <a href="/wiki/CORBA" title="CORBA" class="mw-redirect">CORBA</a>, <a href="/wiki/Java_RMI" title="Java RMI" class="mw-redirect">Java RMI</a>, <a href="/wiki/Distributed_Component_Object_Model" title="Distributed Component Object Model">DCOM</a>, <a href="/wiki/SOAP_(protocol)" title="SOAP (protocol)" class="mw-redirect">SOAP</a>, <a href="/wiki/.NET_Remoting" title=".NET Remoting">.NET Remoting</a>, <a href="/wiki/CTOS" title="CTOS" class="mw-redirect">CTOS</a>, <a href="/wiki/QNX" title="QNX">QNX Neutrino RTOS</a>, <a href="/wiki/OpenBinder" title="OpenBinder">OpenBinder</a>, and <a href="/wiki/D-Bus" title="D-Bus">D-Bus</a>. Distributed object systems have been called "shared nothing" systems because the message passing abstraction hides underlying state changes that may be used in the implementation of sending messages.</p>
<h2><span class="mw-headline" id="Message_passing_versus_calling">Message passing versus calling</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=4" title="Edit section: Message passing versus calling">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Distributed or asynchronous message passing has some overhead associated with it compared to the simpler way of simply calling a procedure. In a traditional <a href="/wiki/Calling_convention" title="Calling convention">procedure call</a>, arguments are passed to the receiver typically by one or more <a href="/wiki/General_purpose_register" title="General purpose register" class="mw-redirect">general purpose registers</a> or in a <a href="/wiki/Parameter_(computer_science)" title="Parameter (computer science)" class="mw-redirect">parameter list</a> containing the addresses of each of the arguments. This form of communication differs from message passing in at least three crucial areas:</p>
<ul>
<li>total memory usage</li>
<li><a href="/wiki/Bit_rate" title="Bit rate">transfer time</a></li>
<li>locality</li>
</ul>
<p>In message passing, each of the arguments has to copy the existing argument into a portion of the new message. This applies regardless of the size of the argument and in some cases the arguments can be as large as a document which can be megabytes worth of data. The argument has to be copied in its entirety and transmitted to the receiving object.</p>
<p>By contrast, for a standard procedure call, only an address (a few bits) needs to be passed for each argument and may even be passed in a <a href="/wiki/General_purpose_register" title="General purpose register" class="mw-redirect">general purpose register</a> requiring zero additional storage and zero transfer time.</p>
<p>This of course is not possible for distributed systems since an (absolute) address – in the callers address space – is normally meaningless to the remote program (however, a <a href="/wiki/Relative_address" title="Relative address" class="mw-redirect">relative address</a> might in fact be usable if the receiver had an <i>exact</i> copy of, at least some of, the sender's memory in advance). Web <a href="/wiki/Web_browsing" title="Web browsing" class="mw-redirect">browsers</a> and <a href="/wiki/Web_server" title="Web server">web servers</a> are examples of processes that communicate by message passing. A <a href="/wiki/URL" title="URL" class="mw-redirect">URL</a> is an example of a way of referencing resources that does not depend on exposing the internals of a process.</p>
<p>A <a href="/wiki/Subroutine" title="Subroutine">subroutine</a> call or <a href="/wiki/Method_(computer_programming)" title="Method (computer programming)">method</a> invocation will not exit until the invoked computation has terminated. Asynchronous message passing, by contrast, can result in a response arriving a significant time after the request message was sent.</p>
<p>A message handler will, in general, process messages from more than one sender. This means its state can change for reasons unrelated to the behaviour of a single sender or client process. This is in contrast to the typical behaviour of an object upon which methods are being invoked: the latter is expected to remain in the same state between method invocations. In other words, the message handler behaves analogously to a <a href="/wiki/Volatile_variable" title="Volatile variable" class="mw-redirect">volatile object</a>.</p>
<h2><span class="mw-headline" id="Mathematical_models">Mathematical models</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=5" title="Edit section: Mathematical models">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The prominent mathematical models of message passing are the <a href="/wiki/Actor_model" title="Actor model">Actor model</a> and <a href="/wiki/Pi_calculus" title="Pi calculus" class="mw-redirect">Pi calculus</a>.<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup><sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup> In mathematical terms a message is the single means to pass control to an object. If the object responds to the message, it has a <a href="/wiki/Method_(computer_science)" title="Method (computer science)" class="mw-redirect">method</a> for that message.</p>
<p><a href="/wiki/Alan_Kay" title="Alan Kay">Alan Kay</a> has argued that message passing is more important than objects in OOP, and that objects themselves are often over-emphasized. The <a href="/wiki/Live_distributed_object" title="Live distributed object">live distributed objects</a> programming model builds upon this observation; it uses the concept of a <a href="/wiki/Distributed_data_flow" title="Distributed data flow">distributed data flow</a> to characterize the behavior of a complex distributed system in terms of message patterns, using high-level, functional-style specifications.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=6" title="Edit section: Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Actor_model_implementation" title="Actor model implementation">Actor model implementation</a></li>
<li><a href="/wiki/Amorphous_computing" title="Amorphous computing">Amorphous computing</a></li>
<li><a href="/wiki/Flow-based_programming" title="Flow-based programming">Flow-based programming</a></li>
<li><a href="/wiki/SOAP_(protocol)" title="SOAP (protocol)" class="mw-redirect">SOAP (protocol)</a></li>
</ul>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="/wiki/Active_message" title="Active message">Active message</a></li>
<li><a href="/wiki/Distributed_computing" title="Distributed computing">Distributed computing</a></li>
<li><a href="/wiki/Event_loop" title="Event loop">Event loop</a></li>
<li><a href="/wiki/Inter-process_communication" title="Inter-process communication">Inter-process communication</a></li>
<li><a href="/wiki/Message-oriented_middleware" title="Message-oriented middleware">Message-oriented middleware</a></li>
<li><a href="/wiki/Messaging_pattern" title="Messaging pattern">Messaging pattern</a></li>
<li><a href="/wiki/Message_passing_in_computer_clusters" title="Message passing in computer clusters">Message passing in computer clusters</a></li>
</ul>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=8" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text"><span class="citation book">Goldberg, Adele; David Robson (1989). <i>Smalltalk-80 The Language</i>. Addison Wesley. pp. 5–16. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-201-13688-0" title="Special:BookSources/0-201-13688-0">0-201-13688-0</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.au=David+Robson&amp;rft.aufirst=Adele&amp;rft.au=Goldberg%2C+Adele&amp;rft.aulast=Goldberg&amp;rft.btitle=Smalltalk-80+The+Language&amp;rft.date=1989&amp;rft.genre=book&amp;rft.isbn=0-201-13688-0&amp;rft.pages=5-16&amp;rft.pub=Addison+Wesley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text"><span class="citation book">Orfali, Robert (1996). <i>The Essential Client/Server Survival Guide</i>. New York: Wiley Computer Publishing. pp. 1–22. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-15325-7" title="Special:BookSources/0-471-15325-7">0-471-15325-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.aufirst=Robert&amp;rft.aulast=Orfali&amp;rft.au=Orfali%2C+Robert&amp;rft.btitle=The+Essential+Client%2FServer+Survival+Guide&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-15325-7&amp;rft.pages=1-22&amp;rft.place=New+York&amp;rft.pub=Wiley+Computer+Publishing&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text"><span class="citation book">Orfali, Robert (1996). <i>The Essential Client/Server Survival Guide</i>. New York: Wiley Computer Publishing. pp. 95–133. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-15325-7" title="Special:BookSources/0-471-15325-7">0-471-15325-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.aufirst=Robert&amp;rft.aulast=Orfali&amp;rft.au=Orfali%2C+Robert&amp;rft.btitle=The+Essential+Client%2FServer+Survival+Guide&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-15325-7&amp;rft.pages=95-133&amp;rft.place=New+York&amp;rft.pub=Wiley+Computer+Publishing&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-4">^</a></b></span> <span class="reference-text"><span class="citation book">Orfali, Robert (1996). <i>The Essential Client/Server Survival Guide</i>. New York: Wiley Computer Publishing. pp. 375–397. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/0-471-15325-7" title="Special:BookSources/0-471-15325-7">0-471-15325-7</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.aufirst=Robert&amp;rft.aulast=Orfali&amp;rft.au=Orfali%2C+Robert&amp;rft.btitle=The+Essential+Client%2FServer+Survival+Guide&amp;rft.date=1996&amp;rft.genre=book&amp;rft.isbn=0-471-15325-7&amp;rft.pages=375-397&amp;rft.place=New+York&amp;rft.pub=Wiley+Computer+Publishing&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text"><span class="citation journal">Milner, Robin (Jan 1993). <a rel="nofollow" class="external text" href="https://dl.acm.org/citation.cfm?id=151240">"Elements of interaction: Turing award lecture"</a>. <i>Communications of the ACM</i> <b>36</b> (1).</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Elements+of+interaction%3A+Turing+award+lecture&amp;rft.aufirst=Robin&amp;rft.aulast=Milner&amp;rft.au=Milner%2C+Robin&amp;rft.date=Jan+1993&amp;rft.genre=article&amp;rft_id=https%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D151240&amp;rft.issue=1&amp;rft.jtitle=Communications+of+the+ACM&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=36" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text"><span id="CITEREFHewitt_et_al.1973" class="citation journal">Carl Hewitt; Peter Bishop; Richard Steiger (1973). "A Universal Modular Actor Formalism for Artificial Intelligence". IJCAI.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.au=Carl+Hewitt&amp;rft.aulast=Carl+Hewitt&amp;rft.au=Peter+Bishop&amp;rft.au=Richard+Steiger&amp;rft.btitle=A+Universal+Modular+Actor+Formalism+for+Artificial+Intelligence&amp;rft.date=1973&amp;rft.genre=book&amp;rft.pub=IJCAI&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web">Kay, Allen. <a rel="nofollow" class="external text" href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">"prototypes vs classes was: Re: Sun's HotSpot"</a>. <i>lists.squeakfoundation.org</i><span class="reference-accessdate">. Retrieved 2 January 2014</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=prototypes+vs+classes+was%3A+Re%3A+Sun%27s+HotSpot&amp;rft.aufirst=Allen&amp;rft.au=Kay%2C+Allen&amp;rft.aulast=Kay&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Flists.squeakfoundation.org%2Fpipermail%2Fsqueak-dev%2F1998-October%2F017019.html&amp;rft.jtitle=lists.squeakfoundation.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://bartoszmilewski.wordpress.com/2010/08/02/beyond-locks-and-messages-the-future-of-concurrent-programming/">Future of Concurrent Programming</a></li>
<li><a rel="nofollow" class="external text" href="http://www.netlib.org/utk/lsi/pcwLSI/text/node58.html#SECTION00720000000000000000">A Packet History of Message Passing</a></li>
</ul>
<h2><span class="mw-headline" id="Further_reading">Further reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Message_passing&amp;action=edit&amp;section=10" title="Edit section: Further reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><span class="citation conference">Ramachandran, U.; M. Solomon; M. Vernon (1987). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=30371&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Hardware support for interprocess communication"</a>. "Proceedings of the 14th annual international symposium on Computer architecture". ACM Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Proceedings+of+the+14th+annual+international+symposium+on+Computer+architecture&amp;rft.aufirst=U.&amp;rft.aulast=Ramachandran&amp;rft.au=M.+Solomon&amp;rft.au=M.+Vernon&amp;rft.au=Ramachandran%2C+U.&amp;rft.btitle=Hardware+support+for+interprocess+communication&amp;rft.date=1987&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D30371%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=ACM+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation web">Dally, William. <a rel="nofollow" class="external text" href="http://cva.stanford.edu/projects/j-machine/">"The Jellybean Machine"</a><span class="reference-accessdate">. Retrieved 7 June 2013</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.au=Dally%2C+William&amp;rft.aufirst=William&amp;rft.aulast=Dally&amp;rft.btitle=The+Jellybean+Machine&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fcva.stanford.edu%2Fprojects%2Fj-machine%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation conference">McQuillan, John M.; David C. Walden (1975). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=810905&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Some considerations for a high performance message-based interprocess communication system"</a>. "Proceedings of the 1975 ACM SIGCOMM/SIGOPS workshop on Interprocess communications". ACM Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Proceedings+of+the+1975+ACM+SIGCOMM%2FSIGOPS+workshop+on+Interprocess+communications&amp;rft.au=David+C.+Walden&amp;rft.aufirst=John+M.&amp;rft.aulast=McQuillan&amp;rft.au=McQuillan%2C+John+M.&amp;rft.btitle=Some+considerations+for+a+high+performance+message-based+interprocess+communication+system&amp;rft.date=1975&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D810905%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=ACM+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
<li><span class="citation conference">Shimizu, Toshiyuki; Takeshi Horie; Hiroaki Ishihata (1992). <a rel="nofollow" class="external text" href="http://portal.acm.org/citation.cfm?id=140385&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">"Low-latency message communication support for the AP1000"</a>. "Proceedings of the 19th annual international symposium on Computer architecture". ACM Press.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AMessage+passing&amp;rft.atitle=Proceedings+of+the+19th+annual+international+symposium+on+Computer+architecture&amp;rft.aufirst=Toshiyuki&amp;rft.au=Hiroaki+Ishihata&amp;rft.aulast=Shimizu&amp;rft.au=Shimizu%2C+Toshiyuki&amp;rft.au=Takeshi+Horie&amp;rft.btitle=Low-latency+message+communication+support+for+the+AP1000&amp;rft.date=1992&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D140385%26coll%3D%26dl%3DACM%26CFID%3D15151515%26CFTOKEN%3D6184618&amp;rft.pub=ACM+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></li>
</ul>
<ul>
<li class="nv-view"><a href="/wiki/Template:IPC" title="Template:IPC"><span title="View this template" style=";;background:none transparent;border:none;;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:IPC" title="Template talk:IPC"><span title="Discuss this template" style=";;background:none transparent;border:none;;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:IPC&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;;">e</span></a></li>
</ul>
<ul>
<li><a href="/wiki/Computer_file" title="Computer file">File</a></li>
<li><a href="/wiki/Mmap" title="Mmap">Memory-mapped file</a></li>
<li><strong class="selflink">Message passing</strong></li>
<li><a href="/wiki/Message_queue" title="Message queue">Message queue and mailbox</a></li>
<li><a href="/wiki/Named_pipe" title="Named pipe">Named pipe</a></li>
<li><a href="/wiki/Anonymous_pipe" title="Anonymous pipe">Anonymous pipe</a></li>
<li><a href="/wiki/Pipeline_(Unix)" title="Pipeline (Unix)">Pipe</a></li>
<li><a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">Semaphore</a></li>
<li><a href="/wiki/Shared_memory" title="Shared memory">Shared memory</a></li>
<li><a href="/wiki/Unix_signal" title="Unix signal">Signal</a></li>
<li>Sockets
<ul>
<li><a href="/wiki/Internet_socket" title="Internet socket" class="mw-redirect">Internet</a></li>
<li><a href="/wiki/Unix_domain_socket" title="Unix domain socket">Unix</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="/wiki/Internet_socket" title="Internet socket" class="mw-redirect">Internet</a></li>
<li><a href="/wiki/Unix_domain_socket" title="Unix domain socket">Unix</a></li>
</ul>
<ul>
<li><a href="/wiki/Apple_events" title="Apple events" class="mw-redirect">Apple events</a></li>
<li><a href="/wiki/Component_Object_Model#COM.2B" title="Component Object Model">COM+</a></li>
<li><a href="/wiki/Common_Object_Request_Broker_Architecture" title="Common Object Request Broker Architecture">CORBA</a></li>
<li><a href="/wiki/D-Bus" title="D-Bus">D-Bus</a></li>
<li><a href="/wiki/Data_Distribution_Service" title="Data Distribution Service">DDS</a></li>
<li><a href="/wiki/Distributed_Computing_Environment" title="Distributed Computing Environment">DCE</a></li>
<li><a href="/wiki/Internet_Communications_Engine" title="Internet Communications Engine">ICE</a></li>
<li><a href="/wiki/Open_Network_Computing_Remote_Procedure_Call" title="Open Network Computing Remote Procedure Call">ONC RPC</a></li>
<li><a href="/wiki/POSIX" title="POSIX">POSIX</a> (various methods)</li>
<li><a href="/wiki/SOAP" title="SOAP">SOAP</a></li>
<li><a href="/wiki/Representational_State_Transfer" title="Representational State Transfer" class="mw-redirect">REST</a></li>
<li><a href="/wiki/Apache_Thrift" title="Apache Thrift">Thrift</a></li>
<li><a href="/wiki/TIPC" title="TIPC">TIPC</a></li>
<li><a href="/wiki/XML-RPC" title="XML-RPC">XML-RPC</a></li>
</ul>
<ul>
<li><a href="/wiki/D-Bus" title="D-Bus">D-Bus</a></li>
<li><a href="/wiki/Libevent" title="Libevent">libevent</a></li>
<li><a href="/wiki/SIMPL" title="SIMPL">SIMPL</a></li>
<li><a href="/wiki/LINX_(IPC)" title="LINX (IPC)">LINX</a></li>
</ul>
