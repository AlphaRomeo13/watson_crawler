<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Arrow (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>arrows</b> are a <a href="/wiki/Type_class" title="Type class">type class</a> used in <a href="/wiki/Programming_language" title="Programming language">programming</a> to describe <a href="/wiki/Computation" title="Computation">computations</a> in a <a href="/wiki/Pure_function" title="Pure function">pure</a> and <a href="/wiki/Declarative_programming" title="Declarative programming">declarative</a> fashion. First proposed by computer scientist <a href="/wiki/John_Hughes_(computer_scientist)" title="John Hughes (computer scientist)">John Hughes</a> as a generalization of <a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">monads</a>, arrows provide a <a href="/wiki/Referential_transparency_(computer_science)" title="Referential transparency (computer science)">referentially transparent</a> way of expressing relationships between <i>logical</i> steps in a computation.<sup id="cite_ref-Hughes98_1-0" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup> Unlike monads, arrows don't limit steps to having one and only one input. As a result, they have found use in <a href="/wiki/Functional_reactive_programming" title="Functional reactive programming">functional reactive programming</a>, <a href="/wiki/Point-free_programming" title="Point-free programming" class="mw-redirect">point-free programming</a>, and <a href="/wiki/Parser" title="Parser" class="mw-redirect">parsers</a> among other applications.<sup id="cite_ref-Hughes98_1-1" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-Paterson03_2-0" class="reference"><a href="#cite_note-Paterson03-2"><span>[</span>2<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Motivation_and_History"><span class="tocnumber">1</span> <span class="toctext">Motivation and History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Definition"><span class="tocnumber">2</span> <span class="toctext">Definition</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Functions"><span class="tocnumber">2.1</span> <span class="toctext">Functions</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Arrow_Laws"><span class="tocnumber">2.2</span> <span class="toctext">Arrow Laws</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Applications"><span class="tocnumber">3</span> <span class="toctext">Applications</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Utility"><span class="tocnumber">4</span> <span class="toctext">Utility</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Arrow (computer science)</span></h1>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>arrows</b> are a <a href="/wiki/Type_class" title="Type class">type class</a> used in <a href="/wiki/Programming_language" title="Programming language">programming</a> to describe <a href="/wiki/Computation" title="Computation">computations</a> in a <a href="/wiki/Pure_function" title="Pure function">pure</a> and <a href="/wiki/Declarative_programming" title="Declarative programming">declarative</a> fashion. First proposed by computer scientist <a href="/wiki/John_Hughes_(computer_scientist)" title="John Hughes (computer scientist)">John Hughes</a> as a generalization of <a href="/wiki/Monad_(functional_programming)" title="Monad (functional programming)">monads</a>, arrows provide a <a href="/wiki/Referential_transparency_(computer_science)" title="Referential transparency (computer science)">referentially transparent</a> way of expressing relationships between <i>logical</i> steps in a computation.<sup id="cite_ref-Hughes98_1-0" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup> Unlike monads, arrows don't limit steps to having one and only one input. As a result, they have found use in <a href="/wiki/Functional_reactive_programming" title="Functional reactive programming">functional reactive programming</a>, <a href="/wiki/Point-free_programming" title="Point-free programming" class="mw-redirect">point-free programming</a>, and <a href="/wiki/Parser" title="Parser" class="mw-redirect">parsers</a> among other applications.<sup id="cite_ref-Hughes98_1-1" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup><sup id="cite_ref-Paterson03_2-0" class="reference"><a href="#cite_note-Paterson03-2"><span>[</span>2<span>]</span></a></sup></p>
<p></p>
<h2>Contents</h2>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Motivation_and_History"><span class="tocnumber">1</span> <span class="toctext">Motivation and History</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Definition"><span class="tocnumber">2</span> <span class="toctext">Definition</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Functions"><span class="tocnumber">2.1</span> <span class="toctext">Functions</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Arrow_Laws"><span class="tocnumber">2.2</span> <span class="toctext">Arrow Laws</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Applications"><span class="tocnumber">3</span> <span class="toctext">Applications</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Utility"><span class="tocnumber">4</span> <span class="toctext">Utility</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Functions"><span class="tocnumber">2.1</span> <span class="toctext">Functions</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Arrow_Laws"><span class="tocnumber">2.2</span> <span class="toctext">Arrow Laws</span></a></li>
</ul>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Functions"><span class="tocnumber">2.1</span> <span class="toctext">Functions</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Arrow_Laws"><span class="tocnumber">2.2</span> <span class="toctext">Arrow Laws</span></a></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Motivation_and_History">Motivation and History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Motivation and History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>While arrows were in use before being recognized as a distinct class, Hughes would publish their first definition in 2000. Until then, monads had proven sufficient for most problems requiring the combination of program logic in pure code. However, some useful <a href="/wiki/Library_(computing)" title="Library (computing)">libraries</a>, such as the <a href="/wiki/Fudgets" title="Fudgets">Fudgets</a> library for <a href="/wiki/Graphical_user_interface" title="Graphical user interface">graphical user interfaces</a> and certain efficient parsers, defied rewriting in a monadic form.<sup id="cite_ref-Hughes98_1-2" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup></p>
<p>The formal concept of arrows was developed to explain these exceptions to monadic code, and in the process, monads themselves turned out to be a <a href="/wiki/Subset" title="Subset">subset</a> of arrows.<sup id="cite_ref-Hughes98_1-3" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup> Since then, arrows have been an active area of research. Their underlying laws and operations have been refined several times, with recent formulations such as <a href="/w/index.php?title=Arrow_calculus&amp;action=edit&amp;redlink=1" class="new" title="Arrow calculus (page does not exist)">arrow calculus</a> requiring only five laws.<sup id="cite_ref-Lindley10_3-0" class="reference"><a href="#cite_note-Lindley10-3"><span>[</span>3<span>]</span></a></sup></p>
<p>In <a href="/wiki/Category_theory" title="Category theory">category theory</a>, the <a href="/wiki/Kleisli_categories" title="Kleisli categories" class="mw-redirect">Kleisli categories</a> of all <a href="/wiki/Monad_(category_theory)" title="Monad (category theory)">monads</a> form a proper subset of Hughes arrows.<sup id="cite_ref-Hughes98_1-4" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup> While <a href="/w/index.php?title=Freyd_category&amp;action=edit&amp;redlink=1" class="new" title="Freyd category (page does not exist)">Freyd categories</a> were believed to be <a href="/wiki/Equivalence_of_categories" title="Equivalence of categories">equivalent</a> to arrows for a time, it has since been proven that arrows are even more general. In fact, arrows are not merely equivalent, but directly equal to <a href="/wiki/Enriched_category" title="Enriched category">enriched</a> Freyd categories.<sup id="cite_ref-Atkey11_4-0" class="reference"><a href="#cite_note-Atkey11-4"><span>[</span>4<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Like all type classes, arrows can be thought of as a set of qualities that can be applied to any <a href="/wiki/Data_type" title="Data type">data type</a>. In the <a href="/wiki/Haskell_programming_language" title="Haskell programming language" class="mw-redirect">Haskell programming language</a>, arrows allow <a href="/wiki/Function_(mathematics)" title="Function (mathematics)">functions</a> (represented in Haskell by an arrow symbol) to combine in a <a href="/wiki/Reification_(computer_science)" title="Reification (computer science)">reified</a> form. However, the actual term "arrow" may also come from the fact that some (but not all) arrows correspond to the <a href="/wiki/Morphism" title="Morphism">morphisms</a> (also known as "arrows" in category theory) of different Kleisli categories. As a relatively new concept, there is not a single, standard definition, but all formulations are logically equivalent, feature some required methods, and strictly obey certain mathematical laws.<sup id="cite_ref-Hughes05_5-0" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Functions">Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The description currently used by the Haskell <a href="/wiki/Standard_libraries" title="Standard libraries" class="mw-redirect">standard libraries</a> <i>requires</i> only two basic operations:</p>
<ul>
<li>A <a href="/wiki/Type_constructor" title="Type constructor">type constructor</a> <img class="mwe-math-fallback-image-inline tex" alt="arr" src="//upload.wikimedia.org/math/4/7/c/47c80780ab608cc046f2a6e6f071feb6.png"> that takes functions <img class="mwe-math-fallback-image-inline tex" alt="\to" src="//upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"> from any type <img class="mwe-math-fallback-image-inline tex" alt="s" src="//upload.wikimedia.org/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png"> to another <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">, and lifts those functions into an arrow <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> between the two types.<sup id="cite_ref-HaskArrows_6-0" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p></p>
<h2><span class="mw-headline" id="Motivation_and_History">Motivation and History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Motivation and History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>While arrows were in use before being recognized as a distinct class, Hughes would publish their first definition in 2000. Until then, monads had proven sufficient for most problems requiring the combination of program logic in pure code. However, some useful <a href="/wiki/Library_(computing)" title="Library (computing)">libraries</a>, such as the <a href="/wiki/Fudgets" title="Fudgets">Fudgets</a> library for <a href="/wiki/Graphical_user_interface" title="Graphical user interface">graphical user interfaces</a> and certain efficient parsers, defied rewriting in a monadic form.<sup id="cite_ref-Hughes98_1-2" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup></p>
<p>The formal concept of arrows was developed to explain these exceptions to monadic code, and in the process, monads themselves turned out to be a <a href="/wiki/Subset" title="Subset">subset</a> of arrows.<sup id="cite_ref-Hughes98_1-3" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup> Since then, arrows have been an active area of research. Their underlying laws and operations have been refined several times, with recent formulations such as <a href="/w/index.php?title=Arrow_calculus&amp;action=edit&amp;redlink=1" class="new" title="Arrow calculus (page does not exist)">arrow calculus</a> requiring only five laws.<sup id="cite_ref-Lindley10_3-0" class="reference"><a href="#cite_note-Lindley10-3"><span>[</span>3<span>]</span></a></sup></p>
<p>In <a href="/wiki/Category_theory" title="Category theory">category theory</a>, the <a href="/wiki/Kleisli_categories" title="Kleisli categories" class="mw-redirect">Kleisli categories</a> of all <a href="/wiki/Monad_(category_theory)" title="Monad (category theory)">monads</a> form a proper subset of Hughes arrows.<sup id="cite_ref-Hughes98_1-4" class="reference"><a href="#cite_note-Hughes98-1"><span>[</span>1<span>]</span></a></sup> While <a href="/w/index.php?title=Freyd_category&amp;action=edit&amp;redlink=1" class="new" title="Freyd category (page does not exist)">Freyd categories</a> were believed to be <a href="/wiki/Equivalence_of_categories" title="Equivalence of categories">equivalent</a> to arrows for a time, it has since been proven that arrows are even more general. In fact, arrows are not merely equivalent, but directly equal to <a href="/wiki/Enriched_category" title="Enriched category">enriched</a> Freyd categories.<sup id="cite_ref-Atkey11_4-0" class="reference"><a href="#cite_note-Atkey11-4"><span>[</span>4<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Like all type classes, arrows can be thought of as a set of qualities that can be applied to any <a href="/wiki/Data_type" title="Data type">data type</a>. In the <a href="/wiki/Haskell_programming_language" title="Haskell programming language" class="mw-redirect">Haskell programming language</a>, arrows allow <a href="/wiki/Function_(mathematics)" title="Function (mathematics)">functions</a> (represented in Haskell by an arrow symbol) to combine in a <a href="/wiki/Reification_(computer_science)" title="Reification (computer science)">reified</a> form. However, the actual term "arrow" may also come from the fact that some (but not all) arrows correspond to the <a href="/wiki/Morphism" title="Morphism">morphisms</a> (also known as "arrows" in category theory) of different Kleisli categories. As a relatively new concept, there is not a single, standard definition, but all formulations are logically equivalent, feature some required methods, and strictly obey certain mathematical laws.<sup id="cite_ref-Hughes05_5-0" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<p>WHATSON? 4e553ec9-d6ba-432b-9952-32b02bce2815</p>
<pre class="de1">
arr <span class="br0">(</span>s <span class="sy0">-&gt;</span> t<span class="br0">)</span>        <span class="sy0">-&gt;</span>   A s t
</pre>
<h3><span class="mw-headline" id="Functions">Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The description currently used by the Haskell <a href="/wiki/Standard_libraries" title="Standard libraries" class="mw-redirect">standard libraries</a> <i>requires</i> only two basic operations:</p>
<ul>
<li>A <a href="/wiki/Type_constructor" title="Type constructor">type constructor</a> <img class="mwe-math-fallback-image-inline tex" alt="arr" src="//upload.wikimedia.org/math/4/7/c/47c80780ab608cc046f2a6e6f071feb6.png"> that takes functions <img class="mwe-math-fallback-image-inline tex" alt="\to" src="//upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"> from any type <img class="mwe-math-fallback-image-inline tex" alt="s" src="//upload.wikimedia.org/math/0/3/c/03c7c0ace395d80182db07ae2c30f034.png"> to another <img class="mwe-math-fallback-image-inline tex" alt="t" src="//upload.wikimedia.org/math/e/3/5/e358efa489f58062f10dd7316b65649e.png">, and lifts those functions into an arrow <img class="mwe-math-fallback-image-inline tex" alt="A" src="//upload.wikimedia.org/math/7/f/c/7fc56270e7a70fa81a5935b72eacbe29.png"> between the two types.<sup id="cite_ref-HaskArrows_6-0" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 16d9d88b-5c09-4b35-a735-6868c1da0da2</p>
<pre class="de1">
arr <span class="br0">(</span>s <span class="sy0">-&gt;</span> t<span class="br0">)</span>        <span class="sy0">-&gt;</span>   A s t
</pre>
<ul>
<li>A piping method <img class="mwe-math-fallback-image-inline tex" alt="first" src="//upload.wikimedia.org/math/8/b/0/8b04d5e3775d298e78455efc5ca404d5.png"> that takes an arrow between two types and converts it into an arrow between <a href="/wiki/Tuple" title="Tuple">tuples</a>. The first elements in the tuples represent the portion of the input and output that is altered, while the second elements are a third type <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> describing an unaltered portion that bypasses the computation.<sup id="cite_ref-HaskArrows_6-1" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 42ff2be4-fc87-4cb0-add9-9ac80308a32a</p>
<pre class="de1">
first <span class="br0">(</span>A s t<span class="br0">)</span>       <span class="sy0">-&gt;</span>   A <span class="br0">(</span>s<span class="sy0">,</span>u<span class="br0">)</span> <span class="br0">(</span>t<span class="sy0">,</span>u<span class="br0">)</span>
</pre>
<p>Although only these two procedures are strictly necessary to define an arrow, other methods can be derived to make arrows easier to work with in practice and theory. As all arrows are <a href="/wiki/Category_(mathematics)" title="Category (mathematics)">categories</a>, they can <a href="/wiki/Inheritance_(computer_science)" title="Inheritance (computer science)" class="mw-redirect">inherit</a> a third operation from the class of categories:</p>
<ul>
<li>A <a href="/wiki/Function_composition" title="Function composition">composition</a> operator <img class="mwe-math-fallback-image-inline tex" alt="\ggg" src="//upload.wikimedia.org/math/f/b/7/fb7d1cf9a5e65f98089b6b2cb1570a3c.png"> that can attach a second arrow to a first as long as the first function's output and the second's input have matching types.<sup id="cite_ref-HaskArrows_6-2" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 518e3501-18a5-4ac1-9328-b07d89984235</p>
<pre class="de1">
A s t  <span class="sy0">&gt;&gt;&gt;</span>  A t u   <span class="sy0">-&gt;</span>   A s u
</pre>
<p>One more helpful method can be derived from a combination of the previous three:</p>
<ul>
<li>A merging operator <img class="mwe-math-fallback-image-inline tex" alt="***" src="//upload.wikimedia.org/math/8/a/7/8a7ab20ec0ab3262ce329c7dcb399a4e.png"> that can take two arrows, possibly with different input and output types, and fuse them into one arrow between two compound types. Note that the merge operator is <i>not</i> necessarily <a href="/wiki/Commutative" title="Commutative" class="mw-redirect">commutative</a>.<sup id="cite_ref-HaskArrows_6-3" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 709a1fa4-ff95-40c5-ba70-1b2d5c0a1684</p>
<pre class="de1">
A s t  <span class="sy0">***</span>  A u v   <span class="sy0">-&gt;</span>   A <span class="br0">(</span>s<span class="sy0">,</span>u<span class="br0">)</span> <span class="br0">(</span>t<span class="sy0">,</span>v<span class="br0">)</span>
</pre>
<h3><span class="mw-headline" id="Arrow_Laws">Arrow Laws</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Arrow Laws">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In addition to having some well-defined procedures, arrows must obey certain rules for any types they may be applied to:</p>
<ul>
<li>Arrows must always preserve all types' <a href="/wiki/Identity_morphism" title="Identity morphism" class="mw-redirect">identities</a> <img class="mwe-math-fallback-image-inline tex" alt="id" src="//upload.wikimedia.org/math/b/8/0/b80bb7740288fda1f201890375a60c8f.png"> (essentially the definitions of all values for all types within a category).<sup id="cite_ref-HaskArrows_6-4" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 17020710-b3ab-4f76-bb7b-c3a6a6b25496</p>
<pre class="de1">
arr <span class="kw3">id</span>              <span class="sy0">==</span>   <span class="kw3">id</span>
</pre>
<ul>
<li>When connecting two functions <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png"> &amp; <img class="mwe-math-fallback-image-inline tex" alt="g" src="//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png">, the required arrow operations must <a href="/wiki/Distributivity" title="Distributivity" class="mw-redirect">distribute</a> over compositions from the left.<sup id="cite_ref-HaskArrows_6-5" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<ul>
<li>A piping method <img class="mwe-math-fallback-image-inline tex" alt="first" src="//upload.wikimedia.org/math/8/b/0/8b04d5e3775d298e78455efc5ca404d5.png"> that takes an arrow between two types and converts it into an arrow between <a href="/wiki/Tuple" title="Tuple">tuples</a>. The first elements in the tuples represent the portion of the input and output that is altered, while the second elements are a third type <img class="mwe-math-fallback-image-inline tex" alt="u" src="//upload.wikimedia.org/math/7/b/7/7b774effe4a349c6dd82ad4f4f21d34c.png"> describing an unaltered portion that bypasses the computation.<sup id="cite_ref-HaskArrows_6-1" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? d573696e-d07b-42de-a5ab-4b275d39a5ca</p>
<pre class="de1">
first <span class="br0">(</span>A s t<span class="br0">)</span>       <span class="sy0">-&gt;</span>   A <span class="br0">(</span>s<span class="sy0">,</span>u<span class="br0">)</span> <span class="br0">(</span>t<span class="sy0">,</span>u<span class="br0">)</span>
</pre>
<p>Although only these two procedures are strictly necessary to define an arrow, other methods can be derived to make arrows easier to work with in practice and theory. As all arrows are <a href="/wiki/Category_(mathematics)" title="Category (mathematics)">categories</a>, they can <a href="/wiki/Inheritance_(computer_science)" title="Inheritance (computer science)" class="mw-redirect">inherit</a> a third operation from the class of categories:</p>
<ul>
<li>A <a href="/wiki/Function_composition" title="Function composition">composition</a> operator <img class="mwe-math-fallback-image-inline tex" alt="\ggg" src="//upload.wikimedia.org/math/f/b/7/fb7d1cf9a5e65f98089b6b2cb1570a3c.png"> that can attach a second arrow to a first as long as the first function's output and the second's input have matching types.<sup id="cite_ref-HaskArrows_6-2" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? b195a5d2-8fdf-4d01-8515-8ae3842c1b74</p>
<pre class="de1">
A s t  <span class="sy0">&gt;&gt;&gt;</span>  A t u   <span class="sy0">-&gt;</span>   A s u
</pre>
<p>One more helpful method can be derived from a combination of the previous three:</p>
<ul>
<li>A merging operator <img class="mwe-math-fallback-image-inline tex" alt="***" src="//upload.wikimedia.org/math/8/a/7/8a7ab20ec0ab3262ce329c7dcb399a4e.png"> that can take two arrows, possibly with different input and output types, and fuse them into one arrow between two compound types. Note that the merge operator is <i>not</i> necessarily <a href="/wiki/Commutative" title="Commutative" class="mw-redirect">commutative</a>.<sup id="cite_ref-HaskArrows_6-3" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 96089922-8417-41f6-bbfc-2cd4c9cc2707</p>
<pre class="de1">
A s t  <span class="sy0">***</span>  A u v   <span class="sy0">-&gt;</span>   A <span class="br0">(</span>s<span class="sy0">,</span>u<span class="br0">)</span> <span class="br0">(</span>t<span class="sy0">,</span>v<span class="br0">)</span>
</pre>
<h3><span class="mw-headline" id="Arrow_Laws">Arrow Laws</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Arrow Laws">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In addition to having some well-defined procedures, arrows must obey certain rules for any types they may be applied to:</p>
<ul>
<li>Arrows must always preserve all types' <a href="/wiki/Identity_morphism" title="Identity morphism" class="mw-redirect">identities</a> <img class="mwe-math-fallback-image-inline tex" alt="id" src="//upload.wikimedia.org/math/b/8/0/b80bb7740288fda1f201890375a60c8f.png"> (essentially the definitions of all values for all types within a category).<sup id="cite_ref-HaskArrows_6-4" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 1e230b60-4821-4902-82b3-ed6477bbf92c</p>
<pre class="de1">
arr <span class="kw3">id</span>              <span class="sy0">==</span>   <span class="kw3">id</span>
</pre>
<ul>
<li>When connecting two functions <img class="mwe-math-fallback-image-inline tex" alt="f" src="//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png"> &amp; <img class="mwe-math-fallback-image-inline tex" alt="g" src="//upload.wikimedia.org/math/b/2/f/b2f5ff47436671b6e533d8dc3614845d.png">, the required arrow operations must <a href="/wiki/Distributivity" title="Distributivity" class="mw-redirect">distribute</a> over compositions from the left.<sup id="cite_ref-HaskArrows_6-5" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 4ab931d8-dd9f-4ae7-b1c5-127ec556789b</p>
<pre class="de1">
arr <span class="br0">(</span>f <span class="sy0">&gt;&gt;&gt;</span> g<span class="br0">)</span>       <span class="sy0">==</span>   arr f  <span class="sy0">&gt;&gt;&gt;</span>  arr g
first <span class="br0">(</span>f <span class="sy0">&gt;&gt;&gt;</span> g<span class="br0">)</span>     <span class="sy0">==</span>   first f  <span class="sy0">&gt;&gt;&gt;</span>  first g
</pre>
<ul>
<li>In the previous laws, piping can be applied directly to functions because order must be irrelevant when piping &amp; lifting occur together.<sup id="cite_ref-HaskArrows_6-6" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? d39dd669-1040-4524-ba6e-0ce1c08e43a9</p>
<pre class="de1">
arr <span class="br0">(</span>first f<span class="br0">)</span>       <span class="sy0">==</span>   first <span class="br0">(</span>arr f<span class="br0">)</span>
</pre>
<p>The remaining laws restrict how the piping method behaves when the order of a composition is reversed, also allowing for simplifying <a href="/wiki/Expression_(computer_science)" title="Expression (computer science)">expressions</a>:</p>
<p>WHATSON? 2d82f8b2-d5e9-4823-beec-db4e95fe22b5</p>
<pre class="de1">
arr <span class="br0">(</span>f <span class="sy0">&gt;&gt;&gt;</span> g<span class="br0">)</span>       <span class="sy0">==</span>   arr f  <span class="sy0">&gt;&gt;&gt;</span>  arr g
first <span class="br0">(</span>f <span class="sy0">&gt;&gt;&gt;</span> g<span class="br0">)</span>     <span class="sy0">==</span>   first f  <span class="sy0">&gt;&gt;&gt;</span>  first g
</pre>
<ul>
<li>In the previous laws, piping can be applied directly to functions because order must be irrelevant when piping &amp; lifting occur together.<sup id="cite_ref-HaskArrows_6-6" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 8dadebb6-ea7b-4ff5-8930-360cf5066255</p>
<pre class="de1">
arr <span class="br0">(</span>first f<span class="br0">)</span>       <span class="sy0">==</span>   first <span class="br0">(</span>arr f<span class="br0">)</span>
</pre>
<p>The remaining laws restrict how the piping method behaves when the order of a composition is reversed, also allowing for simplifying <a href="/wiki/Expression_(computer_science)" title="Expression (computer science)">expressions</a>:</p>
<ul>
<li>If an identity is merged with a second function to form an arrow, attaching it to a piped function must be commutative.<sup id="cite_ref-HaskArrows_6-7" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? c2f4ad35-1926-4d91-bd0d-2c4d573556ff</p>
<pre class="de1">
arr <span class="br0">(</span><span class="kw3">id</span> <span class="sy0">***</span> g<span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  first f       <span class="sy0">==</span>   first f  <span class="sy0">&gt;&gt;&gt;</span>  arr <span class="br0">(</span><span class="kw3">id</span> <span class="sy0">***</span> g<span class="br0">)</span>
</pre>
<ul>
<li>Piping a function before type simplification must be equivalent to simplifying type before connecting to the unpiped function.<sup id="cite_ref-HaskArrows_6-8" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 8b229254-ac43-4fdb-8099-6701d764b90b</p>
<pre class="de1">
first f  <span class="sy0">&gt;&gt;&gt;</span>  arr <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span> <span class="sy0">-&gt;</span> s<span class="br0">)</span>     <span class="sy0">==</span>   arr <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span> <span class="sy0">-&gt;</span> s<span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  f
</pre>
<ul>
<li>Finally, piping a function twice before <a href="/wiki/Associativity" title="Associativity" class="mw-redirect">reassociating</a> the resulting tuple, which is nested, should be the same as reassociating the nested tuple before attaching a single bypass of the function. In other words, stacked bypasses can be flattened by first bundling together those elements unchanged by the function.<sup id="cite_ref-HaskArrows_6-9" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? f1ee2c5e-0ae3-468d-bf89-ccbaf1ef8adb</p>
<pre class="de1">
first <span class="br0">(</span>first f<span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  arr <span class="br0">(</span> <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span><span class="sy0">,</span>u<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="br0">(</span>s<span class="sy0">,</span><span class="br0">(</span>t<span class="sy0">,</span>u<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span>   <span class="sy0">==</span>
  arr <span class="br0">(</span> <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span><span class="sy0">,</span>u<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="br0">(</span>s<span class="sy0">,</span><span class="br0">(</span>t<span class="sy0">,</span>u<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  first f
</pre>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Arrows may be extended to fit specific situations by defining additional operations and restrictions. Commonly used versions include arrows with choice, which allow a computation to make <a href="/wiki/Conditional_(programming)" title="Conditional (programming)" class="mw-redirect">conditional</a> decisions, and arrows with <a href="/wiki/Feedback" title="Feedback">feedback</a>, which allow a step to take its own outputs as inputs. Another set of arrows, known as arrows with application, are rarely used in practice because they are actually equivalent to monads.<sup id="cite_ref-Hughes05_5-1" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<ul>
<li>If an identity is merged with a second function to form an arrow, attaching it to a piped function must be commutative.<sup id="cite_ref-HaskArrows_6-7" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? bb251faa-65bc-4b55-be83-eb7f3c2b9a95</p>
<pre class="de1">
arr <span class="br0">(</span><span class="kw3">id</span> <span class="sy0">***</span> g<span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  first f       <span class="sy0">==</span>   first f  <span class="sy0">&gt;&gt;&gt;</span>  arr <span class="br0">(</span><span class="kw3">id</span> <span class="sy0">***</span> g<span class="br0">)</span>
</pre>
<ul>
<li>Piping a function before type simplification must be equivalent to simplifying type before connecting to the unpiped function.<sup id="cite_ref-HaskArrows_6-8" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 3508b589-5e0a-4104-9129-f6c7435adf2f</p>
<pre class="de1">
first f  <span class="sy0">&gt;&gt;&gt;</span>  arr <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span> <span class="sy0">-&gt;</span> s<span class="br0">)</span>     <span class="sy0">==</span>   arr <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span> <span class="sy0">-&gt;</span> s<span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  f
</pre>
<ul>
<li>Finally, piping a function twice before <a href="/wiki/Associativity" title="Associativity" class="mw-redirect">reassociating</a> the resulting tuple, which is nested, should be the same as reassociating the nested tuple before attaching a single bypass of the function. In other words, stacked bypasses can be flattened by first bundling together those elements unchanged by the function.<sup id="cite_ref-HaskArrows_6-9" class="reference"><a href="#cite_note-HaskArrows-6"><span>[</span>6<span>]</span></a></sup></li>
</ul>
<p>WHATSON? 0581a31b-c430-4fd0-af5e-fdf2ff0920a7</p>
<pre class="de1">
first <span class="br0">(</span>first f<span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  arr <span class="br0">(</span> <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span><span class="sy0">,</span>u<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="br0">(</span>s<span class="sy0">,</span><span class="br0">(</span>t<span class="sy0">,</span>u<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span>   <span class="sy0">==</span>
  arr <span class="br0">(</span> <span class="br0">(</span><span class="br0">(</span>s<span class="sy0">,</span>t<span class="br0">)</span><span class="sy0">,</span>u<span class="br0">)</span> <span class="sy0">-&gt;</span> <span class="br0">(</span>s<span class="sy0">,</span><span class="br0">(</span>t<span class="sy0">,</span>u<span class="br0">)</span><span class="br0">)</span> <span class="br0">)</span>  <span class="sy0">&gt;&gt;&gt;</span>  first f
</pre>
<h2><span class="mw-headline" id="Applications">Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Arrows may be extended to fit specific situations by defining additional operations and restrictions. Commonly used versions include arrows with choice, which allow a computation to make <a href="/wiki/Conditional_(programming)" title="Conditional (programming)" class="mw-redirect">conditional</a> decisions, and arrows with <a href="/wiki/Feedback" title="Feedback">feedback</a>, which allow a step to take its own outputs as inputs. Another set of arrows, known as arrows with application, are rarely used in practice because they are actually equivalent to monads.<sup id="cite_ref-Hughes05_5-1" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Utility">Utility</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Utility">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Arrows have several benefits, mostly stemming from their ability to make program logic explicit yet concise. Besides avoiding <a href="/wiki/Side_effect_(computer_science)" title="Side effect (computer science)">side effects</a>, <a href="/wiki/Purely_functional" title="Purely functional">purely functional</a> programming creates more opportunities for <a href="/wiki/Static_code_analysis" title="Static code analysis" class="mw-redirect">static code analysis</a>. This in turn can theoretically lead to better <a href="/wiki/Compiler_optimization" title="Compiler optimization" class="mw-redirect">compiler optimizations</a>, easier <a href="/wiki/Debugging" title="Debugging">debugging</a>, and features like <a href="/wiki/Syntax_sugar" title="Syntax sugar" class="mw-redirect">syntax sugar</a>.<sup id="cite_ref-Hughes05_5-2" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Utility">Utility</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Utility">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Arrows have several benefits, mostly stemming from their ability to make program logic explicit yet concise. Besides avoiding <a href="/wiki/Side_effect_(computer_science)" title="Side effect (computer science)">side effects</a>, <a href="/wiki/Purely_functional" title="Purely functional">purely functional</a> programming creates more opportunities for <a href="/wiki/Static_code_analysis" title="Static code analysis" class="mw-redirect">static code analysis</a>. This in turn can theoretically lead to better <a href="/wiki/Compiler_optimization" title="Compiler optimization" class="mw-redirect">compiler optimizations</a>, easier <a href="/wiki/Debugging" title="Debugging">debugging</a>, and features like <a href="/wiki/Syntax_sugar" title="Syntax sugar" class="mw-redirect">syntax sugar</a>.<sup id="cite_ref-Hughes05_5-2" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<p>Although no program strictly requires arrows, they generalize away much of the dense <a href="/wiki/First-class_function" title="First-class function">function passing</a> that pure, declarative code would otherwise require. They can also encourage <a href="/wiki/Code_reuse" title="Code reuse">code reuse</a> by giving common linkages between program steps their own class definitions. The ability to apply to types generically also contributes to reusability and keeps <a href="/wiki/Interface_(computing)" title="Interface (computing)">interfaces</a> simple.<sup id="cite_ref-Hughes05_5-3" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<p>Arrows do have some disadvantages, including the initial effort of defining an arrow that satisfies the arrow laws. Because monads are usually easier to implement, and the extra features of arrows may be unnecessary, it is often preferable to use a monad.<sup id="cite_ref-Hughes05_5-4" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup> Another issue, which applies to many <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a> constructs, is efficiently <a href="/wiki/Compiling" title="Compiling" class="mw-redirect">compiling</a> code with arrows into the <a href="/wiki/Imperative_programming" title="Imperative programming">imperative</a> style used by computer <a href="/wiki/Instruction_set" title="Instruction set">instruction sets</a>.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This statement is commonly heard, but no strong, specific source on hand (June 2012)">citation needed</span></a></i>]</sup></p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-Hughes98-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-Hughes98_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Hughes98_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Hughes98_1-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-Hughes98_1-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-Hughes98_1-4"><sup><i><b>e</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Hughes, John (May 2000). <a rel="nofollow" class="external text" href="http://pdn.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271600&amp;_user=10&amp;_pii=S0167642399000234&amp;_check=y&amp;_origin=search&amp;_zone=rslt_list_item&amp;_coverDate=2000-05-31&amp;wchp=dGLzVlk-zSkWb&amp;md5=fa91ab4ffc136b0cedc52318c7c249be&amp;pid=1-s2.0-S0167642399000234-main.pdf">"Generalising Monads to Arrows"</a> (PDF). <i>Science of Computer Programming</i> (Elsevier) <b>37</b> (1-3): 67–111. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2FS0167-6423%2899%2900023-4">10.1016/S0167-6423(99)00023-4</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0167-6423">0167-6423</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=Generalising+Monads+to+Arrows&amp;rft.aufirst=John&amp;rft.au=Hughes%2C+John&amp;rft.aulast=Hughes&amp;rft.date=May+2000&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fpdn.sciencedirect.com%2Fscience%3F_ob%3DMiamiImageURL%26_cid%3D271600%26_user%3D10%26_pii%3DS0167642399000234%26_check%3Dy%26_origin%3Dsearch%26_zone%3Drslt_list_item%26_coverDate%3D2000-05-31%26wchp%3DdGLzVlk-zSkWb%26md5%3Dfa91ab4ffc136b0cedc52318c7c249be%26pid%3D1-s2.0-S0167642399000234-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2FS0167-6423%2899%2900023-4&amp;rft.issn=0167-6423&amp;rft.issue=1-3&amp;rft.jtitle=Science+of+Computer+Programming&amp;rft.pages=67-111&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=37" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Paterson03-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-Paterson03_2-0">^</a></b></span> <span class="reference-text"><span class="citation book">Paterson, Ross (27 March 2003). <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.ps.gz">"Chapter 10: Arrows and Computation"</a> (PS.GZ). In Gibbons, Jeremy; de Moor, Oege. <i>The Fun of Programming</i>. Palgrave Macmillan. pp. 201–222. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-1403907721" title="Special:BookSources/978-1403907721">978-1403907721</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=The+Fun+of+Programming&amp;rft.aufirst=Ross&amp;rft.aulast=Paterson&amp;rft.au=Paterson%2C+Ross&amp;rft.btitle=Chapter+10%3A+Arrows+and+Computation&amp;rft.date=27+March+2003&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.soi.city.ac.uk%2F~ross%2Fpapers%2Ffop.ps.gz&amp;rft.isbn=978-1403907721&amp;rft.pages=201-222&amp;rft.pub=Palgrave+Macmillan&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Lindley10-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-Lindley10_3-0">^</a></b></span> <span class="reference-text"><span class="citation journal">Lindley, Sam; Wadler, Philip; Yallop, Jeremy (January 2010). <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf">"The Arrow Calculus"</a> (PDF). <i>Journal of Functional Programming</i> <b>20</b> (1): 51–69. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1017%2FS095679680999027X">10.1017/S095679680999027X</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0956-7968">0956-7968</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=The+Arrow+Calculus&amp;rft.aufirst=Sam&amp;rft.aulast=Lindley&amp;rft.au=Lindley%2C+Sam&amp;rft.au=Wadler%2C+Philip&amp;rft.au=Yallop%2C+Jeremy&amp;rft.date=January+2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fhomepages.inf.ed.ac.uk%2Fwadler%2Fpapers%2Farrows-jfp%2Farrows-jfp.pdf&amp;rft_id=info%3Adoi%2F10.1017%2FS095679680999027X&amp;rft.issn=0956-7968&amp;rft.issue=1&amp;rft.jtitle=Journal+of+Functional+Programming&amp;rft.pages=51-69&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=20" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Atkey11-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-Atkey11_4-0">^</a></b></span> <span class="reference-text"><span class="citation journal">Atkey, Robert (8 March 2011). <a rel="nofollow" class="external text" href="http://pdn.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=272990&amp;_user=10&amp;_pii=S157106611100051X&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=08-Mar-2011&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVBA-zSkzS&amp;md5=d479e9216510ae882e9db588ac09dad5&amp;pid=1-s2.0-S157106611100051X-main.pdf">"What is a Categorical Model of Arrows?"</a> (PDF). <i>Electronic Notes in Theoretical Computer Science</i> (Elsevier) <b>229</b> (5): 19–37. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fj.entcs.2011.02.014">10.1016/j.entcs.2011.02.014</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/1571-0661">1571-0661</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=What+is+a+Categorical+Model+of+Arrows%3F&amp;rft.au=Atkey%2C+Robert&amp;rft.aufirst=Robert&amp;rft.aulast=Atkey&amp;rft.date=8+March+2011&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fpdn.sciencedirect.com%2Fscience%3F_ob%3DMiamiImageURL%26_cid%3D272990%26_user%3D10%26_pii%3DS157106611100051X%26_check%3Dy%26_origin%3Darticle%26_zone%3Dtoolbar%26_coverDate%3D08-Mar-2011%26view%3Dc%26originContentFamily%3Dserial%26wchp%3DdGLzVBA-zSkzS%26md5%3Dd479e9216510ae882e9db588ac09dad5%26pid%3D1-s2.0-S157106611100051X-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2Fj.entcs.2011.02.014&amp;rft.issn=1571-0661&amp;rft.issue=5&amp;rft.jtitle=Electronic+Notes+in+Theoretical+Computer+Science&amp;rft.pages=19-37&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=229" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Hughes05-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-Hughes05_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Hughes05_5-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Hughes05_5-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-Hughes05_5-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-Hughes05_5-4"><sup><i><b>e</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">Hughes, John (2005). <a rel="nofollow" class="external text" href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">"Programming with Arrows"</a> (PDF). In Uustalu, Tarmo; Vene, Varmo. "Advanced Functional Programming". 5th International Summer School on Advanced Functional Programming. 14–21 August 2004. Tartu, Estonia. Springer. pp. 73–129. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F11546382_2">10.1007/11546382_2</a>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-28540-3" title="Special:BookSources/978-3-540-28540-3">978-3-540-28540-3</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=Advanced+Functional+Programming&amp;rft.aufirst=John&amp;rft.au=Hughes%2C+John&amp;rft.aulast=Hughes&amp;rft.btitle=Programming+with+Arrows&amp;rft.date=2005&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cse.chalmers.se%2F~rjmh%2Fafp-arrows.pdf&amp;rft_id=info%3Adoi%2F10.1007%2F11546382_2&amp;rft.isbn=978-3-540-28540-3&amp;rft.pages=73-129&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-HaskArrows-6"><span class="mw-cite-backlink">^ <a href="#cite_ref-HaskArrows_6-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-4"><sup><i><b>e</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-5"><sup><i><b>f</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-6"><sup><i><b>g</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-7"><sup><i><b>h</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-8"><sup><i><b>i</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-9"><sup><i><b>j</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Paterson, Ross (2002). <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html">"Control.Arrow"</a>. <i>base-4.5.0.0: Basic libraries</i>. haskell.org<span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=Control.Arrow&amp;rft.aufirst=Ross&amp;rft.aulast=Paterson&amp;rft.au=Paterson%2C+Ross&amp;rft.date=2002&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fghc%2Fdocs%2Flatest%2Fhtml%2Flibraries%2Fbase%2FControl-Arrow.html&amp;rft.jtitle=base-4.5.0.0%3A+Basic+libraries&amp;rft.pub=haskell.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<p>Although no program strictly requires arrows, they generalize away much of the dense <a href="/wiki/First-class_function" title="First-class function">function passing</a> that pure, declarative code would otherwise require. They can also encourage <a href="/wiki/Code_reuse" title="Code reuse">code reuse</a> by giving common linkages between program steps their own class definitions. The ability to apply to types generically also contributes to reusability and keeps <a href="/wiki/Interface_(computing)" title="Interface (computing)">interfaces</a> simple.<sup id="cite_ref-Hughes05_5-3" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup></p>
<p>Arrows do have some disadvantages, including the initial effort of defining an arrow that satisfies the arrow laws. Because monads are usually easier to implement, and the extra features of arrows may be unnecessary, it is often preferable to use a monad.<sup id="cite_ref-Hughes05_5-4" class="reference"><a href="#cite_note-Hughes05-5"><span>[</span>5<span>]</span></a></sup> Another issue, which applies to many <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a> constructs, is efficiently <a href="/wiki/Compiling" title="Compiling" class="mw-redirect">compiling</a> code with arrows into the <a href="/wiki/Imperative_programming" title="Imperative programming">imperative</a> style used by computer <a href="/wiki/Instruction_set" title="Instruction set">instruction sets</a>.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This statement is commonly heard, but no strong, specific source on hand (June 2012)">citation needed</span></a></i>]</sup></p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol class="references">
<li id="cite_note-Hughes98-1"><span class="mw-cite-backlink">^ <a href="#cite_ref-Hughes98_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Hughes98_1-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Hughes98_1-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-Hughes98_1-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-Hughes98_1-4"><sup><i><b>e</b></i></sup></a></span> <span class="reference-text"><span class="citation journal">Hughes, John (May 2000). <a rel="nofollow" class="external text" href="http://pdn.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271600&amp;_user=10&amp;_pii=S0167642399000234&amp;_check=y&amp;_origin=search&amp;_zone=rslt_list_item&amp;_coverDate=2000-05-31&amp;wchp=dGLzVlk-zSkWb&amp;md5=fa91ab4ffc136b0cedc52318c7c249be&amp;pid=1-s2.0-S0167642399000234-main.pdf">"Generalising Monads to Arrows"</a> (PDF). <i>Science of Computer Programming</i> (Elsevier) <b>37</b> (1-3): 67–111. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2FS0167-6423%2899%2900023-4">10.1016/S0167-6423(99)00023-4</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0167-6423">0167-6423</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=Generalising+Monads+to+Arrows&amp;rft.aufirst=John&amp;rft.au=Hughes%2C+John&amp;rft.aulast=Hughes&amp;rft.date=May+2000&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fpdn.sciencedirect.com%2Fscience%3F_ob%3DMiamiImageURL%26_cid%3D271600%26_user%3D10%26_pii%3DS0167642399000234%26_check%3Dy%26_origin%3Dsearch%26_zone%3Drslt_list_item%26_coverDate%3D2000-05-31%26wchp%3DdGLzVlk-zSkWb%26md5%3Dfa91ab4ffc136b0cedc52318c7c249be%26pid%3D1-s2.0-S0167642399000234-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2FS0167-6423%2899%2900023-4&amp;rft.issn=0167-6423&amp;rft.issue=1-3&amp;rft.jtitle=Science+of+Computer+Programming&amp;rft.pages=67-111&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=37" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Paterson03-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-Paterson03_2-0">^</a></b></span> <span class="reference-text"><span class="citation book">Paterson, Ross (27 March 2003). <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.ps.gz">"Chapter 10: Arrows and Computation"</a> (PS.GZ). In Gibbons, Jeremy; de Moor, Oege. <i>The Fun of Programming</i>. Palgrave Macmillan. pp. 201–222. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-1403907721" title="Special:BookSources/978-1403907721">978-1403907721</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=The+Fun+of+Programming&amp;rft.aufirst=Ross&amp;rft.aulast=Paterson&amp;rft.au=Paterson%2C+Ross&amp;rft.btitle=Chapter+10%3A+Arrows+and+Computation&amp;rft.date=27+March+2003&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.soi.city.ac.uk%2F~ross%2Fpapers%2Ffop.ps.gz&amp;rft.isbn=978-1403907721&amp;rft.pages=201-222&amp;rft.pub=Palgrave+Macmillan&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Lindley10-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-Lindley10_3-0">^</a></b></span> <span class="reference-text"><span class="citation journal">Lindley, Sam; Wadler, Philip; Yallop, Jeremy (January 2010). <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf">"The Arrow Calculus"</a> (PDF). <i>Journal of Functional Programming</i> <b>20</b> (1): 51–69. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1017%2FS095679680999027X">10.1017/S095679680999027X</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/0956-7968">0956-7968</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=The+Arrow+Calculus&amp;rft.aufirst=Sam&amp;rft.aulast=Lindley&amp;rft.au=Lindley%2C+Sam&amp;rft.au=Wadler%2C+Philip&amp;rft.au=Yallop%2C+Jeremy&amp;rft.date=January+2010&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fhomepages.inf.ed.ac.uk%2Fwadler%2Fpapers%2Farrows-jfp%2Farrows-jfp.pdf&amp;rft_id=info%3Adoi%2F10.1017%2FS095679680999027X&amp;rft.issn=0956-7968&amp;rft.issue=1&amp;rft.jtitle=Journal+of+Functional+Programming&amp;rft.pages=51-69&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=20" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Atkey11-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-Atkey11_4-0">^</a></b></span> <span class="reference-text"><span class="citation journal">Atkey, Robert (8 March 2011). <a rel="nofollow" class="external text" href="http://pdn.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=272990&amp;_user=10&amp;_pii=S157106611100051X&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=08-Mar-2011&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVBA-zSkzS&amp;md5=d479e9216510ae882e9db588ac09dad5&amp;pid=1-s2.0-S157106611100051X-main.pdf">"What is a Categorical Model of Arrows?"</a> (PDF). <i>Electronic Notes in Theoretical Computer Science</i> (Elsevier) <b>229</b> (5): 19–37. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016%2Fj.entcs.2011.02.014">10.1016/j.entcs.2011.02.014</a>. <a href="/wiki/International_Standard_Serial_Number" title="International Standard Serial Number">ISSN</a> <a rel="nofollow" class="external text" href="//www.worldcat.org/issn/1571-0661">1571-0661</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=What+is+a+Categorical+Model+of+Arrows%3F&amp;rft.au=Atkey%2C+Robert&amp;rft.aufirst=Robert&amp;rft.aulast=Atkey&amp;rft.date=8+March+2011&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fpdn.sciencedirect.com%2Fscience%3F_ob%3DMiamiImageURL%26_cid%3D272990%26_user%3D10%26_pii%3DS157106611100051X%26_check%3Dy%26_origin%3Darticle%26_zone%3Dtoolbar%26_coverDate%3D08-Mar-2011%26view%3Dc%26originContentFamily%3Dserial%26wchp%3DdGLzVBA-zSkzS%26md5%3Dd479e9216510ae882e9db588ac09dad5%26pid%3D1-s2.0-S157106611100051X-main.pdf&amp;rft_id=info%3Adoi%2F10.1016%2Fj.entcs.2011.02.014&amp;rft.issn=1571-0661&amp;rft.issue=5&amp;rft.jtitle=Electronic+Notes+in+Theoretical+Computer+Science&amp;rft.pages=19-37&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.volume=229" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-Hughes05-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-Hughes05_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Hughes05_5-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-Hughes05_5-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-Hughes05_5-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-Hughes05_5-4"><sup><i><b>e</b></i></sup></a></span> <span class="reference-text"><span class="citation conference">Hughes, John (2005). <a rel="nofollow" class="external text" href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">"Programming with Arrows"</a> (PDF). In Uustalu, Tarmo; Vene, Varmo. "Advanced Functional Programming". 5th International Summer School on Advanced Functional Programming. 14–21 August 2004. Tartu, Estonia. Springer. pp. 73–129. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="http://dx.doi.org/10.1007%2F11546382_2">10.1007/11546382_2</a>. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a> <a href="/wiki/Special:BookSources/978-3-540-28540-3" title="Special:BookSources/978-3-540-28540-3">978-3-540-28540-3</a><span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=Advanced+Functional+Programming&amp;rft.aufirst=John&amp;rft.au=Hughes%2C+John&amp;rft.aulast=Hughes&amp;rft.btitle=Programming+with+Arrows&amp;rft.date=2005&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.cse.chalmers.se%2F~rjmh%2Fafp-arrows.pdf&amp;rft_id=info%3Adoi%2F10.1007%2F11546382_2&amp;rft.isbn=978-3-540-28540-3&amp;rft.pages=73-129&amp;rft.pub=Springer&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;"> </span></span></span></li>
<li id="cite_note-HaskArrows-6"><span class="mw-cite-backlink">^ <a href="#cite_ref-HaskArrows_6-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-2"><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-3"><sup><i><b>d</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-4"><sup><i><b>e</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-5"><sup><i><b>f</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-6"><sup><i><b>g</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-7"><sup><i><b>h</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-8"><sup><i><b>i</b></i></sup></a> <a href="#cite_ref-HaskArrows_6-9"><sup><i><b>j</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Paterson, Ross (2002). <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html">"Control.Arrow"</a>. <i>base-4.5.0.0: Basic libraries</i>. haskell.org<span class="reference-accessdate">. Retrieved 10 June 2012</span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AArrow+%28computer+science%29&amp;rft.atitle=Control.Arrow&amp;rft.aufirst=Ross&amp;rft.aulast=Paterson&amp;rft.au=Paterson%2C+Ross&amp;rft.date=2002&amp;rft.genre=article&amp;rft_id=http%3A%2F%2Fwww.haskell.org%2Fghc%2Fdocs%2Flatest%2Fhtml%2Flibraries%2Fbase%2FControl-Arrow.html&amp;rft.jtitle=base-4.5.0.0%3A+Basic+libraries&amp;rft.pub=haskell.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;"> </span></span></span></li>
</ol>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.haskell.org/arrows">Arrows: A General Interface to Computation</a></li>
<li><a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for Arrows</a>, Ross Paterson, in ICFP, Sep 2001.</li>
<li><a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html">Arrow notation</a> ghc manual</li>
</ul>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Arrow_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.haskell.org/arrows">Arrows: A General Interface to Computation</a></li>
<li><a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for Arrows</a>, Ross Paterson, in ICFP, Sep 2001.</li>
<li><a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html">Arrow notation</a> ghc manual</li>
</ul>
